<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[algTool 正则]]></title>
    <url>%2F2018%2F10%2F09%2FalgTool%2F</url>
    <content type="text"><![CDATA[65 Valid Number无向图 弗洛伊德算法 扩充全部最短路径12345678910111213141516171819202122232425262728// 读取无向图 cost矩阵//[i][i] = 0 没有路径是infmap = new int[n][n];for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(map[i], inf); map[i][i] = 0;&#125;//path 只保留最短for (int i = 1; i &lt;= m; i++) &#123; u = nextInt(); v = nextInt(); val = nextInt(); map[v][u] = map[u][v] = Math.min(map[u][v], val);&#125;//弗洛伊德for (int k = 0; k &lt; n; k++)for (int i = 0; i &lt; n; i++) &#123; //可去 if (map[i][k] == inf) continue; for (int j = 0; j &lt; n; j++) &#123; //可去 if (map[k][j] == inf) continue; map[j][i] = map[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]); &#125;&#125; 最大公约数gcd123public static long gcd(long a, long b) &#123; return (b == 0) ? a : gcd(b, a % b);&#125; 素数正确二分查找的写法1.查找范围是 [0,len-1][0]：l=0,r=1-1，while(l==r)的时候应该继续123456789101112131415int l = 0,r=n-1;while(l&lt;=r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)&#123; return mid; &#125; else if(arr[mid]&lt;target)&#123; l=mid+1;// &#125; else&#123; r=mid-1; &#125;&#125;//如果l&gt;rreturn -1; 2.[0,len) 保持len取不到[0]:l=0,r=1,l++,while(l==r)的时候应该结束好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的1234567891011121314int l = 0,r = n;while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)return mid; if(arr[mid]&gt;target)&#123; //在左边，边界为取不到的数 r=mid;//[l,mid) &#125;else&#123; //左闭又开 l = mid+1;//[mid+1,r) &#125;&#125;//如果l==r [1,1)表示空的return -1; lt 458 lastIndexOf12345678910111213public int lastPosition(int[] nums, int target) &#123; if(nums==null||nums.length&lt;1)return -1; int i = 0, j = nums.length-1; while(i&lt;=j)&#123; int mid = (i+j)/2; if(nums[mid]&gt;target)j = mid-1; //找到了继续向右找 else i =mid+1; &#125; if(j&lt;0)return-1; if(nums[j]==target) return j; return -1;&#125; 34 二分查找数字的first+last idx Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 二分查找获取最左/右边相等的 12345678public int[] searchRange(int[] a, int k) &#123; if(a==null||a.length&lt;1)return new int[]&#123;-1,-1&#125;; int first = lowerBound(a, k); if(first==a.length||a[first]!=k)return new int[]&#123;-1,-1&#125;; int last = upper_bound(a, k); last = last==-1||a[last]!=k?-1:last; return new int[]&#123;first,last&#125;;&#125; lower_bound二分搜索lowerBound1234567891011121314151617/* 满足ai&gt;=k条件的最小i* nums[index] &gt;= target, min(index)*/public static int lowerBound(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lb = -1, ub = nums.length; while (lb + 1 &lt; ub) &#123; int mid = lb + (ub - lb) / 2; if (nums[mid] &gt;= target) &#123; ub = mid; &#125; else &#123; lb = mid; &#125; &#125; return ub;&#125; upper_boundai&lt;=k 的最大i123456789101112public static int upper_bound(int[] a,int k)&#123; if (a == null || a.length == 0) return -1; int lb = -1,ub = a.length; while (ub - lb &gt; 1) &#123; int mid = (lb+ub)/2; if(a[mid]&lt;=k)&#123; lb = mid; &#125;else ub = mid; &#125; return lb;&#125; java快速io123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;int test = nextInt();out.println("Case #" + ttt + ":");out.println(ans);out.flush();out.close();static BufferedReader br = new BufferedReader(new InputStreamReader( System.in));static StreamTokenizer in = new StreamTokenizer(br);static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));static String next() throws IOException &#123; in.nextToken(); return in.sval;&#125;static char nextChar() throws IOException &#123; in.nextToken(); return in.sval.charAt(0);&#125;static int nextInt() throws IOException &#123; in.nextToken(); return (int) in.nval;&#125;static long nextLong() throws IOException &#123; in.nextToken(); return (long) in.nval;&#125;static float nextFloat() throws IOException &#123; in.nextToken(); return (float) in.nval;&#125;static double nextDouble() throws IOException &#123; in.nextToken(); return in.nval;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些DFS,BFS可以变成DP,BB的计数题]]></title>
    <url>%2F2018%2F09%2F09%2Falgdfs2bfs2dp2bb%2F</url>
    <content type="text"><![CDATA[784 大小写字母的permutation&#39;a&#39;-&#39;A&#39;=32所以就是(1&lt;&lt;5)的位置是0或1，但是不会变快小写和数字都加上这一位继续dfs，大写要123456if(idxchar-'A'&gt;=0&amp;&amp;idxchar-'A'&lt;26||idxchar-'a'&gt;=0&amp;&amp;idxchar-'a'&lt;26)&#123; idxchar = (char)(idxchar^(1&lt;&lt;5)); dfs(s,idx+1,cur+idxchar); idxchar = (char)(idxchar^(1&lt;&lt;5));&#125; dfs(s,idx+1,cur+idxchar); $C(n,r) = P(n,r)/r!$ 46 permutations生成全排列的算法: 移动高位1的全排列只有1，1，2的全排列考虑2 放在1前，1后1，2，3的全排列考虑3 放在 1，2 的全排列的左中右3个位置 一共3*2 = 6种 给定{1..n-1}的排列，存在n种方法将n插入得到{1..n}的排列n个球放入r个盒子里分步递推：$P(n,r)=nP(n-1,r-1)$分类递推：不选第一个球，方案数$P(n-1,r)$,选第一个球方案数$rP(n-1,r-1)$-&gt;$P(n,r)=P(n-1,r)+rP(n-1,r-1)$O(2^n)复杂度 3ms1234if(tmp.size()==nums.length)&#123; rst.add(new ArrayList&lt;Integer&gt;(tmp)); return;&#125; 一定要复制一份tmp，不然tmp是对象最后tmp会被remove为空1234567for(int i =0;i&lt;nums.length;i++)&#123; //dfs的marked if(tmp.contains(nums[i]))continue; tmp.add(nums[i]); help(rst,nums,tmp); tmp.remove(tmp.size()-1);&#125; O(n!)复杂度 只能处理10个数字不用contains 用markd数组 3ms展开代码 1234567891011121314151617181920212223boolean[] used;private void dfs(int idx,List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; tmp,int[] nums)&#123; if(idx&gt;=nums.length)&#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; //注意 排列无顺序 每次从0开始，但是要去重 for(int i = 0;i&lt;nums.length;i++)&#123; if(used[i]) continue; used[i] = true; tmp.add(nums[i]); dfs(idx+1,rst,tmp,nums); tmp.remove(tmp.size()-1); used[i] = false; &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); int n = nums.length; used = new boolean[n]; dfs(0,rst,new ArrayList&lt;&gt;(),nums); return rst;&#125; 方法2 swap java不能int[]-&gt;List SJI算法：可移动数 [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]12345678910111213141516vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; ans; help(nums,0,ans); return ans;&#125;void help(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt; &gt; &amp;ans)&#123; if(begin&gt;=num.size())&#123; ans.push_back(num); return; &#125; for(int i =begin;i&lt;num.size();i++)&#123; swap(num[begin],num[i]); help(num,begin+1,ans); swap(num[begin],num[i]); &#125;&#125; 39 Combination tum target 不重复元素组合求目标 candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] 注意这种写法 如果输入[1,1,1] 有重复元素的不行关键：加上start，防止出现3,2,2的重复组合比排列dfs的时候多一个start,每次只向后取数字先输出[2,2,3]44% 15ms12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); help(rst,candidates,target,new ArrayList&lt;&gt;(),0); return rst;&#125;private void help(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,int target,List&lt;Integer&gt; tmp,int idx)&#123;if(target&lt;0)return; if (target == 0) &#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125;for (int i = idx ; i &lt;candi.length; i++) &#123; //因为排序了，如果之后元素都大则不用向装这个向后找了 if(candi[i]&gt;target)break; tmp.add(candi[i]); //可以使用重复元素则idx,不能重复则idx+1 help(rst,candi, target-candi[i], tmp,i); tmp.remove(tmp.size()-1); &#125;&#125; 如果要先输出长度短的：先输出[7] 加个长度d和总长度len可以作为从N个数里选len个数的模板12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSumLenOrder(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); //最长用第一个元素target/candi[0]次 for (int i = 1; i &lt;=target/candidates[0] ; i++) &#123; dfs(rst,candidates,new ArrayList&lt;&gt;(),target,0,0,i); &#125; return rst;&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,List&lt;Integer&gt; tmp,int target,int d,int idx,int len)&#123; if(d==len)&#123; if(target==0)rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = idx; i &lt;candi.length ; i++) &#123; if(candi[i]&gt;target)break; tmp.add(candi[i]); dfs(rst,candi,tmp,target-candi[i],d+1,i,len); tmp.remove(tmp.size()-1); &#125;&#125; lt135 有重复元素的可以利用一个元素多次的comb sum 输入[1,1,1],target = 2 -&gt; [[1,1]] 方法1.用set去重1234567Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i:candidates)set.add(i); int[] nums = new int[set.size()]; int idx =0; for(int i:set)&#123; nums[idx++] = i; &#125; 方法2.加一行12345678for(int i = idx;i&lt;candidates.length;i++)&#123; if(candidates[i]&gt;target)break; //跳过重复的 if(i&gt;0&amp;&amp;candidates[i]==candidates[i-1])continue; tmp.add(candidates[i]); dfs(rst,candidates,target-candidates[i],tmp,i); tmp.remove(tmp.size()-1);&#125; 40 有重复元素且每个元素只能用一次的combsum1.直接用Set&lt;List&gt;-&gt;List&lt;List&gt; 34ms 11% 加上注意一定是&gt;idx,不然[1,1]会被跳过if(i&gt;idx&amp;&amp;candi[i]==candi[i-1])continue;并且dfs(rst,candi, target-candi[i], tmp,i+1); 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); dfs(rst,candidates,target,new ArrayList&lt;&gt;(),0); return new ArrayList&lt;&gt;(rst);&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,int target,List&lt;Integer&gt; tmp,int idx)&#123; if(target&lt;0)return; if (target == 0) &#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = idx ; i &lt;candi.length; i++) &#123; if(candi[i]&gt;target)break; //不是第一个元素，如果是[1,1,1] 这一层不找相同的元素 if(i&gt;idx&amp;&amp;candi[i]==candi[i-1])continue; tmp.add(candi[i]); //可以使用重复元素则idx,不能重复则idx+1 dfs(rst,candi, target-candi[i], tmp,i+1); tmp.remove(tmp.size()-1); &#125;&#125; 216 从1-9中选k个数字组成target 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] AC 78% 1ms lt564 无重复，可用多次，顺序不一样也计数，组成target的个数 dp 给出 nums = [1, 2, 4], target = 4可能的所有组合有：[1, 1, 1, 1][1, 1, 2][1, 2, 1][2, 1, 1][2, 2][4]返回 6 ?90 有重复的subset[1,2,2,2] 选不同的2得到{1,2}是重复的 次序不同得到{1,2},{2,1}是重复的先排序，再去重。 78 subset[1,2,3]-&gt;[1][1,2][1,2,3][2,3][2][3]回溯法：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]12345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); back(rst,new ArrayList&lt;&gt;(),nums,0); return rst; &#125;private void back(List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; item,int[] nums,int index)&#123; rst.add(new ArrayList&lt;&gt;(item)); for(int i =index;i&lt;nums.length;i++)&#123; item.add(nums[i]); back(rst,item,nums,i+1); item.remove(item.size()-1); &#125;&#125; 位运算法 集合每一项可以用0，1表示取不取输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 从000到111的过程{A,B,C}=111=7{A,B}=110=6{A}=100=5…一共有2^3种A用100表示B用010表示C用001表示如果i=011=3,添加j=0,001,j=1,010到item；i=100=4,添加j==2,1&lt;&lt;2=412345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); for(int i=0;i&lt;(1&lt;&lt;nums.length);i++)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for(int j =0;j&lt;nums.length;j++)&#123; if((i&amp;(1&lt;&lt;j))!=0)&#123; tmp.add(nums[j]); &#125; &#125; rst.add(new ArrayList&lt;&gt;(tmp)); &#125; return rst;&#125; 45jump game cnt 2do next timedp:12345678910111213141516 private int jumpdp(int[] nums)&#123; int n = nums.length; int[] dp = new int[n]; if(n == 0||nums[0] ==0)return 0; dp[0] = 0; for (int i = 1; i &lt; n; i++) &#123; dp[i] = Integer.MAX_VALUE; for (int j = 0; j &lt;i ; j++) &#123; if(i&lt;=j+nums[j]&amp;&amp;dp[j]!= Integer.MAX_VALUE)&#123; dp[i] = Math.min(dp[i],dp[j]+1); break; &#125; &#125; &#125; return dp[n-1];&#125; BFS：12345678910111213141516171819public int jumpBFS(int[] nums)&#123; if(nums==null||nums.length&lt;2)return 0; int level = 0; int cur = 0; int max =0; int i =0; //cur-i+1=1,level++; i&lt;=cur,i++,max = 2;cur = 2; //cur=2,i=1;level++; i&lt;=2,i++,max = 4,max&gt;=n-1 return 2; while (cur-i+1&gt;0)&#123; level++; for(;i&lt;=cur;i++)&#123; max = Math.max(max,nums[i]+i); if(max&gt;=nums.length-1)return level; &#125; cur = max; &#125; return 0;&#125; 递归1234567891011121314151617181920212223public int minJumpRecur(int[] arr)&#123; int n = arr.length; memo = new int[n][n]; return jump(arr, 0, n-1);&#125;int[][] memo;private int jump(int[] steps,int from,int end)&#123;// System.out.println(from+" "+end); if(from==end)return 0; //不可达 if(memo[from][end]!=0)return memo[from][end]; if(steps[from]==0)return Integer.MAX_VALUE; int min = Integer.MAX_VALUE; //当前可以到达的范围是[from,from+step[from]] for(int i = from+1;i&lt;=end&amp;&amp;i&lt;=from+steps[from];i++)&#123; int jumps = jump(steps,i , end); if(jumps!=Integer.MAX_VALUE&amp;&amp;jumps+1&lt;min)&#123; min = jumps+1; memo[from][end] = min; &#125; &#125; return min;&#125; 最正常的做法：12345678910111213141516171819public int jump(int[] nums) &#123; if(nums==null||nums.length&lt;2)return 0; int res = 0; int curMax = 0; int maxNext = 0; //i=0,max = 2 i==cur -&gt;res++,cur = max=2 //i=1,max = max(2,4)=4, i!=cur //i=2,max = max(4,3)=4, i==cur res++,cur = max=4 //i=3,max = max(4,4)=4, i!=cur break //不需要走到i=4,max = max(4,4+4)=8,i==cur res++,cur=max for (int i = 0; i &lt; nums.length-1; i++) &#123; maxNext = Math.max(maxNext,i+nums[i] ); if(i==curMax)&#123; res++; curMax = maxNext; &#125; &#125; return res;&#125; 743 从一个node广播，让所有节点收到最多要多久 单源最短路径 time[[2,1,1],[2,3,1],[3,4,1]] times[i] = (u, v, w) u到v花费wN个节点，从K发送dijkstra如果用heap可以从$N^2$-&gt;$NlogN+E$ O(N+E)Bellman-Ford O(NE)稠密图不好 空间O(N) 可以有负的路径Floyd-Warshall O(N^3) heapDijkstra78%//todo faster dijkstra:每次扩展距离最近的点 70% 32ms1234567891011121314151617181920212223242526272829303132333435363738public int networkDelayTimeDFSDj(int[][] times, int N, int K) &#123; Map&lt;Integer,List&lt;int[]&gt;&gt; graph = new HashMap&lt;&gt;(); for(int[] edge:times) &#123; if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList&lt;int[]&gt;()); graph.get(edge[0]).add(new int[]&#123;edge[1], edge[2]&#125;); &#125; int[] dis = new int[N]; Arrays.fill(dis, Integer.MAX_VALUE); dis[K-1]=0; boolean[] marked = new boolean[N+1]; while (true)&#123; int candNode =-1; int canDist = Integer.MAX_VALUE; for (int i = 1; i &lt;= N ; i++) &#123; //最近的点 if(!marked[i]&amp;&amp;dis[i-1]&lt;canDist)&#123; canDist = dis[i-1]; candNode = i; &#125; &#125;// System.out.println(candNode); //都当作扩展点过了, if(candNode&lt;0)break; marked[candNode] = true; //最近点的邻接 if(graph.containsKey(candNode)) for(int[] next:graph.get(candNode)) dis[next[0]-1] = Math.min(dis[next[0]-1],dis[candNode-1]+next[1]);// System.out.println(Arrays.toString(dis)); &#125; int ans = 0; for(int cost:dis)&#123; if(cost==Integer.MAX_VALUE)return -1; ans= Math.max(ans,cost); &#125; return ans;&#125; dfs: 邻接表 建图，递归终止条件:到达所有点花费的时间已经是最小的了dfs Hashmap6% 改成数组11% 124ms12345678910111213141516171819202122232425262728293031public int networkDelayTimeDFS(int[][] times, int N, int K) &#123; //creategraph Map&lt;Integer,List&lt;int[]&gt;&gt; graph = new HashMap&lt;&gt;(); for(int[] edge:times) &#123; if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList&lt;int[]&gt;()); graph.get(edge[0]).add(new int[]&#123;edge[1], edge[2]&#125;); &#125;//end-creategraph //只是为了加速， 不排序2.8% 352ms for(int node:graph.keySet())&#123; Collections.sort(graph.get(node),(a,b)-&gt;a[1]-b[1]); &#125; dis = new int[N]; Arrays.fill(dis, Integer.MAX_VALUE); dfs(graph,K,0); int ans = 0; for(int cost:dis)&#123; ans = Math.max(ans,cost); &#125; return ans==Integer.MAX_VALUE?-1:ans;&#125;//用于记录到某点的距离，如果到这个点花费的时间已经超过记录的最小值了，不对这个点dfs了。int[] dis;private void dfs(Map&lt;Integer,List&lt;int[]&gt;&gt; graph,int node,int elased)&#123; if(elased&gt;=dis[node-1])return; dis[node-1]=elased; if(graph.containsKey(node))&#123; for(int[] nei:graph.get(node)) dfs(graph,nei[0],elased+nei[1]); &#125;&#125; 12345678910111213141516171819202122232425262728293031/**Bellman Ford 边集 * 从K点广播给N个点需要的最少时间 * @param times u到v花费w秒 1 &lt;= w &lt;= 100. * @param N N will be in the range [1, 100]. * @param K * @return */public int networkDelayTime(int[][] times, int N, int K) &#123; int max_time = 100*101; int[] dis = new int[N]; int rst = Integer.MIN_VALUE; Arrays.fill(dis,max_time); //起点 dis[K-1] = 0; //其他N-1个点 for (int i = 1; i &lt;N ; i++) &#123; //遍历n次边的数组 for(int[] edge:times)&#123; int u = edge[0]-1; int v = edge[1]-1; int w = edge[2]; //动态规划 dis[v] = Math.min(dis[v],dis[u]+w); &#125; &#125; for(int cost:dis)&#123; rst = Math.max(cost,rst ); &#125; return rst == max_time?-1:rst;&#125; 弗洛伊德算法 边集12345678910111213141516171819202122232425public int networkDelayTimeF(int[][] times, int N, int K) &#123; int max_time = 100*101; //二维数组 表示i到j的最短路径 int[][] dis = new int[N][N]; for(int[] d:dis)&#123; Arrays.fill(d,max_time); &#125; for(int[] time:times)&#123; dis[time[0]-1][time[1]-1] = time[2]; &#125; for (int i = 0; i &lt;N ; i++) &#123; dis[i][i] =0; &#125; for (int k = 0; k &lt;N ; k++) for (int i = 0; i &lt;N ; i++) for (int j = 0; j &lt;N ; j++) //三维动态规划 dis[i][j] = Math.min(dis[i][j],dis[i][k]+dis[k][j]); int ans = Integer.MIN_VALUE; for (int i = 0; i &lt;N ; i++) &#123; if(dis[K-1][i]&gt;=max_time)return -1; ans = Math.max(ans,dis[K-1][i]); &#125; return ans;&#125; 322找钱最少硬币数贪心算法一般考举反例。不能用贪心的原因：如果coin={1,2,5,7,10}则使用2个7组成14是最少的，贪心不成立。满足贪心则需要coin满足倍数关系{1,5,10,20,100,200} 输入：coins = [1, 2, 5], amount = 11输出：3 (11 = 5 + 5 + 1) 递归mincoins(coins,11)=mincoins(coins,11-1)+1=(mincoins,10-1)+1+1..=(mincoins,0)+n 递归 记忆子问题 剩下3，用2的硬币变成剩下1的子问题和 剩下2，用1的硬币 剩下1的子问题是相同的。递归给count赋值是从下往上的。123456789101112131415161718public int coinChange3(int[] coins, int amount) &#123; if(amount&lt;1)return 0; return coinChange2(coins,amount,new int[amount]);&#125;private int coinC(int[] coins,int left,int[] count)&#123; if(left&lt;0)return -1; if(left==0)return 0; //关键，不然超时 if(count[left]!=0)return count[left]; int min = Integer.MAX_VALUE; for(int coin:coins)&#123; int useCoin = coinC(coins,left-coin,count); if(useCoin &gt;=0&amp;&amp;useCoin&lt;min)&#123; min = 1+useCoin; &#125; &#125; return count[left] = (min==Integer.MAX_VALUE)?-1:min; &#125; dp: 注意点：初值如果设为Int的max，两个都是max的话+1变成负数，所以设amount+1 j 从coin开始81%~94% 不稳定 123456789int[] dp = new int[amount+1];Arrays.fill(dp,amount+1);dp[0] =0;for(int coin:coins)&#123; for(int j = coin;j&lt;=amount;j++)&#123; dp[j]=Math.min(dp[j],dp[j-coin]+1); &#125;&#125;return dp[amount]&gt;amount?-1:dp[amount]; 最正确的方法：dfs分支限界 1.逆序coins数组 贪心从大硬币开始试 2.dfs终止条件是 找到硬币整除了，或者idx==0但是不能整除 3.剪枝条件是 考虑用当前coins[idx]i个之后，用下一个硬币至少1个，如果超了break99% 12345678910111213141516171819202122232425262728int minCnt = Integer.MAX_VALUE;public int coinChangedfs(int[] coins,int amount)&#123; Arrays.sort(coins); dfs(amount,coins.length-1,) return minCount == Integer.MAX_VALUE?-1:minCount;&#125;private void dfs(int amount,int idx,int[] coins,int count)&#123; if(amount%coins[idx]==0)&#123; int bestCnt = count+amount/coins[idx]; //当[1,2,5] 11, 用掉两个5，count=2 idx=0,cnt+1=3 return if(bestCnt&lt;minCnt)&#123; minCnt = bestCnt; //这个return放在里面97% return; &#125; //本来应该放在这里 94% &#125; if(idx==0)return; for(int i = amount/coins[idx];i&gt;=0;i--)&#123; int leftA = amount - i*coins[idx]; int useCnt = count+i; int nextCoin = coins[idx-1]; //保证只要left&gt;0都还需要至少1枚硬币 //或者简单一点if(useCnt+1&gt;minCount)break; 98% if(useCnt+(leftA+nextCoin-1)/nextCoin&gt;=minCount)break; dfs(leftA,idx-1,coins,useCnt); &#125;&#125; 91 1-26数字对应26个字母，问一个数字对应多少种解码方式226-&gt;2(B)2(B)6(F),22(V)6(F),2(B)26(Z)1递归：8%1234567891011121314Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();public int numDecodings(String s)&#123; if(s.length()&lt;1)return 1; if(map.containsKey(s))return map.get(s); if(s.charAt(0)=='0')return 0; if(s.length()==1)return 1; w = numDecodings(s.substring(1)); int pre2 = Integer.parseInt(s.substring(0,2)); if(pre2&lt;=26)&#123; w+=numDecodings(s.substring(2)); &#125; map.put(s,w); return w;&#125; 2递归改成index 63%123456789101112131415public int numDecodings(String s)&#123; return help(s,0,s.length()-1); &#125;private int help(String s,int l,int r)&#123; if(l&gt;s.length()-1)return 1; if(s.charAt(0)=='0')return 0; if(l&gt;=r)return 1; w = help(s,l+1,r); int pre2 = (s.charAt(l)-'0')*10+s.charAt(l+1)-'0'; if(pre2&lt;=26)&#123; w+=help(s,l+2,r); &#125; map2.put(l,w); return w;&#125; 3.dp[i]表示s[0..i]的解码方式？？？dp[0]=1226-&gt;s[‘2’]-&gt;dp[1]=dp[0]=1 -&gt;s[‘2’]-&gt;s[‘22’]-&gt;dp[2]=dp[1]+dp[0]=2 -&gt;s[‘6’]-&gt;s[‘26’]-&gt;dp[3]=dp[2]+dp[1]=3 102当s[i]合法,dp[i]=dp[i-1], dp[1]=dp[0]当s[i][i-1]合法dp[i]=dp[i-2] ,dp[2]=dp[0]当s[i-1]s[i]合法，dp[i]=dp[i-1]+dp[i-2] 343 整数拆分 并使乘机最大 Input: 2Output: 1Explanation: 2 = 1 + 1, 1 × 1 = 1. 123456789101112131415int[] memo;public int IntegerBread(int n)&#123; memo = new int[n+1]; return ib(n);&#125;private int ib(int n)&#123; if(memo[n]!=0)return memo[n]; if(n==1)return 1; int res = -1; for(int i=1;i&lt;n;i++)&#123; res = Math.max(res,Math.max(i*(n-i),i*ib(n-i))); memo[n]=res; &#125; return res;&#125; dp：12345678910public int integerBreak(int n) &#123; int[] dp = new int[n+1]; dp[1]=1; for(int i =2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i-1;j++)&#123; dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j])); &#125; &#125; return dp[n]; 数学方法：考虑f=x(N-x) 当x=N/2的时候取最大值。所以当N是偶数时，最大值是(N/2)(N/2)当N是奇数， 最大值是(N-1)/2 (N+1)/26, 3 * 3&gt;2 * 2 * 2123456789101112public int integerBreak(int n) &#123; if(n==2) return 1; if(n==3) return 2; int product = 1; while(n&gt;4)&#123; product*=3; n-=3; &#125; product*=n; return product;&#125; 787 中间最多停留k次的，最小花费路线 Input: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 1from src to dst with up to k stops 最小花费Output: 200 dfs：复杂度n^(k+1)1.cost边集-&gt;邻接表12345678Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; edgeC2graph(int[][]edges,int n)&#123; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = new HashMap&lt;&gt;(n); for (int[] edge : edges) &#123; graph.putIfAbsent(edge[0], new HashMap&lt;&gt;()); graph.get(edge[0]).put(edge[1], edge[2]); &#125; return graph;&#125; dfs 常规回溯1234567891011121314151617181920212223242526272829303132Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph;boolean[] visited;public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; graph = new HashMap&lt;&gt;(n); for (int[] edge : flights) &#123; graph.putIfAbsent(edge[0], new HashMap&lt;&gt;()); graph.get(edge[0]).put(edge[1], edge[2]); &#125; visited = new boolean[n]; visited[src] = true; dfs(graph, src, dst, K + 1, 0); return ans == Integer.MAX_VALUE ? -1 : ans;&#125;int ans = Integer.MAX_VALUE;private void dfs(Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph, int src, int dst, int k, int cost) &#123; if (src == dst) &#123; ans = cost; return; &#125; if (k == 0) return; Map&lt;Integer, Integer&gt; adj = graph.getOrDefault(src,new HashMap&lt;&gt;()); for (int key : adj.keySet()) &#123; if (visited[key]) continue; if (cost + adj.get(key) &gt; ans) continue; visited[key] = true; dfs(graph, key, dst, k - 1, cost + adj.get(key)); visited[key] = false; &#125;&#125; 94msbfs:复杂度n^(k+1) Dijkstra 最小优先队列扩展，先扩展加上下一个点cost最小的1234567891011121314151617181920public int findCheapestPriceDj(int n, int[][] flights, int src, int dst, int k) &#123; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = edgeC2graph(flights, n); //每次选cost最小的先扩展 Queue&lt;int[]&gt; que = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[0])); que.add(new int[]&#123;0,src,k+1&#125;); while(!que.isEmpty())&#123; int[] top = que.remove(); int price = top[0]; int city = top[1]; int stops = top[2]; if(city == dst)return price; if(stops&gt;0)&#123; Map&lt;Integer, Integer&gt; adj = graph.getOrDefault(city, new HashMap&lt;&gt;()); for(int a:adj.keySet())&#123; que.add(new int[]&#123;price+adj.get(a),a,stops-1&#125;); &#125; &#125; &#125; return -1;&#125; bellman-ford 单源到所有点的最短路径kn^2 dpdp[k][v] 从起点到v最多k次stop的最小花费123456789101112131415161718192021public int findCheapestPriceDp(int n, int[][] flights, int src, int dst, int k) &#123; int max = 10001*(k+2); //走1~k+1步 int[][] dp = new int[k+2][n]; for(int[] ints:dp)&#123; for (int j = 0; j &lt; n; j++) &#123; ints[j] = max; &#125; &#125; dp[0][src] = 0; //如果不限制中间k个点，则可以遍历n次 for (int i = 1; i &lt;= k+1; i++) &#123; //走i步走到src ， cost 0 dp[i][src] = 0; for(int[] flight:flights)&#123; //关键 dp[i][flight[1]] = Math.min(dp[i][flight[1]],dp[i-1][flight[0]]+flight[2]); &#125; &#125; return dp[k+1][dst]&gt;=max?-1:dp[k+1][dst];&#125; ？96 不同的BST数量 catalan数(为什么是乘)12345671个节点只有1种，2个节点1 2 一共两种 \ / 2 13个节点1 2 3 / \ / \ / \ （0）(2) (1)(1) (2)(0) 1x2 + 1x1 + 2x1 当n=5 $T[4]+T[1][3]+T[2][2]+T[3][1]+T[4]$ 左子树有j个节点，右子树有n-j-1个节点123456789101112int[] dp = new int[n+1];dp[0] = 1;dp[1] = 1;//节点个数for(int i =2;i&lt;=n;i++)&#123; //左边j个 for(int j =0;j&lt;i;j++)&#123; //注意是累加 dp[i]+=dp[j]*dp[i-j-1]; &#125;&#125;return dp[n]; dfs:1234567891011121314public int numTreesDfs(int n) &#123; int[] memory = new int[n+1]; return dfs(n,memory);&#125;public int dfs(int n,int[] memroy)&#123; if(n==0||n==1)return 1; if(memroy[n-1]!=0)return memroy[n-1]; int sum = 0; for (int i = 1; i &lt;=n ; i++) &#123; sum+=dfs(i-1,memroy)*dfs(n-i,memroy); &#125; memroy[n-1] = sum; return sum;&#125; 12int ans[] = &#123;1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190&#125;;return ans[n]; 12345int res = 0;if(n&lt;=1)return 1;for (int i = 0; i &lt; n; i++) &#123; res += catalan(i) * catalan(n - i - 1);&#125; 二项式系数123456789101112private int C(int a,int b)&#123; long res = 1; for(int i =0;i&lt;Math.min(b,a-b);i++)&#123; res=res*(a-i)/(i+1); &#125; return (int)res;&#125;//C(2n,n)/(n+1)public int catalen2(int n)&#123; int c =C(2*n,n); return c/(n+1);&#125; 847 BFS边可以重复访问的访问所有点的最短路径graph.length = N Input: [[1,2,3],[0],[0],[0]] 邻接表Output: 4Explanation: One possible path is [1,0,2,0,3] dp：比tsp少判断一次next已经是访问过的点12345678910111213141516171819202122232425public int shortestPathLengthDP(int[][] graph) &#123; int n = graph.length; int[][] dp = new int[n][1&lt;&lt;n]; Deque&lt;State&gt; que = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(dp[i],Integer.MAX_VALUE); dp[i][1&lt;&lt;i]=0; que.add(new State(i,1&lt;&lt;i)); &#125; while(!que.isEmpty())&#123; State state = que.poll(); for(int next:graph[state.source])&#123; int nextMask = state.mask|(1&lt;&lt;next); if(dp[next][nextMask]&gt;dp[state.source][state.mask]+1)&#123; dp[next][nextMask] = dp[state.source][state.mask]+1; que.add(new State(next,nextMask)); &#125; &#125; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt;n ; i++) &#123; res = Math.min(res, dp[i][(1&lt;&lt;n)-1]); &#125; return res;&#125; BFS： 定点可以访问多次，用当前搜索节点和当前访问过的节点mask作为visited数组 bfs第一层每个顶点都可以作为出发点 que中存储pair&lt;当前节点，访问过的节点&gt; 展开代码 12345678910111213141516171819202122232425262728293031class Pair&lt;K,V&gt;&#123; K key; V value;&#125;public int shortestPathLength(int[][] graph) &#123; int n = graph.length; int endState = (1&lt;&lt;n)-1; Deque&lt;Pair&lt;Integer,Integer&gt;&gt; que = new ArrayDeque&lt;&gt;(); boolean [][] visited = new boolean[n][1&lt;&lt;n]; for(int i=0;i&lt;n;i++)&#123; que.add(new Pair&lt;&gt;(i,1&lt;&lt;i)); &#125; int step =0; while(!que.isEmpty())&#123; int size = que.size(); while(size--&gt;0)&#123; Pair&lt;Integer, Integer&gt; front = que.poll(); Integer cur = front.key; Integer state = front.value; // mask全是1，访问了所有点 if(state == endState) return step; if(visited[cur][state])continue; visited[cur][state] = true; for(int next:graph[cur])&#123; que.add(new Pair&lt;&gt;(next,state|(1&lt;&lt;next))); &#125; &#125; step++; &#125; return -1;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[need2Learn]]></title>
    <url>%2F2018%2F09%2F07%2Fneed2Learn%2F</url>
    <content type="text"><![CDATA[todoList Octotree 分屏翻译chrome插件 排值日小程序 tx实习 编程基本功扎实，掌握C/C++/JAVA等开发语言、常用算法和数据结构； 熟悉TCP/UDP网络协议及相关编程、进程间通讯编程； 了解Python、Shell、Perl等脚本语言； 了解MYSQL及SQL语言、编程，了解NoSQL,&nbsp;key-value存储原理； 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识； 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。 商汤java开发实习2.具备扎实的Java基础知识和良好的编码风格，深入理解Java虚拟机，反射机制以及常用的设计模式。3.熟悉MVC设计模式，掌握SpringMVC、Mybatis等主流MVC框架的工作原理。4.熟练使用MySQL，至少熟悉Redis、Memcached、Kafka、Dubbo等主流中间件框架中的二种，及其原理。5.熟悉Nginx、Tomcat、Netty等应用服务框架，熟练使用Linux/UNIX等服务器的常用命令。6.熟练使用常见的IDE工具，如Idea、eclipse、maven、gradle、git等。7.具有良好的团队协作能力，具备较强的自我驱动意识和学习能力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[avtiviti]]></title>
    <url>%2F2018%2F09%2F05%2Favtiviti%2F</url>
    <content type="text"><![CDATA[查看tomcat启动jps -mlv复制3个war包到tomcat webapphttp://localhost:8080/activiti-app/admin testhttp://localhost:8080/activiti-adminadmin admin git checkout -b bpmnLearn activiti-6.0.0mvn clean test-compile]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2018%2F09%2F05%2Fredis%2F</url>
    <content type="text"><![CDATA[ConcurrentSkipListMap4.搭建redis服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152cd /usr/localtar -zvxf yum -y install gcc gcc-c++ libstdc++-develmake MALLOC=libcyum install tclmake testvi tests/integration/replication-2.tcl 1000-&gt;10000make installredis-servervi redis.conf bind 127.0.0.1-&gt;0.0.0.0所有ip都能访问 :/dae daemonize yes 允许后台执行redis-server ./redis.conf#Redis version=4.0.2, bits=64, commit=00000000, modified=0, pid=10217, just startedps -ef |grep redis#root 10218 1 0 10:42 ? 00:00:00 redis-server 0.0.0.0:6379redis-cli#给redis加密码vi redis.conf :/requirepass # requirepass foobared -&gt; requirepass 123456#重启redis-cli shutdown save exitps -ef | grep redisredis-server ./redis.confredis-cli auth 123456# 变成系统服务cd utils./install_server.sh# 配置文件位置 /usr/local/redis-4.0.2/redis.conf# log位置 /usr/local/redis-4.0.2/redis.log# data位置 /usr/local/redis-4.0.2/data# 可执行文件路径chkconfig --list |grep redis# redis_6379 0:关 1:关 2:开 3:开 4:开 5:开 6:关systemctl status redis_6379systemctl stop redis_6379systemctl start redis_6379ps -ef |grep redis# 改服务名vi /etc/init.d/redis_6379# ！打开防火墙firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-ports 查看配置config get * 常用APIkeys * 查询所有的键，会遍历所有的键值，复杂度O(n)dbsize 查询键总数，直接获取redis内置的键总数变量，复杂度O(1)exists key 存在返回1，不存在返回0 O(1) ttl 命令可以查看键hello的剩余过期时间，单位：秒（&gt;0剩余过期时间；-1没设置过期时间；-2键不存在）expire key seconds 当超过过期时间，会自动删除，key在seconds秒后过期persist key 去掉过期时间 type key 如果键hello是字符串类型，则返回string；如果键不存在，则返回none 所有key都是字符串 epoll实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[经典问题 巧妙的算法和DP方程]]></title>
    <url>%2F2018%2F09%2F04%2FalgRight%2F</url>
    <content type="text"><![CDATA[poj2686 车票约束的最短路径123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * * 3 4 3路径数量 1 4 3 1 2 1 2 10 2 3 30 3 4 20 time = graph[v][w]/hourse[i] * @param n ticket number 一张票只能走一条路 * @param m city number * @param graph * @param a 起点 * @param b 终点 * @param hourse 马的数量 * @return */public static double mintime(int n,int m,int[][] graph,int a,int b,int[] hourse)&#123; // dp[S][v]剩下车票S 当前在城市v的最小花费 double[][] dp = new double[1&lt;&lt;n][m]; for (int i = 0; i &lt;1&lt;&lt;n ; i++) &#123; Arrays.fill(dp[i], inf); &#125; //起点 dp[(1&lt;&lt;n)-1][a-1] = 0; double res = inf; //n = 3 S = 111 用哪个车票的子集 for (int S = (1&lt;&lt;n)-1; S &gt;=0 ; S--) &#123; res = Math.min(res, dp[S][b-1]); for (int v = 0; v &lt; m ; v++) &#123; //车票i for (int i = 0; i &lt; n ; i++) &#123; if((S&gt;&gt;i &amp; 1)!=0)&#123; for (int u = 0; u &lt;m ; u++) &#123; if(graph[v][u]&gt;=0)&#123; dp[S&amp;~(1&lt;&lt;i)][u] = Math.min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)graph[v][u]/hourse[i]); &#125; &#125; &#125; &#125; &#125; &#125; if(res == inf)&#123; return -1; &#125;else return res;&#125; LCS 最长公共子序列 长度 “abcd” “becd” -&gt;3(“bcd”) 1234567891011121314public int lcs(String s,String t)&#123; int n = s.length(); int m = t.length(); int[][] dp = new int[n+1][m+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;m ; j++) &#123; if(s.charAt(i)==t.charAt(j))&#123; dp[i+1][j+1] = dp[i][j]+1; &#125;else dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]); &#125; &#125; return dp[n][m];&#125; 最长上升子序列 LIS n = 5,a = {4,2,3,1,5}out:3 (2,3,5) 无后效性：可写出递推式。之与子问题函数的状态函数值有关，与到达值的路径无关子问题：求以a_k(k=1,2,3...N)为终点的最长上升子序列长度max(n个子问题) 如果ak比已得最长子序列的最后ai大，则长度+1maxLen(k)=max(maxLen(i):i in range(1,k)且ai&lt;ak且k!=1)+112345678for i in range(1,n) maxlen[i]=1for i in range(2,n) ##求以ai 为终点的最长 for j in range(0,i)# ai左边所有的数 if a[i]&gt;a[j]: # ai为终点的更长 #？？ maxlen[i]也更新了，可能比manlen[j]+1大 maxlen[i]=max(maxlen[j]+1,maxlen[i]) 背包9讲: dp求解背包问题的复杂度是O(nW) 超大背包v和w都很大，n很小//364 1&lt;wi&lt;10^7 1&lt;w&lt;10^9重量范围很大的01背包！！！测试lt125 同01背包： n = 4; A = {2,1,3,2}; V = {3,2,4,2}; W = 5; dp[i+1][j]表示取前i个物品，获得value j的最小W123456789101112131415161718192021222324int maxV = 100;int maxW = 1000000000;public int bigW01bag(int[] A,int[] V,int W)&#123; int n = A.length; //dp[i+1][j] 前i个物品中挑选出价值总和为j时的总重量的最小值 int[][] dp = new int[n+1][n*maxV+1]; //前0个物品挑任何价值都是INF Arrays.fill(dp[0],maxW ); dp[0][0] = 0; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=n*maxV ; j++) &#123; if(j&lt;V[i])dp[i+1][j]=dp[i][j]; else dp[i+1][j] = Math.min(dp[i][j],dp[i][j-V[i]]+A[i] ); &#125; &#125; int res = 0; //找小于W的最大value for (int i = 0; i &lt;= n*maxV ; i++) &#123; if(dp[n][i]&lt;=W)res = i; &#125; return res;&#125; 01背包N个物品，背包容量VF[i,v]前i件物品放入容量v的背包可获得的最大价值。如果放第i件，转化为前i-i件放入容量为v-Ci的背包中，最大价值是F[i-1,v-Ci]+Wi$F[i,v]=max{F[i-1,v],F[i-1,v-C_i]+W_i}$递归终止条件1：所有物品都装过了-&gt;0 2.这个物品w装不下-&gt;下一个物品记忆化递归1234567891011121314151617181920int[][] dp;//参数组合一共nW种 只需要O(nW)复杂度public int bagmemo(int i,int n,int[][]wv,int w)&#123; dp = new int[n+1][w+1]; return memo(i, n, wv, w);&#125;public int memo(int i,int n,int[][]wv,int w)&#123; if(dp[i][w]&gt;0)return dp[i][w]; int res; if(i==n)return 0; else if(w&lt;wv[i][0])&#123; //不选这个 res = bagrec(i+1,n,wv,w); &#125;else&#123; //选和不选 res = Math.max(bagrec(i+1,n ,wv ,w ),bagrec(i+1, n,wv ,w-wv[i][0])+wv[i][1]); &#125; dp[i][w] = res; return res;&#125; 终止条件：没有物品/剩余重量12345678private int zoknap(int W,int[] val,int[] wt,int n)&#123; if(n == 0||W == 0)&#123; return 0; &#125; //这个物品超重了 跳过 if(wt[n-1]&gt;W)return zoknap(W, val, wt,n-1 ); else return Math.max(val[n-1]+zoknap(W-wt[n-1],val ,wt ,n-1 ),zoknap(W,val ,wt ,n-1) );&#125; dp 复杂度和记忆化递归一样逆向n-1-&gt;0123456789101112public int bagdp(int n,int W,int[][]wv)&#123; int[][] dp = new int[n+1][W+1]; for (int i = n-1; i &gt;=0 ; i--) &#123; for (int j = 0; j &lt;=W ; j++) &#123; if(j&lt;wv[i][0]) dp[i][j] = dp[i+1][j]; else dp[i][j] = Math.max(dp[i+1][j],dp[i+1][j-wv[i][0]]+wv[i][1]); &#125; &#125; return dp[0][W];&#125; 正向dp 123456789101112public int frontDp(int n,int W,int[][] wv)&#123; int[][] dp = new int[n+1][W+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=W ; j++) &#123; if(wv[i][0]&gt;j) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = Math.max(dp[i][j-wv[i][0]]+wv[i][1],dp[i][j]); &#125; &#125; return dp[n][W];&#125; 从前i个物品中选不超过j的状态-&gt;前i+1中选不超过j，前i+1不超过j+w[i]1234567891011public int maxbag(int n,int w,int[][]wv)&#123; int[][] dp = new int[n+1][w+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=w ; j++) &#123; dp[i+1][j] = Math.max(dp[i+1][j],dp[i][j]); if(j+wv[i][0]&lt;=w) dp[i+1][j+wv[i][0]] = Math.max(dp[i+1][j+wv[i][0]],dp[i][j]+wv[i][1]); &#125; &#125; return dp[n][w];&#125; 输出路径123456789w = W;for (i = n; i&gt;0&amp;&amp;res&gt;0 ; i--) &#123; if(res ==dp[i-1][w])continue; else&#123; System.out.println(wt[i-1]+" "); res-= val[i-1]; w-= wt[i-1]; &#125;&#125; 01背包一维dp123456789private int zoknapdp1d(int W,int[] wt,int[] val,int n)&#123; int[] dp = new int [W+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = W; j &gt;=wt[i] ; j--) &#123; dp[j] = Math.max(dp[j],dp[j-wt[i]]+val[i]); &#125; &#125; return dp[W];&#125; ?taotao要吃鸡 h为0代表没有装备背包n个物品，容量=m+h接下来n行，第i个物品的物品的重量Wi和威力值Vi。0&lt;=Wi,Vi&lt;=100.当装备背包之后，如果可携带重量没有满，就可以拿一个任意重的东西。3 3 32 33 22 30输出8 拿了1，2物品val=5,weight=5&lt;6，可以拿3 1.方法1m+h容量背包，在m+h没装满时可以任意取一个超过重量的最外层遍历：最后一个超额的物品i. 计算m+h-1背包容量的最大val123456789101112int ans = -1;for(int i =0;i&lt;n;i++)&#123; ans = max(ans,v[i]+slove(m+h-1),i);&#125;int slove(int W,int index)&#123; for(int i =0;i&lt;n;i++)&#123; if(i==index)continue; for(int j = W;j&gt;=w[i];j--)&#123; dp[j] = max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125;&#125; 2.方法2直接dp 1.按重量排序123456789101112for(int i =0;i&lt;n;i++)&#123; for(int j = m+h;j&gt;=goods[i].w;j--)&#123; dp[j] = Math.max(dp[j],dp[j-goods[i].w]+goods[i].v); &#125; if(h&gt;0)&#123; //强行装的位置,不能填dp[0]，0表示装满了 for(int j = Math.min(m+h,goods[i].w-1)j&gt;0;j--)&#123; dp[j] = Math.max(dp[j],goods[i].v); &#125; &#125; out.println(dp[m+h]);&#125; 01背包 bb解法展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Item&#123; double weight; int value;&#125;class Node&#123; // level --&gt; Level of node in decision tree (or index // in arr[] // profit --&gt; Profit of nodes on path from root to this // node (including this node) // bound ---&gt; Upper bound of maximum profit in subtree // of this node/ int level,profit,bound; double weight;&#125;public class BBpack &#123; //用分数背包问题的贪心法求接下去可能的最大值 public static int bound(Node u,int n,int W,List&lt;Item&gt; arr)&#123; if(u.weight&gt;=W)return 0; int profit_bound = u.profit; int j = u.level+1; int totweight = (int)u.weight; while(j&lt;n&amp;&amp;(totweight+arr.get(j).weight&lt;=W))&#123; totweight += arr.get(j).weight; profit_bound += arr.get(j).value; j++; &#125; if(j&lt;n)&#123; profit_bound+=(W-totweight)*arr.get(j).value/arr.get(j).weight; &#125; return profit_bound; &#125; public static int knapsack(int W,List&lt;Item&gt;arr,int n)&#123; //1. 排序// Comparator&lt;Item&gt; comparing = Comparator.comparing(item -&gt; item.value / item.weight);// arr.sort(comparing.reversed()); arr.sort(Comparator.comparing((Item item )-&gt; item.value / item.weight).reversed()); //2.队列 System.out.println(arr); Deque&lt;Node&gt; que = new ArrayDeque&lt;&gt;(); // dummy node Node u = new Node(-1,0,0); Node v = new Node(-1,0,0); que.add(u); int MaxProfit = 0; while(!que.isEmpty())&#123; u = que.poll(); if(u.level == -1)&#123; v.level =0; &#125; if(u.level == n-1)continue; v.level = u.level+1; //装 v.weight = u.weight+arr.get(v.level).weight; v.profit = u.profit+arr.get(v.level).value; //如果不超重 更新当前最大收益 if(v.weight&lt;=W&amp;&amp;v.profit&gt;MaxProfit) MaxProfit = v.profit; v.bound = bound(v,n ,W ,arr ); //不装 if(v.bound&gt;MaxProfit) que.add(new Node(v)); v.weight = u.weight; v.profit = u.profit; v.bound = bound(v,n,W ,arr); //不装也有可能 if(v.bound&gt;MaxProfit)&#123; que.add(new Node(v)); &#125; &#125; return MaxProfit; &#125;public static void main(String[] args) &#123; List&lt;Item&gt; arr= new ArrayList&lt;Item&gt;(5); arr.add(new Item(2,40)); arr.add(new Item(3.14,50)); arr.add(new Item(1.98,100)); arr.add(new Item(5,95)); arr.add(new Item(3,30)); int W = 10; System.out.println(knapsack(W, arr, arr.size())); &#125; ！！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。12345678910111213141516public boolean canPartition(int[] nums)&#123; int sum = 0; for(int n : nums)&#123; sum+=n; &#125; if(sum%2!=0)return false; int[] dp = new int[sum+1]; dp[0] = 1; for(int n : nums)&#123; for(int v = sum;v&gt;=0;v--)&#123; if(dp[v]==1)dp[v+n]=1; &#125; if(dp[sum/2]==1)return true; &#125; return false;&#125; 2.初始化F 恰好装满背包，F[0]=0 其余-∞没有装任务物品时，只有容量为0的背包表示装满，其它容量为非法解。 不用装满，F全部为0任何容量的背包，什么都不装，价值F都为0也是合法解。 lt440完全背包 每个物品可用无限次 n = 3; [3,4],[4,5],[2,3]; W = 7;out 10 (0选1个，2选2个) dp[i+1][j]计算k的循环和dp[i+1][j-w[i]]计算k-1的循环是重复的 记忆化递归：终止条件，当n==0的时候还要继续削减w1234567891011121314151617181920int[][] memo;public int backPackIII(int[] A, int[] V, int m) &#123; if(A==null||V==null||A.length&lt;1||V.length&lt;1)return 0; int n = A.length; memo = new int[n+1][m+1]; return backrec(n-1,m,A,V);&#125;private int backrec(int n,int w,int[] A,int[] V)&#123; if(memo[n][w]&gt;0)return memo[n][w]; if(w==0)return 0; if(n==0&amp;&amp;w&lt;A[0])return 0; else if(n==0&amp;&amp;w&gt;=A[0])return memo[n][w] = backrec(0,w-A[0],A,V)+V[0]; else if(n&gt;0)&#123; if(A[n]&gt;w)return memo[n][w] = backrec(n-1,w,A,V); else return memo[n][w] = Math.max(backrec(n-1,w,A,V),backrec(n,w-A[n],A,V)+V[n]); &#125; return 0;&#125; 123456789101112public int completeBagDP(int n,int W,int[][] wv)&#123; //dp[i+1][j]从前i种物品中总重&lt;=j的最大值 int[][] dp = new int[n+1][W+1]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;=W ; j++) &#123; for (int k = 0; k*wv[i][0] &lt;=j ; k++) &#123; dp[i+1][j] = Math.max(dp[i+1][j],dp[i][j-k*wv[i][0]]+k*wv[i][1]); &#125; &#125; &#125; return dp[n][W]; &#125; 完全背包一维dp和01背包的一维dp差别只有循环的方向1234567891011public int backPackIII(int[] A, int[] V, int m) &#123; int[]dp = new int[m+1]; int n = A.length; for(int i =0;i&lt;n;i++)&#123; //for(int j = m;j&gt;=A[i];j--) for(int j = A[i];j&lt;=m;j++)&#123; dp[j] = Math.max(dp[j-A[i]]+V[i],dp[j]); &#125; &#125; return dp[m];&#125; 利用奇偶性简化空间dp[2]12345678910111213public int backpackdp2(int[] A, int[] V, int m)&#123; //只需要计算dp[i+1]和dp[i] int[][] dp = new int[2][m+1]; for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt;=m ; j++) &#123; if(j&lt;A[i]) dp[(i+1)&amp;1][j]= dp[i&amp;1][j]; else dp[(i+1)&amp;1][j] = Math.max(dp[i&amp;1][j],dp[(i+1)&amp;1][j-A[i]]+V[i]); &#125; &#125; return dp[A.length&amp;1][m];&#125; 两个状态转移方程$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=kC_i&lt;=v}$$F[i,v] = max(F[i-1,v],F[i,v-C_i]+W_i)$ exactly装满背包需要的最少/最大物品数量 Input : W = 100 val[] = {1, 30} wt[] = {1, 50}Output : 100 放100个{1，1}是物品数最多的方案 1234567891011private int multicnt(int W,int n,int[] val,int[] wt)&#123; int dp[] = new int[W+1]; for (int i = 0; i &lt;=W ; i++) &#123; for (int j = 0; j &lt; n ; j++) &#123; if(wt[j]&lt;=i)&#123; dp[i] = Math.max(dp[i],dp[i-wt[j]]+val[j] ); &#125; &#125; &#125; return dp[W];&#125; 填满背包的方案数多重背包 第i种物品最多Mi件可用 能否恰好装满 p62$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=k&lt;=Mi}$n个不同的数字，每种m个，能否和恰好为K每种数字，每个最多用m次，能否求和K n=3 a = {3,5,8} m = {3,2,2} K = 17 123456789101112131415public boolean canSum(int[] A, int[] V,int K)&#123; int n = A.length; //dp[i+1][j]用钱i种数字是否能加和成j boolean[][] dp = new boolean[n+1][K+1]; dp[0][0] = true; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;=K ; j++) &#123; //为了使用数字i，需要i-1数字加成j-vi,j-2*vi,j-m*vi的情况 for (int k = 0; k &lt;=A[i]&amp;&amp;k*V[i]&lt;=j ; k++) &#123; dp[i+1][j] |= dp[i][j-k*A[i]]; &#125; &#125; &#125; return dp[n][K];&#125; 123456789101112131415161718192021public boolean canSumOnk(int[] A,int[] V,int K)&#123; //dp[i+1][j] 用前i种数求和j 第i种数最多剩多少个 不能得到j 为-1 int[] dp = new int[K+1]; int n = A.length; Arrays.fill(dp,-1 ); dp[0] = 0; for (int i = 0; i &lt; n ; i++) &#123; for (int j = 0; j &lt;=K ; j++) &#123; //如果前i-1可以得到j i不用加，剩下全部 if(dp[j]&gt;=0)&#123; dp[j] = A[i]; &#125;else if(j&lt;V[i]||dp[j-V[i]]&lt;=0)&#123; dp[j] =-1; &#125;else&#123; //前i-1个可以加出 -V[i]的情况 dp[j] = dp[j-V[i]]-1; &#125; &#125; &#125; return dp[K]&gt;=0;&#125; n=3,m=3,a=[1,2,3] 答案1234567891011121314151617public static int multibagans(int[]a,int n,int m,int M)&#123; int[][] dp = new int[n+1][m+1]; //每种都不取 for (int i = 0; i &lt;=n ; i++) &#123; dp[i][0]=1; &#125; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 1; j &lt;=m; j++) &#123; if(j-1-a[i]&gt;=0) dp[i+1][j] = (dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a[i]]+M)%M; else dp[i+1][j]=(dp[i+1][j-1]+dp[i][j])%M; &#125; &#125; return dp[n][m];&#125; 找钱的方案数123456789101112public int waysNCents(int n) &#123; int[] coins = &#123;1,5,10,25&#125;; int[] dp = new int[n+1]; dp[0] = 1; for(int i =0;i&lt;4;i++)&#123; for(int j = 1;j&lt;=n;j++)&#123; if(j-coins[i]&gt;=0) dp[j] += dp[j-coins[i]]; &#125; &#125; return dp[n];&#125; lt740 coin change2123456789101112public int change(int amount, int[] coins) &#123; int n = coins.length; int[] dp = new int[amount+1]; dp[0] =1; for(int i=0;i&lt;n;i++)&#123; for(int j = 1;j&lt;=amount;j++)&#123; if(j&gt;=coins[i]) dp[j]+=dp[j-coins[i]]; &#125; &#125; return dp[amount];&#125; 递归12345678int count(int[] coins,int N,int idx)&#123; if(N==0)return 1; if(N&lt;0)return 0; if(coins==null||(idx&lt;=0&amp;&amp;N&gt;=1)) return 0; //用/不用这枚硬币(无限次)换 return count(coins,N ,idx-1)+count(coins,N-coins[idx-1] ,idx);&#125; 二维dp123456789101112131415public int coinDp2(int amount, int[] coins)&#123; int n = coins.length;// Arrays.sort(coins); int[][] dp = new int[n+1][amount+1]; dp[0][0] =1; for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 0; j &lt;= amount; j++) &#123; if(coins[i-1]&lt;=j) dp[i][j] += dp[i][j - coins[i-1]]; dp[i][j]+= dp[i - 1][j]; &#125; &#125; return dp[n][amount];&#125; 装配线调度问题Assembly Line两条装配线分别有相同的n个station每个任务必须依次通过这n种station在j号station从装配线1/2换到装配线2/1有额外cost T1(j),T2(j)每条线用时要加上开始用时10/12和结束用时18/7123456789101112131415161718192021222324252627282930313233public class assembleLine &#123; public int assembly(int[][]line,int[][]t,int[]e,int[]x)&#123; int n = line[0].length; int[] T1 = new int[n]; int[] T2 = new int[n]; //两条线经过第一个station后的用时 T1[0] = e[0]+line[0][0]; T2[0] = e[1]+line[1][0]; for(int i =1;i&lt;n;i++)&#123; //line1上第二个station用时是line1前一个用时+当前station 和 从line2上跳过来的用时的min T1[i] = Math.min(T1[i-1]+line[0][i],T2[i-1]+t[1][i]+line[0][i]); T2[i] = Math.min(T2[i-1]+line[1][i],T1[i-1]+t[0][i]+line[1][i]); &#125; return Math.min(T1[n-1]+x[0],T2[n-1]+x[1]); &#125; public static void main(String[] args) &#123; //statin num int n = 4; //[2][4]两条装配线上4个station的耗时 int[][] line =&#123; &#123;4, 5, 3, 2&#125;, &#123;2, 10, 1, 4&#125;&#125;; //两条装配线上换装配线到下一个station的额外开销 int[][] t = &#123;&#123;0, 7, 4, 5&#125;, &#123;0, 9, 2, 8&#125;&#125;;// entry time ei and exit time xi //要加上的开始时间和结束时间 int e[] = &#123;10,12&#125;; int x[] = &#123;18,7&#125;; assembleLine sl = new assembleLine(); System.out.println(sl.assembly(line, t, e, x)); &#125;&#125; lt 254 2个鸡蛋从n层楼中找到可以丢碎鸡蛋的楼层，最少几次1.只能从低往高试，碎了鸡蛋就-12.第一次选择楼层n，再向上跳n-1层，再n-2层假如100层的楼，$n+(n-1)+(n-2)+…+1&gt;=100$-&gt;$(n+1)n/2&gt;=100$ -&gt;n=14第一次从n层楼投没破，则需要再跳一段再投，cnt++，当在 n层破了，则需要搜索1~n-1层。为了平衡向上跳一大格和单步搜索，minimize max regret所以每次往上跳一大格应该缩短破了之后搜索的间隔，弥补一下cnt的计算。每次跳一大格，减少单步搜索的次数。 第一次跳到14，如果没破，搜索1~13，在13层破，则最坏情况14步如果最坏情况跳了14步到达100层破了，跳了14步。 假如10层：策略：$(1+n)*n/2&gt;=10$1print(scipy.optimize.fsolve(lambda x: x**2 + 2*x - 20, 0)) 输出3.58所以4,即4步就能把10层楼遍历掉 4-&gt;7-&gt;9-&gt;10 12345678if(n==1||n==2)return n;long ans = 0;//死循环之后外面不需要return语句了for(int i =1;;i++)&#123; ans+=(long)i; if(ans&gt;=(long)n) return i;&#125; !!887 K个蛋，N层楼正确解法：K个鸡蛋移动M次可以check的最大层数dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1移动1步，如果碎了可以checkdp[m - 1][k - 1]层如果没碎，可以checkdp[m - 1][k]层12345678910public int superEggDrop(int K, int N) &#123; int[][] dp = new int[N + 1][K + 1]; int m = 0; while (dp[m][K] &lt; N) &#123; ++m; for (int k = 1; k &lt;= K; ++k) dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1; &#125; return m;&#125; 压缩成1D 81%1234567public int superEggDrop(int K, int N) &#123; int dp[] = new int[K + 1], m = 0; for (m = 0; dp[K] &lt; N; ++m) for (int k = K; k &gt; 0; --k) dp[k] += dp[k - 1] + 1; return m;&#125; drop(9,3)9层楼3个鸡蛋，在6层落下碎了继续[0~5]层drop(5,2),没碎继续[6~9]层drop(3,3)超时原因 复杂度O(K*N^2)展开代码 超时递归123456789101112int eggDrop(int k,int n)&#123; //1层/0层 if(n==0||n==1)return n; if(k==1)return n; int min = Integer.MAX_VALUE; //[0~5]6[7~9] for(int i =1;i&lt;=n;i++)&#123; int res = Math.max(eggDrop(k-1,i-1),eggDrop(k,n-i)); min = Math.min(res,min); &#125; return min+1;&#125; 超时dp初始化第一行（鸡蛋）和前两列（楼）1234567891011121314151617181920212223242526public int superEggDrop(int K, int N) &#123; int[][] dp= new int[K+1][N+1]; //有鸡蛋 两列楼 for(int i=1;i&lt;=K;i++)&#123; dp[i][0] = 0; dp[i][1] = 1; &#125; //1个鸡蛋 有楼 一列行 没鸡蛋也没楼第一行默认0 for(int i =1;i&lt;=N;i++)&#123; dp[1][i] = i; &#125; int min = Integer.MAX_VALUE; //鸡蛋 int i,j; for( i =2;i&lt;=K;i++)&#123; for( j =2;j&lt;=N;j++)&#123; dp[i][j] = Integer.MAX_VALUE; for(int x = 1;x&lt;=j;x++)&#123; int res = 1+Math.max(dp[i-1][x-1],dp[i][j-x]); dp[i][j] =Math.min(dp[i][j],res); &#125; &#125; &#125; return dp[K][N];&#125; 加速优化1leetcode上的优化和数学方法分析递推方程，dp(k-1,x-1)随着x增加递增。dp(k,N-x)随着x增加递减。二分查找到t1=t2的位置是max(t1,t2)最小的位置复杂度降到复杂度O(K*NLogN) 5% 263ms12345678910111213141516171819202122232425Map&lt;Integer,Integer&gt; memo = new HashMap&lt;&gt;();public int superEggDrop(int K,int N)&#123; //1&lt;=k&lt;=100 if(!memo.containsKey(N*100+K))&#123; int ans; if(N==0)ans = 0; else if(K==1)ans = N; else&#123; int lo = 1,hi = N; while(lo&lt;hi)&#123; int mid = (lo+hi)/2; int t1 = superEggDrop(K-1,mid-1); int t2 = superEggDrop(K,N-mid); if(t1&lt;t2)lo = mid+1; else if(t1&gt;t2) hi = mid; //关键 else lo=hi=mid; &#125; ans = 1+Math.min(Math.max(superEggDrop(K-1,lo-1),superEggDrop(K,N-lo)), Math.max(superEggDrop(K-1,hi-1),superEggDrop(K,N-hi))); &#125; memo.put(N*100+K,ans); &#125; return memo.get(N*100+K);&#125; Celebrity Problem 所有人都认识他但是他不认识所有人方法1：找全是0的行，O(n^2)方法2： 如果A认识B，则A肯定不是名人 O(N)；A不认识B，则A可能是名人，B肯定不是名人A,B不认识，重新入栈AA,C认识，入栈C方法3：双指针12345678910111213141516171819int findCele(int[][]Matrix)&#123; int n = Matrix.length; int a = 0; int b = n-1; while (a&lt;b)&#123; if(Matrix[a][b]==1)&#123; a++; &#125; else&#123; b--; &#125; &#125; for (int i = 0; i &lt;n ; i++) &#123; //不是自己，但是别人不认识他，或者他认识别人 if(i!=a&amp;&amp;Matrix[i][a]!=1||Matrix[a][i]==1) return -1; &#125; return a;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ToDoAgain]]></title>
    <url>%2F2018%2F09%2F03%2Falg2do%2F</url>
    <content type="text"><![CDATA[153 Roataed Sorted Array的最小值 二分logN123456789101112public int findMin(int[] nums) &#123; if(nums.length==1)return nums[0]; return findMin(nums,0,nums.length-1);&#125;private int findMin(int[] nums,int low,int hi)&#123; //只有1个或者2个 if(low+1&gt;=hi)return Math.min(nums[low],nums[hi]); if(nums[low]&lt;nums[hi])return nums[low]; int mid = low+(hi-low)/2; //无缝 return Math.min(findMin(nums,low,mid-1),findMin(nums,mid ,hi));&#125; 154 有重复元素Roataed Sorted Array Input: [2,2,2,0,1]Output: 0 去掉第二个递归条件。 138https://leetcode.com/problems/copy-list-with-random-pointer/solution/ poj3617构造最小字典序12345678910111213141516171819202122232425262728293031/** * 不断取Min(S头/尾)放到T末尾 * 相等：判断下一个字符希望先用到小的字符 * 可以的操作： * 从S头删除一个加到T尾 * 从S尾删除一个加到T尾 * * @param S ACDBCB * @return 构造字典序尽可能小的字符串T ABCBCD */public static String BestCowLine(String S)&#123; int a = 0,b = S.length()-1; StringBuilder sb = new StringBuilder(); while (a&lt;=b)&#123; //关键 boolean left = false; //a+i&lt;b关键 for (int i = 0; a+i &lt;= b ; i++) &#123; if(S.charAt(a+i)&lt;S.charAt(b-i))&#123; left = true; break; &#125;else if(S.charAt(a+i)&gt;S.charAt(b-i))&#123; left = false; break; &#125; &#125; if(left)sb.append(S.charAt(a++)); else sb.append(S.charAt(b--)); &#125; return sb.toString(); &#125; 818 A加速，R掉头并减速，到指定位置最少需要多少条指令 当车得到指令 “A” 时, 将会做出以下操作： position += speed, speed *= 2。 当车得到指令 “R” 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。 (当前所处位置不变。) 例如，当得到一系列指令 “AAR” 后, 你的车将会走过位置 0-&gt;1-&gt;3-&gt;3，并且速度变化为 1-&gt;2-&gt;4-&gt;-1。 输入:target = 3输出: 2解释:最短指令列表为 “AA”位置变化为 0-&gt;1-&gt;3 ！！！！76 最小的子串窗口 很重要的题152 最大子列乘积 保留当前值之前的最大积和最小积负数的最小积有潜力变成最大积4ms 11.99%1234567891011public int maxProduct(int[] nums) &#123; int sum = nums[0],min = nums[0],max = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int nextmax = nums[i]*max; int nextmin = nums[i]*min; max = Math.max(Math.max(nextmax,nextmin),nums[i]); min = Math.min(Math.min(nextmax,nextmin),nums[i]); sum = Math.max(max,sum); &#125; return sum;&#125; 127 word Ladder bfs最短单词转换路径//todo双向bfs 注意marked和dfs的不同，单纯bfs访问wordlist里每个单词1.79% 1097ms//list.size()*cur.length()展开代码 12345678910111213141516171819202122232425262728293031323334private boolean dif(String difword,String cur)&#123; int cnt=0; for(int i =0;i&lt;difword.length();i++)&#123; if(difword.charAt(i)!=cur.charAt(i))&#123; cnt++; if(cnt&gt;1)return false; &#125; &#125; return true;&#125;public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int cnt = 0; HashSet&lt;String&gt; words = new HashSet&lt;&gt;(); for(String word:wordList)&#123; words.add(word); &#125; Set&lt;String&gt; marked = new HashSet&lt;&gt;(); Deque&lt;String&gt; que = new ArrayDeque&lt;&gt;(); que.add(beginWord); marked.add(beginWord); while(!que.isEmpty())&#123; cnt++; int size = que.size(); while(size&gt;0)&#123; size--; String cur = que.poll(); for(String difword:words)&#123; if(dif(difword,cur))&#123; if(difword.equals(endWord))return cnt+1; if(!marked.contains(difword))&#123; que.add(difword); marked.add(difword);&#125;&#125;&#125;&#125;&#125; return 0;&#125; 先改变单词cur.length()*25再查表47% 97ms展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int cnt = 0; HashSet&lt;String&gt; words = new HashSet&lt;&gt;(); for(String word:wordList)&#123; words.add(word); &#125; Set&lt;String&gt; marked = new HashSet&lt;&gt;(); Deque&lt;String&gt; que = new ArrayDeque&lt;&gt;(); que.add(beginWord); marked.add(beginWord); while(!que.isEmpty())&#123; cnt++; int size = que.size(); while(size&gt;0)&#123; size--; String cur = que.poll(); //System.out.println(cur); char[] curr = cur.toCharArray(); for(int i =0;i&lt;curr.length;i++)&#123; char ori = curr[i]; for(char c='a';c&lt;='z';c++)&#123; if(curr[i]!=c)&#123; curr[i]=c; String next = new String(curr); if(words.contains(next))&#123; if(next.equals(endWord))return cnt+1; if(!marked.contains(next))&#123; que.add(next); marked.add(next); &#125; &#125; &#125; &#125; curr[i] = ori; &#125; &#125; &#125; return 0; &#125; 464 博弈A,B玩家轮流从1-10中选数组加到同一个total，让total先大于11的赢.B肯定赢。1.计算1-n个数的permutation，并判断每个赢的可能性复杂度(n!)2.因为1,2…和2,1…是一样的，所以可以降为$2^n$状态压缩 子状态，m个数state[m+1]表示visited 记忆化递归key是子状态，Arrays.toString(state) 遍历state中还是0的没选的数， 如果d-i选这个数赢了或者另一个人递归d-i的子问题不能赢， 更新map中这个state为true，可以先state[i]=0回溯return true到之前的选择(上一层递归) 12345if(d-i&lt;0||!canwin(d-i,hmap))&#123; hmap.put(key,true); state[i]=0; return true;&#125; 如果对方赢了，不选这个state[i]=0，继续尝试循环中其它state如果所有的state都试过了也不行，说明当前子问题hamp.put(key,false),return false 优化19ms：用二进制存一个int表示状态 用byte[i&lt;&lt;M+1]记忆化12int byte[] m_;m = new byte[1&lt;&lt;M+1]; 遍历M个数12345if(state&amp;(1&lt;&lt;i)&gt;0)continue;if(!canwin(d-i,state|(1&lt;&lt;i)))&#123; m_[state]=1; return true;&#125; 出循环，表示这个状态不行12m_[state]=-1;return false; 优化2：如果用byte[1&lt;&lt;M] 遍历0~M ,canwin(d-i+1,state|(1&lt;&lt;i))只需要15ms 1左移i位int mask=1&lt;&lt;i表示选这个数的状态如果(mask&amp;visited)==0表示没使用过这个数另一个玩家能不能赢的state：mask|visited 在visited（上一个状态）的基础将i位也置1 486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高https://leetcode.com/problems/predict-the-winner/solution/{3，9，1，2} 二维数组dp：[i][j]只用右上三角表示两个人都从list取1个数，2个数，3个数到list长能获得的最大差值 填对角线，如果两个人只剩下一个数为3：{A取3，B取0}，剩下9：{A取9，B取0}… 如果剩下2个数，剩下{3,9}[1][2]：{A取9，B剩下{3}回到1的情况}… 如果剩下3个数，剩下{3,9,1}[1][3]:{A取3,B剩下{9,1}即表格[2][3]的情况} 剩下4个数，填[1][4]即为答案 递归：但是会有很多重复计算复杂度$2^n$比如让对手选[3,9,1]后，自己选[9,1]和[3,9]/让对手选[9,1,2]后，自己选[9,1]和[1,2][9,1]被计算了两次。可以进行存储1234567//最大的分数差int dif(int[] nums,int left,int right)&#123; //如果长度为1，获得的差值就是这个数 if(left==right)return nums[left]; //选一个数之后 交给对手用相同策略选 return max(nums[left]-dif(nums,left+1,right),nums[right]-dif(nums,left,right+1));&#125; 用一维数组存储key是left*len+right展开代码 123456789101112131415int[] m;int len =0;public boolean PredictTheWinner(int[] nums) &#123; this.len = nums.length; if(len==1)return true; this.m= new int[len*len]; return help(nums,0,len-1)&gt;=0;&#125;private int help(int[] nums,int l,int r)&#123; if(l==r)return nums[l]; int index = l*len+r; if(m[index]&gt;0)return m[index]; m[index]=Math.max(nums[l]-help(nums,l+1,r),nums[r]-help(nums,l,r-1)); return m[index];&#125; lt 1470 1号玩家先取。问最后谁将获胜。 他们只能从数组的两头进行取数，且一次只能取一个。若1号玩家必胜或两人打成平局，返回1，若2号玩家必胜，返回2。如果数组长度是偶数 先手必胜只要return 1就行了 123456789public int theGameOfTakeNumbers(int[] arr) &#123; if(dif(arr,0,arr.length-1)&gt;=0)return 1; else return 2;&#125;private int dif(int[] nums,int left,int right)&#123; if(left&lt;right)return 0; if(left==right)return nums[left]; return Math.max(nums[left]-dif(nums,left+1,right),nums[right]-dif(nums,left,right-1));&#125; lc 877 偶数堆石子排成一行，每堆都有正整数颗石子 piles[i]输入： [5,3,4,5] 先手可以拿1+3 或者2+4 对手反之拿2+4或者1+3，所以先手选大的那个肯定赢。递归同上 77%可以加一个memo[l][r] 从2^n-&gt;n^2 因为l和r一共有n^2个子问题 dp ：1234567891011121314151617public boolean stoneGame(int[] piles) &#123; int n = piles.length; int[][] dp = new int[n][n]; //left=i,right=i的子问题 for (int i = 0; i &lt;n ; i++) &#123; dp[i][i] = piles[i]; &#125; //长度为[2,n]的子问题 for (int i = 2; i &lt;=n ; i++) &#123; for (int l = 0; l &lt;n-i+1 ; l++) &#123; int r = i+l-1; //[l+1][r]的长度比[l][r]小 已经计算过了 dp[l][r] = Math.max(piles[l]-dp[l+1][r],piles[r]-dp[l][r-1]); &#125; &#125; return dp[0][n-1]&gt;0;&#125; 子问题是 长度-1的dp 降维1234567891011public boolean stoneGameDP1D(int[] piles) &#123; int n = piles.length; int[] dp = piles.clone(); for (int i = 2; i &lt;=n ; i++) &#123; for (int l = 0; l&lt;n-i+1 ; l++) &#123; //dp[i] 还没有更新,都是长度i-1的值 dp[i] = Math.max(piles[l]-dp[i+1],piles[l+i-1]-dp[i] ); &#125; &#125; return dp[0]&gt;0;&#125; lt920 meeting room给定一系列的会议时间间隔，包括起始和结束时间[[s1,e1]，[s2,e2]，…(si &lt; ei)，确定一个人是否可以参加所有会议。[[0,30]，[5,10]，[15,20]]，返回false。贪心12345678910public boolean canAttendMeetings(List&lt;Interval&gt; intervals) &#123; if(intervals == null||intervals.size() == 0)return true; Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); int end = intervals.get(0).end; for (int i = 1; i &lt; intervals.size(); i++) &#123; if(intervals.get(i).start&lt;end)return false; end = Math.max(end,intervals.get(i).end); &#125; return true;&#125; 一个人最多可以参加几个会议12345678910111213public int howmany(List&lt;Interval&gt; intervals)&#123; intervals.sort((a,b)-&gt;a.end-b.end); int cnt = 0; int end = 0; for (int i = 0; i &lt;intervals.length ; i++) &#123; if(end&lt;intervals.get(i).start)&#123; // System.out.println(i); cnt++; end = intervals.get(i).end; &#125; &#125; return cnt;&#125; lt919 !!!需要几个会议室不能贪心： [[1, 5][2, 8][6, 9]]这种情况本来只需要2间房，但是直接贪心就会需要3间房 1234567891011121314151617181920212223242526272829303132333435363738/** |___| |______| |_____| |____| starts: | | | | i ends: | | | | end res++; --------- i end res++; 这个end之前有2个start，前一个会议没有结束 --------- i end end++; start&gt;end表示有个room的会议已经结束，可以安排到这个room --------- *///251ms 74%public int minMeetingRooms2Arr(List&lt;Interval&gt; intervals) &#123; int[] starts = new int[intervals.size()]; int[] ends = new int[intervals.size()]; for(int i=0;i&lt;intervals.size();i++)&#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); int cnt =0; int end = 0; for (int i = 0; i &lt; intervals.size(); i++) &#123; if(starts[i]&lt;ends[end])cnt++; else end++; &#125; return cnt;&#125; 用TreeMap123456789101112131415//240ms 75%public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; TreeMap&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;(); for(Interval i:intervals)&#123; map.put(i.start,map.getOrDefault(i.start,0)+1); map.put(i.end,map.getOrDefault(i.end,0)-1); &#125; int room = 0; int max = 0; for(int num:map.values())&#123; room+=num; max = Math.max(max,room); &#125; return max;&#125; 用PriorityQ1234567891011//403ms 54%public int minMeetingRoomsPQ(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals,(o1, o2)-&gt;o1.start-o2.start); PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;&gt;(intervals.size(),(o1, o2)-&gt;o1.end-o2.end); heap.add(intervals.get(0)); for (int i = 1; i &lt;intervals.size() ; i++) &#123; if(intervals.get(i).start&gt;=heap.peek().end)heap.poll(); heap.add(intervals.get(i)); &#125; return heap.size();&#125; 452 重叠线段？？12345678910111213int cnt =0;//按结束顺序排序不会出现// |__| 只有： |___| 和 |____|//|______|的情况 |____| |_|Arrays.sort(points,(a,b)-&gt;a[1]&gt;b[1])for(int i =0;i&lt;points.length;i++)&#123; int cur = points[i][1]; cnt++; while(i+1&lt;points.length&amp;&amp;points[i+1][0]&lt;=cur&amp;&amp;cur&lt;=points[i+1][1])&#123; i++; &#125;&#125;return cnt; 前一个的end在i+1的线段中，则跳过。问题：1&#123;&#123;1,3&#125;,&#123;2,5&#125;,&#123;4,7&#125;,&#123;6,9&#125;&#125;输出2还是3？ 56 合并区间 扫描线 Input: [[1,4],[4,5]]Output: [[1,5]] 方法1：O(nLogn) 需要O(n)空间1.按起点排序，2.push第一个interval3.for全部interval： a.不交叉，push b.交叉,更新栈顶的end 59ms 27%展开代码 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if(intervals==null||intervals.size()&lt;2)return intervals; intervals.sort((a,b)-&gt;a.start-b.start); List&lt;Interval&gt; rst = new ArrayList&lt;&gt;(); for(Interval interval:intervals)&#123; if(rst.size()&lt;1)&#123; rst.add(interval); &#125; else if(rst.get(rst.size()-1).end&gt;=interval.start)&#123; // 不用新建 只需要更新栈顶 // Interval newInter = rst.get(rst.size()-1); // rst.remove(rst.size()-1); // newInter.end = Math.max(newInter.end,interval.end); // rst.add(newInter); rst.get(rst.size()-1).end =Math.max(rst.get(rst.size()-1).end,interval.end); &#125;else&#123; rst.add(interval ); &#125; &#125; return rst;&#125; 方法2：分解成start[],end[]思想：后一个区间的start(i+1)一定要大于前一个区间的end(i)98% 10ms1234starts: 1 2 8 15 i i+1ends: 3 6 10 18 j add(1,6)start[i+1]&gt;end[i] 直到找的第一个start&gt;end add(start[j],end[i]) j=i+1如果start到了最后一个，这个区间肯定是从上一个区间(j)开始，到end(i)结束1234567891011121314151617181920public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; int len = intervals.size(); int[] start = new int[len]; int[] end = new int[len]; for(int i =0;i&lt;len;i++)&#123; start[i] = intervals.get(i).start; end[i] = intervals.get(i).end; &#125; Arrays.sort(start); Arrays.sort(end); List&lt;Interval&gt; rst = new ArrayList&lt;&gt;(); for(int i =0,j=0;i&lt;len;i++)&#123; //关键 当start扫描到最后一个 ，直接建立起最后一个区间 if(i==len-1||start[i+1]&gt;end[i])&#123; rst.add(new Interval(start[j],end[i])); //下一个区间起点 j=i+1; &#125; &#125;&#125; 方法3：原地算法1.按地点降序排序 a如果不是第一个，并且和前一个可以合并，则合并b push当前 lt156合并区间 123456[ [ (1, 3), (1, 6), (2, 6), =&gt; (8, 10), (8, 10), (15, 18) (15, 18) ]] O(n log n) 的时间和 O(1) 的额外空间。 原地算法 57 插入一个区间并合并方法1： 将区间插到newInterval.start&gt;interval.start之前的位置，用56的和last比较合并方法2： 分成left+new+right三部分并合并 中间部分取自身和重叠区间的min/max12345678910111213141516171819public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; left = new ArrayList&lt;&gt;(); List&lt;Interval&gt; right = new ArrayList&lt;&gt;(); int start =newInterval.start; int end =newInterval.end; for(Interval interval:intervals)&#123; if(interval.end&lt;newInterval.start)&#123; left.add(interval); &#125;else if(interval.start&gt;newInterval.end)&#123; right.add(interval); &#125;else &#123; start = Math.min(start,interval.start); end = Math.max(end,interval.end); &#125; &#125; left.add(new Interval(start,end)); left.addAll(right); return left;&#125; ？？？315 输出数组每个位置后有多少个数字比它小暴力n^2复杂度一般只能到1k数量级 方法一：1.把input倒序，并映射到argsort的index2.建立unique frequence list 原数组中unique的元素+13.逆序扫描input，更新相应的frequence[rank]++。 并求frequence rank-1前的sum #有几个元素比当前元素小4.依次读入的sum list 倒序就是结果 方法2：BST1.逆序读入建BST 动态更新 并sum所有有右节点的count+left累加和 方法3：归并排序 小和问题(右边有多少个数比它大)123451 3 4 2 5 / \1 3 4 2 5 /\ 13 4 归并1,3得小和-&gt;+1归并13，4 得小和-&gt;+1,+3 并且merge好了[1,3,4]归并2,5 得小和-&gt;+2归并134,25 :1比右边多少个数小：2的位置是mid+1，所以通过index可以得到 小和1x2个p1指向3，p2指2，无小和p1=3 p2=5 小和3x1个p1=4 p2=5 小和4x1 例子2123451 3 4 5 6 71比多少个数小：13)-&gt;113)4)-&gt;113)4)567)-&gt;1*3 如果[p1…][p2…]如果p1比p2小，则p1比p2后面的数都小，是后面的数的小和比归并排序就多这一句1res+=arr[p1]&lt;arr[p2]?(r-p2+1)*arr[p1]:0; 展开代码 123456789101112131415161718192021222324252627282930313233343536373839//数组每个数左边比当前小的数累加起来叫这个 组数的小和。//[1,3,4,2,5]-&gt;1 +1+3 +1 +1+3+4+2 public int xiaohe(int[] arr)&#123; if(arr==null||arr.length&lt;2)return 0; return mergesort(arr,0,arr.length-1); &#125; private int mergesort(int[] arr,int l,int r)&#123; if(l==r)return 0; int mid = l+((r-l)&gt;&gt;2); return mergesort(arr,l,mid)+mergesort(arr,mid+1,r)+merge(arr,l,mid,r); &#125;// 如果[p1...][p2...]// 如果p1比p2小，则p1比p2后面的数都小，是后面的数的小和 private static int merge(int[] arr,int l,int mid,int r)&#123; int[] help = new int[r-l+1]; int i = 0; int p1 = l; int p2 = mid+1; int res = 0; while (p1&lt;=mid&amp;&amp;p2&lt;=r)&#123; System.out.println(res); res+=arr[p1]&lt;arr[p2]?(r-p2+1)*arr[p1]:0; help[i++] = arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++]; System.out.println(Arrays.toString(help)); &#125; while (p1&lt;=mid)&#123; help[i++] = arr[p1++]; &#125; while (p2&lt;=r)&#123; help[i++] = arr[p2++]; &#125; for (int j = 0; j &lt;help.length ; j++) &#123; arr[l+j] = help[j]; &#125; System.out.println(Arrays.toString(help)); return res; &#125; ??Convert BST to Greater Tree17ms 66% Reverse Morris In-order Traversal展开代码 123456789101112131415161718192021222324252627282930313233public TreeNode convertBST(TreeNode root) &#123; int sum = 0; TreeNode cur = root; while(cur!=null)&#123; //最右 if(cur.right==null)&#123; sum+=cur.val; cur.val=sum; cur=cur.left; &#125;else&#123; //找前继，键link TreeNode pre = cur.right; //一直向左 while(pre.left!=null&amp;&amp;pre.left!=cur)&#123; pre=pre.left; &#125; //找到了pre 联立链接 if(pre.left== null)&#123; pre.left = cur; cur=cur.right; &#125; //右边没了，并且左连接向上 else&#123; pre.left=null; sum+=cur.val; cur.val= sum; cur=cur.left; &#125; &#125; &#125; return root; &#125; 正常做法递归中序 15ms 99%12345678public TreeNode convertBST(TreeNode root) &#123;if(root==null)return root;convertBST(root.right);sum+=root.val;root.val=sum;convertBST(root.left);return root;&#125; lc393 判断合法UTF8编码287 数组中重复元素网络流https://algs4.cs.princeton.edu/64maxflow/https://www.geeksforgeeks.org/minimum-cut-in-a-directed-graph/ 最小割 st-cut 去掉这几条边，源点S和终点T就会被分为两个不相交的set，S到不了T。这种边集的最小值断掉两点间的通信的最小代价。 最大流max-flow 边的流量小于capacity。每个点的入流和出流相等。除了源点S和终点T。求源点/终点能发出/接收的最大值。 其实可以是一个问题。 Ford-fulkerson算法1 先假设每条边的当前流量是0/capacity2 找到S到T的路径，并最大化这条路径上的空的边的当前流量3 继续找路径，如果可以通过一条边的反向到达T，经过的是一条边的反向流，则减少这条边逆向流过去。4 每条边到达正向包和或者负向为0 不能remove from backward edge flow value lemma :最小cut上的流量 == 最大网络流flow &lt;= capacity of cutmax flw == min cut 已知最大流(cur/capacity) 求cut从S点 正向走最不满的正向流。走最满的逆向流，满正向流和空逆向流当作不存在。 如何找augmenting path BFS如果容量都是integernumber of augemntation &lt;= maxflow value 每次增加至少1 查找插入 786 数组中可能组成的分数排序后第k大的是哪个组合数组长度2000 n^2的算法是超时 A = [1, 2, 3, 5], K = 3Output: [2, 5]Explanation:The fractions to be considered in sorted order are:1/5, 1/3, 2/5, 1/2, 3/5, 2/3.The third fraction is 2/5. M[i][j]=A[i]/A[j]肯定在右上角最小1231/2 1/3 1/5 - 2/3 2/5- - 3/5 1 查比0.5小有1/2,1/3,2/5 大于3个 r =0.52 查比0.25小的有1/5 l=0.253 查比0.375小的有1/3,1/5 l=0.3754 查比0.475小的正好3个 ！？？？95 输出全部不同的BST[1~n]组成的BST1231.......k...n / \[1~k-1] [k+1,n] 与上一层的构建过程是一样的 287 数组中只有1个重复元素 返回元素 containing n + 1 integers where each integer is between 1 and n (inclusive) 不用set，空间降为O(1)将数组的数字想象成链表，找环 1 4 6 6 6 2 3 慢指针走num[slow]快指针走num[num[fast]] 慢指针会在环与head指针相遇12345678910111213141516public int findDuplicate(int[] nums) &#123;// use only constant, O(1) extra space int slow = nums[0]; int fast = nums[0]; do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125;while(slow != fast); int head = nums[0]; while(head!=slow)&#123; head= nums[head]; slow = nums[slow]; &#125; return head;&#125; 142 环起始于哪个node1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;3 meet:6a: 从head到环b：快指针走了两次的环内距离(慢指针到环起点的距离)c: 慢指针没走完的环内距离已知快指针走的距离是slow的两倍慢=a+b 快=a+2b+c则a=c从len(head - 环起点) == 慢指针没走完的环距离head与慢指针能在环起点相遇。1234567if(slow==fast)&#123; while(head!=slow)&#123; head=head.next; slow=slow.next; &#125; return slow;&#125; 719410 分割数组使Max(Sum(subarr))最小 Input:nums = [7,2,5,10,8]m = 2Output:18 [7,2,5] and [10,8], 复杂度： mn^2 有mn个子问题 每个子问题找最佳k dp[i][j] 长度为j的数组划分成i组的最大值1.dp[1][j]= sum(0,j)2.找分割点k，k左边划成i-1组的解和右边划分为1组 取max，在所有分割点k中取最小值dp[i][j] = min(max(dp[i-1][k],sum(k+1,j))递归：76ms 6% 二分：复杂度(log(sum(nums))*n) 空间O(1) ok //todo nextlower bound 数组中的最大元素max(nums)up bound 分成1组 sum(nums)12345678910111213141516171819202122232425262728293031323334public int splitArray(int[] nums, int m) &#123; int max = 0;long sum = 0; for(int num:nums)&#123; max = Math.max(num,max ); sum+=num; &#125; if(m==1)return (int)sum; long l = max,r = sum; while (l&lt;=r)&#123; long mid = (l+r)/2; //用这个最小值能不能划分成m组 可以更小一点 if(valid(mid,nums ,m ))&#123; r = mid-1; &#125; else&#123; l = mid+1; &#125; &#125;return (int)l;&#125;private boolean valid(long target,int[] nums,int m)&#123; int cnt =1; long total = 0; for(int num:nums)&#123; total += num; if(total&gt;target)&#123; total = num; //需要一个新的分组 cnt++; if(cnt&gt; m)return false; &#125; &#125; return true;&#125; 5只猴子分桃，每次拿走一个正好分成5堆，问桃子数!543树中两点的最远路径，自己到自己0 [4,2,1,3]路径长度3 将每个点试当成转折点,在更新左右最长高度的同时更新rst = Max(rst,l+r); ！！687树中值相等的点的路径长!!!114原地将二叉树变成链表1.入栈迭代40% 1. 先入栈右子树，再入栈左子树，更新右节点为栈顶。 2. 将当前左子树变成null。下一次循环cur是栈顶（原左子树） 后序遍历 递归6%123456pre = null;flat(root.right);flat(root.left);root.right = pre;root.left = null;pre = root; 438 Anagrams in a String 滑动窗口Arryas.equals Anagrams 字母相同，顺序不同的单词 连续s: “cbaebabacd” p: “abc”Output:[0, 6] 输出起始位置 Sliding Window algorithm16ms 50%12345678910111213141516171819public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); int[] ch = new int[26]; int wcn = p.length(); for(char c:p.toCharArray())&#123; ch[c-'a']++; &#125; int[] window = new int[26]; for (int i = 0; i &lt;s.length() ; i++) &#123; if(i&gt;=wcn)&#123; --window[s.charAt(i-wcn)-'a']; &#125; window[s.charAt(i)-'a']++; if(Arrays.equals(window, ch))&#123; rst.add(i-wcn+1); &#125; &#125; return rst;&#125; ！5 最长回文串 lt893最快最正确的做法8ms 99%:版本2123456789101112131415161718192021222324252627public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0)&#123; return s; &#125; char[] ca = s.toCharArray(); int rs = 0, re = 0; int max = 0; for(int i = 0; i &lt; ca.length; i++) &#123; if(isPalindrome(ca, i - max - 1, i)) &#123; rs = i - max - 1; re = i; max += 2; &#125; else if(isPalindrome(ca, i - max, i)) &#123; rs = i - max; re = i; max += 1; &#125; &#125; return s.substring(rs, re + 1);&#125;private boolean isPalindrome(char[] ca, int s, int e) &#123; if(s &lt; 0) return false; while(s &lt; e) &#123; if(ca[s++] != ca[e--]) return false; &#125; return true;&#125; 版本1123456789101112131415161718192021222324252627282930int max = 0;int left = 0;char[] chars;public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0)&#123; return s; &#125; chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++)&#123; i = longestPalindrome(i); &#125; return s.substring(left, left + max);&#125;private int longestPalindrome(int index)&#123; int ll = index, rr = index; while (rr + 1 &lt; chars.length &amp;&amp; chars[rr] == chars[rr + 1])&#123; rr++; &#125; int temp = rr; while (ll - 1 &gt;= 0 &amp;&amp; rr + 1 &lt; chars.length &amp;&amp; chars[ll - 1] == chars[rr + 1])&#123; ll--; rr++; &#125; if (rr - ll + 1 &gt; max)&#123; max = rr - ll + 1; left = ll; &#125; return temp;&#125; http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/!!反转做法不行:abcxyzcba -&gt; abczyxcba -&gt;相同的abc并不是回文!! 不能用LCS“cba”是“abc”的 reversed copy中心扩展法：回文的中心有奇数：n个，偶数：n-1个位置会输出靠后的abab-&gt;输出bab12345678910111213141516171819202122232425262728int len;public String longestPalindrome(String s) &#123; if(s==null||s.length()&lt;2)return s; len = s.length(); int start = 0;int end = 0; // int max = 0; for(int i =0;i&lt;len;i++)&#123; //"babad" -&gt;"bab" -&gt;i =1 len = 3 //"cbbd" -&gt; "bb" -&gt;i=1 len = 2 int len1 = help(s,i,i);//奇数扩展 int len2 = help(s,i,i+1);//偶数扩展 int max = Math.max(len1,len2); if(max&gt;end-start)&#123; start = i - (max-1)/2;//去掉中间那个左边长度的一半 end = i+max/2;//右边长度的一半 &#125;//end-start= i+max/2-i+(max-1)/2 = max-1/2 &#125; return s.substring(start,end+1); &#125;private int help(String s,int left,int right)&#123; while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; return right-left-1;&#125; Manacher’s 算法 O(n) 并不理解https://algs4.cs.princeton.edu/53substring/Manacher.java.html前缀/ 73%123456789101112131415161718192021222324252627282930public String longestPalindrome2(String s) &#123; StringBuilder sb = new StringBuilder("^#"); for (int i = 0; i !=s.length() ; i++) sb.append(s.charAt(i)).append("#"); sb.append("$"); final int N = sb.length(); int[] p = new int[N]; //id是长度为mx的回文串的中心(? int id = 0,mx = 0; int maxLen = 0,maxId= 0; for (int i = 1; i &lt;N-1 ; i++) &#123; //注意// System.out.println(2*id-i); p[i] = mx &gt; i ? Math.min(p[2 * id - i], mx - i ) : 1; while(sb.charAt(i+p[i])==sb.charAt(i-p[i])) p[i]++; if(mx &lt; i+p[i])&#123; mx = i+p[i]; id = i; &#125; if(maxLen &lt; p[i])&#123; maxLen = p[i]; maxId = i; &#125; &#125; int start = (maxId-maxLen)/2; return s.substring(start,start+maxLen-1);&#125; 回文树next[i][c] 编号为i的节点表示的回文串两边添加c后变成的回文串编号。fail[i]节点i失配后cnt[i] K-D tree快速排序的各种优化https://algs4.cs.princeton.edu/23quicksort/ 前序中序构造二叉树A BDEG CFDBGE A CF1234567891011121314public TreeNodeT&lt;Character&gt; createTree(String preOrder,String inOrder)&#123; if(preOrder.isEmpty())return null; char rootVal = preOrder.charAt(0); int leftLen = inOrder.indexOf(rootVal); TreeNodeT&lt;Character&gt; root = new TreeNodeT&lt;Character&gt;(rootVal); root.left = createTree( preOrder.substring(1,1+leftLen), inOrder.substring(0,leftLen)); root.right = createTree( preOrder.substring(1+leftLen), inOrder.substring(leftLen+1)); return root;&#125; 106 中序+后序建树698 将数组分成sum相等的k份？？？有100个帽子，每个人有几顶，问每个人戴出来都不一样有多少种239 数组给定滑动窗口大小的最大值Monotonic queue 前后可以修改o(1)，并且可以随机访问维护一个单调递减的序列，读一个窗口输出单调队列的first 15 3sum=0 荷兰国旗写法3指针1p：从0~len-2，3个数的和 右边至少留两个数 sum=0-nums[i]转化成2sum问题去重：当num[i]=num[i-1]:continue另外两个指针从1p往后从len-1往前。去重：预判：nums[low]=nums[low+1]:low++;nums[high]=nums[high-1]:high–; poj2406 字符串周期 power stringhttps://my.oschina.net/hosee/blog/661974http://poj.org/problem?id=2406abcd 1aaaa 4ababab 3 459 判断字符串有重复模式 KMPkmp89% todo !!!3 连续最长不重复子序列32%用set维护一个[i,j)窗口，不重复则窗口向右扩展，重复则窗口右移。12345678910111213public int lengthOfLongestSubstring(String s)&#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0,i=0,j=0; while(i&lt;n&amp;&amp;j&lt;n)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans,j-i); &#125; else set.remove(s.charAt(i++)); &#125; return ans;&#125; 优化： todoint[26] for Letters ‘a’ - ‘z’ or ‘A’ - ‘Z’int[128] for ASCIIint[256] for Extended ASCII 659 数组413 数组划分 能组成的等差数列个数 A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 725链表划分成k份子集lt886 判断凸包https://www.lintcode.com/problem/convex-polygon/description ?409 string中字符组成回文串的最大长度1.开int[128]，直接用int[char]++计数2.奇数-1变偶数&amp;(~1)3.判断奇数(&amp;1)&gt;0 ！30 字典中单词连续出现在字符串中的位置 AC自动机（？加入字典的常用写法dict.put(word,dict.getOrDefault(word,0)+1)展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Solution &#123;public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res;&#125;public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start;&#125;public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1);&#125;&#125; 139 word break1.状态：boolean[n+1]长度为i的前缀能否由字典组成2.初始值：[0]=true 空字符串3.转移方程if(dp[i]==true&amp;&amp;dic.contains(sub(i,i+j))) dp[i+j]=true4.结果 12345678910f[0]=true;for(int i =1;i&lt;s.length();i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(f[j]&amp;&amp;dic.contains(s.substring(j,i)))&#123; f[i]=true; break; &#125; &#125;&#125;return f[s.length()]; 55 ?jump gamejump gamei+nums[i]大于lastp表示i位置可以跳到lastp位置。将lastp更新成现在的i。再向前直到lastp变成0，表示0位置可以到下一个lastp一直到len-1。1234lastp = len-1;for(int i =len-1;i&gt;=0;i--) if(i+nums[i]&gt;=lastp)lastp==i;return lastp==0; 45 ??????jump game最少跳跃次数超时递归（？递归终止条件是from==end，如果有0不可达展开代码 1234567891011121314151617181920212223public int minJumpRecur(int[] arr)&#123; int n = arr.length; memo = new int[n][n]; return jump(arr, 0, n-1);&#125;int[][] memo;private int jump(int[] steps,int from,int end)&#123;// System.out.println(from+" "+end); if(from==end)return 0; //不可达 if(memo[from][end]!=0)return memo[from][end]; if(steps[from]==0)return Integer.MAX_VALUE; int min = Integer.MAX_VALUE; //当前可以到达的范围是[from,from+step[from]] for(int i = from+1;i&lt;=end&amp;&amp;i&lt;=from+steps[from];i++)&#123; int jumps = jump(steps,i , end); if(jumps!=Integer.MAX_VALUE&amp;&amp;jumps+1&lt;min)&#123; min = jumps+1; memo[from][end] = min; &#125; &#125; return min;&#125; 1.在本次可跳跃的长度范围内如果不能达到len-1则表示一定要跳跃//不懂12345678910111213141516171819public int jump(int[] nums) &#123; if(nums==null||nums.length&lt;2)return 0; int res = 0; int curMax = 0; int maxNext = 0; //i=0,max = 2 i==cur -&gt;res++,cur = max=2 //i=1,max = max(2,4)=4, i!=cur //i=2,max = max(4,3)=4, i==cur res++,cur = max=4 //i=3,max = max(4,4)=4, i!=cur break //不需要走到i=4,max = max(4,4+4)=8,i==cur res++,cur=max for (int i = 0; i &lt; nums.length-1; i++) &#123; maxNext = Math.max(maxNext,i+nums[i] ); if(i==curMax)&#123; res++; curMax = maxNext; &#125; &#125; return res;&#125; 2.!!!BFS123456789101112131415161718public int jumpBFS(int[] nums)&#123; if(nums==null||nums.length&lt;2)return 0; int level = 0; int cur = 0; int max =0; int i =0; //cur-i+1=1,level++; i&lt;=cur,i++,max = 2;cur = 2; //cur=2,i=1;level++; i&lt;=2,i++,max = 4,max&gt;=n-1 return 2; while (cur-i+1&gt;0)&#123; level++; for(;i&lt;=cur;i++)&#123; max = Math.max(max,nums[i]+i); if(max&gt;=nums.length-1)return level; &#125; cur = max; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构模板&模板题]]></title>
    <url>%2F2018%2F09%2F01%2FadvanceDS%2F</url>
    <content type="text"><![CDATA[归并树每个节点对应区间排好序的结果 O(nlogn)建立树 连通分量无向图的连通分量可以用并查集（集合）来做并查集：[12,3,4,5]-&gt;[6,2,3,4,5]位置存放的是根节点有向图的连通分量Kosaraju 算法4p3801.将图的边反向,dfs得到逆后序2.按逆后序列dfs原图 cnt++ tarjan https://algs4.cs.princeton.edu/42digraph/TarjanSCC.java.html和拓扑排序一样Tarjan算法的运行效率也比Kosaraju算法高30%左右每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。 130 围棋 用并查集dfs ac100% !200 number of islandsdfs 52% 5ms展开代码 123456789101112131415161718192021public int numIslands(char[][] grid) &#123; int cnt =0; for(int i = 0;i&lt;grid.length;i++)&#123; for(int j =0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]=='1')&#123; dfs(grid,i,j); ++cnt; &#125; &#125; &#125; return cnt;&#125;private void dfs(char[][] grid,int x,int y)&#123; if(x&lt;0||x&gt;grid.length-1||y&lt;0||y&gt;grid[0].length-1||grid[x][y]=='0') return; grid[x][y] = '0'; dfs(grid,x+1,y); dfs(grid,x-1,y); dfs(grid,x,y+1); dfs(grid,x,y-1);&#125; 并查集模板find O(1)判断是否在同一个集合中（同一个parent)1.找到一个‘1’2.用并查集把相邻的‘1’都union起来，本来8个‘1’，每次合并两个不同分量的就cnt–22% 8ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//union find模板class UnionFind&#123; int [] parent; int m,n; int count = 0; UnionFind(char[][] grid)&#123; m = grid.length; n = grid[0].length; parent = new int[m*n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == '1')&#123; int id = i*n+j; parent[id] = id; count++; &#125; &#125; &#125;// System.out.println(Arrays.toString(parent));// System.out.println("初始化完成"); &#125; public void union(int node1,int node2)&#123; int find1 = find(node1); int find2 = find(node2); System.out.println("int union:"+node1+" "+node2); System.out.println("find1,find2:"+find1+" "+find2); if(find1 != find2)&#123; parent[find1] = find2; count--; &#125; &#125; public int find (int node)&#123; if(parent[node] == node)return node; parent[node] = find(parent[node]); return parent[node]; &#125;&#125;int[][] distance = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;public int numIslands(char[][] grid)&#123; // if(grid==null||grid.length&lt;1||grid[0].length&lt;1) return 0; UnionFind uf = new UnionFind(grid); int rows = grid.length; int cols = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt;cols ; j++) &#123; if(grid[i][j] == '1')&#123; for(int[] d :distance)&#123; int x = i+d[0]; int y = j+d[1]; if(x&gt;=0&amp;&amp;x&lt;rows&amp;&amp;y&gt;=0&amp;&amp;y&lt;cols&amp;&amp;grid[x][y] == '1')&#123; int id1 = i*cols+j; int id2 = x*cols+y; uf.union(id1,id2); System.out.println(Arrays.toString(uf.parent)); &#125; &#125; &#125; &#125; &#125; return uf.count; &#125; ！684 多余的连接（构成环）用UF模板 uf可以改到97%123456789101112131415161718192021222324252627282930313233//Unifind模板class UnionFind&#123; int [] parent; UnionFind(int size)&#123; parent = new int[size+1]; for (int i = 0; i &lt; size+1; i++) &#123; parent[i] = i; &#125; &#125; public boolean union(int node1,int node2)&#123; int find1 = find(node1); int find2 = find(node2); //已经在一个集合里了 if(find1==find2)return false; if(find1 != find2)&#123; parent[find1] = find2; &#125; return true; &#125; public int find (int node)&#123; if(parent[node] == node)return node; parent[node] = find(parent[node]); return parent[node]; &#125;&#125;public int[] findRedundantConnectionUF(int[][] edges) &#123; UnionFind uf = new UnionFind(edges.length); for(int[]edge:edges)&#123; if(!uf.union(edge[0],edge[1] )) return edge; &#125; return new int[]&#123;&#125;;&#125; 其他方法//todo 547 互相是朋友的圈子有几个12 208 Trie树 前缀树实现Stringinsert search startsWith插入和查找的time都是O(len(s))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TrieNode&#123; public char val; public boolean end; public TrieNode[] children = new TrieNode[26]; TrieNode(char c)&#123; TrieNode node = new TrieNode(); node.val = c; &#125;&#125;class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(' '); &#125; public void insert(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c= word.charAt(i); if(cur.children[c-'a']==null)&#123; cur.children[c-'a'] = new TrieNode(c); &#125; cur = cur.children[c-'a']; &#125; cur.end = true; &#125; public boolean search(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length() ; i++) &#123; char c = word.charAt(i); if(cur.children[c-'a']==null)return false; cur = cur.children[c-'a']; &#125; return cur.end; &#125;//trie.startsWith("app"); // returns true public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (int i = 0; i &lt; prefix.length() ; i++) &#123; char c = prefix.charAt(i); if(cur.children[c-'a']== null)return false; cur = cur.children[c-'a']; &#125; return true; &#125;&#125; Trie应用：https://leetcode.com/problems/implement-trie-prefix-tree/solution/应用场景：1.查找公共前缀的key2.以字典序遍历数据相比hashtable节省空间 211 单词查询.匹配Trie677计算单词前缀的累积和RMQhttps://www.jianshu.com/p/bb2e6b355b31 线段树Segment Tree定义：1.叶节点是输入2.每个内部节点是为不同问题设计的，叶节点的组合（和/最大值/最小值）查找范围内的最小值/和 只需要Log(n) 数组实现https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/ lc307 sum线段树 Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Binary Index Tree/ Fenwick Tree 34% 106msO(logN) sum和update与dp不同，dp[i]存储了前i个的总和 e只存部分visualgo可视化1.树12345678910111213class NumArray &#123; int[] nums=null; int[] e = null; int len =0; public NumArray(int[] nums) &#123; len = nums.length; e = new int[len+1]; this.nums = new int[len]; for(int i =0;i&lt;len;i++)&#123; update(i,nums[i]); &#125; &#125; 每个叶子节点的父节点的计算方法i+lowbit(i)1的父节点=001+001=0102的父节点=010+010=100==44的父节点=100+100 = 1000==8 最低位：lowbit(5) = 101&amp;((010+1)==011)=0015的父节点=101+001=110==6沿着path向上更新，最多只会更新logn(树高个节点)12345678void update(int i,int val)&#123; int dif = val-nums[i]; nums[i++]=val; while(i&lt;e.length)&#123; e[i]+=dif; i+=(i&amp;-i); &#125;&#125; 2.sum树 前7个元素的和=7+11+101234567891011int query(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum+=e[i]; i-=(i&amp;-i); &#125; return sum;&#125;int rangeSum(int i,int j)&#123; return query(j+1)-query(i);&#125; k=末尾零个数 二进制末尾有k个0则e[i] 是2^k个元素的和 1 -&gt; 1 e[1]=a[1] 2 -&gt; 10 e[2]=a[1]+a[2] 3 -&gt; 11 e[3]=a[3] 4 -&gt; 100 e[4]=a[1]+a[2]+a[3]+a[4] = e[2]+e[3]+a[4] 5 -&gt; 101 e[5]=a[5] 6 -&gt; 110 e[6] = e[5]+e[6] 7 -&gt; 111 e[7] = a[7] 8 -&gt; 1000 e[8] = e[4]+e[6]+e[7]+a[8] 区间和查询305+修改307n个元素线段树的初始化时间复杂度和空间复杂度都是O(n)Spare Table 预处理时空复杂度都是O(nlogn) 但是二分查询i只需要O(loglogn)因为节点数是n+n/2+n/4+…=2n1.线段树用模板 59% 80ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class SegmentTreeNode &#123; int start, end; SegmentTreeNode left, right; int sum; public SegmentTreeNode(int start, int end) &#123; this.start = start; this.end = end; this.left = null; this.right = null; this.sum = 0; &#125;&#125;SegmentTreeNode root = null;private SegmentTreeNode build(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; else &#123; SegmentTreeNode ret = new SegmentTreeNode(start, end); if (start == end) &#123; ret.sum = nums[start]; &#125; else &#123; int mid = start + (end - start) / 2; ret.left = build(nums, start, mid); ret.right = build(nums, mid + 1, end); ret.sum = ret.left.sum + ret.right.sum; &#125; return ret; &#125;&#125;public int query(SegmentTreeNode root, int start, int end) &#123; if (root.end == end &amp;&amp; root.start == start) &#123; return root.sum; &#125; else &#123; int mid = root.start + (root.end - root.start) / 2; if (end &lt;= mid) &#123; return query(root.left, start, end); &#125; else if (start &gt;= mid+1) &#123; return query(root.right, start, end); &#125; else &#123; return query(root.right, mid+1, end) + query(root.left, start, mid); &#125; &#125;&#125;void modify(SegmentTreeNode root, int pos, int val) &#123; if (root.start == root.end) &#123; root.sum = val; &#125; else &#123; int mid = (root.end + root.start) / 2; if (pos &lt;= mid) &#123; modify(root.left, pos, val); &#125; else &#123; modify(root.right, pos, val); &#125; root.sum = root.left.sum + root.right.sum; &#125;&#125;public NumArray(int[] nums) &#123; root = build(nums, 0, nums.length-1);&#125;void update(int i, int val) &#123; modify(root, i, val);&#125;public int sumRange(int i, int j) &#123; return query(root, i, j);&#125; 2.用数组实现的线段树 太复杂就快3mshttps://leetcode.com/problems/range-sum-query-mutable/solution/ sqrt(n)复杂度拆分成sqrt份和 8% 308ms12345678910111213141516171819202122232425262728293031323334353637383940414243private int[] b;private int len;private int[] nums;public NumArray(int[] nums)&#123; this.nums = nums; double l = Math.sqrt(nums.length); len = (int)Math.ceil(nums.length/l); b = new int[len]; for (int i = 0; i &lt; nums.length; i++) &#123; b[i/len]+=nums[i]; &#125;&#125;public int sumRange(int i,int j)&#123; int sum = 0; int startBlock = i/len; int endBlock = i/len; //在同一个区间里 if(startBlock == endBlock)&#123; for (int k = i; k &lt;= j ; k++) &#123; sum+=nums[k]; &#125; &#125;else&#123; //start所在区间 //len = 3,start =0 for (int k = i; k &lt;(startBlock+1)*len ; k++) &#123; sum += nums[k]; &#125; //1-2) for (int k = startBlock+1; k &lt;endBlock ; k++) &#123; sum += b[k]; &#125; for (int k = endBlock*len; k &lt;j ; k++) &#123; sum += nums[k]; &#125; &#125; return sum;&#125;public void update(int i,int val)&#123; int bidx = i/len; b[bidx] = b[bidx]-nums[i]+val; nums[i] = val;&#125; lt206区间求和lt201按区间构造线段树展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SegmentTnode&#123; public int start,end; public SegmentTnode left,right; public SegmentTnode(int start, int end) &#123; this.start = start; this.end = end; this.left = null; this.right = null; &#125; @Override public String toString() &#123; Queue&lt;SegmentTnode&gt; q = new ArrayDeque&lt;&gt;(); StringBuilder sb = new StringBuilder(); sb.append("["); q.add(this); while (!q.isEmpty()) &#123; SegmentTnode top = q.remove(); sb.append("["+top.start+","+top.end+"]"); if (top.left != null) &#123; q.add(top.left);&#125; if (top.right != null) &#123; q.add(top.right); &#125; &#125; sb.append("]"); return sb.toString(); &#125;&#125;public SegmentTnode build(int start,int end)&#123; if(start&gt;end)return null; SegmentTnode root = new SegmentTnode(start,end); int left = (start+end)/2; int right = left+1; if(start!=end)&#123; root.left = build(start,left); root.right = build(right,end); &#125; return root;&#125;public static void main(String[] args) &#123; SegmentTree sl = new SegmentTree(); System.out.println(sl.build(1, 4));&#125; lt439 对数组构造max线段树 输入[3,2,1,4]输出“[0,3,max=4][0,1,max=3][2,3,max=4][0,0,max=3][1,1,max=2][2,2,max=1][3,3,max=4]”1.递归到0,0 max =3.回到上一层left = (0,0,3)2.root.right = (1,1,2);3.root.max = max(left,right)4.return root[0,1,3][0,0,3][1,1,2] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class SegmentTreeNode &#123; public int start, end, max; public SegmentTreeNode left, right; public SegmentTreeNode(int start, int end, int max) &#123; this.start = start; this.end = end; this.max = max; this.left = this.right = null; &#125; @Override public String toString() &#123; Queue&lt;SegmentTreeNode&gt; q = new ArrayDeque&lt;&gt;(); StringBuilder sb = new StringBuilder(); sb.append("["); q.add(this); while (!q.isEmpty()) &#123; SegmentTreeNode top = q.remove(); sb.append("["+top.start+","+top.end+", max="+top.max+"]"); if (top.left != null) &#123; q.add(top.left);&#125; if (top.right != null) &#123; q.add(top.right); &#125; &#125; sb.append("]"); return sb.toString(); &#125;&#125;public SegmentTreeNode build(int[] A)&#123; return build(A,0,A.length-1);&#125;private SegmentTreeNode build(int[] A,int start,int end)&#123; if(start==end)&#123;return new SegmentTreeNode(start,end,A[start]);&#125; SegmentTreeNode root = new SegmentTreeNode(start,end,Integer.MIN_VALUE); int left = (start+end)/2; root.left = build(A,start ,left ); root.right = build(A,left+1,end); root.max = Math.max(root.left.max, root.right.max); return root;&#125;public static void main(String[] args) &#123; lt439 sl = new lt439(); System.out.println(sl.build(new int[]&#123;3, 2, 1, 4&#125;));&#125; 202 max线段树查询 对于数组 [1, 4, 2, 3], 对应的线段树为：12345 [0, 3, max=4] / \ [0,1,max=4] [2,3,max=3] / \ / \[0,0,max=1] [1,1,max=4] [2,2,max=2], [3,3,max=3] query(root, 1, 1), return 4query(root, 1, 2), return 4query(root, 2, 3), return 3query(root, 0, 2), return 4 求和线段树1.区间完全匹配的，return value2.区间完全不匹配的，return 03.部分匹配超出查询区间的 递归查询左右子树查[3:4] 遇到[3:5],继续查[3:4],[5,5]完全超出 90%123456789public int query(lt439.SegmentTreeNode root, int start, int end) &#123; if(root.start&gt;=start&amp;&amp;root.end&lt;=end)return root.max; int rst = Integer.MIN_VALUE; int mid = (root.start+root.end)/2; //关键 if(mid&gt;=start)rst = Math.max(rst,query(root.left,start,end)); if(mid+1&lt;=end)rst = Math.max(rst,query(root.right,start,end)); return rst;&#125; 写法2：98%12345678910public int query(SegmentTreeNode root,int start,int end)&#123; if(start&gt;end)return 0; if(root.start==root.end)return root.max; int mid = (root.start+root.end)/2; //分割当前查询区间，如果和左边有交集，则查找左边最大值 int left = query(root.left,start,Math.min(mid,end)); //mid = 4,query(5,4) int right = query(root.right,Math.max(start,mid+1),end); return Math.max(left,right);&#125; lt203 线段树更新123456789101112 [1, 4, max=3] / \ [1, 2, max=2] [3, 4, max=3] / \ / \[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=3]如果调用 modify(root, 2, 4), 返回: [1, 4, max=4] / \ [1, 2, max=4] [3, 4, max=3] / \ / \[1, 1, max=2], [2, 2, max=4], [3, 3, max=0], [4, 4, max=3] 90%1234567891011121314public void modify(SegmentTreeNode root, int index, int value) &#123; if(index&gt;root.end&amp;&amp;index&lt;root.start)return; if(index==root.start&amp;&amp;root.end==index)&#123; root.max = value; return; &#125; int mid = (root.start+root.end)/2; if(mid&gt;=index)&#123; modify(root.left,index,value); &#125;else&#123; modify(root.right,index,value); &#125; root.max = Math.max(root.left.max,root.right.max);&#125; lt205区间最小数LogN 查询时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class segMinNode&#123; public int start,end,min; public segMinNode left,right; public segMinNode(int start,int end,int min)&#123; this.start = start; this.end = end; this.min = min; this.left = null; this.right = null; &#125;&#125;private segMinNode build(int[] A,int start,int end)&#123; if(start&gt;end)return null; if(start == end)return new segMinNode(start,end,A[start]); segMinNode root = new segMinNode(start,end,A[0]); int mid = (start+end)/2; root.left = build(A,start,left); root.right = build(A,left+1,end); root.min = Math.min(root.left.min,root.right.min); return root;&#125;public int query(segMinNode root,int start,int end)&#123; if(start == root.start&amp;&amp;root.end ==end)return root.min; int mid = (root.start+root.end)/2; int left = Integer.MAX_VALUE,right = Integer.MAX_VALUE; //查询区间&lt;=mid，肯定全在左边 if(end&lt;=mid)&#123; left = query(root.left,start,end); &#125; if(mid&lt;end)&#123; //查询区间开始在mid或者mid左边，必须查左子树 if(start&lt;=mid)&#123; left = query(root.left,start,mid); right = query(root.right,mid+1,end); &#125;else&#123; right = query(root.right,start,end); &#125; &#125; return Math.min(left,right);&#125;public List&lt;Integer&gt; intervalMinNumber(int[] A, List&lt;Interval&gt; queries) &#123; segMinNode root = build(A,0,A.length-1); List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(queries.size()); for(Interval in:queries)&#123; rst.add(query(root, in.start,in.end )); &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Trie</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webflux]]></title>
    <url>%2F2018%2F08%2F30%2Fwebflux%2F</url>
    <content type="text"><![CDATA[函数式编程 lambda+Stream外部迭代 内部迭代外部：for循环内部迭代求和1int sum = IntStream.of(nums).sum(); 惰性求值 求int数组最小值1IntStream.of(new int[]&#123;1,2,3,4,5&#125;).min().getAsInt(); 改成并行：新建线程池，拆分数组，归并1IntStream.of(test).parallel().min().getAsInt(); 展开代码 123456789101112131415Random random = new Random(1024);int[] test = new int[1&lt;&lt;10];for (int i = 0; i &lt;test.length ; i++) &#123; test[i] = random.nextInt(1&lt;&lt;10);&#125;long start1 = System.currentTimeMillis();IntStream.of(test).min().getAsInt();long end1 = System.currentTimeMillis();//44System.out.println(end1-start1);long start = System.currentTimeMillis();IntStream.of(test).parallel().min().getAsInt();long end = System.currentTimeMillis();//3System.out.println(end-start); lambda：1234567891011Object ok = new Runnable() &#123; @Override public void run() &#123; System.out.println("ok"); &#125;&#125;;new Thread((Runnable)ok).start();new Thread(()-&gt;System.out.println("ok")).start();Object target3 = (Runnable)()-&gt;System.out.println("ok");new Thread((Runnable)target3); 4种写法123456789@FunctionalInterfaceinterface interface1&#123; int doubleNum(int i);&#125;interface1 i1 = (i)-&gt;i*2;interface1 i2 = i-&gt;i*2;interface1 i3 = (int i)-&gt;i*2;interface1 i4 = (int i)-&gt;&#123;return i*2;&#125;; 12345678910111213141516//输入int返回Stringinterface IMoneyFormat&#123; String format(int i);&#125;class MyMoney&#123; private final int money; public MyMoney(int money)&#123; this.money = money; &#125; public void printMoney(IMoneyFormat moneyFormat)&#123; System.out.println("存款："+moneyFormat.format(this.money)); &#125;&#125;MyMoney me = new MyMoney(99999);//存款：99,999me.printMoney(i-&gt;new DecimalFormat("#,###").format(i)); 使用JDK8带的函数接口Function1234public void printMoneyJDK8(Function&lt;Integer,String&gt; moneyFormat)&#123; System.out.println("存款："+moneyFormat.apply(this.money));&#125; me.printMoneyJDK8(i-&gt;new DecimalFormat("#,###").format(i)); 好处：链式操作123Function&lt;Integer,String&gt; moneyFormat = i-&gt;new DecimalFormat("#,###").format(i);//存款：RMB99,999me.printMoneyJDK8(moneyFormat.andThen(s-&gt;"RMB"+s)); 级联表达式和科里化//todo类型推断2-13 //todo::方法引用 用::将方法名称与类/对象分隔开1.类::实例方法 12BiFunction&lt;Dog,Integer,Integer&gt; eatFunc = Dog::eat;System.out.println("还有"+eatFunc.apply(new Dog(),2 )); 2.类::静态方法 Integer::valueOf12345678class Dog&#123; //消费者：输入Dog，输出void public static void Bark(Dog dog)&#123; System.out.println("bark"); &#125;&#125;Consumer&lt;Dog&gt; consumer = Dog::Bark;consumer.accept(new Dog()); 对象::实例方法 list::add静态方法和成员方法的区别：静态方法没有thisJDK默认会将当前实例传给非静态方法，叫this，位置必须第一个。java里都是传值而不是引用 所以不会空指针123IntUnaryOperator eat = dog::eat;dog=null;System.out.println("还剩下"+eat.applyAsInt(3)); 1234567891011class Dog&#123; private int food = 10; //函数：输入int，输出int public int eat(Dog this,int num)&#123; System.out.println("eat:"+num+"kg"); this.food-=num; return this.food; &#125;&#125;IntUnaryOperator eat = dog::eat;System.out.println("还剩下"+eat.applyAsInt(3)); 类::构造方法 ArrayList::new提供者：输入空，输出是实例1Supplier&lt;Dog&gt; supplier = Dog::new; 方法：带参构造函数，输入是int,输出是实例1Function&lt;Integer,Dog&gt; dog2 = Dog::new; 四大核心函数式接口 Consumer 消费者 接收一个值消费掉list.forEach 接收T返回void 12Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s);consumer.accept("等待输出"); Function&lt;T,R&gt; 接收一个参数返回一个结果 1234public static String str(String str,Function&lt;String,String&gt; f)&#123; return f.apply(str);&#125;String s = str("functionnnntest",(str)-&gt; str.toUpperCase()); BiFunction&lt;T, U, R&gt; R apply(T t, U u); Supplier::T get();不传参数返回结果 123456public static List&lt;Integer&gt; getNumber(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i =0;i&lt;num;i++)&#123; list.add(sup.get());&#125; return list;&#125;List&lt;Integer&gt; list = getNumber(10,()-&gt;(int)(Math.random()*100)); Predicate::boolean test(T t);断言 123Predicate&lt;Integer&gt; predicate = i-&gt;i&gt;0;//trueSystem.out.println(predicate.test(9)); 过滤器保留有L的单词1234567891011private static void predicate()&#123;&#125;private static List&lt;String&gt; filter(List&lt;String&gt;list,Predicate&lt;String&gt; prd)&#123; List&lt;String&gt; res=new ArrayList&lt;&gt;(); for(String s:list)&#123; if(prd.test(s))res.add(s); &#125; return res;&#125;List&lt;String&gt; words = Arrays.asList("LL","LB","EE");//[LL, LB]List&lt;String&gt; sig = filter(words,(d)-&gt;d.contains("L")); 有一些自带的类型接口，不用写泛型,优先使用12IntPredicate predicateint = i-&gt;i&gt;0;IntConsumer intConsumer = System.out::println;; Lambda：函数作为方法的参数当接口只有一个抽象方法，函数式接口，不会生成class 内部类写法 1234567interface Ido&#123; public void doo(String thing);&#125;class IdoImp implements Ido&#123; public void doo(String thing)&#123; System.out.println(thing+"adfadfa");&#125;&#125;//mainIdoImp idoimp = new IdoImp();idoimp.doo("thing"); Lambda写法 12interface Ido&#123; public void doo(String thing);&#125;Ido ido = (thing)-&gt; System.out.println(thing+"doooooo"); 比较对象Comparator&lt;Integer&gt; c = (x,y)-&gt;Integer.compare(x,y); 方法引用 123Arrays.sort(strings,String::compareToIgnoreCase);Arrays.sort(strings,(x,y)-&gt;x.compareToIgnoreCase(y));System.out.println(Arrays.toString(strings)); ArrayList 打印全部元素list.forEach(x-&gt;sout(x))list.forEach(System.out::println)]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[可变对象和不可变对象]]></title>
    <url>%2F2018%2F08%2F30%2Fimmutable%2F</url>
    <content type="text"><![CDATA[可变对象(可变Integer)输出objTest{val=888}地址1670782018 objTest{val=888}地址1670782018 1234567891011121314151617181920212223class objTest&#123; int val = 0; public objTest(int val) &#123; this.val = val; &#125; @Override public String toString() &#123; return "objTest&#123;" + "val=" + val + '&#125;'; &#125;&#125; private static void dfsObj(List&lt;objTest&gt; rst,objTest tmp,int idx)&#123; if(tmp.val==999)&#123; rst.add(tmp); &#125; for (int i = idx; i &lt;4 ; i++) &#123; tmp.val=999; dfsObj(rst,tmp,idx+1); tmp.val=888; &#125; &#125; 数组 同理List输出：[[I@5674cd4d, [I@5674cd4d,123456789101112List&lt;int[]&gt; rst5 = new ArrayList&lt;&gt;();dfsarr2(rst5,new int[]&#123;0&#125;,0); private static void dfsarr2(List&lt;int[]&gt; rst,int[] tmp,int idx)&#123; if(tmp[0]==3)&#123; rst.add(tmp); &#125; for(int i =idx;i&lt;4;i++)&#123; tmp[0]=3; dfsarr2(rst,tmp,idx+1); tmp[0]=1; &#125; &#125; 不可变对象：Integer 注意-127~128有cache 同理String，Double 的基本数据类型的包装类（如Integer 、 Long 和 Float ）都是不可变的，其它数字类型（如 BigInteger 和 BigDecimal ）也是不可变的。 输出：每次地址不一样1002地址1450495309 1002地址1670782018 1002地址1706377736 1002地址468121027123456789101112131415161718192021private static void dfsInteger(List&lt;Integer&gt; rst,Integer i,int idx)&#123; if(i.equals(999+3))&#123; rst.add(i); return; &#125; for(int j=idx;j&lt;4;j++)&#123; i++; dfsInteger(rst,i,j+1); i--; &#125;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; rst2 = new ArrayList&lt;&gt;(); dfsInteger(rst2,Integer.valueOf(999),0); System.out.println(); System.out.println("Integer结果 "); for(Integer i:rst2)&#123; System.out.print(i+"地址"+System.identityHashCode(i)+ " "); &#125;&#125; 不可变对象的源码：Double1private final double value; Integer1private final int value; String1private final char value[]; 不可变容器：12345Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();map.put(1,1);//java.lang.UnsupportedOperationExceptionMap&lt;Integer, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);unmodifiableMap.put(2,2); 实现源码1private final Map&lt;? extends K, ? extends V&gt; m; 重写了方法直接抛异常123456789101112public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125;public V remove(Object key) &#123; throw new UnsupportedOperationException();&#125;public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; throw new UnsupportedOperationException();&#125;public void clear() &#123; throw new UnsupportedOperationException();&#125; 可变对象源码ArrayList12transient Object[] elementData;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[go]]></title>
    <url>%2F2018%2F08%2F27%2Fgo%2F</url>
    <content type="text"><![CDATA[对象 没有继承和多态 只有封装 只有struct构造123456789101112131415161718192021222324type treeNode struct&#123; value int left,right *treeNode&#125;func main() &#123; var root treeNode root = treeNode&#123;value:3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;&#125; root2 :=treeNode&#123;3,nil,nil&#125; root.right.left = new(treeNode) nodes:= []treeNode&#123; &#123;value:3&#125;, &#123;&#125;, &#123;6,nil,&amp;root&#125;, &#125; //&#123;3 0xc04205c400 0xc04205c420&#125; fmt.Println(root) //&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; fmt.Println(root2) // [&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; 0xc04205c3e0&#125;] fmt.Println(nodes)&#125; 没有构造函数可以写工厂函数局部变量的地址也能返回给外面用123func factory(value int)*treeNode&#123; return &amp;treeNode&#123;value:value&#125;&#125; 容器支持中文的go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "fmt" "unicode/utf8")func lengthOfLongestSubstringrune(s string) int &#123; lastcur := make(map[rune]int) start :=0 maxLength :=0 for i,ch:=range []rune(s)&#123; if lastI,ok:=lastcur[ch];ok&amp;&amp;lastI&gt;=start&#123; start = lastcur[ch]+1 &#125; if(i-start+1&gt;maxLength) &#123; maxLength = i - start + 1 &#125; lastcur[ch] = i; &#125; return maxLength;&#125;func main() &#123; s:="中文中文中文字符串我" fmt.Println(len(s)) for _,b := range []byte(s)&#123; //utf-8的编码 fmt.Printf(" %X ",b) &#125; fmt.Println(s) for i,ch := range s&#123; //unicode fmt.Printf("(%d, %X) ",i,ch) &#125; fmt.Println(utf8.RuneCountInString(s)) bytes := []byte(s) for len(bytes)&gt;0&#123; ch,size :=utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf("%c ",ch) &#125; fmt.Println()//每个rune占了4个字节 另外开了一个rune数组 for i,ch := range []rune(s)&#123; fmt.Printf("(%d %c)",i,ch) &#125; fmt.Println(lengthOfLongestSubstringrune("中文字符串中文中文"))&#125; Map除了slice map function其他内建类型都可以当keystruct不包含上面三个也可以当key1234567891011121314151617181920212223242526272829303132333435func main() &#123; m := map[string]string&#123; "A": "a", "B": "b", "C": "c", "D": "d", &#125; m2 := make(map[string]int) // m2 == empty map var m3 map[string]int // m3 == nil// map[A:a B:b C:c D:d] map[] map[] fmt.Println(m, m2, m3)// B b// C c// D d// A a for k,v:=range m&#123; fmt.Println(k,v) &#125; //a courseName := m["A"] fmt.Println(courseName) // false 不存在也会输出空串 courseName ,ok:= m["dd"] fmt.Println(courseName,ok) if courseName ,ok:= m["dd"];ok&#123; fmt.Println(courseName) &#125;else&#123; fmt.Println("not Exist") &#125; //删除 delete(m,"D")&#125; 数组初始化12345678func main() &#123; var arr1 [5]int arr2 := [3]int&#123;1,3,5&#125; arr3 := [...]int&#123;2,4,6,8,10&#125; fmt.Println(arr1,arr2,arr3) var grid [4][5] int fmt.Println(grid)&#125; 遍历123for _,v:=range arr3&#123; fmt.Println(v) &#125; 数组是值类型传到func中不会改变1234567891011121314func printArray(arr [5]int) &#123; arr[0]=100 for i,v:=range arr&#123; fmt.Print(i,v," ") &#125; fmt.Print("\n")&#125;func main()&#123; arr3 := [...]int&#123;2,4,6,8,10&#125; printArray(arr3) for i,v:=range arr3&#123; fmt.Print(i," ",v," ") &#125;&#125; 用指针可以改变12345678910111213141516func printArray(arr *[5]int) &#123; arr[0]=100 for _,v:=range arr&#123; fmt.Print(v," ") &#125; fmt.Print("\n")&#125;func main()&#123; arr3 := [...]int&#123;2,4,6,8,10&#125; //100 4 6 8 10 // 100 4 6 8 10 printArray(&amp;arr3) for _,v:=range arr3&#123; fmt.Print(v," ") &#125;&#125; 切片Slice1234567arr:=[...]int &#123;1,2,3,4,5,6,7,8&#125;// [3 4 5 6 7 8]s:=arr[2:]fmt.Println(s)s[1] =100//[1 2 3 100 5 6 7 8]fmt.Println(arr) 切片可以扩展123456789101112arr:=[...]int &#123;1,2,3,4,5,6,7,8&#125;s:=arr[2:4]//6fmt.Println(cap(s))//[6 7 8]fmt.Println(s[3:6])//[3 4 999] 必须接受append的返回值s2:=append(s, 999)fmt.Println(s2)//[1 2 3 100 999 6 7 8]//如果append超过了cap 会创建新的数组fmt.Println(arr) 创建切片123456789101112131415161718var s3[] int; for i:=0;i&lt;100;i++&#123;// len: 0 cap: 0// len: 1 cap: 1// len: 2 cap: 2// len: 3 cap: 4// len: 4 cap: 4// len: 5 cap: 8 fmt.Println("len: ",len(s3)," cap: ",cap(s3)) s3 = append(s3,2*i+1) &#125; fmt.Println(s3)s4 := [] int&#123;1,2,3,4,5&#125;fmt.Println(s4)s5 := make([]int,16)fmt.Println(s5)s6 := make([]int,16,32)fmt.Println(s6) 拷贝12345//s5:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]//s4:[1 2 3 4 5]copy(s5,s4)//s5:[1 2 3 4 5 0 0 0 0 0 0 0 0 0 0 0]fmt.Println(s5) 删除123456789//删掉3s=append(s[:3],s[4:]...)//popfront := s[0]s = s[1:]//poptail = s[len(s)-1]s = s[:len(s)-1] 基础语法变量simple application1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport "fmt"//包内变量var aa = 3var ss = "kkk"var( dd=3 bb=2)func variable() &#123; var a int var s string fmt.Println(a,s) fmt.Printf("%d %q\n",a,s)&#125;func variableInit()&#123; var a,b int=3,4 var s string = "abc" fmt.Println(a,b,s)&#125;func varDeduction() &#123; var a,b,c,s = 3,4,true,"def" fmt.Println(a,b,c,s)&#125;func varShorter() &#123; a,b,c,s := 3,4,true,"def"; fmt.Println(a,b,c,s);&#125;func main() &#123; fmt.Println("Hello world")//Hello world// 0 // 0 "" variable()//3 4 abc variableInit() varDeduction() varShorter()&#125; 内建变量char用rune为了国际化 32位的 utf8很多字符都是3字节的用4字节的int32表示runebyte 8位byte和rune可以和整数混用，就是整数的别名 常量 一般go语言常量不大写123456789101112131415import ( "fmt" "math")func consts()&#123; const filename = "abc.txt" const a,b = 3,4 var c int c = int(math.Sqrt(a*a+b*b)) fmt.Println(filename,c)&#125;func main()&#123; // abc.txt 5 consts()&#125; 枚举123456789101112131415161718192021222324252627282930313233func enums() &#123; const( cpp = 0 java = 1 python = 2 golang = 3 ) fmt.Println(cpp,java,python,golang)&#125;func enumsiota() &#123; const( cpp = iota java python golang ) fmt.Println(cpp,java,python,golang) const( b = 1&lt;&lt;(10*iota) kb mb gb tb pb ) // 1 1024 1048576 1073741824 1099511627776 1125899906842624 fmt.Println(b,kb,mb,gb,tb,pb)&#125;func main() &#123; enums() //0 1 2 3 4 enumsiota()&#125; 条件语法123456789func bounded(v int) int&#123; if v&gt;100&#123; return 100 &#125;else if v&lt;0&#123; return 0 &#125;else&#123; return v &#125;&#125; 读文件，是个byte数组12345678910111213141516package mainimport ( "io/ioutil" "fmt")func main() &#123; const filename = "file.txt" contents, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Println(err) &#125;else&#123; fmt.Printf("%s\n",contents) &#125;&#125; 像for一样写if 赋值之后再做判断12345if contents,err:= ioutil.ReadFile(filename);err!=nil&#123; fmt.Println(err)&#125;else&#123; fmt.Printf("%s\n",contents)&#125; switch 每个case后默认break，除非用fallthrough1234567891011121314151617181920212223242526272829303132func grade(score int) string &#123; g := "" switch &#123; case score &lt; 0 || score &gt; 100: panic(fmt.Sprintf( "Wrong score: %d", score)) case score &lt; 60: g = "F" case score &lt; 80: g = "C" case score &lt; 90: g = "B" case score &lt;= 100: g = "A" &#125; return g&#125;func main()&#123;// panic: Wrong score: 101// goroutine 1 [running]:// main.grade(0x65, 0x4cffc1, 0x1)// D:/goLearn/branch.go:12 +0x154// main.main()// D:/goLearn/branch.go:43 +0x125 fmt.Println( grade(1), grade(99), grade(70), grade(101), )&#125; 循环 10进制转2进制1234567891011121314151617181920212223242526package mainimport ( "fmt" "strconv")func convert2Bin(n int) string &#123; result := "" if n==0&#123; return "0" &#125; for ; n&gt;0;n/=2&#123; lsb:= n%2 result = strconv.Itoa(lsb) + result &#125; return result&#125;func main() &#123; fmt.Println( convert2Bin(5), convert2Bin(13), convert2Bin(99999999999999), convert2Bin(0), )&#125; 按行读文件 没有wile，只有for1234567891011121314151617181920import ( "fmt" "strconv" "os" "bufio")func fileLine(filename string)&#123; file,err :=os.Open(filename) if err !=nil&#123; panic(err) &#125; scanner := bufio.NewScanner(file) for scanner.Scan()&#123; //读一行 fmt.Println(scanner.Text()) &#125;&#125;func main()&#123; fileLine("file.txt")&#125; 死循环12345func forever()&#123; for&#123; fmt.Println("abc") &#125;&#125; 函数带余数除法：1234567891011121314func div(a,b int) (int , int) &#123; return a/b,a%b&#125;func divname(a,b int) (q,r int) &#123; q = a/b r = a%b return&#125;func main() &#123; fmt.Println(div(3,4)) q,r := divname(3,4) fmt.Println(q,r)&#125; 只想用第一个返回值 第二个用_ 其他都会报unused，iota递增也可以用_表示跳过12345678910111213141516func eval(a, b int, op string) (int, error) &#123; switch op &#123; case "+": return a + b, nil case "-": return a - b, nil case "*": return a * b, nil case "/": q, _ := divname(a, b) return q, nil default: return 0, fmt.Errorf( "unsupported operation: %s", op) &#125;&#125; 函数式编程，传递func给func,匿名函数123456789101112131415161718func apply(op func(int,int)int,a,b int) int &#123; p := reflect.ValueOf(op).Pointer() name := runtime.FuncForPC(p).Name() fmt.Println(name) return op(a,b)&#125;func pow(a,b int) int &#123; return int(math.Pow(float64(a),float64(b)))&#125;func main()&#123; //main.pow apply(pow,3,4) //main.main.func1 fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow(a,b)) &#125;,3,4))&#125; 可变参数列表,求和12345678910func sum(number ...int)int&#123; s:=0 for i:= range number&#123; s+=number[i] &#125; return s&#125;func main()&#123; fmt.Println(sum(1,2,3,4,5,5,6))&#125; 指针 指针不能运算cpp的值传递和引用传递1234567891011void pass_by_val(int a)&#123;a++;&#125;void pass_by_ref(int&amp; a)&#123;a++;&#125;int main()&#123; int a=3; pass_by_val(a) //3 cout&lt;&lt;a; pass_by_val(a) //4 cout&lt;&lt;a;&#125; go 语言全是值传递，引用传递要用指针1234567891011121314func swap(a,b *int) &#123; *a,*b = *b,*a&#125;//不可变类型的swapfunc swap2(a,b int) (a2,b2 int) &#123; return b,a&#125;func main() &#123; a,b:=3,4 swap(&amp;a,&amp;b) fmt.Println(a,b) a,b = swap2(a,b) fmt.Println(a,b)&#125;]]></content>
      <categories>
        <category>go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cppSTL]]></title>
    <url>%2F2018%2F08%2F12%2FcppSTL%2F</url>
    <content type="text"><![CDATA[操作符重载https://en.cppreference.com/w/cpp/language/operators 不能重载的操作符 operators :: (scope resolution), . (member access), .* (member access through pointer to member), and ?: (ternary conditional) cannot be overloaded. 链表的迭代器：重定义了所有指针的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869template&lt;typename _Tp&gt;struct _List_iterator&#123; typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; _List_iterator() : _M_node() &#123; &#125; explicit _List_iterator(__detail::_List_node_base* __x) : _M_node(__x) &#123; &#125; // Must downcast from _List_node_base to _List_node to get to _M_data. reference operator*() const &#123; return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; &#125; pointer operator-&gt;() const &#123; return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); &#125; _Self&amp; operator++() &#123;_M_node = _M_node-&gt;_M_next;return *this; &#125; _Self operator++(int) &#123;_Self __tmp = *this;_M_node = _M_node-&gt;_M_next;return __tmp; &#125; _Self&amp; operator--() &#123;_M_node = _M_node-&gt;_M_prev;return *this; &#125; _Self operator--(int) &#123;_Self __tmp = *this;_M_node = _M_node-&gt;_M_prev;return __tmp; &#125; bool operator==(const _Self&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _Self&amp; __x) const &#123; return _M_node != __x._M_node; &#125; // The only member points to the %list element. __detail::_List_node_base* _M_node;&#125;; 源码位置 generic programming\devcpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include\c++\bits数据list/deque/vector和方法algorithm分开全局函数::sort(c.begin(),c.end());通过iterator/泛化指针作为接口 stl_algobase：1234567891011template&lt;typename _Tp&gt;inline const _Tp&amp;min(const _Tp&amp; __a, const _Tp&amp; __b)&#123; // concept requirements __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;) //return __b &lt; __a ? __b : __a; if (__b &lt; __a)return __b; return __a;&#125; 123456789template&lt;typename _Tp, typename _Compare&gt;inline const _Tp&amp;max(const _Tp&amp; __a, const _Tp&amp; __b, _Compare __comp)&#123; //return __comp(__a, __b) ? __b : __a; if (__comp(__a, __b))return __b; return __a;&#125; list不用全局sort 因为全局sort要求传入的指针是randomaccessstl_algobase：1234567891011template&lt;typename _RandomAccessIterator&gt; inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; ... if (__first != __last) &#123; std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2); std::__final_insertion_sort(__first, __last); &#125; &#125; 模板1.类模板在class前加template&lt;typename T&gt;2.函数模板 写typename和class功能相同12345template&lt;class T&gt;inlineconst T&amp; min(const T&amp; a,const T&amp; b)&#123; return b&lt;a?b:a;&#125; 3.成员模板 operator new()/malloc()operator new 调用mallocnewop.cpp1234567891011oid *__CRTDECL operator new(size_t count) _THROW1(_STD bad_alloc)&#123; // try to allocate size bytesvoid *p;while ((p = malloc(count)) == 0) if (_callnewh(count) == 0) &#123; // report no memory static const std::bad_alloc nomem; _RAISE(nomem); &#125;return (p);&#125; STL 分配器Allocator支持容器，处理容器的内存。容器Containers数据和算法Algorithms操作分开。不是OO设计，是模板编程。迭代器是泛化指针 是容器和算法的桥梁。仿函数Functors 容器1 Sequence Containers: Array\vector\deque\list循环双端链表\forwardlist单向链表2 Associative Container:Set\Multiset,Map\Multimap3 unordered Containers: HashTable:Separate Chaning。 array不能改变大小milli-seconds : 11array.size()= 500000array.front()= 41array.back()= 29794数组起点的内存位置array.data()= 0x49c040展开代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;array&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const long ASIZE = 500000L;array&lt;long,ASIZE&gt; c;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int compareLongs(const void* a, const void* b)&#123; return ( *(long*)a - *(long*)b );&#125;int main()&#123;clock_t timeStart = clock();for(long i =0;i&lt;ASIZE;++i)&#123; c[i]=rand();&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; //cout &lt;&lt; "array.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "array.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "array.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "array.data()= " &lt;&lt; c.data() &lt;&lt; endl; //二分查找qsort(c.data(), ASIZE, sizeof(long), compareLongs);long* pItem = (long*)::bsearch(&amp;target, (c.data()), ASIZE, sizeof(long), compareLongs); if (pItem != NULL) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl;&#125; vectormilli-seconds : 6326vector.max_size()= 2305843009213693951vector.size()= 1000000vector.front()= 41vector.back()= 12679vector.data()= 0x33c5040vector.capacity()= 1048576 target (0~32767): 654target:654std::find(), milli-seconds : 1found, 654bsearch(), milli-seconds : 1387found, 654展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //sort()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int compareStrings(const void* a, const void* b)&#123; if ( *(string*)a &gt; *(string*)b ) return 1; else if ( *(string*)a &lt; *(string*)b ) return -1; else return 0; &#125;int main()&#123;vector&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i)&#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; //曾經最高 i=58389486 then std::bad_alloc abort(); &#125;&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "vector.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //1073747823cout &lt;&lt; "vector.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "vector.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "vector.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "vector.data()= " &lt;&lt; c.data() &lt;&lt; endl;cout &lt;&lt; "vector.capacity()= " &lt;&lt; c.capacity() &lt;&lt; endl &lt;&lt; endl; string target = get_a_target_string();cout&lt;&lt;"target:"&lt;&lt;target&lt;&lt;endl; timeStart = clock(); //find的查找速度 auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl; //二分查找的速度timeStart = clock(); sort(c.begin(),c.end()); string* pItem2 = (string*)::bsearch(&amp;target, (c.data()), c.size(), sizeof(string), compareStrings); cout &lt;&lt; "bsearch(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem2 != NULL) cout &lt;&lt; "found, " &lt;&lt; *pItem2 &lt;&lt; endl &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl &lt;&lt; endl; return 0;&#125; Listmilli-seconds : 5165list.size()= 1000000list.max_size()= 768614336404564650list.front()= 41list.back()= 12679target (0~32767): 554//find循序查找用时std::find(), milli-seconds : 2found, 554//容器内的sort用时c.sort(), milli-seconds : 2098展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;list&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;list&lt;string&gt; c; char buf[10];clock_t timeStart = clock();for(long i=0; i&lt; 1000000; ++i)&#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125;&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "list.size()= " &lt;&lt; c.size() &lt;&lt; endl;cout &lt;&lt; "list.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //357913941cout &lt;&lt; "list.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "list.back()= " &lt;&lt; c.back() &lt;&lt; endl;string target = get_a_target_string();//find循序查找 timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl; //排序用时timeStart = clock(); //容器的sort c.sort(); cout &lt;&lt; "c.sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 单向链表没有push_back(太慢)只有push_front只能得到第一个元素不能得到最后milli-seconds : 5716forward_list.max_size()= 1152921504606846975forward_list.front()= 12679target (0~32767): 3443std::find(), milli-seconds : 2found, 3443c.sort(), milli-seconds : 2155展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;forward_list&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;forward_list&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_front(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "forward_list.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //536870911 cout &lt;&lt; "forward_list.front()= " &lt;&lt; c.front() &lt;&lt; endl; string target = get_a_target_string(); timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; timeStart = clock(); c.sort(); cout &lt;&lt; "c.sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl;return 0;&#125; dequegnuC的，不是c++11的,用法与forward_list相同slist:milli-seconds : 5096slist.max_size()= 18446744073709551615slist.front()= 12679target (0~32767): 33std::find(), milli-seconds : 4found, 33c.sort(), milli-seconds : 122812#include &lt;ext\slist&gt;__gnu_cxx::slist&lt;string&gt; c; deque分段连续milli-seconds : 6119deque.size()= 1000000deque.front()= 41deque.back()= 12679deque.max_size()= 2305843009213693951target (0~32767): 354std::find(), milli-seconds : 3found, 354sort(), milli-seconds : 1551展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;deque&gt;//#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;deque&lt;string&gt; c; char buf[10];clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "deque.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "deque.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "deque.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "deque.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //1073741821 string target = get_a_target_string(); timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; timeStart = clock(); sort(c.begin(), c.end()); cout &lt;&lt; "sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 容器适配器stack/queue用deque实现 push,pop没有iterator，没有find，不然就可以改变中间的值stack：milli-seconds : 5545stack.size()= 1000000stack.top()= 12679stack.size()= 999999stack.top()= 171721stack&lt;string&gt; c; queue:milli-seconds : 4943queue.size()= 1000000queue.front()= 41queue.back()= 12679queue.size()= 999999queue.front()= 18467queue.back()= 12679123queue&lt;string&gt; c;c.front();c.back(); multiset 可以当成关联数据库放进去的时候就排序了，红黑树标准库的find和容器的findmilli-seconds : 7833multiset.size()= 1000000multiset.max_size()= 461168601842738790target (0~32767): 23489std::find(), milli-seconds : 124found, 23489c.find(), milli-seconds : 0found, 23489展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;set&gt;//#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;multiset&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比std::find(...)快很多 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; return 0;&#125; multimap c.insert(pair&lt;long,string&gt;(i,buf));milli-seconds : 6038multimap.size()= 1000000multimap.max_size()= 384307168202282325target (0~32767): 293283c.find(), milli-seconds : 0found, value=8239展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;multimap&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 做 insertion c.insert(pair&lt;long,string&gt;(i,buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //178956970 long target = get_a_target_long(); timeStart = clock(); //迭代器 auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0;&#125; unordered_multiset(hashtable)不是红黑树是hash表milli-seconds : 5832unordered_multiset.size()= 1000000unordered_multiset.max_size()= 768614336404564650unordered_multiset.bucket_count()= 1056323unordered_multiset.load_factor()= 0.94668unordered_multiset.max_load_factor()= 1unordered_multiset.max_bucket_count()= 768614336404564650bucket #33 has 36 elements.bucket #37 has 41 elements.bucket #79 has 16 elements.target (0~32767): 555std::find(), milli-seconds : 81found, 555c.find(), milli-seconds : 0found, 555展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;unordered_set&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;unordered_multiset&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.bucket_count()= " &lt;&lt; c.bucket_count() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.load_factor()= " &lt;&lt; c.load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_load_factor()= " &lt;&lt; c.max_load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_bucket_count()= " &lt;&lt; c.max_bucket_count() &lt;&lt; endl; for (unsigned i=1; i&lt; 120; ++i) &#123; if(c.bucket_size(i)!=0) cout &lt;&lt; "bucket #" &lt;&lt; i &lt;&lt; " has " &lt;&lt; c.bucket_size(i) &lt;&lt; " elements.\n"; &#125; string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); //容器内 auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; return 0;&#125; unordered_multimapmilli-seconds : 6266unordered_multimap.size()= 1000000unordered_multimap.max_size()= 768614336404564650target (0~32767): 42342c.find(), milli-seconds : 0found, value=9100展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;unordered_map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;unordered_multimap&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 進行 insertion c.insert(pair&lt;long,string&gt;(i,buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0;&#125; set 红黑树放了1000000但是只有32768大小，0~32767milli-seconds : 6963set.size()= 32768set.max_size()= 461168601842738790target (0~32767): 3std::find(), milli-seconds : 4found, 3c.find(), milli-seconds : 0found, 3展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;set&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;set&lt;string&gt; c; char buf[10];clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "set.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "set.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364 string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#125; map 可以用[]自动变成一个pair c[i] = string(buf);milli-seconds : 6843map.size()= 1000000map.max_size()= 384307168202282325target (0~32767): 4c.find(), milli-seconds : 0found, value=19169展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;map&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c[i] = string(buf); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "map.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "map.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //178956970 long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0; &#125; unordered_set/map1234unordered_set&lt;string&gt; c;c.insert(string(buf)); unordered_map&lt;long, string&gt; c; c[i] = string(buf); GNU C以前用hash_set,hash_map,hash_multiset,hash_multimap#include &lt;ext\hash_set&gt;12#include &lt;ext\hash_map&gt;__gnu_cxx::hash_multimap&lt;long, string&gt; c; GNUC的分配器 VC里名字不一样(1) std::allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4975(2) malloc_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4768(3) new_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4790(4) __pool_alloc 内存池how many elements: 1000000a lot of push_back(), milli-seconds : 7357(5) __mt_alloc 多线程how many elements: 1000000a lot of push_back(), milli-seconds : 4881(6) bitmap_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 7420展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;list&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;ext\array_allocator.h&gt;#include &lt;ext\mt_allocator.h&gt;#include &lt;ext\debug_allocator.h&gt;#include &lt;ext\pool_allocator.h&gt;#include &lt;ext\bitmap_allocator.h&gt;#include &lt;ext\malloc_allocator.h&gt;#include &lt;ext\new_allocator.h&gt; using namespace std;int main()&#123; //不能在 switch case 中宣告，只好下面這樣. //1000000次 list&lt;string, allocator&lt;string&gt;&gt; c1; //3140 list&lt;string, __gnu_cxx::malloc_allocator&lt;string&gt;&gt; c2; //3110 list&lt;string, __gnu_cxx::new_allocator&lt;string&gt;&gt; c3; //3156 list&lt;string, __gnu_cxx::__pool_alloc&lt;string&gt;&gt; c4; //4922 list&lt;string, __gnu_cxx::__mt_alloc&lt;string&gt;&gt; c5; //3297 list&lt;string, __gnu_cxx::bitmap_allocator&lt;string&gt;&gt; c6; //4781 int choice;long value; cout &lt;&lt; "select: " &lt;&lt; " (1) std::allocator " &lt;&lt; " (2) malloc_allocator " &lt;&lt; " (3) new_allocator " &lt;&lt; " (4) __pool_alloc " &lt;&lt; " (5) __mt_alloc " &lt;&lt; " (6) bitmap_allocator "; cin &gt;&gt; choice; if ( choice != 0 ) &#123; cout &lt;&lt; "how many elements: "; cin &gt;&gt; value; &#125; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", i); switch (choice) &#123; case 1 : c1.push_back(string(buf)); break; case 2 : c2.push_back(string(buf)); break; case 3 : c3.push_back(string(buf)); break; case 4 : c4.push_back(string(buf)); break; case 5 : c5.push_back(string(buf)); break; case 6 : c6.push_back(string(buf)); break; default: break; &#125; &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "a lot of push_back(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 可以直接使用allocate 但是不要用 小分配用malloc 大分配用容器123__gnu_cxx::bitmap_allocator&lt;int&gt; alloc6; p = alloc6.allocate(3); alloc6.deallocate(p,3);]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop]]></title>
    <url>%2F2018%2F08%2F09%2Fhadoop%2F</url>
    <content type="text"><![CDATA[Mapper.java模板模式12345678910public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; cleanup(context); &#125; &#125; 重写方法123456789/*** Called once for each key/value pair in the input split. Most applications* should override this, but the default is the identity function.*/@SuppressWarnings("unchecked")protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123;context.write((KEYOUT) key, (VALUEOUT) value);&#125;]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[systemdesign]]></title>
    <url>%2F2018%2F08%2F07%2Fsystemdesign%2F</url>
    <content type="text"><![CDATA[https://soulmachine.gitbooks.io/system-design/content/cn/api-rate-limiting.htmlhttps://wizardforcel.gitbooks.io/system-design-primer/4.html#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8Bhttps://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904 729 Calendar1 时间区间有无重叠1.List&lt;int[]&gt;两个区间是否重叠s1&lt;e2&amp;&amp;e1&gt;s2另一种思考展开代码 1234567891011121314class MyCalendar &#123;List&lt;int[]&gt; calendar;public MyCalendar() &#123; calendar = new ArrayList&lt;&gt;();&#125;public boolean book(int start, int end) &#123; for(int[] it:calendar)&#123; if(it[0]&lt;end&amp;&amp;start&lt;it[1])return false; &#125; calendar.add(new int[]&#123;start,end&#125;); return true;&#125;&#125; 2.维持一个排序的map(红黑树）二分查找，start当key，end当value TreeMap如果不存在，返回小于查询的最大keyfinal Entry&lt;K,V&gt; getFloorEntry(K key)123public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; 如果不存在，返回大于查询的最小key123public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; 只需要查找query start 的floor的end query start 的ceil的start12345678910111213141516class MyCalendar &#123; TreeMap&lt;Integer,Integer&gt; calendar; public MyCalendar() &#123; calendar = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; Integer prev = calendar.floorKey(start); Integer next = calendar.ceilingKey(start); if((prev==null||calendar.get(prev)&lt;=start) &amp;&amp;(next==null||end&lt;=next))&#123; calendar.put(start,end); return true; &#125; return false; &#125;&#125; 731 不三重预定的日历Haversine formula计算经纬度之间的球面距离 布隆过滤器 url去重https://blog.csdn.net/v_july_v/article/details/6685894 746. Design Tic-Tac-Toe 井字棋380insert/delete O(1)，getRandom O(1)的数据结构123456789101112131415161718192021222324252627282930class RandomSet&#123; Map&lt;Integer,Integer&gt; valIdx; List&lt;Integer&gt; list; Random rand = new Random(); public RandomSet() &#123; valIdx = new HashMap&lt;&gt;(); list = new ArrayList&lt;&gt;(); &#125; public boolean insert(int val)&#123; if(valIdx.containsKey(val))return false; valIdx.put(val,list.size()); list.add(val); return true; &#125; public boolean remove(int val)&#123; if(!valIdx.containsKey(val))return false; int idx = valIdx.get(val); int last = list.get(list.size()-1); //最后一个插到前面 list.set(idx,last); valIdx.put(last,idx); //删除 list.remove(list.size()-1); valIdx.remove(val); return true; &#125; public int getRandom()&#123; return list.get(rand.nextInt(list.size())); &#125;&#125; LFUgohashpoi-gohash http://redisdoc.com/geo/geoadd.htmlredis使用的geohash编码长度为26位。可以精确到0.59m的精度。 将经纬度-&gt;字符串，一个字符串表示一个矩形，可以用字符串前缀匹配查找范围 算法步骤：精确度https://en.wikipedia.org/wiki/Geohashhttps://www.cnblogs.com/LBSer/p/3310455.html 通过对经纬度二分查找不断逼近，将经纬度变成01序列 纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。 用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。 实现：https://github.com/kungfoo/geohash-java编码部分Point:1234public class Point &#123; private final double longitude; private final double latitude;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class GeoHash &#123;private static final char[] base32 = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f','g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' &#125;;private static final int MAX_BIT_PRECISION = 64;protected byte significantBits = 0;protected long bits = 0;//最后+1protected final void addOnBitToEnd() &#123; significantBits++; bits &lt;&lt;= 1; bits = bits | 0x1;&#125;//最后+0protected final void addOffBitToEnd() &#123; significantBits++; bits &lt;&lt;= 1;&#125; //1.获得经纬度交叉的byteprivate GeoHash(double latitude, double longitude, int strlen) &#123; int desiredPrecision = (strlen * 5 &lt;= 60) ? strlen * 5 : 60; point = new Point(latitude, longitude); desiredPrecision = Math.min(desiredPrecision, MAX_BIT_PRECISION); boolean isEvenBit = true; double[] latitudeRange = &#123; -90, 90 &#125;; double[] longitudeRange = &#123; -180, 180 &#125;; //偶数是经度 while (significantBits &lt; desiredPrecision) &#123; if (isEvenBit) &#123; divideRangeEncode(longitude, longitudeRange); &#125; else &#123; divideRangeEncode(latitude, latitudeRange); &#125; isEvenBit = !isEvenBit; &#125; setBoundingBox(this, latitudeRange, longitudeRange); //变成64位 bits &lt;&lt;= (MAX_BIT_PRECISION - desiredPrecision);&#125;private void divideRangeEncode(double value, double[] range) &#123; double mid = (range[0] + range[1]) / 2; if (value &gt;= mid) &#123; addOnBitToEnd(); range[0] = mid; &#125; else &#123; addOffBitToEnd(); range[1] = mid; &#125;&#125; //2. base32编码成String public String toBase32() &#123; if (significantBits % 5 != 0) &#123; throw new IllegalStateException("Cannot convert a geohash to base32 if the precision is not a multiple of 5."); &#125; StringBuilder buf = new StringBuilder(); long firstFiveBitsMask = 0xf800000000000000l; long bitsCopy = bits; int partialChunks = (int) Math.ceil(((double) significantBits / 5)); for (int i = 0; i &lt; partialChunks; i++) &#123; int pointer = (int) ((bitsCopy &amp; firstFiveBitsMask) &gt;&gt;&gt; 59); buf.append(base32[pointer]); bitsCopy &lt;&lt;= 5; &#125; return buf.toString();&#125; 测试dr4jb0bn21dr373nzzdrf2kjs728301234567GeoHash hash1 = new GeoHash(40.390943,-75.9375,10);GeoHash hash2 = new GeoHash(41.390943,-76.9375,10);GeoHash hash3 = new GeoHash(47.390943,-72.9375,10);System.out.println(hash1.toBase32());assert (hash1.toBase32().equals("dr4jb0bn21")):"不等于dr4jb0bn21";System.out.println(hash2.toBase32());System.out.println(hash3.toBase32()); 加入表示的矩形12345678910111213141516171819202122232425public class BoundingBox &#123; private double minLat; private double maxLat; private double minLon; private double maxLon; public BoundingBox(Point p1, Point p2) &#123; this(p1.getLatitude(), p2.getLatitude(), p1.getLongitude(), p2.getLongitude()); &#125; public BoundingBox(double y1, double y2, double x1, double x2) &#123; minLon = Math.min(x1, x2); maxLon = Math.max(x1, x2); minLat = Math.min(y1, y2); maxLat = Math.max(y1, y2); &#125;public Point getUpperLeft() &#123; return new Point(maxLat, minLon);&#125;public Point getLowerRight() &#123; return new Point(minLat, maxLon);&#125;public String toString() &#123; return getUpperLeft() + " -&gt; " + getLowerRight();&#125;&#125; 构造函数最后加上,利用划分最后的经纬度区间setBoundingBox(this, latitudeRange, longitudeRange);12345private static void setBoundingBox(GeoHash hash, double[] latitudeRange, double[] longitudeRange) &#123; hash.boundingBox = new BoundingBox(new Point(latitudeRange[0], longitudeRange[0]), new Point( latitudeRange[1], longitudeRange[1]));&#125; 查询部分：给定senter和半径，查询 算法正确性：二分法分割空间成01是Peano空间填充曲线。 Peano曲线就是一种四叉树线性编码方式 但是Peano曲线有突变性，0111和1000并不邻近。解决方法是查询时用周围点一起查询。数据库只需要存经纬度，查询字符串之后计算距离。 为什么需要空间索引：http://www.cnblogs.com/LBSer/p/3392491.html矩形过滤 遍历复杂度高1select id,name from poi where lng between 116.3284 and 116.3296 and lat between 39.9682 and 39.9694; 对维度建立索引 遍历复杂度变成Log(N)1alter table lbs add index latindex(lat); B树其实可以对多个字段进行索引，但这时需要指定优先级，形成一个组合字段，而空间数据在各个维度方向上不存在优先级，我们不能说纬度比经度更重要，也不能说纬度比高程更重要。 其他的空间填充曲线Hilbert最好12345678 0 3 4 5 58 59 60 63 1 2 7 6 57 56 61 62 14 13 8 9 54 55 50 49 15 12 11 10 53 52 51 48 16 17 30 31 32 33 46 47 19 18 29 28 35 34 45 44 20 23 24 27 36 39 40 43 21 22 25 26 37 38 41 42 索引线、折线或者多边形R-tree 弹幕系统一个直播间：在线人数100万1000条弹幕/秒推送频率：100万*1000条/秒 = 10亿/秒 拉模式：客户端轮询服务端推模式：长连接 立即推送（时效性）websocket 将message-&gt;frame go语言携程模型 自带websocket库 146 LRU cache HashMap&lt;Integer,DoubleLinkedList&gt;Cache replacement policiesleast recently used cache最近最少使用缓存java:LinkedHashMap:https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry- 双向链表+hashmap展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class LRUCache &#123; //双向链表 class DoubleLinkedNode&#123; //和hashmap对应，用于日后扩容 int key; int value; DoubleLinkedNode pre; DoubleLinkedNode next; &#125; HashMap&lt;Integer,DoubleLinkedNode&gt; cache; int capacity; DoubleLinkedNode head; DoubleLinkedNode tail; //创建一个头节点 //链表操作： //1. get/update中间的node移到链表最前面 private void move2head(DoubleLinkedNode node)&#123; /**** star ****/ this.remove(node); this.addNode(node); &#125; //2. put1 头插 private void addNode(DoubleLinkedNode node)&#123; node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; &#125; //3. put2 删除节点 (1删除中间的，移到最开头 2.删除尾巴) private void remove(DoubleLinkedNode node)&#123; DoubleLinkedNode pre = node.pre; DoubleLinkedNode next = node.next; pre.next = next; next.pre = pre; &#125; //4.删除尾巴, private int removeTail()&#123; DoubleLinkedNode pre = tail.pre; this.remove(pre); return pre.key; &#125; public LRUCache(int capacity) &#123; cache = new HashMap&lt;&gt;(); this.capacity = capacity; //创建一个头节点 head = new DoubleLinkedNode(); head.pre = null; //创建一个空尾巴 tail = new DoubleLinkedNode(); tail.next= null; head.next = tail; tail.pre = head; &#125; public int get(int key) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) return -1; move2head(node); return node.value; &#125; public void put(int key, int value) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) &#123; //插入新值 DoubleLinkedNode newNode = new DoubleLinkedNode(); newNode.key = key; newNode.value = value; //1. 考虑容量剩余,满不满都要插入，但是满了要先删除 if (capacity == 0) &#123; //删除尾巴 int deleteKey = removeTail(); cache.remove(deleteKey); capacity++; &#125; //2. 插入队列 addNode(newNode); //3. 加入hash cache.put(key, newNode); capacity--; &#125;else &#123; node.value = value; move2head(node); &#125; &#125; public static void main(String[] args) &#123; LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 System.out.println(cache.get(4)); &#125;&#125; 604. Design Compressed String Iteratorhttps://leetcode.com/articles/desing-compressed-string-iterator/ 不需要预处理的O(1)：12345678910111213int p=0;int num=0;char next()&#123; if(!hasNext)return ' '; char ch = s.charAt(p++); while(p&lt;res.length&amp;&amp;Character.isDigit(s.charAt(p))) num = num*10+res.charAt(p++)-'0'; num--; return ch;&#125;boolean hasNext()&#123; return p!=s.length()||num!=0;&#125; 时间空间复杂度O(n) 压缩编码的长度n L1e2t1C1o1d1e1-&gt;[1, 2, 1, 1, 1, 1, 1]-&gt;[L, e, t, C, o, d, e] 12int[] nums = Arrays.stream(cmprs.substring(1).split("[a-zA-z]")).mapToInt(Integer::parseInt).toArray();String[] chars = cmprs.split("[0-9]+"); next,hasNext 展开代码 12345678910111213int p=0;public char next() &#123; if(!hasNext())&#123; return ' '; &#125; nums[p]--; char out = chars[p].charAt(0); if(nums[p]==0)p++; return out;&#125;public boolean hasNext() &#123; return p!=chars.length;&#125; 535 短链接Base62 编码是由 10 个数字 26 个大些英文字母和 26 个小写英文字母组成base63(md5(str))[6:]功能要求：1.过期时间，用户能延长过期时间2.自定义短链接 非功能要求：1.系统高可用2.重定向的延迟3.连接地址不可预测 扩展：1.重定向多少次2.REST api]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2018%2F07%2F22%2Fnodejs%2F</url>
    <content type="text"><![CDATA[CommonJS nodejs的模块规范https://morning.work/page/nodejs/ready-to-async-await.htmlglobal对象和process对象一个文件是一个模块使用requirejs需要自己写包裹函数，nodejs省了这一步 node --inspect-brk learn_path.jschrome打开chrome://inspect/#devices12(function (exports, require, module, __filename, __dirname) &#123; &#125;); exports是对外提供的接口/属性require依赖别的模块module是模块本身里export属性]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2018%2F07%2F20%2Fsvg%2F</url>
    <content type="text"><![CDATA[基本图形&lt;elipse&gt;椭圆，cx,cy是圆心&lt;polyline&gt;标签中间用ponits=”x1 y1 x2 y2 x3 y3” 同理&lt;polygon&gt;svg画一个三角形123456789&lt;svg&gt;&lt;polyline points="250 120 300 220 200 220" stroke="red" fill="none"&gt;&lt;/polyline&gt;&lt;/svg&gt; fill填充颜色stroke描边颜色stroke-width描边粗细transform 操作api：做一个svg编辑器html5中inut的type：color调色盘，range进度条1.创建svg标签并设置svg标签属性，挂载到dom树123456789//命名空间function createSVG()&#123; var SVG_NS = 'http://www.w3.org/2000/svg'; var svg = document.createElementNS(SVG_NS, 'svg'); svg.setAttribute('width', '100%'); svg.setAttribute('height', '100%'); _svg.appendChild(svg); return svg&#125;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[dockermysql]]></title>
    <url>%2F2018%2F07%2F05%2Fdockermysql%2F</url>
    <content type="text"><![CDATA[CentOS7 安装mysql1.下载mysql源1234567891011yum install wgetwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmcd /etc/yum.repos.d/llyum install mysql-serversystemctl enable mysqldmysql -u rootchown -R root:root /var/lib/mysqlservice mysqld restartmysql -u root 改密码1234use mysql;# 一定要引号update user set password=password("root") where user="root";exit; 用windows连接虚拟机mysql配置12345678910bind-address =service mysql restart# ！打开防火墙firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-portsps aux|grep mysqlnetstat -plntu# tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 15323/mysqld 给外部ip权限1234vi /etc/my.cnf# 强行加上[mysqld]bind-address = 0.0.0.0 给任何ip过来的root用户 密码（identified）为root的，可以访问所有表12grant all privileges on *.* to "root"@"%" identified by "root" with grant option;flush privileges; 可以连接并创建表了，注意字符集将centos上的数据库转移到win：front中-其他-转移 redis 高速缓存集群解除docker集群 docker swarm leave -f查看docker内的网络docker network ls 拉镜像docker pull yyyyttttwwww/redis创建容器docker run -it -d --name r1 -p5000:6379 --net=net2 --ip 172.19.0.2 redis bash进入容器docker exec -it r1 bash修改redis配置文件/usr/redis/redis.conf docker mysql集群PXC防火墙? 拉镜像 12docker pull percona/percona-xtradb-clusterdocker load &lt;pxc.tar.gz 改名 123docker imagesdocker tag docker.io/precona/percona-xtradb-cluster pxcdocker rmi docker.io/precona/percona-xtradb-cluster 创建容器要先划分Docker内部网段 docker自带的是172.17.0.x 123docker network create net1 / docker network create --subnet=172.18.0.0/24 net1docker network insepct net1docker network rm net1 业务数据映射到宿主机，pxc不能直接用目录映射要用docker卷 123docker volume create v1docer inspect v1 #//var/lib/docker/volumes/v1/_datadocker volume rm v1 创建pxc容器 -d 后台运行 -t 交互界面 -p 端口映射 -v 路径映射 -e 启动参数 XTRABACKUP_PASSWORD=abc123456 数据库同步用的密码 --preivileged 最高权限 --ip 内部网段中分到的ip地址 注意：容器创建很快，但是mysql初始化可能要2min以上，能连接到一个后再创建第二个 123456789docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxcdocker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxcdocker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxcdocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc 6.用navicat连接5个数据库在db1create schema test1; 刷新，其他节点也更新了。 负载均衡 Haproxy请求转发器nginx 支持http协议负载均衡，最近才支持TCP/IPhaproxy配置 docker pull haproxy 在宿主机创建配置文件mkdir /home/soft/haproxy/touch /home/soft/haproxy/haproxy.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657global #工作目录 chroot /usr/local/etc/haproxy #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info log 127.0.0.1 local5 info #守护进程运行 daemondefaults log global mode http #日志格式 option httplog #日志中不记录负载均衡的心跳检测记录 option dontlognull #连接超时（毫秒） timeout connect 5000 #客户端超时（毫秒） timeout client 50000 #服务器超时（毫秒） timeout server 50000#监控界面 listen admin_stats #监控界面的访问的IP和端口 bind 0.0.0.0:8888 #访问协议 mode http #URI相对地址 stats uri /dbs #统计报告格式 stats realm Global\ statistics #登陆帐户信息 stats auth admin:abc123456#数据库负载均衡listen proxy-mysql #访问的IP和端口 bind 0.0.0.0:3306 #网络协议 mode tcp #负载均衡算法（轮询算法） #轮询算法：roundrobin #权重算法：static-rr #最少连接算法：leastconn #请求源IP算法：source balance roundrobin #日志格式 option tcplog #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测 option mysql-check user haproxy server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000 server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000 server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 server MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000 server MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000 #使用keepalive检测死链 option tcpka bind 0.0.0.0:3306 表示任何ip地址都可以访问3306端口如果有应用向3306端口发数据库请求，会被转发给具体的pxc数据库实例 haroxy 端口3306 映射到宿主机4002 ，后台监控8888映射到4001可以手动分配haroxy的ip地址，docker也会自动分配 123docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 haproxy 进入容器 12docker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg 在mysql创建haproxy用户 haproxy中间件用这个账号登陆数据库，发心跳检测%表示ip都可以用这个账号登陆mysql数据库 密码为空 1create user 'haproxy'@'%' identified by ''; 登陆 http://192.168.3.109:4001/dbs 看监控画面docker stop node1可以看到MySQL_1变红色用navicat连接haproxy192.168.3.109:4002 root:abc123456向haproxy使用的sql都会均匀分发给真实的mysql实例，然后同步 haproxy双机热备 虚拟ip linux一个网卡可以定义多个ip地址，可以把ip地址分配给对应的程序在两个haproxy容器中部署keepalived抢占一个虚拟ip172.18.0.15,抢到的叫主服务器，没抢到的叫备服务器，有心跳检测，检测到主服务器挂了就抢占ip1.1. 进入容器docker exec -it h1 bashharpoxy是用Ubuntu创建的 所以要用apt-getapt-get update #可能要换源 安装vim 不是viapt-get install keepalived 1.2. keepalived配置文件/etc/keepalived/keepalived.confstate:MASTER/BACKUP为主/备服务器 抢占虚拟IP,备用不会抢。都master都抢占，没抢到的自动变成salveinterface:虚拟ip写到docker的网卡里,eth0局域网里看不见的，后续虚拟ip映射到局域网的虚拟ipvirtual_router_id：0-255之间 虚拟路由ippriority 权重，优先抢占advert_int:心跳检测间隔authentication 心跳检测的账号密码virtual_ipaddress 虚拟ip 1234567891011121314vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 123456 &#125; virtual_ipaddress &#123; 172.18.0.201 &#125;&#125; 启动keepalived:service keepalived startexit宿主机 ping 172.18.0.201 在宿主机安装keepalived把宿主机ip映射到docker的虚拟ip 展开代码 1234567891011121314151617181920212223242526272829303132333435363738vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.99.150 &#125;&#125;virtual_server 192.168.99.150 8888 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 8888 &#123; weight 1 &#125;&#125;virtual_server 192.168.99.150 3306 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 3306 &#123; weight 1 &#125;&#125; 数据库热备份冷备份mysql dump热备份LVM要锁表 XtraBackup不锁表docker stop/rm node1docker volume create backup 1234docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged -e CLUSTER_JOIN=node2 --name=node1 --net=net1 --ip 172.18.0.2 pxc 全量备份 在PXC容器中安装XtraBackup 1234567docker exec -it --user root node1 bashapt-get updateapt-get install percona-xtrabackup-24innobackupex --user=root --password=abc123456 /data/backup/full#备份在/data/backup/full/2018-07-05_04-54-31/xtrabackup_infoexitdocker inspect backup 恢复 冷还原 1解散PXC集群，2删除节点，3创建新的节点并还原，4创建其他节点，并同步 重建集群 12345678910111213141516171819docker stop node1 node2 node3 node4 node5docker rm node1 node2 node3 node4 node5docker volume rm v1 v2 v3 v4 v5docker volume create v1docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker exec -it node1 bashrm -rf /var/lib/mysql/*innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-07-05_04-54-31innobackupex --user=root --password=abc123456 --copy-back /data/backup/full/2018-07-05_04-54-31exitdocker stop node1docker start node1]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8]]></title>
    <url>%2F2018%2F06%2F06%2Fjava8%2F</url>
    <content type="text"><![CDATA[JDK9 Reactive Stream其它库Guava，Apache Commons Collections ,ambdaj Collector.java接口提供者 the type of input elements to the reduction operation the mutable accumulation type of the reduction operation (often hidden as an implementation detail) the result type of the reduction operation 1234567891011public interface Collector&lt;T, A, R&gt; &#123; //container容器 Supplier&lt;A&gt; supplier(); //操作 BiConsumer&lt;A, T&gt; accumulator(); //并行计算 BinaryOperator&lt;A&gt; combiner(); //返回结果 Function&lt;A, R&gt; finisher(); Set&lt;Characteristics&gt; characteristics();&#125; toList()123456public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123; return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; &#123; left.addAll(right); return left; &#125;, CH_ID);&#125; 1.CH_ID:12static final Set&lt;Collector.Characteristics&gt; CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); 2.Set characteristics();Collecter的特征1234567enum Characteristics &#123;//可以并行处理 CONCURRENT,//一般true 是否保持原来的顺序 UNORDERED, IDENTITY_FINISH&#125; stream().collect()12345678910111213141516public final &lt;R, A&gt; R collect(Collector&lt;? super P_OUT, A, R&gt; collector) &#123; A container; if (isParallel() &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT)) &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123; container = collector.supplier().get(); BiConsumer&lt;A, ? super P_OUT&gt; accumulator = collector.accumulator(); forEach(u -&gt; accumulator.accept(container, u)); &#125; else &#123; container = evaluate(ReduceOps.makeRef(collector)); &#125; return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH) ? (R) container : collector.finisher().apply(container);&#125; .Collectors1..groupingBy(Apple::getColor))1Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType)); 2.计算平均数averaging[Int/Long/Double]都返回&lt;T&gt; Collector&lt;T, ?, Double&gt;1Optional.ofNullable(menu.stream().collect(Collectors.averagingInt(Dish::getCalories))).ifPresent(System.out::println); 3..collectingAndThen附加返回值1Optional.ofNullable(menu.stream().collect(Collectors.collectingAndThen(Collectors.averagingInt(Dish::getCalories),a-&gt;"The ave"+a))).ifPresent(System.out::println); 变成不可变对象1List&lt;Dish&gt; collect = menu.stream().filter(d -&gt; d.getType().equals(Dish.Type.MEAT)).collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); 4.计数12Optional.of(menu.stream().collect(Collectors.counting())).ifPresent(System.out::println);Optional.ofNullable(menu.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.counting()))).ifPresent(System.out::println); 5.转化成TreeMap1TreeMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType, TreeMap::new, Collectors.averagingInt(Dish::getCalories))); 6.Summary12345public class IntSummaryStatistics implements IntConsumer &#123; private long count; private long sum; private int min = Integer.MAX_VALUE; private int max = Integer.MIN_VALUE;&#125; 1IntSummaryStatistics collect = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories)); 7.groupingByConcurrent1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); 8.Collector&lt;CharSequence, ?, String&gt; joining()前面必须是CharSequence类型,join中还可添加delimiter分隔符1String collect = menu.stream().map(Dish::getName).collect(Collectors.joining(",")); 前后加上分隔符joining(“,”,”Names[“,”]”)输出：Names[pork,…,salmon] 另一种mapping方法IDEA会提示可以使用map().collect()1.collect(Collectors.mapping(Dish::getName, Collectors.joining(","))) 9.maxBy/minBy获得卡路里最高的1Optional&lt;Dish&gt; collect = menu.stream().collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories))); 10.partitioningBy1Map&lt;Boolean, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian)); 输出是/不是水果的卡路里平均值{false=530.0, true=387.5}12Map&lt;Boolean, Double&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian, Collectors.averagingDouble(Dish::getCalories))); Optional.ofNullable(collect).ifPresent(System.out::println); 11 .reducing 可以加入map 相当于map(::).reduce(0,(,)-&gt;)1Integer collect = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (d1, d2) -&gt; d1 + d2)); 12 .summingDdouble1Double collect = menu.stream().collect(Collectors.summingDouble(Dish::getCalories)); 13 .toCollection(LinkedList::new)123Optional.ofNullable(menu.stream().collect(Collectors.toCollection(LinkedList::new))).ifPresent(System.out::println);//可以变成Optional.ofNullable(new LinkedList&lt;&gt;(menu)).ifPresent(System.out::println); lambdaexecute around 环绕执行模式泛型限制public static &lt;T&gt; List filter(List, Predicate p) lambda访问lambda主体中的引用（实例变量，静态变量） 在堆中外层变量 在栈中 局部变量是final的，访问的是原始变量的副本。 12345678910111213list.sort(Comparator.comparing(Integer::intValue));public interface Comparator&lt;T&gt; &#123; public static &lt;T, U&gt; Comparator&lt;T&gt; comparing( Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)&#123; Objects.requireNonNull(keyExtractor); Objects.requireNonNull(keyComparator); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1), keyExtractor.apply(c2));&#125;&#125; 比较器链1list.sort(Comparator.comparing(Integer::intValue).reversed().thenComparing(Integer::byteValue)); 泛型数组 需要知道类型(Item item)1arr.sort(Comparator.comparing((Item item )-&gt; item.value / item.weight).reversed()); 谓词复合.negate(),.and(),.or()函数符合1.andThen12345//g(f(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.andThen(g);int result = h.apply(1);//4 2.compose12345//f(g(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.compose(g);int result = h.apply(1);//3 3.创建流水线123456789class Letter&#123; String addHeader(String text)&#123;return "From:";&#125; String addFooter(String text)&#123;return "Kind regards";&#125; String checkSpelling(String text)&#123;return text.replaceAll("labda","lambda");&#125;&#125;Fucntion&lt;String,String&gt; addHeader = Letter::addHeader;Fucntion&lt;String,String&gt; pipeline = addHeader. addThen(Letter::checkSpelling). addThen(Letter::addFooter); 闭包：函数的实例，可以无限制地访问函数的非本地变量。lambda作闭包不能修改局部变量内容，lambda在新线程运行。会造成线程不安全。栈在线程之间不共享，堆在线程间共享。 Stream 高级迭代器pipelining 流水线式操作，方法返回一个流，可以链式操作Collection.java根据核数划分123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; 查看线程：jconsoleFinalizer是垃圾回收器的线程测试代码：展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Arrays;import java.util.Comparator;import java.util.List;import static java.util.stream.Collectors.toList;class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public enum Type &#123; MEAT, FISH, OTHER &#125;&#125;public class streamm &#123; private static List&lt;String&gt; byStream(List&lt;Dish&gt; menu)&#123; return menu.parallelStream().filter(d-&gt;&#123; try&#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return d.getCalories()&lt;400; &#125;).sorted(Comparator.comparing(Dish::getCalories)).map(Dish::getName).collect(toList()); &#125; public static void main(String[] args) &#123; List&lt;Dish&gt; menu = Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT), new Dish("beef", false, 700, Dish.Type.MEAT), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHER), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHER), new Dish("pizza", true, 550, Dish.Type.OTHER), new Dish("prawns", false, 300, Dish.Type.FISH), new Dish("salmon", false, 450, Dish.Type.FISH) ); List&lt;String&gt; dishNamesByStream = byStream(menu); System.out.println(dishNamesByStream); &#125;&#125; 线程：多了3个ForkJoinPool.commonPool-worker-1/2/3 intermediate 中间方法1.Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);:intermediate将流删选减少数量 1str.filter((s)-&gt;s.length()&gt;4).forEach(System.out::println); 2.&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 投影：映射成数量相同的另一个新流 1str.map(s -&gt; s.toUpperCase()).forEach(System.out::print); IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); 产生一个intStreamStream&lt;T&gt; limit(long maxSize); :intermediate 删掉后面 terminal的void forEach(Consumer&lt;? super T&gt; action); : terminal的void forEachOrdered(Consumer&lt;? super T&gt; action); :terminal&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); :terminalOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); :terminalboolean anyMatch(Predicate&lt;? super T&gt; predicate); :terminal求和，最大值Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);)12Optional&lt;String&gt; opt = str.reduce((s1,s2)-&gt;s1+s2)String res = opt.get(); 静态方法builder,of,empty of 12Stream&lt;String&gt;str = Stream.of("good","study","good");str.forEach((strr)-&gt; System.out.println(strr)); 合并两个Stream 123public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values); &#125; 其它操作去重distinct1str.distinct().forEach(System.out::print); 创建流Collection可以创建流通过文件创建123456789101112private static Stream&lt;String&gt; createStream()&#123; Path path = Paths.get("./src/java8/aaa"); try(Stream&lt;String&gt; lines = Files.lines(path)) &#123; lines.forEach(System.out::print); return lines; &#125; catch (IOException e) &#123; throw new RuntimeException(); &#125;&#125;public static void main(String[] args) &#123; Stream&lt;String&gt; s = createStream();&#125; 无限流123456private static Stream&lt;Integer&gt; createfromiterator()&#123; Stream&lt;Integer&gt; stream = Stream.iterate(0,n-&gt;n+2).limit(100); return stream;&#125;createfromiterator().forEach(System.out::println);//输出0，2，..198 无限随机数1234private static Stream&lt;Double&gt; fromgenerate()&#123; return Stream.generate(Math::random);&#125;fromgenerate().forEach(System.out::println); fib:123Stream.iterate(new int[]&#123;0,1&#125;, t-&gt;new int[]&#123;t[1],t[0]+t[1]&#125;) .limit(20).map(t-&gt;t[0]) .forEach(System.out::print); 扁平化flatMap两个集合一起12Stream&lt;List&lt;Integer&gt;&gt; ss=Stream.of(Arrays.asList(1,2,3),Arrays.asList(4,5));ss.flatMap(list-&gt;list.stream()).forEach(System.out::print); 1234String[] words = &#123;"hello","word"&#125;;//&#123;h,e,l,l,o&#125;,&#123;w,o,r,l,d&#125;Stream&lt;String[]&gt; stream = Arrays.stream(words).map(w-&gt;w.split(""));Stream&lt;String&gt; stringStream = stream.flatMap(Arrays::stream); {1,2,3},{3,4}-&gt;{[1,3],[1,4]…[3,4]}123456List&lt;Integer&gt; numbers1 = Arrays.asList(1,2,3);List&lt;Integer&gt; numbers2 = Arrays.asList(3,4);List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList());pairs.forEach(ints -&gt; &#123; System.out.println(Arrays.toString(ints));&#125;); 只返回[2,4],[3,3]加起来是%3=0123List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream() .filter(j-&gt;(i+j)%3==0) .map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList()); 查找匹配allMatchfind：12Optional&lt;Integer&gt; first = stream.filter(i -&gt; i % 2 == 0).findFirst();int sum = intStream.filter(i -&gt; i &gt; 3).sum(); reduce:.reduce(Integer::max)拆箱：节省内存mapToInt:IntStream intStream = stream.mapToInt(i -&gt; i.intValue());1234@FunctionalInterfacepublic interface ToIntFunction&lt;T&gt; &#123; int applyAsInt(T value);&#125; 装箱：.boxed(),.mapToObj()给一个数a求1-100里找一个数可以与a勾股定理sqrt(a^2+b^2)%1=0（sqrt后不带小数）.rangeClose(start,end)生成start-end中的所有数字range(1,100)是开区间 不包括结束值12345int a =9;IntStream.rangeClosed(1, 100).filter(b -&gt; Math.sqrt(a * a + b * b) % 1 == 0) .boxed()//IntStream的map只能每个元素返回另一个int 应该流中每个元素是数组（onj） .map(x -&gt; new int[]&#123;a, x, (int) Math.sqrt(x * x + a * a)&#125;) .forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); a也需要自动生成123456789Stream&lt;int[]&gt; stream1 = IntStream.rangeClosed(1, 100) .boxed() //把三元流扁平成一个流 //第二个值生成的range从第一个数c开始，去重复(3,4,5)(4,3,5) .flatMap(c -&gt; IntStream.rangeClosed(c, 100) .filter(b -&gt; Math.sqrt(c * c + b * b) % 1 == 0) //创建了三元流 .mapToObj(b -&gt; new int[]&#123;a, b, (int) Math.sqrt(a * a + b * b)&#125;));stream1.forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); 更紧凑的做法 只计算一次sqrt1234IntStream.rangeClosed(1,100).boxed().flatMap(a-&gt; IntStream.rangeClosed(a,100).mapToObj( b-&gt;new double[]&#123;a,b,Math.sqrt(a*a+b*b)&#125;) .filter(t-&gt;t[2]%1==0)); 拼接字符串效率不高，每次迭代都要新建String对象reduce可以设置初始值1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .reduce("", (n1, n2) -&gt; n1 + n2); 使用joining，内部用到StringBuilder1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .collect(joining()); 找最大值最小值.stream().min(comparing(Transaction::getValue));]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[netty]]></title>
    <url>%2F2018%2F06%2F04%2Fnetty%2F</url>
    <content type="text"><![CDATA[select模型 一个进程打开fd（文件描述符）有限1024/2048？ （最大并发数）FD_SETSIZE 在哪 每次select调用会扫描所有fd 内核拷贝fd的消息到用户空间 epollhttps://www.cnblogs.com/xiehongfeng100/p/4636118.html最大打开的文件数量（并发量）cat /proc/sys/fs/file-max mui文档http://dev.dcloud.net.cn/mui/util/http://www.html5plus.org/doc/zh_cn/webview.html 阻塞与非阻塞是线程访问资源是否就绪的一种处理方式同步和异步 数据访问的机制 数据处理完毕后会通知线程 同步阻塞BIO一个线程一个连接，用线程池 伪异步io NIO 同步非阻塞IO一个server一个selector多路复用器，是一个单线程，client注册到selector，每个client创建一个channel（双向通道），数据读写都会到缓冲区buffer，非堵塞地读取buffer客户端增加不会影响selector性能 同步表示要Selector主动轮询channel数据准备好没有异步是等人通知 AIO 异步非阻塞IO NIO2.0在NIO原有基础上，读写的返回类型是Feature对象，Feature有事件监听,等待通知回调 Netty三种线程模型Reactor线程模型 单线程模型 一个NIO线程处理所有请求 多线程模型，一组NIO县城处理IO操作，reactor线程池 主从线程模型，两个线程池，一组用于接收请求，一组用于处理IO HTTP服务器主从模型1234567891011121314151617181920212223public class HelloServer &#123; public static void main(String[] args) throws InterruptedException &#123; //主线程组 EventLoopGroup parentGroup = new NioEventLoopGroup(); //从线程组 EventLoopGroup childGroup = new NioEventLoopGroup(); //启动类 try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); //设置主从线程组和双向通道和child的处理器 serverBootstrap.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .childHandler(new HelloServerInitializer()); //启动server 同步方式 ChannelFuture channelFuture = serverBootstrap.bind(8088).sync(); //监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; parentGroup.shutdownGracefully(); childGroup.shutdownGracefully(); &#125; &#125;&#125; 初始化child线程的处理器pipLine123456789public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt;&#123; @Override protected void initChannel(SocketChannel channel) throws Exception &#123; //获得管道 ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast("HttpServerCodec",new HttpServerCodec()); pipeline.addLast("customHandler",new CustomHandler()); &#125;&#125; 添加自定义的http处理拦截123456789101112131415161718192021222324252627//入站拦截public class CustomHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; //从上下文对象里获得当前channel System.out.println(msg.toString()); System.out.println("--------------"); Channel channel = ctx.channel(); //发送了两次，因为有个图标的请求 //没加路由，所有所有访问8088的请求都会被拦截 if(msg instanceof HttpRequest)&#123; //远程地址 System.out.println(channel.remoteAddress()); //消息big-endian buffer ByteBuf content = Unpooled.copiedBuffer("hello netty", CharsetUtil.UTF_8); //Connection: keep-alive 1.1默认开启 FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,content); //数据类型 response.headers().set(HttpHeaderNames.CONTENT_TYPE,"text/plain"); //长度bytes response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes()); //写到缓冲区再刷到客户端 ctx.writeAndFlush(response); &#125; &#125;&#125; 测试curl 192.168.3.100:80881234567891011--------------DefaultHttpRequest(decodeResult: success, version: HTTP/1.1)GET / HTTP/1.1User-Agent: curl/7.29.0Host: 192.168.3.100:8088Accept: */*--------------/192.168.3.109:58586--------------EmptyLastHttpContent-------------- 生命周期 curl每次发送完会关闭 没有长链接重写SimpleChannelInboundHandler的方法12345678910111213141516171819handlerAddedchannelRegisteredchannelActive--------------DefaultHttpRequest(decodeResult: success, version: HTTP/1.1)GET / HTTP/1.1User-Agent: curl/7.29.0Host: 192.168.3.100:8088Accept: */*--------------/192.168.3.109:58588--------------EmptyLastHttpContent--------------channelReadCompletechannelReadCompletechannelInactivechannelUnregisteredhandlerRemoved 实时通信ajax轮询、Long pull、websocket 零拷贝java读文件:io流-&gt;缓冲区-&gt;java堆netty NIO直接开辟新的堆内存 从io流直接到堆 实现一个简单的协议1.客户端request请求协议12345678public class Request &#123; //编码 private byte encode; //指令 private String command; //命令长度 private int commandLength;&#125; 2.服务器response响应123456public class Response &#123; private byte encode; private int responseLength; //响应内容 private String response;&#125; 3.Server:1234567891011121314151617181920212223ServerSocket server = new ServerSocket(4567);while(true)&#123; Socket client = server.accept(); //客户端数据通过协议解码Request InputStream input = client.getInputStream(); Request request = ProtocolUtil.readRequest(input); OutputStream output = client.getOutputStream(); //封装response,根据客户端请求回应hello或者再见 Response response = new Response(); response.setEncode(Encode.UTF8.getValue()); if(request.getCommand().equals("HELLO"))&#123; response.setResponse("hello!"); &#125;else&#123; response.setResponse("bye bye!"); &#125; response.setResponseLength(response.getResponse().length()); //通过协议发送 ProtocolUtil.writeResponse(output, response); client.shutdownOutput();&#125; 4.编码类1字节长度：12345678910111213public enum Encode &#123; GBK((byte)0), UTF8((byte)1); private byte value = 1; private Encode(byte value)&#123; this.value = value; &#125; public byte getValue()&#123; return value; &#125;&#125; 5.Client端：1234567891011Request request = new Request(Encode.UTF8.getValue(),"HELLO","HELLO".length());Socket client = new Socket("127.0.0.1",4567);OutputStream output = client.getOutputStream();//通过协议发送ProtocolUtil.writeRequest(output, request);//读取服务响应InputStream input = client.getInputStream();Response response = ProtocolUtil.readResponse(input);client.shutdownOutput(); 6.协议实现对socket流的编码解码：InputStream-&gt;Request-&gt;OutputStream InputStream-&gt;Response-&gt;OutputStream 12345678910111213141516171819202122232425262728293031323334353637public class ProtocolUtil &#123; //1.read解码request public static Request readRequest(InputStream input) throws IOException&#123; //1字节编码 byte[] encodeByte = new byte[1]; input.read(encodeByte); byte encode = encodeByte[0]; //4个字节是命令的长度 byte[] commandLengthBytes = new byte[4]; input.read(commandLengthBytes); int commandLength = ByteUtil.bytes2Int(commandLengthBytes); //读命令 byte[] commandBytes = new byte[commandLength]; input.read(commandBytes); String command = ""; command = new String(commandBytes,Encode.GBK.getValue() == encode?"GBK":"UTF8"); //封装返回 return new Request(encode,commandLength,command); &#125; //3.发送请求给服务端 public static void writeRequest(OutputStream output,Request request) throws IOException&#123; //注意read和write的字节顺序要相同 output.write(request.getEncode()); output.write(ByteUtil.int2ByteArray(request.getCommandLength())); output.write(request.getCommand().getBytes(Encode.GBK.getValue() == request.getEncode()?"GBK":"UTF8")); output.flush(); &#125; public static Response readResponse(InputStream input) throws IOException&#123; //... &#125; public static void writeResponse(OutputStream output,Response response) throws IOException&#123;//... &#125;&#125; 读取写入响应长度的byteintjava是大端字节序 TCP/IP协议规定了在网络上必须采用网络字节顺序，也就是大端模式。对于char型数据只占一个字节，无所谓大端和小端。而对于非char类型数据，必须在数据发送到网络上之前将其转换成大端模式。 ByteOrder.nativeOrder()LITTLE_ENDIAN小端Big-endian：将高序字节存储在起始地址（高位编址）12345低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| byte[0]=12 | 34 | 56 | 78 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Little-endian：将低序字节存储在起始地址（低位编址）12345低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| byte[0]=78 | 56 | 34 | 12 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4位大端数据转换{0,0,0,1}11234567891011121314151617public static int bytes2Int(byte[] bytes) &#123; System.out.println(Arrays.toString(bytes)); int num = bytes[3] &amp; 0xFF; num |= ((bytes[2] &lt;&lt; 8) &amp; 0xFF00); num |= ((bytes[1] &lt;&lt; 16) &amp; 0xFF0000); num |= ((bytes[0] &lt;&lt; 24) &amp; 0xFF000000); return num; &#125; public static byte[] int2ByteArray(int i) &#123; byte[] result = new byte[4]; result[0] = (byte)((i &gt;&gt; 24) &amp; 0xFF); result[1] = (byte)((i &gt;&gt; 16) &amp; 0xFF); result[2] = (byte)((i &gt;&gt; 8) &amp; 0xFF); result[3] = (byte)(i &amp; 0xFF); return result; &#125; 利用http协议实现rpc 序列化比较用字节数组流 Hessianhessian-4.0.7.jarObject-&gt;HessianOutput(ByteArrayOutputStream)-&gt;.write(Objcet)-&gt;.toByteArray()HessianInput(ByteArrayInputStream())-&gt;.readObject()1234567891011Person zhangsan = new Person("zhangsan");//序列化 object-&gt;outputStreamByteArrayOutputStream bos = new ByteArrayOutputStream();HessianOutput hot = new HessianOutput(bos);hot.writeObject(zhangsan);byte[] zhangsanByte = bos.toByteArray();//反序列化ByteArrayInputStream ips = new ByteArrayInputStream(zhansanByte);HessianInput hin = new HessianInput(ips);Person person = (Person)hi.readObject(); Java自带的序列化ObjectOutputStream(ByteArrayOutputStream)-&gt;writeObject0&gt;.toByteArray()12345678910Person zhangsan = new Person("zhangsan");//序列化 写到字节数组流-&gt;写到对象流ByteArrayOutputStream os = new ByteArrayOutputStream();ObjectOutputStream out = new ObjectOutputStream(os);out.writeObject(zhangsan);byte[] zhangsanByte = os.toByteArray();//反序列化ByteArrayInputStream is = new ByteArrayInputStream(zhansanByte);ObjectInputStream in = new ObjectInputStream(is);Person person = (Person)in.readObject(); jackson序列化 字符串流jackson-all-1.7.6.jar12345678910//序列化String personJson = null;ObjectMapper mapper = new ObjectMapper();StringWriter sw = new StringWriter();JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);mapper.writeValue(gen, person);gen.close();personJson = sw.toString();//反序列化Person zhangsan = (Person)mapper.readValue(personJson, Person.class); xml xstream-1.4.4.jar123456&lt;pppp&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;address&gt;hangzhou,china&lt;/address&gt; &lt;birth&gt;2018-08-25 11:17:03.450 UTC&lt;/birth&gt;&lt;/pppp&gt; 12345678//将person对象序列化为XMLXStream xStream = new XStream(new DomDriver());//设置Person类的别名xStream.alias("pppp", Person.class);String personXML = xStream.toXML(person);//将XML反序列化还原为person对象Person zhangsan = (Person)xStream.fromXML(personXML); 基于tcp的服务调用 服务接口123public interface SayHelloService&#123; public String sayHello(String str);&#125; Consumer1234567891011121314151617//调用的接口名称String interfaceName = SayHelloService.class.getName();//调用的方法Method method = SayHelloService.class.getMethod("sayHello", java.lang.String.class);//传给服务端方法的参数Object[] arguments = &#123;"hello"&#125;;Socket socket = new Socket("127.0.0.1", 1234);//接口名，方法名，参数类型，参数 传到服务器ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());output.writeUTF(interfaceName); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); //接收远程方法的结果ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); Object result = input.readObject(); Provider12345678910111213141516171819202122232425262728//所有对外提供的服务注册到map里private static Map&lt;String,Object&gt; services = new HashMap&lt;String,Object&gt;();static&#123; services.put(SayHelloService.class.getName(), new SayHelloServiceImpl());&#125;//mainServerSocket server = new ServerSocket(1234);while(true) &#123; Socket socket = server.accept(); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); //接口名称 String interfaceName = input.readUTF(); //方法名称 String methodName = input.readUTF(); //参数类型 Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject(); //参数对象 Object[] arguments = (Object[])input.readObject(); //执行方法 Class interfaceClass = Class.forName(interfaceName); //实现的具体类 Object service = service.get(interfaceName); Method method = interfaceClass.getMethod(methodName,parameterTypes); Objcet result = method.invoke(service,arguments); ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result);&#125; 具体实现类12345678public class SayHelloServiceImpl implements SayHelloService &#123; @Override public String sayHello(String str) &#123; if(helloArg.equals("hello"))&#123; return "hello"; &#125;else&#123; return "bye bye"; &#125;&#125;&#125; 报错初始化堆空间不够-Xmx3550m 基于HTTP的RPCservlet-api.jarjackson-all-1.7.6.jarhttpcore4.2.4.jarhttpclient-4.2.5.jarcommons-logging-1.1.1.jar 接口123public interface BaseService &#123; public Object execute(Map&lt;String,Object&gt; args);&#125; 实现：1234567891011public class SayHelloService implements BaseService&#123; public Object execute(Map&lt;String, Object&gt; args) &#123; //request.getParameterMap() 取出来为array,此处需要注意 String[] helloArg = (String[]) args.get("arg1"); if("hello".equals(helloArg[0]))&#123; return "hello"; &#125;else&#123; return "bye bye"; &#125;&#125;&#125; 消费者：123public class ServiceConsumer extends HttpServlet&#123;&#125; 排队延迟 路由器必须检测分组的首部，以确定出站路由，并且还可能对数据进行检查，这些都要花时间。由于这些检查通常由硬件完成，因此相应的延迟一般非常短，但再短也还是存在。最后，如果分组到达的速度超过了路由器的处理能力，那么分组就要在入站缓冲区排队。数据在缓冲区排队等待的时间，当然就是排队延迟。 光纤RTT 应用必须在几百 ms 之内响应。 在软件交互中，哪怕 100~ 200 ms 左右的延迟，我们中的大多数人就会感觉到“拖拉”；如果超过了 300 ms 的门槛，那就会说“反应迟钝”；而要是延迟达到 1000 ms（1s）这个界限，很多用户就会在等待响应的时候分神，有人会想入非非，有人恨不得忙点别的什么事儿。 带宽：通过波分复用（WDM，Wavelength-Division Multiplexing）技术，光纤可以同时传输很多不同波长（信道）的光到 2010 年初，研究人员已经可以在每个信道中耦合 400 多种波长的光线，最大容量可达 171 Gbit/s，而一条光纤的总带宽能够达到 70 Tbit/s TCP fast open TFO每个 ACK 分组都会携带相应的最新 接收窗口大小rwnd 值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。 RARP无盘工作站，没有存储，无法记录自己的IP地址，用物理地址向服务器查询自身IP地址。 数据链路层、网络层、传输层在内核空间中实现（内核缓冲区）应用层在用户空间 子网掩码https://blog.csdn.net/yinshitaoyuan/article/details/51782330 得到子网的网络地址 每个子网络能容纳500台主机，它的子网掩码是多少？500-&gt;111110100 一共9位子网掩码255.255.255.255从后向前的9位变成0（11111111.11111111.11111110.00000000）255.255.254.0。 3、利用子网掩码计算最大有效子网数 A类IP地址，子网掩码为255.224.0.0，它所能划分的最大有效子网数是多少？ ①将子网掩码转换成二进制表示11111111.11100000.00000000.00000000 ②统计一下它的网络位共有11位 ③A类地址网络位的基础数是8，二者之间的位数差是3 ④最大有效子网数就是2的3次方，即最多可以划分8个子网络。 以太网 Frame帧IP packet 分组（不是分片TCP segment 分节应用层 message消息 NIO:Reactor模式reactor对所有客户端的socket套接字做事件处理，派发到不同的线程。 AIO:Proactor模式动作完成后调用handler 网络计时Timekeeping时间：一天86400秒 365天 假设70年 精度为10位有效数字时钟：振荡器oscillator(14.318MHz+计数器counter Timestamp时间点。是指针 不能相加 只能相减。算中间时间：T1+(T2-T1)/2Time interval 是int时间的一阶导是频率二阶导是jittertsc cpu内部的周期计数器 现在不随cpu频率变化。cpu频率以G 10^9 能精度到1ns NTP网络时间同步 基于UDP算出时间差error:[(T4+T1)-(T2+T3)]/2后调整offset和frequency连续调整 避免时钟跳变。如果时间差小于128ms 缓慢调下去。频率跳变时间会阶越效应 当同一个ip后面多个服务器，没有session会发到不同的服务器上NTP在服务端有两个误差，1从网卡内核到用户进程接收计时 2用户进程开始发送计时到内核网卡发出。两个时间可能不对称。 以太网最小帧长64字节ip20字节 udp 8字节 tcp头20字节tcp还有时间戳option12字节ip-tcp52字节 TCP close发送太早可能发生RST分解。连接重置。netcat光发，不接收响应，ttcp接收到服务器ack再发第二个包 本机测试从/dev/zero读取1G的速度nc -l 5000 &gt;/dev/null &amp;dd if = /dev/zero bs = 1M count = 1000 |nc localhost 5000用io重定向测试本地文件传输速度time nc localhost 5001 &lt; file.file用irb计算 10^10(1G)/9.4(s)/10^6 = M/s 得到磁盘性能 第二次time会快很多因为已经在缓存里了 监测数据nc -l 50001 |pv -W &gt; /dev/null pv的单位是二进制，dd用的十进制文件-&gt;tcp-&gt;文件dd |nc,nc -l &gt;/dev/null6次用户与内核间拷贝 /dev/zero-&gt;dd dd-&gt;pipe pipe-&gt;nc nc-&gt;TCP TCP-&gt;服务端nc sysctl -A |grep range本机端口范围 TCP自连接1发起链接时会从ipv4.ip_local_port_range中选择临时端口号2向服务器发送SYNTCP的同时打开，3000端口无进程监听，但是tcp链接打开了3000端口，当作有监听，形成自连接 pipelining数，连发n个收一个ack用阻塞编程 有上限，超过会收不到ack TTCP tcp实现的检测性能muduo 用非阻塞的muduo库写的ttcp.ccstream-&gt;setNoDelay(true) 不用等ack发送 Epoll 可扩展I/O时间通知特性比旧的POSIX select和poll系统调用性能更好。epoll是linux非阻塞网络编程的事实标准。Linux下：将NioEventLoopGroup换成EpollEventLoopGroupNioServerSocketChannel.class换成EpollServerSocketChannel.class 回调方法：指向已经被提供给另一个方法的 方法的引用OutboundHandler出站：从客户端到服务端 ：链尾取到链头Inbound 入站：链头取到链尾handler添加到pipline时会被分配一个ChannelHandlerContext表示绑定。1.直接写道channel中，从Pipeline尾端开始流动2.写到handler关联的Context对象 从从pipeline从下一个handler开始流动 ChannelHandler的三个子类：编码器，解码器 SimpleC..Inbound..nettyIoc 好莱坞原则Reactor模型 应用向中间人注册回调(event handler) 中间人轮询，IO就绪后中间人产生事件，通知handler处理。 第三种reactor模型，将reactor分两部分。mainReactor负责监听server socket的链接（外部client的链接）subReactor 负责读写网络数据。 netty支持单线程、多线程、主从reactor模型。 创建2个线程组多个线程 线程内串行化 避免线程竞争 无锁 操作系统维护TCP 的SYN队列 将网络请求插入队列，返回SYN/ACK 两次握手 半链接（SYN_RCVD) （主reactor） 第三次握手，收到ACK请求，操作系统将SYN队列中的请求转移到ACCEPT队列（阻塞队列）全链接(ESTABLISHED) （子reacotr） 服务器上的应用队列监听阻塞队列（ACCEPT)accept+SYN队列=backlog长度syn长度：/proc/sys/net/ipv4/tcp_max_syn_backlog =1024accept长度：/proc/sys/net/core/somaxconn =128 引导 构建netty的配置服务端12serverBootstrap.group(pgroup,cgroup).channel(NioSocketChannel.class).option(ChannelOption.SO_RCVBUF,32*1024)//接收缓存大小 客户端引导Bootstrap 连接到主机和端口服务端引导ServerBootstrap 绑定一个本地端口客户端只需一个EventLoopGroup客户端需要2个，管理两组不同的Channel。 ServerChannel绑定本地端口并监听 连接请求创建channel 第二组处理传入客户端连接的channel 给channel分配eventloop Netty的buffer有两个指针，读写指针互不影响，NIO只有一个指针要flipdirectByteBuf堆外 零拷贝 客户端 写给服务端12//直接把字节数组包装成bufferctx.writeAndFlush(Unpooled.wrappedBuffer("响应".getBytes())); 服务器端读取1234567try&#123;ByteBuf buf =(ByteBuf)msg;byte[] responseData = new byte[buf.readableBytes()];buf.readBytes(responseData);&#125;finally&#123; ReferenceCountUtil.release(msg);&#125; Netty阻塞io服务端123456789101112131415161718192021222324252627EventLoopGroup group = new OioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(OioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) //用于回调 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( new ChannelInboundHandlerAdapter() &#123; @Override public void channelActive( ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) .addListener( ChannelFutureListener.CLOSE); &#125; &#125;); &#125; &#125;); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync();&#125; 非阻塞服务端1234567NioEventLoopGroup group = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group).channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) ... &#125; 客户端：12345678910111213141516171819202122232425public void start()throws Exception &#123;EventLoopGroup group = new NioEventLoopGroup();try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; //Pipeline为handler编排顺序 ch.pipeline().addLast( //自定义的handler new EchoClientHandler()); &#125; &#125;); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync();&#125; finally &#123; group.shutdownGracefully().sync();&#125;&#125;]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud zk]]></title>
    <url>%2F2018%2F05%2F08%2Fspring-cloud%2F</url>
    <content type="text"><![CDATA[分布式：节点之间如何通信微服务：按业务划分模块 @EnableEurekaServer 静态文件用Nginx+Lua实现高性能网关文件服务器 FastDFSzk客户端 curator解决watcher注册一次就失效分布式锁 dockerk8s 容器编排工具ZooKeeper1.安装jdk到/usr/ 安装zookeeper到/usr/local/vi /etc/profile12export ZOOKEEPER_HOME=/usr/local/zookeeper-3.4.8export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH:$ZOOKEEPER_HOME/bin 2.cd conf/cp zoo_sample.cfg zoo.cfgtickTime 时间单元 session超时等initLimit=N 用于集群 从从节点连接并同步到主节点 的初始化链接时间 表示是tickTime的N倍syncLimit=N 主发送给从 的请求应答时间长度（心跳）表示是tickTime的N倍 12345678# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir= /usr/local/zookeeper3.4.8/dataDirdataLogDir=/usr/local/zookeeper3.4.8/logDir# the port at which the clients will connectclientPort=2181 并创建dataDir和dataLogDir cd ../bin启动服务器1234[root@localhost bin]# ./zkServer.shZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.8/bin/../conf/zoo.cfgUsage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125; ./zkServer.sh start/restart/stop 启动客户端./zkCli.sh 链接成功后1234567891011121314151617181920212223[zk: localhost:2181(CONNECTED) 0] helpZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] #某个路径下的目录列表 delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit getAcl path close connect host:port ls123456[zk: localhost:2181(CONNECTED) 2] ls /[zookeeper][zk: localhost:2181(CONNECTED) 3] ls /zookeeper[quota][zk: localhost:2181(CONNECTED) 4] ls /zookeeper/quota[] zk 的作用1.M/S节点选举-&gt;高可用2.同步配置文件到所有服务器3.发布订阅MQ4.分布式锁5.集群管理，保证数据强一致性 ls2 /12345678910111213[zk: localhost:2181(CONNECTED) 0] ls2 /[zookeeper]cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0cversion = -1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 1 stat /123456789101112[zk: localhost:2181(CONNECTED) 1] stat /cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0cversion = -1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 1 get /12345678910111213[zk: localhost:2181(CONNECTED) 2] get / #数据 当前为空cZxid = 0x0 ## 创建了之后zk给它分配的idctime = Thu Jan 01 08:00:00 CST 1970 #创建时间mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0 #子节点idcversion = -1 #子节点的变化dataVersion = 0 #数据版本号aclVersion = 0 # 权限ephemeralOwner = 0x0dataLength = 0numChildren = 1 # 子节点有几个 Session 的基本原理一个C/S连接存在一个会话，会话有超时时间心跳结束 session过期 session 临时节点znode被抛弃 心跳机制：C向S发送ping create1234567891011121314151617181920212223[zk: localhost:2181(CONNECTED) 3] creteZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit getAcl path close connect host:port 创建结点 create /iznode inode-data查看get /iznode123456789101112131415[zk: localhost:2181(CONNECTED) 4] create /iznode inode-dataCreated /iznode[zk: localhost:2181(CONNECTED) 5] get /iznodeinode-datacZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0x4mtime = Sat Sep 15 15:30:32 CST 2018pZxid = 0x4cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 10numChildren = 0 创建临时结点create -e /iznode/tmp inode-data12345678910111213141516171819202122232425262728[zk: localhost:2181(CONNECTED) 6] create -e /iznode/tmp inode-dataCreated /iznode/tmp[zk: localhost:2181(CONNECTED) 7] get /iznodeinode-datacZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0x4mtime = Sat Sep 15 15:30:32 CST 2018pZxid = 0x5cversion = 1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 10numChildren = 1[zk: localhost:2181(CONNECTED) 8] get /iznode/tmpinode-datacZxid = 0x5ctime = Sat Sep 15 15:31:33 CST 2018mZxid = 0x5mtime = Sat Sep 15 15:31:33 CST 2018pZxid = 0x5cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x165dc14dc590001 #临时节点dataLength = 10numChildren = 0 ephemeralOwner可以看出是不是临时结点 客户端关闭后，超时后，临时结点会自动删除ctrl-C关闭客户端再打开 还有 因为时效还在 等一下再get就没了123456789101112131415[zk: localhost:2181(CONNECTED) 2] get /iznode/tmpinode-datacZxid = 0x5ctime = Sat Sep 15 15:31:33 CST 2018mZxid = 0x5mtime = Sat Sep 15 15:31:33 CST 2018pZxid = 0x5cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x165dc14dc590001dataLength = 10numChildren = 0[zk: localhost:2181(CONNECTED) 3] get /iznode/tmpNode does not exist: /iznode/tmp 创建顺序结点create -s /iznode/sec seq-data会自动在名字后面加序列号123456[zk: localhost:2181(CONNECTED) 4] create -s /iznode/sec seq-dataCreated /iznode/sec0000000001[zk: localhost:2181(CONNECTED) 5] create -s /iznode/sec seq-dataCreated /iznode/sec0000000002[zk: localhost:2181(CONNECTED) 6] create -s /iznode/sec seq-dataCreated /iznode/sec0000000003 set set path data [version]和deleteset /iznode 123 1添加乐观锁123 版本号+112345678910111213141516171819202122232425[zk: localhost:2181(CONNECTED) 9] set /iznode newnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xbmtime = Sat Sep 15 15:36:04 CST 2018pZxid = 0xacversion = 5dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3[zk: localhost:2181(CONNECTED) 10] get /iznodenewnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xbmtime = Sat Sep 15 15:36:04 CST 2018pZxid = 0xacversion = 5dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3 set 添加版本号 乐观锁1234567891011121314[zk: localhost:2181(CONNECTED) 11] set /iznode newnewnew 1cZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xcmtime = Sat Sep 15 15:37:19 CST 2018pZxid = 0xacversion = 5dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3[zk: localhost:2181(CONNECTED) 12] set /iznode newnewnew 1version No is not valid : /iznode delete123456789101112131415161718[zk: localhost:2181(CONNECTED) 17] ls /iznode [sec0000000003, sec0000000001, sec0000000002][zk: localhost:2181(CONNECTED) 18] delete /iznode/sec0000000003[zk: localhost:2181(CONNECTED) 19] ls /iznode [sec0000000001, sec0000000002][zk: localhost:2181(CONNECTED) 20] get /iznodenewnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xcmtime = Sat Sep 15 15:37:19 CST 2018pZxid = 0xecversion = 6dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 2 watch对node的操作都会触发watcher12stat path [watch]get path [watch] 1234567891011121314151617181920[zk: localhost:2181(CONNECTED) 10] create /iwatch2 145Created /iwatch2[zk: localhost:2181(CONNECTED) 11] get /iwatch2 watch 145cZxid = 0x14ctime = Sat Sep 15 15:50:03 CST 2018mZxid = 0x14mtime = Sat Sep 15 15:50:03 CST 2018pZxid = 0x14cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0[zk: localhost:2181(CONNECTED) 12] delete /iwatch2WATCHER::WatchedEvent state:SyncConnected type:NodeDeleted path:/iwatch2 乐观锁：当节点数据变化版本号会累加 子节点watch123456789[zk: localhost:2181(CONNECTED) 15] create /iwatch/abc 88Created /iwatch/abc[zk: localhost:2181(CONNECTED) 16] ls /iwatch watch[abc][zk: localhost:2181(CONNECTED) 17] delete /iwatch/abcWATCHER::WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/iwatch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[zk: localhost:2181(CONNECTED) 18] ls /iwatch watch[][zk: localhost:2181(CONNECTED) 19] create /iwatch/xyz 999WATCHER::WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/iwatchCreated /iwatch/xyz[zk: localhost:2181(CONNECTED) 20] set /iwatch/xyz newnew999cZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x19mtime = Sat Sep 15 15:53:46 CST 2018pZxid = 0x18cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 0[zk: localhost:2181(CONNECTED) 21] get /iwatch/xyz watchnewnew999cZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x19mtime = Sat Sep 15 15:53:46 CST 2018pZxid = 0x18cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 0[zk: localhost:2181(CONNECTED) 22] set /iwatch/xyz newne888 WATCHER::WatchedEvent state:SyncConnected type:NodeDataChanged path:/iwatch/xyzcZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x1amtime = Sat Sep 15 15:54:25 CST 2018pZxid = 0x18cversion = 0dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 8numChildren = 0 watcher使用场景：统一资源配置ACL access control lists 权限控制123setAcl path aclgetAcl pathaddauth scheme auth 12345[zk: localhost:2181(CONNECTED) 3] create /iznode/abc aaaCreated /iznode/abc[zk: localhost:2181(CONNECTED) 4] getAcl /iznode/abc 'world,'anyone: cdrwa [scheme:id:permissions]权限列表c 创建r 读w 写d 删除a admin权限 不加要super123456789101112131415161718192021[zk: localhost:2181(CONNECTED) 5] setAcl /iznode/abc/ world:anyone:crwaCommand failed: java.lang.IllegalArgumentException: Path must not end with / character[zk: localhost:2181(CONNECTED) 6] setAcl /iznode/abc world:anyone:crwa cZxid = 0x1dctime = Sat Sep 15 15:59:43 CST 2018mZxid = 0x1dmtime = Sat Sep 15 15:59:43 CST 2018pZxid = 0x1dcversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 3numChildren = 0[zk: localhost:2181(CONNECTED) 7] getAcl /iznode/abc 'world,'anyone: crwa[zk: localhost:2181(CONNECTED) 8] create /iznode/abc/xyz 123Created /iznode/abc/xyz[zk: localhost:2181(CONNECTED) 9] delete /iznode/abc/xyzAuthentication is not valid : /iznode/abc/xyz digest用户名密码SHA1+BASE641234567891011121314151617181920[zk: localhost:2181(CONNECTED) 17] create /names nnn Created /names[zk: localhost:2181(CONNECTED) 19] create /names/zhangsan zhangsanCreated /names/zhangsan[zk: localhost:2181(CONNECTED) 14] addauth digest username:pw[zk: localhost:2181(CONNECTED) 20] setAcl /names/zhangsan auth:username:pw:cdrwacZxid = 0x27ctime = Sat Sep 15 16:10:09 CST 2018mZxid = 0x27mtime = Sat Sep 15 16:10:09 CST 2018pZxid = 0x27cversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 8numChildren = 0[zk: localhost:2181(CONNECTED) 21] getAcl /names/zhangsan 'digest,'username:cP33D+25T3/l/dheCyIBuhZjI40=: cdrwa ip设置一个网段的权限12345678910111213141516171819[zk: localhost:2181(CONNECTED) create /names/ip ip Created /names/ip[zk: localhost:2181(CONNECTED) 23] setAcl /names/ip ip:10.1.18.11:cdrwacZxid = 0x29ctime = Sat Sep 15 16:13:47 CST 2018mZxid = 0x29mtime = Sat Sep 15 16:13:47 CST 2018pZxid = 0x29cversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 2numChildren = 0[zk: localhost:2181(CONNECTED) 24] getAcl /names/ip 'ip,'10.1.18.11: cdrwa[zk: localhost:2181(CONNECTED) 25] get /names/ipAuthentication is not valid : /names/ip super 用户vi zkServer.sh/nohup加上12nohup "$JAVA" "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;" "-Dzookeeper.DigestAuthenticationProvider.superDigest=username:cP33D+25T3/l/dheCyIBuhZjI40="\ -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG 对应jar包org.apache.zookeeper.server.auth 重启./zkServer.sh restart12345[zk: localhost:2181(CONNECTED) 3] getAcl /names/ip'ip,'10.1.18.11: cdrwa[zk: localhost:2181(CONNECTED) 4] addauth digest username:pw[zk: localhost:2181(CONNECTED) 5] ls /names/ip acl使用场景：开发/测试人员环境分离Four Letter Wordsyum install nc1234567891011121314151617181920[root@localhost bin]# echo stat | nc 10.1.18.133 2181Zookeeper version: 3.4.8--1, built on 02/06/2016 03:18 GMTClients: /10.1.18.133:38240[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/1/11Received: 25Sent: 24Connections: 1Outstanding: 0Zxid: 0x2dMode: standaloneNode count: 15[root@localhost bin]# echo ruok | nc 10.1.18.133 2181imok[root@localhost bin]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (0):ephemeral nodes dump:Sessions with Ephemerals (0): 创建临时节点1create -e /name/tmp-dump 123 dump123456789101112131415161718192021[root@localhost ~]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (3):0 expire at Sat Sep 15 16:37:30 CST 2018:0 expire at Sat Sep 15 16:37:40 CST 2018:1 expire at Sat Sep 15 16:37:50 CST 2018: 0x165dc54602f0001ephemeral nodes dump:Sessions with Ephemerals (0):[root@localhost ~]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (4):0 expire at Sat Sep 15 16:38:30 CST 2018:0 expire at Sat Sep 15 16:38:40 CST 2018:0 expire at Sat Sep 15 16:38:42 CST 2018:1 expire at Sat Sep 15 16:38:50 CST 2018: 0x165dc54602f0001ephemeral nodes dump:Sessions with Ephemerals (1):0x165dc54602f0001: #可以看到临时节点的目录 /names/tmp-dump conf123456789[root@localhost ~]# echo conf | nc 10.1.18.133 2181clientPort=2181dataDir=/usr/local/zookeeper-3.4.8/dataDir/version-2dataLogDir=/usr/local/zookeeper-3.4.8/logDir/version-2tickTime=2000maxClientCnxns=60minSessionTimeout=4000maxSessionTimeout=40000serverId=0 cons123[root@localhost ~]# echo cons | nc 10.1.18.133 2181 /10.1.18.133:38260[0](queued=0,recved=1,sent=0) /0:0:0:0:0:0:0:1:37946[1](queued=0,recved=33,sent=33,sid=0x165dc54602f0001,lop=PING,est=1537000478725,to=30000,lcxid=0x3,lzxid=0x31,lresp=1537000778393,llat=0,minlat=0,avglat=1,maxlat=15) 健康信息12345678910111213141516[root@localhost ~]# echo mntr | nc 10.1.18.133 2181zk_version 3.4.8--1, built on 02/06/2016 03:18 GMTzk_avg_latency 1zk_max_latency 15zk_min_latency 0zk_packets_received 76zk_packets_sent 75zk_num_alive_connections 2zk_outstanding_requests 0zk_server_state standalonezk_znode_count 16zk_watch_count 0zk_ephemerals_count 1zk_approximate_data_size 237zk_open_file_descriptor_count 29zk_max_file_descriptor_count 4096 watch数量123[root@localhost ~]# echo wchs | nc 10.1.18.133 21810 connections watching 0 pathsTotal watches:0 zk 集群搭建1.伪分布式 端口号不一样 ip一样的cp zookeeper-3.4.8 zookeeper2 -rfvi zoo.cfg]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原子性 可见性 有序性]]></title>
    <url>%2F2018%2F05%2F07%2Favo%2F</url>
    <content type="text"><![CDATA[原子性： 互斥 同一时间只有一个线程操作atomic竞争激烈能维持常态，性能比Lock还好，但每次只能同步一个值 AtomicInteger123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; Unsafe:12345678910//var1 当前对象 var2当前值 var4 add值public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123;//调用底层native方法获得var2当前值，有没有别的线程处理 var5 = this.getIntVolatile(var1, var2); //直到 主存var5和var2工作内存相等，则执行add &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; compareAndSwapInt是native方法 LongAdder与CAS中的AtomicLong比较：AtomicLong竞争激烈时，大概率修改失败，性能差JVM会将64位的long和double读写会拆成2个32位的操作123public void increment() &#123; add(1L);&#125; LongAdderextends Striped64实现热点数据分离，高并发时会将long变成一个数组Cell[] as，但是并发更新可能会有误差。 compareAndSet用于AtomicBoolean中控制代码只执行一次（只能一个线程）。执行之前是false 执行之后true。compareAndSet(false,true)12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125; AtomicBoolean1234567891011private static AtomicBoolean isHappened = new AtomicBoolean(false);//放在线程中semaphore.acquire();test();semaphore.release();private static void test() &#123; //线程执行1k次，F变T只一次 log只输出一次 if (isHappened.compareAndSet(false, true)) &#123; log.info("execute"); &#125;&#125; atomic机器级指令compareAndSet 比锁快，映射到处理器操作。123largest.updateAndGet(x-&gt;Math.max(x,observed));//或者largest.accumulateAndGet(observed,Math::max); 大量线程访问相同的原子值LongAdder,LongAccumulator线程个数增加自动提供新的加数。所有工作都完成后才需要总和的情况使用。 AtomicIntegerFieldUpdate原子性更新类的更新类中相应字段 必须volatile不能static展开代码 1234567891011121314151617public class AtomicExample5 &#123;private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, "count");public volatile int count = 100;public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if (updater.compareAndSet(example5, 100, 120)) &#123; //执行 log.info("update success 1, &#123;&#125;", example5.getCount()); &#125; if (updater.compareAndSet(example5, 100, 120)) &#123; log.info("update success 2, &#123;&#125;", example5.getCount()); &#125; else &#123;//执行 log.info("update failed, &#123;&#125;", example5.getCount()); &#125;&#125;&#125; AtomicStampReference解决CAS的ABA问题1234567891011 private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125;&#125; ABA其它线程将A改成B再改成A，本线程比较发现没有变。每次更新变量版本号+1123456789101112 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp;//比较stamp ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125; AtomicLongArray数组，可以更新索引位置的值long getAndSet(int i, long newValue)boolean compareAndSet(int i, long expect, long update) 锁synchronized 依赖JVM不可中断锁，必须等到代码执行完,竞争不激烈使用，可读性好1.修饰代码块：作用域调用的对象输出0~9，0~91234567891011121314151617181920public class SynchronizedExample1 &#123; // 修饰一个代码块 public void test1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", i); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); &#125;&#125; 2.修饰方法：作用于调用的对象，子类的继承该方法不会带synchronized，需要再声明。因为synchronized不是方法声明的一部分同上输出0~9，0~912345public synchronized void test2() &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", i); &#125;&#125; 当声明另一个对象,两个线程会交叉执行，不同对象之间不影响123SynchronizedExample1 example2 = new SynchronizedExample1();example1.test2();example2.test2(); 3.修饰静态方法：作用于所有对象同一时间只有一个线程可以执行，两个对象也是输出0~9，0~912345public static synchronized void test2(int j) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", j, i); &#125;&#125; 4.修饰类：作用于所有对象1234567public static void test1(int j) &#123; synchronized (SynchronizedExample2.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", j, i); &#125; &#125;&#125; Lock:依赖特殊的CPU指令 可中断unLock竞争激烈维持常态 ReentrantLock123private Lock bankLock = new ReentrantLock();try&#123;bankLock.lock();&#125;finally&#123;bankLock.unlock();&#125; 可见性：每个cpu都有cacheCPU2修改了内存中的a，CPU1读取a只读取cache中的值，不可见虚拟机有两种模式 客户端模式不会优化 -server优化（64位虚拟机一般是server模式） 线程交叉执行 重排序+线程交叉执行 共享变量更新再工作内存和主存没同步 java内存模型线程如何何时看到其它线程修改过的共享变量的值，如何同步地访问共享变量堆 运行时动态分配内存大小。调用栈和本地变量存放在线程栈。 java内存模型JMM对synchronized的两条规定： 线程解锁必须刷新共享变量到主存 线程加锁要清空工作内存中共享变量的值，使用共享变量时从主存读新值（同一个范围的锁） volatile内存屏障，禁止重排序volatile写：会在写操作后加入一条store屏障指令它的修改会立刻刷新到主存，图有问题？？？读：读之前加入load屏障指令，c去内存中读取新值。 使用volatile run(){count++}还是会出错volatile不具有原子性。因为：1. 取值2. +1 3.写回主存，两个线程同时拿到值并+1，同时写回主存，丢1. 使用场景：对变量的写操作不依赖当前值适合当状态标记量：用volatile的值作为线程1的状态加载完毕。线程2 while(!)判断 有序性volatile、synchronized、Lock 不满足happends-beforey原则 JVM就可以重排序volatile 写操作先于读操作终止检测Thread.isAlive()]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io-file]]></title>
    <url>%2F2018%2F05%2F04%2Fjava-io-file%2F</url>
    <content type="text"><![CDATA[http://blog.jmecn.net/java-iostream/JNI java native interface 本地接口堆外内存：ByteBuffer1.wrap可以包装一个数组，保证不被直接修改2.ByteBuffer.allocateDirect() 堆外内存。123public static ByteBuffer allocateDirect(int capacity) &#123; return new DirectByteBuffer(capacity);&#125; DirectByteBuffer继承MappedByteBuffer,map..继承ByteBuffer继承BufferBuffer.java中 实现零拷贝1234// Used only by direct buffers// NOTE: 升级为了JNI方法调用的速度hoisted here for speed in JNI GetDirectBufferAddress//堆外内存数据地址用c申请的long address; Reactor模式IO分为广义File I/O和Stream I/O两类common-ioxml解析SAX 事件驱动，顺序。，读取(内存占用小) 解析器工厂 1SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); 创建SAX解析器 1SAXParser saxParser = saxParserFactory.newSAXParser(); 数据处理器 1PersonHandler personHandler = new PersonHandler(); 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class PersonHandler extends DefaultHandler&#123; public List&lt;Person&gt; getPersons() &#123; return persons; &#125; private List&lt;Person&gt; persons = null; private Person p= null; //用于记录当前正在解析的标签 private String tag; @Override public void startDocument() throws SAXException &#123; super.startDocument(); //开始解析文档 persons = new ArrayList&lt;&gt;(); System.out.println("开始解析标签"); &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); System.out.println("结束解析"); &#125; /* * @param uri 命名空间 * @param localName 不带前缀的标签 * @param qName 带前缀的标签&lt;aa: * @param attributes 标签里的属性集合 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; super.startElement(uri, localName, qName, attributes); if("Person".equals(qName))&#123; p=new Person(); int id = Integer.parseInt(attributes.getValue("id")); p.setId(id); &#125; //开始解析标签时记录名字 tag = qName; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; super.endElement(uri, localName, qName); //每次结束标记就把tag置空 if ("Person".equals(qName)) &#123; persons.add(p); &#125; tag = null; &#125; @Override //解析文本内容时 public void characters(char[] ch, int start, int length) throws SAXException &#123; super.characters(ch, start, length); //ch是整个xml文件的内容 if (tag != null) &#123; if("name".equals(tag))&#123; p.setName(new String(ch,start,length)); &#125; &#125; &#125;&#125; 开始解析12InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("person.xml");saxParser.parse(is,personHandler); 据说jdom和dom文档超过10M会内存溢出 Dom解析 解析器工厂 1DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); 解析器对象 1DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); 解析（把所有文件读取到内存） 12//树状结构Document parse = documentBuilder.parse(is); 从内存中读取 123456789101112131415161718192021NodeList people = parse.getElementsByTagName("Person");ArrayList&lt;Person&gt; pp = new ArrayList&lt;&gt;();Person p =null;for (int i = 0; i &lt;people.getLength() ; i++) &#123;Node person = people.item(i);p = new Person();//获取person元素的属性idp.setId(Integer.parseInt(person.getAttributes().getNamedItem("id").getNodeValue()));//获取子节点NodeList childNodes = person.getChildNodes();for (int j = 0; j &lt;childNodes.getLength() ; j++) &#123; Node child = childNodes.item(j); if ("name".equals(child.getNodeName())) &#123; p.setName(child.getTextContent()); System.out.println(child.getFirstChild()); System.out.println(child.getFirstChild().getNodeValue()); &#125;&#125;pp.add(p);System.out.println(p);&#125; JDOM 三方 不用NodeList 返回原生的Collection123456789101112131415161718SAXBuilder builder = new SAXBuilder();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document build = builder.build(is);Element root = build.getRootElement();List&lt;Person&gt; list = new ArrayList&lt;&gt;();Person p = null;List&lt;Element&gt; children = root.getChildren();for(Element e :children)&#123; p = new Person(); p.setId(Integer.parseInt(e.getAttributeValue("id"))); List&lt;Element&gt; child = e.getChildren(); for(Element ce:child)&#123; if ("name".equals(ce.getName())) &#123; p.setName(ce.getText()); &#125; &#125; list.add(p);&#125; DOM4JJAXM 和hibernate读写配置文件 都使用1234567891011121314151617181920SAXReader reader = new SAXReader();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document doc = reader.read(is);Element root = doc.getRootElement();Iterator&lt;Element&gt; iter = root.elementIterator();ArrayList&lt;Person&gt; people = new ArrayList&lt;&gt;();Person p = null;while(iter.hasNext())&#123; p = new Person(); Element next = iter.next(); p.setId(Integer.parseInt(next.attributeValue("id"))); Iterator&lt;Element&gt; childiter = next.elementIterator(); while(childiter.hasNext())&#123; Element next1 = childiter.next(); if ("name".equals(next1.getName())) &#123; p.setName(next1.getText()); &#125; &#125; people.add(p);&#125; 对象写入生成xml1.XMLEncoder 用decoder直接解析12345BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("outxml.xml"));XMLEncoder xmlEncoder = new XMLEncoder(bos);//forxmlEncoder.writeObject(p);xmlEncoder.close(); 生成1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;java version="1.8.0_144" class="java.beans.XMLDecoder"&gt; &lt;object class="javacoretest.xmljson.Person"&gt; &lt;void property="id"&gt; &lt;int&gt;3&lt;/int&gt; &lt;/void&gt; &lt;void property="name"&gt; &lt;string&gt;第三个&lt;/string&gt; &lt;/void&gt; &lt;/object&gt;&lt;/java&gt; 2.xstream 依赖包xpp312XStream xStream = new XStream(new Xpp3Driver());String xml = xStream.toXML(p); 输出：1234&lt;javacoretest.xmljson.Person&gt; &lt;name&gt;第三个&lt;/name&gt; &lt;id&gt;3&lt;/id&gt;&lt;/javacoretest.xmljson.Person&gt; 修改成Person包名，id为属性:在toXML之前加12xStream.alias("Person",Person.class);xStream.useAttributeFor(Person.class,"id"); 解析:xml是字符串xml(Person)xStream.fromXML(xml); JSON：GSON12[&#123;"id":"1","name":"小明"&#125;, &#123;"id":"2","name":"小红"&#125;] 1解析list123456789InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/people.json");InputStreamReader in = new InputStreamReader(is);JsonReader reader = new JsonReader(in);List&lt;Person&gt; list = new ArrayList&lt;&gt;();reader.beginArray();while(reader.hasNext())&#123; list.add(addobj(reader));&#125;reader.endArray(); 2解析obj123456789101112131415161718private static Person addobj(JsonReader reader) throws IOException &#123; Person p = null; //读大括号 reader.beginObject(); p = new Person(); while(reader.hasNext())&#123; String s = reader.nextName(); if ("name".equals(s)) &#123; p.setName(reader.nextString()); &#125; else if("id".equals(s))&#123; int i = reader.nextInt(); p.setId(i); &#125; &#125; reader.endObject(); return p;&#125; 直接用Gson将字符串{:}转化成类 “age”:”4”会自动映射成int12Gson gson = new Gson();list.add(gson.fromJson(reader,Person.class)); 3 生成json12345678910private static String createJson(List&lt;Person&gt; people)&#123; JsonArray array = new JsonArray(); for(Person p: people) &#123; JsonObject obj = new JsonObject(); obj.addProperty("name",p.getName()); obj.addProperty("id",p.getId()); array.add(obj); &#125; return array.toString();&#125; 直接用gson将对象转成json字符串1String s = gson.toJson(pp); 制定生成json list12345//相当于 允许运行时创建一个子列获取typeclass mytype extends TypeToken&lt;List&lt;People&gt;&gt;&#123;&#125;//new一个子类，里面什么都不写TypeToken&lt;List&lt;Person&gt;&gt; typeToken = new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;;List&lt;Person&gt; people = gson.fromJson(reader,typeToken.getType()); 用List生成list json1String pjson = gson.toJson(people,typeToken.getType()); IO文件File File.separator:winsows:”\”,linux”/“ windows换行符：System.lineSeparator().equals(&quot;\r\n&quot;) trueLinux：equals(&quot;\n&quot;) .list()列出目录下所有文件名.listFiles()返回File[].length()返回文件字节数 123Date last = new Date(f.lastModified());DateFormat df = new SimpleDateFormat();System.out.println(f.getName()+f.length()+df.format(last)); 过滤： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(".java")); 递归找文件： 展开代码 123456789101112131415 private static void findFile(File start,String file)&#123; if(start==null)return; if(start.isDirectory()) &#123; File[] list = start.listFiles(); if (list != null) &#123; for (File f : list) &#123; findFile(f,file); &#125; &#125; &#125;else&#123; if (start.getName().equals(file)) &#123; System.out.println(start.getAbsolutePath()); &#125; &#125;&#125; 字节流123456789InputStream inputStream = new FileInputStream(a);//汉字两个字节大小过小会出错byte[] bt = new byte[3];int len=-1;StringBuffer sb = new StringBuffer();while ((len=inputStream.read(bt))!=-1)&#123; //如果最后一次只读1个字节，bt[0]是新值，[1-2]是旧值，重复 sb.append(new String(bt,0,len));&#125;System.out.println(sb); InputStream 字节 ：mark() reset() 字符流顶层父类：Writer、Reader 解决不同文字编码占的字节数不同1.Reader用char[]接收1234567Reader rd = new FileReader(a);char[] buff = new char[1];StringBuffer sb = new StringBuffer();int len =-1;while((len = rd.read(buff))!=-1) &#123; sb.append(new String(buff,0,len));&#125;rd.close(); 实现： FileReader extends InputStreamReader private final StreamDecoder sd;sd.read()是一个.class LineNumberReader2.Writer append调用writeprivate char[] writeBuffer;,WRITE_BUFFER_SIZE = 1024;1.关闭流.close()、2.手动刷新、3.缓存满 之后才会把缓冲区写入文件字节流的.write()直接写3.文件复制(用字节流)12byte[] bytes = new byte[1024];int len =-1;while((len=in.read(bytes))!=-1)&#123;out.write(bytes,0,len);&#125; OutputStreamWriter Writer = InputStreamReader Reader= 4个缓冲流1.BufferedOutputStream(OutputStream)的关闭1234@SuppressWarnings("try") public void close() throws IOException &#123; try (OutputStream ostream = out) &#123; flush(); &#125; &#125; 只需要关闭外层bos的close 默认缓存大小8192 8K 使用try语法的类要实现Closeable，作用域在后面的大括号中2.BufferedReader可以readLine() 打印流PrintStream字节,PrintWriter字符添加了更多的print，只是为了遍历输出 对象流 存储到物理介质/网络传输12345678910Student st = new Student("小明",33);File store = new File("src/javacoretest/File/tryst.obj");//写try (ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(store)))&#123;oos.writeObject(st);&#125;//读try(ObjectInputStream ois = new ObjectInputStream( new FileInputStream("src/javacoretest/File/tryst.obj")))&#123; Student xiaoming = (Student) ois.readObject(); System.out.println(xiaoming);&#125; 加上serialVersionUID=1L 版本号用数组实现一组对象的存储trasient在序列化中被忽略,还原时变成默认值 字节数组流ByteArrayInputStream ByteArrayOutputStream内存操作与文件无关，每次读取一个字节，处理字符串，无需关闭从String中得到过滤出全部字母展开代码 12345678910String s = "12345dadfa(*dafAAAdaf@$#234";ByteArrayInputStream bais = new ByteArrayInputStream(s.getBytes());ByteArrayOutputStream baos = new ByteArrayOutputStream();int curr =-1;while((curr=bais.read())!=-1)&#123; if((curr&gt;=65&amp;&amp;curr&lt;=90)||curr&gt;=97&amp;&amp;curr&lt;=122)&#123; baos.write(curr); &#125;&#125;System.out.println(baos.toString()); 数据流DataInputStream DataOutputStream按java基本数据类型,与机器底层无关.writeInt(10) 对应.readXXX.wirteByte(1).writeUTF(&quot;中文&quot;) 分割文件void divide(File target,long cutSize) 123456789for (int i = 0; i &lt;n ; i++) &#123; out = new BufferedOutputStream(new FileOutputStream("src/javacoretest/File/"+(i+1)+".txt")); ... if((len = in.read(bytes))!=-1)&#123; out.write(bytes, 0, len); out.flush(); &#125; out.close();&#125; 合并文件 合并流SequenceInputStream 123456Vector&lt;InputStream&gt; v = new Vector&lt;&gt;();Eumeration es = v.elements();SequenceInputStream sis = new SequenceInputStream(es);sis.read(bytes);bos.write(bytes,0,len);bos.flash(); 字符串流StringReader StringWriterStringTokenizer流标记器1if(st.nextToken()==StreamTokenizer.TT_WORD)cnt++; 管道流 PipedInputStream.. 线程之间的数据通信pin.connect(pout); RandomAccessFile在jdk1.4中nio 被内存映射文件 替代复制文件12RandomAccessFile r = new RandomAccessFile("a.txt","r");RandomAccessFile w = new RandomAccessFile("c.txt","rw"); seek 实现文件续传 Properties 工具类 extends HashtableResourceBundle只能读取12345678910Properties p = new Properties();InputStream cfg = new FileInputStream...p.load(cfg);String name = p.getProperty("username");//放到内存中 setProperty调用的也是putp.put("passwd","dafdafa");String pw = p.getProperty("passwd");//写OutputStream out = new FileOutputStream...p.store(out,"updatatatata"); 可以通过类加载器加载1InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("src/a.p"); 清除所有的键值对p.clear(); 压缩ZipOutputStream压缩 z.putNextEntry(new ZipEntry(name));ZipEntry(String name) 创建条目解压 zIn.getNextEntry() NIO原来IO流一个字节一个字节处理。NIO块。每一种java数据类型都有缓冲区1.ByteBuffer bf = ByteBuffer.allocate(8);2.添加 bf.put((byte)10); 获取.get(index)3.偏移量：bf.position()4.缓冲区反转：bf.flip()取值的数据变成position-limit 123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 5.bf.hasRemaining()positon和limit之间有值, bf.remaining()有多少个：return limit - position;123456bf.flip()if(bf.hasRemaining())&#123; for(int i =0;i&lt;bf.remaining();i++)&#123; byte b= bf.get(i); &#125;&#125; 6.campact丢弃position及以前的数据，将position到limit的数据复制到之前，并将pisiton移到复制完的数据之后，用于写入新数据覆盖没被覆盖掉但是已经移到前面去的值，limit放到capacity上。 Channel 文件只能通过RandomAccessFile,FileInput/OutputStream的.getChannel()打开只读/只写 socket有Socket,Server,Datagram三种Channel selector是系统(native)调用select() poll()的封装注册:通道设置成非阻塞，File通道不能是非阻塞123Selector sl = Selector.open();channel.configureBolcking(false);SelectionKey = channel.register(selector,Selection.OP_READ); rigister的第二个参数监听四种不同类型：Connect，Accept，R/W可以用|位运算连接多个监听的值 返回的SelectionKey对象有4个boolean方法表示通道的就绪状态从键可以访问对应的通道和选择器： 12selectionKey.channel();selectionKey.selector(); Selecotr对象维护3个键的Set：每个键关联一个通道 12345public abstract SelectorProvider provider();//已注册的键的集合public abstract Set&lt;SelectionKey&gt; keys();//已注册中的已经准备好的集合public abstract Set&lt;SelectionKey&gt; selectedKeys(); select方法返回上次select之后就绪的通道数(增量)通过就绪key访问通道1234567891011Set selectedKeys = selector.selectedKeys();Iterator KeyIterator = selectedKeys.iterator();while(KeyIterator.hasNext)&#123; SelectionKey key = KeyIterator.next(); //四种就绪状态 if(key.isAcceptable())&#123; ... &#125; //从就绪集中移除，下次通道再就绪时再放入选择集 KeyIterator.remove();&#125; 内存缓存区1outBuf.put(inBuf.get()); Path get file.toPath() FileSystem.getDefault().getPath(“”,); Files工具类 copy move delete deleteifExists]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-Collection]]></title>
    <url>%2F2018%2F04%2F28%2Fjava-Collection%2F</url>
    <content type="text"><![CDATA[集合框架 三大接口：Iterator,Collection,Map 工具类：Collections Arrays Arrays.asListString可以12String[] ss = &#123;"da","da"&#125;;List&lt;String&gt; strings = Arrays.asList(ss); 基本数据类型不行12int[] ss = &#123;1,2&#125;;List&lt;int[]&gt; ints1 = Arrays.asList(ss); 源码：基本数据类型123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 泛型泛型方法： 类型参数放在修饰符public static后，返回类型之前 元素限定&lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems)确保Array的元素类型是AutoCloseable的子类；extends表示子类型、类型限定 多个限定T extends Runnable &amp; AutoCloseable,只能有一个限定类，放在第一个，其它都是接口 Manager是Employee子类但ArrayList&lt;Manger&gt;不是ArrayList&lt;Employee&gt;子类因为123ArrayList&lt;Manger&gt; bosses = new ArrayList&lt;&gt;();ArrayList&lt;Employee&gt; empls = bosses; //非法empls.add(new Employee(...)); //可以在管理员列里添加普通成员 如果使用数组Manger[]和Employee[] 转型是合法的，但赋值会爆ArrayStoreException 如果不对ArrayList写操作，转换是安全的。可以用子类通配符 &lt;? extends Employee&gt; staff可以传Arraylist staff.get(i)可以 可以将&lt;? extends Employee&gt;转成Employee staff.add(i)不行 不能将任何对象转成&lt;? extends Employee&gt; 父类通配符&lt;? super Employee&gt;常用于函数式对象参数（用lambda调用） 泛型类型擦除1234List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();//trueSystem.out.println(l1.getClass() == l2.getClass()); 12345List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();l2.add(1);Method madd = l2.getClass().getDeclaredMethod("add",Object.class);//[1, abc]madd.invoke(l2,"abc"); 泛型约束 类型变量不能实例化 T[] result = new T[n];错误 以【方法引用】方式提供数组的构造函数Sting[]::newIntFunction&lt;T[]&gt; constr T[] result = constr.apply(n) 反射 1234567public static &lt;T&gt; T[] repeat(int n,T obj,Class&lt;T&gt; c1)&#123;//编译器不知道类型，必须转换@SuppressWarnings("unchecked") T[] result = (T[])java.lang.reflect.Array.newInstance(c1,n);for(int i=0;i&lt;n;i++)result[i]=obj;return result;&#125; 调用String[] greetings = repeat(10,&quot;Hi&quot;,String.class); 最简单的方法12345 public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n,T obj)&#123; ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;(); for(int i =0;i&lt;n;i++) result.add(obj); return result;&#125; 泛型数组Entry&lt;String,Integer&gt;[]是合法的，但是初始化要@SuppressWarnings(“unchecked”)正确方法：ArrayList&lt;Entry&lt;String,Integer&gt;&gt; 1234//可以List&lt;Integer&gt;[] gen = (List&lt;Integer&gt;[]) new ArrayList[10];//可以 List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; guava组件 ImmutableList&lt;String&gt; ilist = ImmutableList.of(&quot;a&quot;,&quot;b&quot;);不可变List 过滤器 工具类Lists 1List&lt;String&gt; lit = Lists.newArrayList("aaa","ddd","bbb"); 1Collection&lt;String&gt; cl =Collections2.filter(lit,(e)-&gt;e.toUpperCase().startsWith("a")); 转换 (有问题)日期 12Set&lt;Long&gt; set = Sets.newHashSet(20170801L,20980320L,19950730L);Collection&lt;String&gt; col = Collections2.transform(set,(e)-&gt;new SimpleDateFormat("yyyy-MM-dd").format(e)); 组合函数Functions.compose(f1,f2) 用google的Function 集合操作 交集SetView&lt;Integer&gt; v1 = Sets.intersection(set, set2); 差集：只是1中没有在2中的元素.difference(s1,s2) 并集：把重复的只留一份 Mutiset无序可重复12345//输出[study, dayday, up, good x 2]String[] sp = s.split(" ");HashMultiset&lt;String&gt; hms = HashMultiset.create();for(String str:sp)&#123; hms.add(str);&#125; 获取次数123 Set&lt;String&gt; ele = hms.elementSet();for(String ss:ele)&#123; System.out.println(ss+":"+hms.count(ss));&#125; Multimap Key 可以重复，一个键对应一个Collection1234567891011121314151617//输出：// 作者2 [书3]// 作者1 [书2, 书1]Multimap&lt;String,String&gt; mmap = ArrayListMultimap.create();Map&lt;String,String&gt; map = new Hashtable&lt;&gt;();map.put("书1","作者1");map.put("书2","作者1");map.put("书3","作者2");Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = map.entrySet().iterator();while(iter.hasNext())&#123; Map.Entry&lt;String,String&gt; entry = iter.next(); mmap.put(entry.getValue(),entry.getKey());&#125;for(String key:mmap.keySet())&#123; Collection&lt;String&gt; value = mmap.get(key); System.out.println(key+" "+value);&#125; BiMap 双向map 键值都不能重复BiMap&lt;String,String&gt; map = HashBiMap.create();key和val可以反转map.inverse() 双键Map 行，列，值Table&lt;String,String,Integer&gt; table = HashBasedTable.create();获取条settable.cellSet() 多对多拆分成两个一对多Student和Course生成StudentAndCourse12345class StudentAndCourse&#123; private int id; private int cid;//添加在Course private int sid;//添加在Student&#125; Collections工具类排序类：针对List（set不用排序） shuffle(list)随机打乱 reverse(list) .sort()/(,Comparator c) .swap 123public static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; ArrayList: set返回旧值 123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; rotate(list,int)i移动到(i+d)%size rotate1(list, distance); : 数组实现，并且长度小于100 if (list instanceof RandomAccess ||list.size() &lt; ROTATE_THRESHOLD) leetcode的算法3展开代码 直接放在正确的位置上理解：把0位放到正确位置（distance)后，将这个位置继续当作0位，继续移动distance步，直到i回到0位1234567891011121314151617181920212223private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; distance = distance % size; if (distance &lt; 0) distance += size; if (distance == 0) return; /****以上得的了正确的distance size和distance有一个为零就不动***/ for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123; //size = 5 T displaced = list.get(cycleStart);//1.得到[0] int i = cycleStart; do &#123; i += distance; //向前走3步 if (i &gt;= size) i -= size;//对长度取模 displaced = list.set(i, displaced);//2.赋值给[3],得到[3]的值 nMoved ++;//3.每位放一次一共执行size次同时退出for循环 &#125; while (i != cycleStart); &#125; &#125; 123reverse(list.subList(0, mid));reverse(list.subList(mid, size));reverse(list); 查找 binarySearch,max,min(遍历compare/compareTo) fill(List,o)填充 （遍历调用set） frequency(c,o)c中与o相等元素数量（遍历equals) replaceAll(list,old,new)遍历equals，set 同步重建，加上代码块的锁只有vector/hashtable比较古老是安全的 synchronizedList(list)… 设置不可变的集合emptyXXX,singletonXXX,unmodifiableXXX EmptyList防空指针 UnmodifiableCollection重写了add、remove等方法，直接抛异常 singletonMapsize=1 其它 disjoint(,)没有相同元素返回true addAll(c,T...)全部加入c reverseOrder(Comparator&lt;T&gt; cmp)返回比较器12//反转排序[5, 4, 3, 2, 1] Collections.sort(list,Collections.reverseOrder()); Optional创建： of工厂方法Optional.of(&quot;abb&quot;); ofNullable:如果为空返回empty()空的optionalOptional.ofNullable(&quot;abb&quot;); .empty() isPresent.. Iterator ListIterator Enumeration Vector使用public Enumeration&lt;E&gt; elements()1234Enumeration&lt;Integer&gt; es = v.elements();while(es.hasMoreElements())&#123; System.out.println(es.nextElement());&#125; 迭代器设计模式1.迭代器接口 2.迭代器的实现（用构造函数传入（3））3.抽象类 4.具体类（return new迭代器） forEach jdk1.8 ArrayList:public void forEach(Consumer&lt;? super E&gt; action) Consumer接口：void accept(T t); 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Map 键值setSet&lt;Map.Entry&lt;Integer,String&gt;&gt; enry = map.entrySet(); 值Collection&lt;String&gt; cl = map.values(); forEach(BiConsumer&lt;? super K, ? super V&gt; action) 权限查询.containsKey() Map接口中的新方法 getOrDefault(Object key, V defaultValue)不存在返回默认值 1return (((v = get(key)) != null) || containsKey(key))? v: defaultValue; V putIfAbsent(K key, V value)不覆盖添加 原本的put覆盖并返回旧值 12V v = get(key);if (v == null) &#123;v = put(key, value);&#125; boolean remove(Object key, Object value)保证key和val都有 1234567 Object curValue = get(key);if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false;&#125;remove(key);return true; boolean replace(K key, V oldValue, V newValue) V compute对key位置上的kv对用BiFunction最后更新并返回计算后的值put(key, newValue); 12map.compute(1,(k,v)-&gt;v+="1");map.computeIfAbsent(5,(k)-&gt;"空空空"); merge 1map.merge(1,"222",(oldv,newv)-&gt;oldv+newv); TreeMapHashMap 数组+链表+（链表长度达到8，会转化成红黑树） Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distributionwith a parameter of about 0.5 on average for the default resizingthreshold of 0.75,负载因子0.75的清空下，bin满足泊松分布(exp(-0.5) * pow(0.5, k) /factorial(k)).落在0的桶的概率有0.6 用树存储冲突hash when bins contain enough nodes to warrant useTREEIFY_THRESHOLD = 8; 计算hash值 【扰动函数】1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 实验：12345678910111213141516171819202122int a = (65535&lt;&lt;2)+1;//262141 111111111111111101System.out.println(a+" "+Integer.toBinaryString(a));//32是表长int hash=a^(a&gt;&gt;&gt;16);//输出：11 反转最后两位 //扰动(如果&gt;65536，右移16位) //低16与高16位`^`,混合hash的高位低位System.out.println(Integer.toBinaryString(a&gt;&gt;&gt;16));int index = (32-1)&amp;hash;/*11111111111111111011111//只取了低位-------------11110-&gt;30*/System.out.println(Integer.toBinaryString(hash));System.out.println(Integer.toBinaryString(31));System.out.println("-------------");System.out.println(Integer.toBinaryString(index));//262142 30System.out.println(hash+" "+index); put(K key, V value) {return putVal(hash(key), key putVal 123n = (tab = resize()).length;if ((p = tab[i = (n - 1) &amp; hash]) == null)//n=length=16 tab[i] = newNode(hash, key, value, null); putVal如果Node链表太长 12if (binCount &gt;= TREEIFY_THRESHOLD - 1) //TREEIFY_THRESHOLD==8 treeifyBin(tab, hash);//变成红黑树 TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;65536(2^16)&gt;&gt;&gt;16 ==1 table uses power-of-two masking 为了用&amp;2^n-1取模 2^n的table长不是素数很容易冲突 *spreads the impact of higher bits downward int类型自带hashCode范围-2147483648到2147483648 i = (n - 1) &amp; hash 插入位置 n-1=15是1111低位掩码高位归零 int长32&gt;&gt;&gt;16是int的高16位，低16与高16位^,混合hash的高位低位key1=0ABC0000 &amp; (16-1) = 0（8个16进制数，共32位）key2=0DEF0000 &amp; (16-1) = 0hashcode的1位全集中在前16位。key相差很大的pair，却存放在了同一个链表把hashcode的“1位”变得“松散”，比如，经过hash函数处理后，0ABC0000变为A02188B，0DEF0000变为D2AFC70 Hashtable 数组加链表没用二叉树数据结构一样的名字不同：hashtable:private transient Entry&lt;?,?&gt;[] table; 默认大小11hashmap: transient Node&lt;K,V&gt;[] table; LinkedHashMap 双重链表set String、Path都有很好的hash函数 顺序遍历集合TreeSet实现了SortedSet和NavigableSet接口 set的元素必须实现Comparable接口或者构造函数中有Comparator HashSet HashMap实现,用空对象占位 12345private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 保持不重复 使用HashMap的 putVal 比较hashCode相同不一定是同一个对象，再比较equals 重写放入hash的类的hashCode： LinkedHashSet 用链表记录插入的位置TreeSet 排序 需要实现Comparatable或传入Comparator，会根据compare的值覆盖，去重 NavigableSet使用元素自然顺序排序，or 用Comparator]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2018%2F04%2F23%2FJVM%2F</url>
    <content type="text"><![CDATA[27个点 内存占20G堆内存-Xmx12mhttps://www.jianshu.com/p/1b1c998c4448 jstackhttps://toutiao.io/posts/1ogbep/preview打印所有工作线程 包括析构Finalizer，JIT还有debug的线程状态有6个 javap 字节码指令12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 JVM是基于栈的架构：指令短，指令数多一般x86是基于寄存器的架构：指令长，指令集小 bytecode-viewerjava -XX:MaxHeapSize=734003200 -jar .\Bytecode-Viewer-2.9.11.jar jclasslib bytecode viewer jstat 查看类加载/GC/JIT编译信息jstat官网 jinfo 查看运行中的jvm参数123&gt;jinfo -flag MaxHeapSize 1972-XX:MaxHeapSize=734003200&gt;jinfo -flag ThreadStackSize &lt;进程号&gt; 打印进程Non-default参数（被赋值过的）1&gt;jinfo -flags 1972 展开代码 123456Attaching to process ID 1972, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.144-b01Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=132120576 -XX:MaxHeapSize=734003200 -XX:MaxNewSize=244318208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44040192 -XX:OldSize=88080384 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCCommand line: -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs="" -Djdt.compiler.useSingleThread=true -Dpreload.project.path=D:/demo/algLearn -Dpreload.config.path=C:/Users/cecil/.IntelliJIdea2017.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true -Dio.netty.initialSeedUniquifier=1077334432047011613 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2017.2 -Didea.home.path=C:\Program Files\JetBrains\IntelliJ IDEA 2017.2.5 -Didea.config.path=C:\Users\cecil\.IntelliJIdea2017.2\config -Didea.plugins.path=C:\Users\cecil\.IntelliJIdea2017.2\config\plugins -Djps.log.dir=C:/Users/cecil/.IntelliJIdea2017.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/JetBrains/IntelliJ IDEA 2017.2.5/jre64 -Djps.fallback.jdk.version=1.8.0_152-release -Dio.netty.noUnsafe=true -Djava.io.tmpdir=C:/Users/cecil/.IntelliJIdea2017.2/system/compile-server/alglearn_d660bc04/_temp_ -Djps.backward.ref.index.builder=true -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.client.alive.path="C:\Users\cecil\AppData\Local\Temp\kotlin-idea-4845382868272217760-is-running" jpsjps官网1234jps -l5392 sun.tools.jps.Jps1972 org.jetbrains.jps.cmdline.Launcher6500 JVM参数1.java -help XX参数(JVM调优和Debug) Boolean类型格式：-XX:[+-]&lt;name&gt; 启用或禁用name属性启用CMS垃圾回收器-XX:+UseConcMarkSweepGC启用G1垃圾回收器-XX:+UseG1GC 非boolean kv类型格式：-XX:&lt;name&gt;=&lt;value&gt;GC最大停顿时间-XX:MaxGCPauseMillis=500 -Xmx -Xms-Xms等价于-XX:InitialHeapSize-Xmx等价于-XX:MaxHeapSize-Xss线程堆栈大小 X参数（非标准化参数）各个版本可能会变 不常用java代码是解释执行的，JIT编译信息 即时编译 java代码转化成本地代码-Xint 完全解释执行（不转换成本地代码-Xcomp 第一次就编译成本地代码-Xmixed 混合模式JVM自己决定是否本地代码mixed mode:1234java -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode) 解释模式：1234java -Xint -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, interpreted mode) 编译模式：1234java -Xcomp -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, compiled mode) 堆外内存64位的JVM 寻址空间类装载器12345678910/* 只有jvm能创建 * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */private Class(ClassLoader loader) &#123; // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; &#125; 装载：（磁盘-&gt;内存）1）取得类的二进制流：装载器ClassLoader 读入java字节码装在到JVM2）放到方法区3）在堆中生成java.lang.Class对象 封装方法区的数据结构 链接：1.验证 符合jvm对字节码的要求2.准备 为static final静态变量 分配内存，并初始化默认值。(还没生成对象)3.解析 符号引用转换成指针or地址偏移量（直接引用）（内存中的位置） 初始化：静态变量赋值（用户赋值）&lt;clint&gt; lang.NoSuchFiledError 最终结果是堆区的class对象，提供了访问方法区的接口（反射接口） 主动使用6种1.创建类实例2.读写静态变量3.调用静态方法4.反射Class.forName 5.初始化类的子类 6.启动类其它都是被动使用，都不会类初始化 jvm用软件模拟java字节码的指令集jvm规范定义了：returnAddress数据类型 指向操作码的指针;输出整数的二进制123456789public static void main(String[] args) &#123; int a = 6; //0x80000000表示最高位为1的数字 for(int i =0;i&lt;32;i++)&#123; //取出a的第一位 //无符号右移( &gt;&gt;&gt; ) int t = (a&amp;0x80000000&gt;&gt;&gt;i)&gt;&gt;&gt;(31-i); System.out.print(t); &#125; &#125; public native String intern();运行期间放入常量池]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2018%2F04%2F23%2Fcpp%2F</url>
    <content type="text"><![CDATA[emplace_back()和push_back()emplace_back()更节省空间边集&lt;u,v,cost&gt;-&gt;邻接表1234unordered_map&lt;int,vector&lt;pair&lt;int,int&gt; &gt; &gt; g_;for(const auto&amp; e: flights)&#123; g_[e[0]].emplace_back(e[1],e[2]);&#125; 大端小端union的存放顺序是所有成员都从低地址开始存放一般操作系统都是小端，而通讯协议是大端的。常见文件的字节序1234567Adobe PS – Big EndianBMP – Little EndianDXF(AutoCAD) – VariableGIF – Little EndianJPEG – Big EndianMacPaint – Big EndianRTF – Little Endian 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;bool IsBigEndian2()&#123; union NUM &#123; //低地址 int a; char b; &#125;num; num.a = 0x1234; if( num.b == 0x12 ) &#123; return true; &#125; return false;&#125;bool IsBigEndian()&#123; //8bit的char int a = 0x1234; //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分 char b = *(char *)&amp;a; if( b == 0x12) &#123; std::cout&lt;&lt;b; return true; &#125; return false;&#125; #include&lt;pthread.h&gt;https://sourceware.org/pthreads-win32/pthreads-w32-2-9-1-release.zipinclude:C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\includelib:C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\libdll:x86C:\Windows\SysWOW64dll:x64C:\Windows\System3212#include &lt;pthread.h&gt;#pragma comment(lib,"pthreadVC2.lib") 编译错误C2011 “timespec”:“struct”类型重定义可修改pthread.h文件，在1234#if !defined( PTHREAD_H )#define PTHREAD_H下面加上一行宏定义#define HAVE_STRUCT_TIMESPEC 可以解决“timespec”:“struct”类型重定义错误 1 4 00 10 15 2010 0 35 2515 35 0 3020 25 30 0并行tsp12345678910111213141516171819202122232425262728293031323334353637383940```### MS-MPIhttps://blog.csdn.net/u011514451/article/details/50675222编译期常量constexpr### static_cast强制类型转换### 拓扑排序![topu](/images/topu.jpg)### 树结构review树结构是为了对vector(数组)和list(链表)的静态操作(search)和动态操作(insert,remove)效率的平衡。1. 任何树，边数(e)=所有顶点度数之和=顶点总数(n)-1 意义：边数与顶点数是同阶的O(n)可以拿顶点数做复杂度的参照2. 路径长度复杂度以边数定义会简化算法描述3. 数和无环和连通的关系：1.无环连通图，2.极小连通图，3.极大无环图 结论：1.任一节点v与【根】存在【唯一】路径，记作path(v)4. 路径(path (from root) to v)、节点、子树(subtree (rooted at) v)是等价类，互相指代 结论：v的深度:depth(v)=|path(v)| 树根深度为0 树是半线性结构：前驱(父节点)是唯一的，后继不唯一，图则都不唯一。 叶子节点中深度最大的为(子)树的高度$height(v) + depth(v) &lt;= height(T)$,单个节点高度为0，空树高度为-1。#### 树存储结构1.`rank[n],data[n],parent[n]`,空间O(n) 时间： 1. 访问父节点`parent()` O(1) 2. `root()`一直沿着`parent[]`到-1 O(n),可以将根放在`rank[0]`变成O(1) 3. 但是找长子O(n)遍历`rank[i]`的parent 兄弟节点也是O(n)2. 将`parent[]`变成指针`child[n]`，指向子节点，子节点的查找效率是度数，但是查找parent变成O(n)3. 保留parent[n]也添加child[n]保证了parent和child的查找速度，但是child指向的list可能是O(n)4. 儿子兄弟法 可以用二叉树表示所有的树#### 二叉树1. 每一层$2^k$个节点2. 树的节点数 $h&lt; n&lt;2^&#123;h+1&#125;$3. 为简化算法思考，为叶子节点加上2个子节点(null)，将每个节点补齐度为2 BinNode:lchild parent rchild dataheight npl(左氏堆) colorsize12345671. 插入左/右孩子```cpp//data和父节点template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;:: insertAsRC(T const &amp;e)&#123; return lchild = new BinNode(e,this);&#125;return rchild = new BinNode(e,this); 计算后代数量O(n) 1234567template &lt;typename T&gt;int BinNode&lt;T&gt;:: size()&#123; int s = 1;//本身 if(lChild) s+=lChild.size(); if(rChild) s+=rChild.size(); return s;&#125; BinTree模板类 1234567891011121314template &lt;typename T&gt; class BinTree&#123; protected: int _size; //树根节点的位置 BinNodePosi(T) _root; //各种二叉树对高度的定义和更新的方法不同 virtual int updateHeight(BinNodePosi(T) x); //更新了一个节点之后更新所有祖先的高度 void updateHeightAbove(BinNodePosi(T) x); public: int size() const &#123;return _size;&#125;//规模 bool empty() const &#123;return !_root;&#125;//判空 BinNodePosi(T) root() const &#123;return _root;&#125;//树根&#125; 高度更新(最深叶节点path) 12345//使用宏定义 空树 h=-1#define stature(p) ((p)?(p)-&gt;height:-1);int BinTree&lt;T&gt; ::updateHeight(BinNodePosi(T) x)&#123; return x-&gt;height = 1+max(stature(x-&gt;lChild),stature(x-&gt;rChild));&#125; 更新了x节点的高度，x的父节点们的高度也高更新O(n=depth(x)) 123456template&lt;typename T&gt;void BinTree&lt;T&gt;:: updateHeightAbove(BinNodePosi(T) x)&#123; while(x)&#123; updateHeight(x);x= x-&gt;parent; &#125;&#125; 节点插入 1234567template &lt;typename T&gt; BinNodePosi(T)BinTree&lt;T&gt; ::insertAsRC(BinNodePosi(T) x,T const &amp;e)&#123; _size++; x-&gt;insertAsRC(e); updateHeightAbove(x); return x-&gt;rChild;&#125; 6. 先序遍历$T(n) =O(1)+T(a)+T(n-a-1) =O(n)$问题是每个递归帧虽然是O(1)但是每个帧差很大，而且是尾递归能用栈优化1234567template &lt;typename T,typename VST&gt;void traverse(BinNodePosi(T) x,VST &amp;visit)&#123; if(!x)return; visit(x-&gt;data); traverse(x-&gt;lChild,visit); traverse(x-&gt;rChild,visit);&#125; 迭代版本1：1234567891011template &lt;typename T,typename VST&gt;void traPre_v1(BinNodePosi(T) x,VST &amp; visit)&#123; //存放位置（引用） Stack&lt;BinNodePosi(T)&gt; s; if(x)s.push(x); while(!s.empty())&#123; x = s.pop();visit(x-&gt;data); if(HasRChild(*x))s.push(x-&gt;rChild); if(HasLChild(*x))s.push(x-&gt;lChild); &#125;&#125; 先放入栈右子树再入栈左子树。不能推广到中序、后序遍历12345while(!s.empty())&#123; x=s.pop();visit(x); if(root.right!=null)stack.push(root.right); if(root.left!=null) stack.push(root.left);&#125; 迭代版本2： 沿着左孩子下行，到左侧空了之后向上遍历刚才没访问的右子树12345678910111213template &lt;typename T,typename VST&gt;static void visitAlongLeftBranch( BinNodePosi(T) x, VST &amp; visit, Stack &lt;BinNodePosi(T)&gt; &amp;s)&#123; //3.pop出的x是null while(x)&#123; visit(x-&gt;data); //1. 如果x是叶子，右节点是null也push了 s.push(x-&gt;rChild); x=x-&gt;lChild; &#125;&#125; 主算法1234567891011template &lt;typename T,typename VST&gt;void trapRE_v2(BinNodePosi(T) x,VST&amp; visit)&#123; Stack &lt;BinNodePosi(T)&gt; S; while(true)&#123; visitAlongLeftBranch(x,visit,S); if(s.empty())break; //进入了以x为根节点的子树 //2. x是叶子节点右指针null x = s.pop(); &#125;&#125; 中序遍历O(n)1.不是尾递归2.一直向左，到左边没有了visit，再访问右子树，回到原来左链上的上个节点访问并继续右子树左侧链上的每个节点是一个阶段，都是相同的，上一个节点访问的时候可以当下一个节点不存在将所有左节点入栈，最后弹出访问并访问右子树12345678910111213141516171819template &lt;typename T&gt;static void goAlongLeftBranch(BinNodePosi(T) x,Stack &lt;BinNodePosi(T)&gt; &amp;S)&#123; //O(n)但是所有左侧链的长度合在一起也是O(n) 每个节点只入栈一次 while(x)&#123;S.push(x);x=x-&gt;lChild;&#125;&#125;template &lt;typename T,typename V&gt; void traIn_v2(BinNodePosi(T) x,V&amp; visit)&#123; Stack &lt;BinNodePosi(T)&gt; S; while(true)&#123; goAlongLeftBranch(x,S); if(S.empty())break; //x的左子树为空 x = S.pop(); //O(n) visit(x-&gt;data); //进入右子树分支 x = x-&gt;rChild; &#125;&#125; 层次遍历12345678910111213template &lt;typename T&gt; template &lt;typename Vst &gt;void BinNode&lt;T&gt;::travLevel(VST &amp; visit)&#123; Queue&lt;BinNodePosi(T)&gt; Q; //根 Q.enqueue(this); while(!Q.empty())&#123; BinNodePosi(T) x = Q.dequeue(); visit(x-&gt;data); //先进先出 if(HasLChild(*x)) Q.enqueue(x-&gt;lChild); if(HasRChild(*x)) Q.enqueue(x-&gt;rChild); &#125;&#125; [先序|后序]+中序可以还原唯一的二叉树先序[r][L][R]中序[L][r][R]左右子树为空不会有歧义 而先序和后序无法分别到底是左子树还是右子树先序 [r][L] 右空 [r][R] 左空后序 [L][r] 右空 [R][r] 左空 每个节点的度是0或2的真二叉树可以由先序，后序还原。左右子树同时为空/非空 图 简单路径：不含重复顶点 欧拉图：一笔画 所有边经过所有顶点、所有边的闭路径（边不重复，允许顶点重复） 欧拉路径：经过所有顶点，所有边的路径（边不重复，顶点重复） 不是闭路径（不需要回到原地）。 欧拉图判定条件：无向图：G是连通的，所有顶点的度都是偶数。有向图：G弱连通，每个顶点的出度和入度相等 欧拉路径判定条件：无向图：G连通，恰有两个顶点的度是奇数。从一个奇数顶点出发，到另一个奇数度顶点结束。有向图：G连通，恰两个顶点出度入度不相等，其实于出度多1的终结与入度多1的。 哈密顿图 所有顶点一条经过所有顶点的回路（不要求经过所有边） 哈密顿通路：经过所有顶点的通路，不要求回路 充分条件：满足： 是哈密顿图 resigter 寄存器变量存放在寄存器中，调用时直接从寄存器中取出参加运算。 对象像指针*,-&gt;智能指针 包装类修改指针的行为 像一个指针-&gt;会对作用到的结果一直作用下去operator*() operator -&gt; () 写法固定 迭代器 包括智能指针，++,–对象像函数()转换函数当编译器遇到要把该类转换成double类型时，调用double explicit 用在构造函数前non-explicit-one-argument 可以把4转换成fraction用了explicit不能自动调用构造函数转型 委托：delegation,空心菱形表示有。又称Composition by reference 生命周期不同步 handle/body(impl)组合：实心菱形 生命周期同步组合是part在内，继承是base在内 cpp继承有三种 java只有public不用写继承的base class的构造函数必须是virtual不然西沟就不会先子类再base1struct ListNode:public _list_node_base&#123;&#125;; 虚函数成员函数有3种12345678class Shap&#123;//纯虚函数 所有子类必须重新定义virtual void draw() const = 0;//可以重新定义virtual void error(const std::string&amp; msg);//不让子类overrideint objId() const;&#125;; delegation+继承组合模式（文件/文件夹）原型模式，继承框架类，将自己定义的新类加入框架让框架调用 静态方法要在类外给内存 .h头文件写法conplex.h1234#ifndef __COMPLEX__#define __COMPLEX__...#endif 语法制导翻译：类型检查/中间代码生成向文法的产生式附加一些规则（或程序片段）语法分析过程时相应的程序片段会被执行。在语法分析的过程中结合语义动作。 语法指导定义 上下文无关文法和属性及规则集合。规则：语义规则 和产生式相关联。属性与文法相关联 splice emplace_front map:find找到第一个相等的元素 iterator :.cend()容器最后面 把vector中的一个元素移动到最前面 12//it-&gt;second map中的值，指向结点的指针list.splice(list.begin(),list,it-&gt;second); 查找vector中的最大最小元素*max_element(first,end) multiset和set在c++里是有序的，是红黑树，用*set.rbegin()可以获得最大值.erase()会遍历删除所有相同的元素，.equal_range()限定范围 123456multiset&lt;int&gt; s;s.insert(5);s.insert(5);s.insert(5);//只删除了第一个5s.erase(s.equal_range(5).first); c++ 的deque：用指针取头尾的连续存储 advance(it,5)将迭代器移动5次，迭代器*it指向第6个元素 dummy标记[0]元素?????? vector1.swap(v2) 与另一个vector交换数据 unordered_set 拉链法hash表 #include读 hash-include ; 读semicolon auto 类型由编译器自动推断 explicit 禁止隐式转换 成员初始化列表语法 继承关系： 共有继承：is a == is a kind of关系不可逆 香蕉是一种水果，水果不是香蕉 has a 午餐包括水果 is like a 律师像鲨鱼 is implemented as a 栈用数组实现 uses a 计算机可以使用打印机使用友元通信 多态：派生类使用基类的方法；方法行为随上下文，取决于调用该方法的对象。 在派生类中重新定义基类方法 虚方法:根据引用/指针指向的对象 的类型选择方法.派生类回重新定义的方法，在基类中应为虚的。 派生通过 作用域解析运算符 调用基类方法 虚函数原理： 每个对象由隐藏成员，是虚函数表（virtual function table） _vtbl,所有虚函数的地址表 例程 fprintf]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVVM]]></title>
    <url>%2F2018%2F04%2F19%2FMVVM%2F</url>
    <content type="text"><![CDATA[实现myvue.b=222页面刷新 1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234let myvue = new myVue(&#123; el:'#app', data:&#123;a:&#123;a:&#123;a:1&#125;&#125;,b:'aaaaaaaaaaa'&#125; &#125;); 12345678910111213141516171819function myVue(options=&#123;&#125;) &#123;//传入的对象（&#123;el:,data:&#125; //将所有属性挂载在$opthion this.$options = options var data = this._data=this.$options.data //用data别名._data observe(data)//-----------&gt;数据劫持 for(let key in data)&#123; //--&gt; this代理了this._data Object.defineProperty(this,key,&#123; enumerable:true, get()&#123; return this._data[key]//this.a=&#123;a:1&#125; &#125;, set(newVal)&#123; this._data[key]=newVal &#125; &#125;) &#125; ///-------渲染 new Compile(options.el,this)&#125; 数据劫持（观察者）对_data定义get/set属性 123456789101112131415161718192021222324252627282930function Observer(data) &#123; for(let key in data)&#123; // let dep = new Dep() let val = data[key] observe(val)//递归 Object.defineProperty(data,key,&#123; enumerable:true, get() &#123; // -- watcher里的this //只有target绑定了this(Watcher函数) 才把watcher函数放入dep队列 Dep.target&amp;&amp;dep.addSub(Dep.target) return val; &#125;, set(newVal)&#123; if(newVal===val)return val=newVal //----深度数据劫持myvue.a=&#123;a:1&#125; 里面的a也有get/set observe(newVal) // dep.notify() &#125; &#125;) &#125;&#125;//观察对象，给对象添加define...function observe(data) &#123; if(typeof data !== 'object')return //为方便递归 return new Observer(data)&#125; 渲染 123456789101112131415161718192021222324252627282930313233343536function Compile(el,vm) &#123; vm.$el=document.querySelector(el); //创建文档碎片 let fragment = document.createDocumentFragment(); // console.log(vm.$el.firstChild) //移到内存中 while(child = vm.$el.firstChild)&#123; fragment.appendChild(child) &#125; replace(fragment) function replace(fragment) &#123; //从DOM元素节点集合返回一个数组 Array.from(fragment.childNodes).forEach(function (item) &#123; let text = item.textContent let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/ //nodeType=3文本节点 if(item.nodeType===3&amp;&amp;reg.test(text))&#123; //获取匹配的第一个分组 //是标签 nodeType=1 let arr = RegExp.$1.split('.')//[a.a] let val = vm//----&gt;vm=myvue arr.forEach(function (k) &#123;//val=vm[a]-&gt;val=vm[a][a] val = val[k] &#125;) // //----------- 监听替换位置 // new Watcher(vm,RegExp.$1,function (newVal) &#123; // item.textContent = text.replace(reg,newVal) // &#125;) item.textContent = text.replace(reg,val)&#125; if(item.childNodes)&#123; replace(item) &#125; &#125;) &#125;&#125; 订阅器：接受更新重新渲染 订阅器[fn1,fn2]方法集合 1function Dep() &#123;this.subs =[]&#125; 订阅器添加方法、订阅器中方法全部执行(约定订阅”update方法”) 1234567Dep.prototype.addSub= function (sub) &#123; this.subs.push(sub)&#125;//假设每个方法里都有update方法 遍历激活Dep.prototype.notify= function () &#123; this.subs.forEach(sub=&gt;sub.update())&#125; 订阅者（Dep数组中的方法类，被激活的方法类) 在观察者Observer中注册let dep = new Dep() 订阅事件在渲染Compile中 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) 定义watcher并添加到订阅中 12345678910111213 function Watcher(vm,exp,fn) &#123; this.fn = fn this.vm= vm this.exp = exp Dep.target = this; let val = vm; let arr = exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) Dep.target=null&#125; 调用get方法更新时添加Dep.target&amp;&amp;dep.addSub(Dep.target) 在set中执行订阅器中所有watcher的方法dep.notify() 12345678910 Watcher.prototype.update=function () &#123; //取最新的值 let val = this.vm let arr = this.exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) //将新值传给回调函数 this.fn(val)&#125; this.fn(val)回调函数会回到渲染中,用新值替换 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) ====效果：1.myvue.b放入队列2.myvue.b=222先调用set，调用notify3.执行watcher的update4.回调函数fn更新页面 实现v-model 双向数据绑定1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;input type = "text" v-model="b"&gt;&lt;/div&gt; 找到带v-的元素并获得v-model绑定的属性；在渲染中添加监听器；并添加触发事件12345678910111213141516171819202122if(item.nodeType==1)&#123; //如果是元素节点 获取所有dom属性 let nodeAttrs = item.attributes; Array.from(nodeAttrs).forEach(function (attr) &#123; //获取v-model后的属性 //b if(attr.name.indexOf('v-')==0)&#123; let exp = attr.value //初始输入框填值 item.value = vm[exp] //订阅每次更改都更新 new Watcher(vm,exp,function (newVal) &#123; item.value = newVal &#125;) //定义触发事件 item.addEventListener('input',function (e) &#123; console.error(e) let newVal = e.target.value vm[exp] = newVal//调用set方法-&gt;notify-&gt;更新watcher &#125;) &#125; &#125;) &#125; 实现computed的缓存 绑数据挂到vm上1&lt;div&gt;&#123;&#123;hello&#125;&#125;&lt;div&gt; 12345computed:&#123; hello()&#123; return this.b+this.a &#125; &#125; 1234function myVue(options=&#123;&#125;) &#123; ... initComputed.call(this)&#125; 12]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[About-js]]></title>
    <url>%2F2018%2F04%2F17%2FAbout-js%2F</url>
    <content type="text"><![CDATA[手机端查看页面npm install http-server -ghttp-server prototypehttp://prototypejs.org/learn/event-delegation.html js unicode-&gt;中文1unescape(''); h5视频控制到指定位置并播放12345var v = document.getElementsByTagName("video")[0];v.currentTime = 10.0;v.play()//暂停v.pause() html5存储Content-Length 单位是字节DnionOS nginx？ cookie 4kdocument.cookiecookies会有主域名污染在.baidu.com放了cookie之后music子域名访问都带主域名的cookies，请求头会臃肿http-only cookie只能被服务器端读写，客户端无权限。Secure 请求只能是https 单个域名持支的cookie个数。chrome50个，长度4k与localStorage类似 不同域名独立。可以设置cookie的path和domain相同父域共享 H5之前userData 只有IE，存放成XMLindexedDB 按域名分配独立空间，一个域名多个数据库H5离线缓存 manifestnavigator.onLine检测是否在线1&lt;html lang = "en" manifest = 'manifestFile'&gt; manifestFile文件12345CACHE MANIFEST#version 1.1CACHE: img/1.jpgNETWORK 123456789window.addEventListener('load',function(e)&#123; window.applicationCache.addEventListener('updateready',function(e)&#123; if(window.applicationCache.status == window.applicationCache.UPDATEREADY)&#123; window.applicationCache.swapCache() if(confirm("是否更新页面")) window.location.reload() &#125; &#125;,fasle)&#125;,false) 改manifest版本号会更新 本地存储 子域名不能共享 h5 postMessage 共享数据 只有5个api：setItem/getItem/removeItem/clear/keyios的隐身模式没有，需要检测浏览器支持，最好的方法是先set一次1234localStorage.setItem('testkey','testvalue')localStorage.getItem('testkey')localStorage.key(9)localStorage.clear() localstorage 永不过期sessionstorage 重新打开页面/关闭浏览器 消失 每个 域名5MlocalStroage在chrome限制为2.6M 同域名一般共享 所有可以序列化的都能存到localStorage 存图片set(&#39;key&#39;)+get(&#39;key&#39;)展开代码 1234567891011121314151617181920212223242526var src = "./bd_logo1.png"function set(key)&#123; var img = document.createElement('img') img.addEventListener('load',function () &#123; var imgCanvas = document.createElement("canvas"), imgContext = imgCanvas.getContext("2d"); imgCanvas.width = this.width; imgCanvas.height = this.height; imgContext.drawImage(this,0,0,this.width,this.width); //base64 url图片 var imgAsDataUrl = imgCanvas.toDataURL("image/png") try&#123; localStorage.setItem(key,imgAsDataUrl) &#125; catch(e)&#123; console.log("storage failed"+e) &#125;&#125;,false); img.src = src;&#125;function get(key) &#123; var srcStr =localStorage.getItem(key) var imgObj = document.createElement('img') imgObj.src = srcStr document.body.appendChild(imgObj)&#125; 业务代码添加过期控制set(&#39;wait4expire&#39;,&#39;expire&#39;),get(&#39;wait4expire&#39;,60*5*1000)12345678910111213function set(key,v)&#123; var curTime = new Date().getTime() localStorage.setItem(key,JSON.stringify(&#123;data:v,time:curTime&#125;))&#125;function get(key,exp) &#123; var data = localStorage.getItem(key) var dataObj = JSON.parse(data) if(new Date().getTime() - dataObj.time &gt; exp)&#123; console.log("expires") &#125;else&#123; console.log("data = "+dataObj.data) &#125;&#125; HTTP文件缓存Application-FramesEtag响应/if-Node-Match请求同时设置Expire和Cache-Control只有Cache-Control生效 浏览器缓存https://segmentfault.com/a/1190000009638800 Connectionhttps://imququ.com/post/transfer-encoding-header-in-http.htmlHTTP/1.0 的持久连接机制是后来才引入的，通过 Connection: keep-alive 这个头部来实现，服务端和客户端都可以使用它告诉对方在发送完数据之后不需要断开 TCP 连接，以备后用。HTTP/1.1 则规定所有连接都必须是持久的，除非显式地在头部加上 Connection: close。所以实际上，HTTP/1.1 中 Connection 这个头部字段已经没有 keep-alive 这个取值了，但由于历史原因，很多 Web Server 和浏览器，还是保留着给 HTTP/1.1 长连接发送 Connection: keep-alive 的习惯。 浏览器可以通过 Content-Length 的长度信息，判断出响应实体已结束。那如果 Content-Length 和实体实际长度不一致会怎样？有兴趣的同学可以自己试试，通常如果 Content-Length 比实际长度短，会造成内容被截断；如果比实体内容长，会造成 pending。 TTFB（Time To First Byte），它代表的是从客户端发出请求到收到响应的第一个字节所花费的时间。 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\r\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。12345678910111213141516require('net').createServer(function(sock) &#123; sock.on('data', function(data) &#123; sock.write('HTTP/1.1 200 OK\r\n'); sock.write('Transfer-Encoding: chunked\r\n'); sock.write('\r\n'); sock.write('b\r\n'); sock.write('01234567890\r\n'); sock.write('5\r\n'); sock.write('12345\r\n'); sock.write('0\r\n'); sock.write('\r\n'); &#125;);&#125;).listen(9090, '127.0.0.1'); webworkers《高性能网站建设进阶指南》https://www.html5rocks.com/en/tutorials/workers/basics/123456789101112131415161718 var worker = new Worker("./worker.js") console.log("主线程主线程主线程主线程1")//1 worker.addEventListener("message",function(e)&#123; console.log("主线程主线程主线程主线程2")//8 console.log("worker said",e.data)//9 console.log("主线程主线程主线程主线程3")//10 &#125;,false) console.log("主线程主线程主线程主线程4")//2 worker.postMessage("hello world"); console.log("主线程主线程主线程主线程5")//3//worker.jsconsole.log("子线程0")//4self.addEventListener("message",function(e)&#123; console.log("子线程1")//6 self.postMessage(e.data) console.log("子线程2")//7&#125;,false)console.log("子线程3")//5 fisher-yates 洗牌 shuffle the deck first to randomize the order and insure a fair gameO(n) 1234567891011function shuffle(array)&#123; var m = array.length,t,i; while(m)&#123; //99...0 i = Math.floor(Math.random()*m--); t = array[m]; array[m] = array[i]; array[i] = t; &#125; return array;&#125; 测试shuff如果5x2一共10个格，雷5个，则出现的概率应该都是0.51234567891011121314151617181920212223function testshuff (N,n,m,num)&#123; var freq = Array(); for(var i=0;i&lt;m*n;i++) freq[i]=0; var arr = Array() for(var test=0;test&lt;N;test++)&#123; for(var i = 0;i&lt;num;i++)&#123; arr[i]=1; &#125; for(var i = num;i&lt;m*n;i++) &#123; arr[i]=0; &#125;shuffle(arr)//console.log(arr) for(var j=0;j&lt;n*m;j++)&#123; freq[j]+=arr[j]; &#125;&#125;for(var i =0;i&lt;n*m;i++)&#123;console.log(i+" "+freq[i]/N);&#125;&#125; 假装做个扫雷 生成nxm大小的格子里面有num个雷,并且打乱它123456789101112131415161718192021222324252627282930313233function generate(n,m,num)&#123; var mines = new Array() let x,y; for(var i =0;i&lt;n;i++)&#123; mines[i]=new Array(); for(var j=0;j&lt;m;j++)&#123; mines[i][j]=0; &#125; &#125; while(num)&#123; x= Math.floor(Math.random()*n); y= Math.floor(Math.random()*m); //一定要加，不然雷数少于num if(mines[x][y]===0)&#123; mines[x][y]=1; num--; &#125; &#125; return mines;&#125;function shuff2d(mines,n,m)&#123; var t,ix,iy,ranx,rany; for(var i = n*m-1;i&gt;=0;i--)&#123; ix = Math.floor(i/m); iy = i%m; var random = Math.floor(Math.random()*(i+1)); ranx = Math.floor(random/m); rany = random%m; t = mines[ix][iy]; mines[ix][iy]=mines[ranx][rany]; mines[ranx][rany]=t; &#125;&#125; 其他要设置用户点击open[][],这个点周围有多少雷cnt[][]，用户插旗坐标flag[][]另外 点开不是数字的地方要扩展 window.getSelections()https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getSelection css 伪类选择器的notcss权重计算？123456789101112131415&lt;head&gt; &lt;style&gt; p:not(.classy) &#123; color: red; &#125; body :not(p) &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p class="classy"&gt;就这条不用这个样式&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;span&gt;body里面除了p都是绿的&lt;span&gt;&lt;div&gt;body里面除了p都是绿的&lt;/div&gt; 写一个base62.jsrequirejs异步加载文件加载机制：使用head.appendChild()将每个依赖变成&lt;script&gt;标签helper不是xhr是以js形式加载的Content-Type:application/javascript;charset=UTF-8所以模块加载可以跨域，可以从cdn1&lt;script data-main = "/js/app" src = "/js/require.js"&gt;&lt;/script&gt; app.js123456789//不用data-main直接配置base-Url//在html里两个script标签，先require.js再app.jsrequirejs.config(&#123; baseUrl:'/js'&#125;);require(['helper'],function(helper)&#123; var str = helper.trim(' amd ') console.log(str)&#125;); helper.js12345678//模块名，依赖的模块，加载的依赖中的对象（jquery）define("helper",['jquery'],fucntion($)&#123; return &#123; trim: function(str)&#123; return $.trim(str) &#125; &#125;&#125;); 获取用户信息1.定义简单对象user.js123456define(&#123; username:'username', name:'zhou', email:'abc@abc.com', gender:'男' &#125;) 2.app.js12345678require(['jquery','../js/api'],function($,api)&#123; $("#user").click(function()&#123; //.then异步处理 api.getUser().then(function(user)&#123; console.log(user); &#125;) &#125;)&#125;); 3.api.js12345678define(['jquery'],function($)&#123;//异步处理 var def = $.Deferred(); require(['../js/user'],function(user)&#123; def.resolve(user); &#125;); return def;&#125;); 不支持AMD(require,define)的库：Mondernizr，bootstrapnodejs 单线程IO密集：静态资源（文件），网络，数据库Event loop主进程是单线程，I/O等操作系统多线程调用。nojs有cluster模块可以在每个核启一个进程不会浪费cpu 移动端自适应1.css像素即逻辑像素。一般屏幕【设备像素比】1：1，一个逻辑像素对应一格设备物理像素Retina屏幕，1：2，一个逻辑像素需要4个物理像素表示2.viewport分三类layout viewport 整个网页visual viewport 在手机上拖动显示的网页的一部分ideal viewport 手机的宽和高content=&quot;width=device-width&quot;让layout==手机的ideal 手机自动铺满3.rem：em是相对于父级元素计算大小，rem相对于root element 用viewport和设备像素比可以调整基准像素 spa的好处不用每次请求消耗dns tcp等接口相应时间。单页面只有接口耗费的时间。Prerender可以优化SEO 实现1.History api pushState onpopstate2.Hash hashchange location.hash gulp不用io流式处理 比grunt晚出现 chrome 技巧截图：ctrl+shift+P Captrue full size screenshot Web Component 用法Webview loadUrl浏览器由7部分组成用户界面网络：请求静态资源发起请求js引擎渲染引擎：DOM和CSS内容排版 WebKit中Html和CSS解析可以并行UI后端：选择框、按钮、输入框js解释器持久化数据存储 查看渲染计算后的CSS规则document.defaultView.getComputedStype(document.getElementById(&quot;id&quot;,null))css计算权重：!important&gt;内联样式&gt;id选择器&gt;类选择器&gt;元素选择器 HTTPhttp/1.1 字符串传输持久链接：一个tcp链接里可以发送很多http请求。减少三次握手次数。pipeline:添加了host： 《Web性能权威指南》 是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。 它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2.0 最重要的一项增强。 http2:：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。 每个来源一个链接:，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。 http2：分帧传输二进制传输（不用连续）信道复用 同一个链接多个请求一个tcp链接并发http请求，不用等前一个请求接收到之后再发送。server push推送。以前要先解析html再发送请求css/js。现在请求html就获取。 nginx开启http2 开启https才能http2ALPN转称http1.1传给服务器12345server&#123; listen 443 http2; server_name test.com; http2_push_preload on;&#125; nodejs12345678if(request.url === '/')&#123; response.writeHead(200,&#123; 'Content-Type':'text/html', 'Connection':'close', //http2的push 'Link':'&lt;/test.jpg&gt;;as=image;rel=preload' &#125;)&#125; 协议变成h2chrome://net-internals/#http2 看pushed和 claimed 使用1个push到30个push的区别https的握手过程 http2性能测试 nodejs跨域测试 被请求的添加html里type:xhr12345&lt;script&gt;var xhr = new XMLHttpRequest()xhr.open('GET','http://127.0.0.1:8897')xhr.send()&lt;script&gt; 8897:任何服务都能访问这个服务1response.writeHead(200,&#123;'Access-Control-Allow-Origin':'*'&#125;) 或者特定域名12response.writeHead(200, &#123;'Access-Control-Allow-Origin':'http://localhost:8898'&#125;) jsonp标签里允许跨域不用添加allow-origintype:script1&lt;script src="http://127.0.0.1:8897"&gt;&lt;script&gt; CORS预请求 option跨域只允许get/head/postcontent-type只允许 form表单三种数据类型text/plain multipart/form-data application/x-www.form-urlencodedhtml：报错not allowed by Access-Control-Allow-Headers123456fetch('http://localhost:8897/',&#123; method:'POST', headers:&#123; 'X-cors':'123' &#125;&#125;) fetch允许跨域的header允许的header 其它的都需要服务器端验证先发送option类型再发送post123response.writeHead(200,&#123; 'Access-Control-Allow-Header':'X-Test-Cors'&#125;) 同理可以添加Allow-Methods等设置允许跨域的最长时间不需要再发送option预请求&#39;Access-Control-Max-Age&#39;:&#39;1000&#39; 缓存Cache-Control 可缓存性public：http经过的代理服务器、客户端都能缓存private：只有发起请求的浏览器可以缓存(百度设置了privae) 过期max-age：客户端过期时间s-maxage=代理服务器的过期时间max-stale=使用过期缓存 重新验证must-revalidate 其它对代理服务器nginxno-cache 可以本地缓存。向服务器发起验证是否可以使用本地缓存no-store 不能本地缓存。no-transform 不压缩 在请求服务器设置123response.writeHead(200,&#123;'Cache-Control':'max-age=200,public'&#125;) 服务端12345678const etag = request.headers['if-none-match']if(etag === '777')&#123; response.writeHead(304,&#123; 'Content-Type':'text/javascript', 'Etag':'777' &#125;) response.end('并不会显示，浏览器直接读了缓存')&#125; 设置Cookie禁止javascript修改cookie1234response.writeHead(200,&#123; 'Set-Cookie:['id=123;max-age=2','abc=456;HttpOnly']&#125;)response.end(html) &#39;adc=456;domain=test.com&#39; 不能跨域设置给a.test.com 长链接Network-Connection ID（TCP链接的id）http1.1发送请求有先后顺序。不能并发请求chrome允许并发限制创建6个保持长链接Connect:Keep-Alive 默认都是keep-alive本地开发 把网速调慢：online-&gt;Fast 3G可以设置&#39;Connection&#39;:&#39;close&#39; google 使用h2 都是一个connectID 数据协商AcceptAccept-EncodingAccept-Languagemimetype &#39;X-Content-Type-Options&#39;:&#39;nosniff&#39; 禁止浏览器自动猜测返回类型 使用gzip压缩1234567const fs = require('fs')const zlib = require('zlib')const html = fs.readFileSync('test.html')response.writeHead(200,&#123; 'Content-Encoding':'gzip',&#125;)response.end(zlib.gzipSync(html)) 表单如果用ajax使用application/json或者application/xml123456&lt;form action ='/from' id = "form" method = "POST" enctype="multipart/form-data"&gt;&lt;input type = "text" name = "name"&gt;&lt;input type = "password" name = "password"&gt;&lt;input type="file" name="file"&gt;&lt;input type ="submit" name = "submit"&gt;&lt;/form&gt; ajax发送123456789var form = document.getElementById("form")form.addEventListener('submit',fumction(e)&#123; e.preventDefault()//页面不会跳转 var formData = new FormData(form) fetch('/form',&#123; method:'post', body:formData &#125;)&#125;) 会自动带上Content-Type redirect只有302的头才表示跳转123response.writeHead(302,&#123; 'Location':'/new'&#125;) 改成301永久变更 浏览器会自动只发送/new的请求 /new的路由放到了缓存里。接下来改成200也读不到了。 CSP content-security-policy 内容安全策略1'Content-Security-Policy':'default-src http:https' 考虑同一域名的浏览器请求上限将html放在admin.domain.com下,js+css放在s.下，将image放在image.下前端访问后端api.发生跨域需要使用代理服务器 304是协商缓存 还会和服务器通信一次本地缓存(cache-control/expires) 通过html中引用css地址更新v1放弃缓存 用摘要算法当文件更新时更新css文件名静态资源部署在cdn，动态网页部署在另一个节点。1 先更新页面：加载旧缓存，页面样式错乱2 先静态资源后页面：有缓存则不更新，第一次访问的没缓存用户 页面执行错误。访问量小的网站可以先静态资源后页面非覆盖式发布：新旧css同时存在cdn上，再更新html页面 全局微软雅黑document.getElementByTagName(&quot;body&quot;).sytle.fontFamily=&quot;微软雅黑&quot;Array.from(document.getElementByTagName(&quot;p&quot;).forEach((item)=&gt;item.style.fontFamily=&quot;微软雅黑&quot;)) import有无default ，default导出的只能一个，所以不用大括号 webpack-dev-server 开发模式wepack.config.js:123456789101112131415const isDev = process.env.NODE_ENV==='development'const config=&#123; target: 'web'&#125;if(isDev)&#123; config.devSever =&#123; port:8888 host:0.0.0.0,//可以在内网中用内网ip用手机访问测试 overlay:&#123; errors:true, &#125;, historyFallback:"index.html", hot:ture//只渲染当前组件&#125;&#125; 安装corss-env在windows平台下设置NODE_ENV要用set和linux不同package.json1234"script":&#123; "build":"cross-env NODE_ENV=production webpack --config webpack.config.js", "dev": "cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js"&#125; html-webpack-pluginautoprefixerpostcss.config.js优化css代码 自动加webkit等前缀 mixin模式typeof一共有五种返回值按存储方式只有值类型和引用类型（共用内存块）只能区分值类型。无法区分引用类型：数组、对象、方法 强制类型转换==123100=='100'//true0=='' //true 都会转换成falsenull==undefine//true 都会转换成false if和逻辑运算符判断变量被当成true还是false12var a = 100console.log(!!a)//true 何时使用===和==除了1234obj.a==null//相当于obj.a===null||obj.a===undefined//来自jquery 其它都用=== 12个js内置函数 （数据封装类对象）JSON和Math也是内置对象12JSON.stringify(&#123;a:10,b:20&#125;)JSON.parse('&#123;"a":10,"b":20&#125;') 原型js构造函数12345678910//构造函数function MathHandle(x,y)&#123; this.x=x; this.y=y;&#125;MathHandle.prototype.add=function()&#123; return this.x+this.y&#125;var m = new MathHandle(1,2)console.log(m.add()) Class语法1234567891011class MathHandle&#123; construct(x,y)&#123; this.x=x; this.y=y; &#125; add()&#123; return x+y &#125;&#125;const m = new MathHandle(1,2);console.log(m.add()) 语法糖实现MathHandle===MathHandle.prototype.constructor true 继承123456789function Animal()&#123; this.eat = function()&#123; console.log("animal")&#125;&#125;function Dog()&#123; this.bark = function()&#123; console.log("bark")&#125;&#125;Dog.prototype = new Animal()var hs = new Dog()//hs有了eat方法 window.onload和DOMContentLoaded区别zeptorollup.js 比webpack小 babel src/index.js zepto小型jquery专门移动端开发Rivets.js数据绑定js预处理器 pug webpack 模版处理器（jade） 数组 arr.includes(4) true/false .find 123let result = arr3.find(function (item,index) &#123; return item.toString().indexOf(5)&gt;-1&#125;) .some找到true后停止返回true .every找到false后停止返回false .reduce变成undefined是因为没有写返回值 对象求和：12//不报错，返回NaN 因为pre从对象变成了数 [&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev.price*prev.count+next.price*next.count) 正确写法：123[0,&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count)//或者添加默认参数[&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count,0) 数组扁平化：二维数组变成一维1[[1,2,3],[4,5,6],[4,5,6]].reduce((prev,next)=&gt;prev.concat(next)) 箭头函数let a = b =&gt; c =&gt; b+ca(1)(2)=3(return function(c){b+c})闭包：返回的是引用数据类型，赋值给外界变量，不会被销毁。 更改this指向 call和apply和bindapply\call详解绑定this上下文，call和apply使函数立即执行 bind返回函数自己实现bind12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125; &#125; 文档碎片在赋值操作中 A||B :A真返回A，A假返回B A&amp;&amp;B :A假返回A，A真返回B &amp;&amp;优先于||应用场景：1234function fn(num,callBack)&#123; num=num||0//undefined会转换成false callBack&amp;&amp;callBack();//只要传了函数进来callBack为真&#125; 闭包里边的作用域被赋值给外面的变量占用了，不能释放。1234567891011var a = 9;function fn()&#123; a=0; return function(b)&#123; return b+a++; &#125;&#125;var f=fn()//占用 function(b)console.log(f(5))//输出5.f(5)执行后会销毁 全局a=1console.log(f()(5))//修改全局a=0 输出5 执行完后a++ 全局a=1console.log(f(5))//输出6 从fn到return之间的被保留 类数组 （arguments形参集合） 以0~n数字作索引 length arguments.callee是函数本身 严格模式不使用 arguments.caller 是fn 严格模式不使用 Array.from()将类数组转换成数组12function sum()&#123;console.log(arguments.callee.caller)&#125;function fn()&#123;sum(1,2,3,4)&#125; 立即执行函数IIFEfunction t (num){console.log(num)}(3) 浏览器的【全局作用域】是window,nodejs的全局作用域是globalvar a=1 给window加了属性 对象数据类型： 浏览器开辟内存空间分配一个16进制的地址， 内存空间存对象键值对 给对象变量存地址 任意数求和123456function fn()&#123; //类数组转化成数组 var ary = Array.prototype.slice.call(arguments); return eval(ary.join('+'))&#125;fn(12,23,34) 函数与对象的创建相同也是地址，函数把js代码当作字符串存到空间中 js中栈内存是作用域，用于执行代码，存放基本数据类型。堆内存用于存储键值对or函数字符串调用栈是连续空间。后进先释放，要节约栈空间。堆是链表。 变量提升：在当前作用域，浏览器把所有 带var的声明， 带function的声明并定义（defined赋值(代码字符串的地址)） 全局作用域var相当于给window加了属性 单例模式：团队合作防止全局变量污染：封装到对象内置类 htmlCollection元素集合类 123getElementByTagNamegetElementByClassNamequerySelectorAll NodeList 节点集合类 12getElementByTagNamechildNodes proto:HTML[Div]Element元素对象-&gt;HTMLElement-&gt;ELement-&gt;Node-&gt;EventTarget-&gt;Object 构造函数构造函数执行方式new fn() 普通函数 fn() this是window 123function fn(num)&#123; console.log(this)&#125; 调用构造函数时 this指向函数本身 输出：nfn的属性nnn:10构造函数过程：创建this实例，对this赋值并返回this并且每次new都是不同实例 12345function nfn(nnn)&#123; console.log(this) this.nnn=nnn;&#125;var ff = new nfn(10) 判断JS数据类型的4种方法js数据类型 typeof 无法区分正则和array 都返回object instanceof 检测当前实例是否属于这个类 .constructor（对象实例的constructor是类） Object.prototype.toString.call in/hasOwnPropertyhsOwnProperty是通过原型链检测是否是Constuctor的实例区别：Object.hasOwnProperty(&#39;hasOwnProperty&#39;) false&#39;hasOwnProperty&#39; in Object truehasOwnProperty用于检测私有属性in 私有共有都返回true共有：类提供，所有实例都能用 （静态方法） 原型和原型链类是函数，实例是对象。 函数的prototype属性是对象 实例的__proto__属性是对象 typeof Object “function” 所有的类都是函数类型Function instanceof Object -&gt;true 所有内置类String/Number 也是”function”类型 原型 三个自带的属性原型链：实例的__proto__是类的prototype prototype对象（原型对象）是所有函数的属性。存储了当前类给实例提供的公共属性和方法通过prototype定义类：使用new Person获得实例 1234567var Person = function()&#123;&#125;;//function Person()&#123;&#125;Person.prototype = &#123; name : 'ecmadao', sayName : function()&#123; console.log(this.name); &#125;&#125;; prototype对象，带constructor属性存的值就是函数本身（类） 每个对象都带__proto__属性，值是当前对象所属类的原型(prototype)1234function fun(num)&#123; this.num = num&#125;var f1 = new fun(10)fun.prototype=== f1.__proto__ //true 对fun.prototype添加的方法1fun.prototype.say = function()&#123;console.log("prototypesay")&#125; 对f1来说f1.hasOwnProperty(&#39;say&#39;) false . 是公共方法 fun.prototype.__proto__是Object.prototype Object.prototype没有__proto__ 有也指向自己 构造原型Fn.prototype = {} 会没有constructor,使用constructor:Fn 会导致原来使用Fn.prototype.c=function的属性被替换（可以遍历原有的克隆） 12var jQuery = function(selector,context)&#123;return new jQuery.fn.init(,)&#125;jQuery.fn = jQuery.prototype=&#123;constructor:jQuery,init:function(,)&#123;&#125;&#125; BOM document.querySelector(&quot;body&quot;).setAttribute(&quot;style&quot;,&quot;background-color:black&quot;);document.querySelector(&quot;body&quot;).style.cssText=&quot;background-color:black&quot;; https://chromium.googlesource.com/chromium/src/+/master/docs/es6_chromium.md 前端模块化 CommonJS CommonJS是不适用于浏览器端,因为文件是从服务器请求过来，不能同步加载模块。 浏览器模块化AMD规范：require.js非同步，指定回调函数浏览器中异步加载。可以并行加载多个模块。???如何并行？ CMD规范：按需加载sea.js ES6模块化 通过babel将不被支持的import编译为当前受到广泛支持的 require 加载过程defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后 虚拟DOMhttps://segmentfault.com/a/1190000015821780 Virtual Node 用json构建，type\props\children{type:”div”,props:{“style:”},children:[]}vnodes-&gt;vdom 柯里化currying：函数式编程风格，组合函数123456789101112131415//两数相乘var multiple = function(a)&#123; return function(b)&#123; return +b*a+"" &#125;&#125;//拼接var concatArray = function(list,fct)&#123; return list.map(fct) .reduce(function(a,b)&#123; return a.concat(b) &#125;) &#125;//运行24concatArray(["1","2"],multiple(2)) Object.defineProperty 为对象定义属性 js对象or DOM对象 属性名 描述符： {value: “covergou”, writable: false, enumerable: true, configurable: false} 12let obj =&#123;&#125;Object.defineProperty(obj,"school",&#123;get:,set:&#125;) value:”name” writable:true/false 是否可写 configurable:false 删除属性、修改属性（writable, configurable, enumerable）的行为将被无效化 enumerable: true 是否能在for-in循环中遍历出来或在Object.keys中列举出来 get/set:function(){}使用get/set不能有writable和value属性 实现数据双向绑定数据劫持12345678Object.defineProperty(dom, 'translateX', &#123;set: function(value) &#123; var transformText = 'translateX(' + value + 'px)'; dom.style.webkitTransform = transformText; dom.style.transform = transformText;&#125;&#125;)dom.scale = 1.5; ES6数组类方法： Array.form(1,2,3,4)转成数组.from(3)生成空位 Array.of(3)与from用法相同，解决了单个值数组 toArray(1,2,3,4)转数组 原型方法（用于实例） .copyWithin(target,start,end) cool()函数丢失了同this之间的绑定var self = this 123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log( this.id ); &#125; &#125;; var id = "not awesome" obj.cool(); // 酷 setTimeout( obj.cool, 100 ); // 不酷 setTimeout中的this指向的是全局对象 var self = this function(){}.bind(this),1000 模板字符串 显示所有全局变量12for(name in this)&#123; vars+=name+"\n"&#125; 对象保护 对象代理 ES3,ES5 123456789//声明类var Person= fuction()&#123; var data=&#123; name='es3', sex:'male', age:15 &#125; this.get,this.set = function()&#123;&#125;&#125; es5:对象的只读属性Object.defineProperty(&quot;Person&quot;,&#39;sex&#39;,{ writable:false,value:&#39;male&#39; })只能读不能写 ES6用代理访问对象1234567let Person=&#123;:,:,:&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; target[key] &#125;, set(target,key,value) &#125;) 箭头函数import {}块状作用域 .map(function(v){return v+1}).map(v=&gt;v+1) 箭头函数内的this指向是定义时this的指向function中this指向是该函数被调用的对象]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[concurrent并发多线程]]></title>
    <url>%2F2018%2F04%2F13%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[ThreadLocal可以看成是 Map&lt;Thread,T&gt; 特定于该线程的值 Cache伪共享：多线程读同一cache line的不同变量，变量无关却要线程同步。X86 cpu的cache line长64字节如果有一对象有成员变量long a,b,c(共24字节）则可能加载在一个cache line中。当 CPU1：线程1和cpu2：线程2 都从内存中读取这个对象放入自己的cache line1和2。当线程1写a则2上的cache line变成Invalid，当2要读b需要重新从内存中读。本来无关的两个线程，并行变成串行。 解决方法：将a,b分到不同的cache line 采用@Contended https://www.jianshu.com/p/7f89650367b8 redis 10w OPSDisruptorhttps://tech.meituan.com/disruptor.htmlhttp://ifeve.com/locks-are-bad/ PV和QPS估计每天300w PV 80%会在24小时的20%的时间里$3000 000*0.8)/(86400*0.2*)=139(QPS)$如果一台机器QPS是58，则需要139/58=3台机器 并发模型1.进程&amp;线程Apache C10K问题2.异步非阻塞 Nginx Libevent Nodejs 回调复杂度高3.协程Golang Erlang Lua TreeMap是非线程安全的。跳表：数据大时性能高于红黑树123456789101112131415161718private transient volatile HeadIndex&lt;K,V&gt; head;static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125;static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile Node&lt;K,V&gt; next;&#125;static class Index&lt;K,V&gt; &#123; final Node&lt;K,V&gt; node; final Index&lt;K,V&gt; down; volatile Index&lt;K,V&gt; right;&#125; ConcurrentMap的实现类ConcurrentSkipListMap跳表 redis的实现方法1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); ConcurrentHashMap 读不加锁HashMap的迭代器用modCount 不允许读的时候修改。HashMap的nodestatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;HashTable的entryprivate static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;ConcurrentHashMap 的entryvalue是可以改的value可能是null1234static final class MapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // non-null V val; // non-null final ConcurrentHashMap&lt;K,V&gt; map; V是volatile 线程同步12345678/*这个类不会被暴露出去当用户可变的 Map.Entry *但是可以用于只读遍历 */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next;&#125; 线程池ThreadPoolExecutor1private final BlockingQueue&lt;Runnable&gt; workQueue; 工作队列（阻塞队列） 保护性暂时挂起模式不可变对象模式不可变对象如果对象作为key放入HashMap，对象状态变化导致HashCode变化，会导致同样的对象作为Key，get不到相关联的值。 所以不可变对象适合作为Key。电信服务商的路由表 模式应用：CopyOnWriteArrayList对集合加锁：不适合插入删除操作比遍历多的集合。CopyOnWriteArrayList 应用了不可变对象模式。不用锁的遍历安全。适用于遍历操作比添加删除频繁的场景。源码：加添元素时会复制123Object[] newElements = Arrays.copyOf(elements,len+1);newElements[len] = e;setArray(newElements); 线程池中线程数量过多，会竞争浪费事件再上下文切换。线程池大小与处理器利用率之比：$N_{threads}=N_{CPU}处理器核数*U_{CPU}期望的cpu利用率（0-1）*(1+W/C等待时间与计算时间的比率)$ Stream在背后引入Fork/join框架Future接口目标：实现并发，充分利用cpu的核，最大化程序吞吐量，避免因为等待远程服务返回/数据库查询。阻塞线程。对计算结果的建模，返回一个运算结果的引用给调用方。12345678910ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;Double&gt; future = executor.submit(new Callable&lt;Double&gt;() &#123; @Override public Double call() throws Exception &#123; //异步操作 return doSomeLongComputation(); &#125; &#125;); //异步操作运行同时也能执行 doSomeThingElse(); Fork/Join工作窃取算法 发布对象：可以得到成员变量引用对象溢出：内部类 AQS 两个node的队列多个CPU缓存一致性 MESI缓存一致性！！！ 4种数据状态，4种状态转换的cpu操作。M（Modified)被修改：只缓存在该CPU的缓存中，被修改，与主存不一致。写回主存Exlusive独享：缓存行只在该CPU的缓存中，未被修改，与主存一致。其它CPU读取内存时变成S状态。被修改则变成M。Share共享：该缓存行被多个CPU缓存，且与主存相同。当一个CPU修改时其它CPU的变成I。Invaild无效。 local read读本地缓存中数据local write写本地缓存remote read读取内存数据 remote write写回主存 NUMA架构：内存分割，被CPU私有化：一致性协议MESIF：目录表message packmsgpack 并发模拟 PostMan-runner选中测试的接口iteration(并发多少次)delay(每次延迟多少) 安装apahce服务器bin下的ab -n 1000 -c 50 http://localhost:8080/test本次测试请求总数1000次，同时并发数50 1234567891011121314151617181920 并发量Concurrency Level: 50 整个测试所用的时间Time taken for tests: 0.667 seconds 完成的请求数Complete requests: 1000 失败请求数Failed requests: 0 所有响应数据长度总和，包括http头信息和正文数据长度，不包括http请求信息的长度Total transferred: 136000 bytes 所有正文数据长度HTML transferred: 4000 bytes 吞吐率（与并发数相关）=Complete requests:/Time taken for testsRequests per second: 1498.52 [#/sec] (mean) 用户平均请求等待时间Time per request: 33.366 [ms] (mean) 服务器平均请求等待时间Time per request: 0.667 [ms] (mean, across all concurrent requests) 单位时间从服务器获取的数据长度=Total transferred/Time taken for testsTransfer rate: 199.02 [Kbytes/sec] received JMeter 添加线程组File-Test Plan-Add-Threads- Thread Group用户数：50虚拟用户增长时长(Ramp-Up Period): 1Loop Count循环次数：一个虚拟用户做多少次测试 20（共1000次） 添加实例请求 add Sanper HttpRequest 添加监听器 图形结果、查看结果树 Option 打开Logviewer展开代码 Throughput吞吐量 用代码并发模拟123456789101112131415161718192021ExecutorService executorService = Executors.newCachedThreadPool();//同时的并发数final Semaphore semaphore = new Semaphore(threadTotal);//请求完之后统计结果 传入请求总数final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123;//超过了并发数add会被阻塞 semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error("exception", e); &#125;//闭锁 每执行完一次-1 countDownLatch.countDown(); &#125;); &#125;//保证闭锁到0再执行 countDownLatch.await(); executorService.shutdown(); log.info("count:&#123;&#125;", count);&#125; 通常与线程池一起使用 同步器Semaphore信号量 阻塞线程 控制同一时间请求并发量 适合控制并发数 Semaphore(int count)创建count个许可的信号量 每个线程：123//public void runsemaphore.acquire();//获取1/num个许可证semaphore.release();//释放许可 Semphore（2）则A,B,C三个线程，A执行完后C才能开始执行。 CountDownLatch()计数栓:必须发生指定数量的事件后才可以继续使用阻塞线程，直到满足某种条件线程再继续执行,计数值（count）实际上就是闭锁需要等待的线程数量 适合保证线程执行完再做其它处理 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 123void run()&#123;&#125;//主线程必须在启动其他线程后立即调用CountDownLatch.await()方法CountDownLatch.await();&#125;//等待锁存器 线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。 12345//倒计时为0执行main&#123; new CountDownLatch(3); CountDownLatch.countDown();//触发事件&#125; 面试题解释一下CountDownLatch概念?CountDownLatch 和CyclicBarrier的不同之处?给出一些CountDownLatch使用的例子?CountDownLatch 类中主要的方法? 汇编 jne有条件跳转 jmp无条件跳转进程-详细-设置相关性：分配到指定cpu执行，开的线程只在指定的执行java会把线程直接映射到操作系统 javac xxx.java-&gt;.classjavap -c -v xxx 查看虚拟机字节码 Condition1234567private Condition sufficientFunds;if (accounts[from] &lt; amount) //将该线程放到等待集 sufficientFunds.await();try&#123;////最后。账户发生变化，重新检查余额 sufficientFunds.signalAll();&#125; synchronizedjava每个对象有内部锁。并且该锁有一个内部条件12while (accounts[from] &lt; amount)wait();notifyAll(); final 匿名内部类中只能使用final？ 阻塞队列CAS(compareAndSwap)AtomicReference&lt;V&gt;模板，可以封装任何对数据加上时间戳解决ABA过程状态敏感问题（充值10，20，花费10if (money.compareAndSet(m, m + 20, timestap, timestap + 1))Pair&lt;V&gt; current = pair;第i个元素在数组中的偏移量123private static long byteOffset(int i) &#123; return ((long) i &lt;&lt; shift) + base;//左移2，00乘4 &#125; shift = 31 - Integer.numberOfLeadingZeros(scale); 29个前导0-&gt;shift=2 前导零：数字转换成二进制数后前面0的个数 数组当中每个元素有多宽：int scale = unsafe.arrayIndexScale(int[].class); 4 private static final int base = unsafe.arrayBaseOffset(int[].class); int的话4个byte 静态工厂方法 casPair使用cas的方式更新 1. .start开启新线程调用run .run不开启新线程两种创建方法1.传入一个runnable对象 2.覆盖runThread:123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 2. stop不建议使用，会释放所有的锁（monitor） 实例方法.interrupt()在run()中处理 123456public void run()&#123; while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125; Thread.yeild();&#125; 用Thread.sleep(2000)异常处理 sleep会释放cpu时间片，不释放监视器所有权。让给其它线程在外部对这个sleep的线程中断会抛出异常.isInterrupted方法可以清除中断状态 1234567891011 while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125;try&#123; Thread.sleep(2000);&#125;catch(InterruptedException e)&#123; //设置中断状态，抛出异常后会清除中断标记位 Thread.currentTread.interrupt();&#125; Thread.yeild(); &#125; 用自定义标记抛出异常 3. suspend &amp; resume 已弃用 If the target thread holds a lock on the monitor protecting a critical system resource when it is suspended, no thread can access this resource until the target thread is resumed.If the thread that would [resume] the target thread attempts to lock thismonitor prior to calling resume, deadlock results. Such deadlocks typically manifest themselves as “frozen” processes. 线程2resume线程1发生在线程1suspend之前，当线程1suspend之后没办法resume，导致线程1资源冻结。测试代码点击显/隐内容 1234567891011121314151617181920212223242526272829package learnThr;public class learnThread &#123; public static Object u = new Object(); static ChangeObjectThread t1 = new ChangeObjectThread("t1"); static ChangeObjectThread t2 = new ChangeObjectThread("t2"); public static class ChangeObjectThread extends Thread&#123; public ChangeObjectThread(String name)&#123; super.setName(name); &#125; @Override public void run()&#123; //加锁 synchronized (u)&#123; Thread.currentThread().suspend(); &#125; &#125; &#125; public static void main(String[] args)throws InterruptedException&#123; t1.start(); Thread.sleep(100); t2.start(); t1.resume(); t2.resume(); t1.join(); t2.join(); &#125;&#125; yield &amp; joinA.join(0)等待A结束后执行 用wait实现join实现 As a thread terminates the this.notifyAll method is invoked.It is recommended that applications not use wait, notify, ornotifyAllon Thread instances.不要在Thread实例上使用，会影响系统API wait该线程释放监视器所有权。 在同步方法中使用虚拟机实现notifyAll，在Object上。结束时会唤醒所有等待线程。12345if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; 守护线程t.setDaemon(true);虚拟机不会管守护线程是否存在，直接退出。 优先级12high.setPriority(Thread.MAX_PRIORITY);low.setPriority(Thread.MIN_PRIORITY); wait &amp; notify-Object.wait() 线程等待在当前对象上 The current thread must own this object’s monitor.releases ownership of this monitor and waits until another thread notifies -Object.notify()通知等待在这个线程上的对象 随机唤醒一个 Wakes up a single threadthat is waiting on this object’s monitor. 12synchronized (object) &#123; object.wait();&#125;synchronized (object) &#123; object.notify();&#125; 同步 synchronized独占加锁 java.util.concurrent 并发工具包 CyclicBarrier(int num)等待多个线程到达预定点 执行器 并发集合 Frok/Join框架：并行 atomic包：不需要锁即可完成并发环境变量使用的原子性操作 locks包]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F04%2F12%2Fperformance%2F</url>
    <content type="text"><![CDATA[谷歌 PageSpeed团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。 浏览器解析 Firefox 规则树 CSS图像精灵 减少http请求次数服务端对静态文件gzip压缩使用css/js（内容不是很多）内嵌式减少http请求 JS和DOM的映射机制是浏览器的监听机制是，DOM操作会触发浏览器回流和重绘。减少css选择器前缀，使用组合名表示层级。避免使用css表达式 服务器多处理304缓存，客户端利用localStoreage将css/js存储在本地。少使用闭包，会产生不销毁的栈内存。内存泄漏。eval性能消耗大，压缩后会错乱。DOM事件绑定使用事件委托（代理），把事件绑定给外层容器，里面元素触发外层也触发（冒泡）。通过事件源判断做不同的操作。 用CSS3替代js动画，css3有硬件加速。减少css滤镜使用和页面flash。 CDN 效果最佳 数据懒加载 分页(后台) html渲染 外部资源在浏览器加载是并发加载，对于单个域名浏览器的并发度有限，设3-4个CDN域名，防止浏览器达到外部资源并发请求数目上限，导致资源不能并发请求。 css阻塞用link在head导入css会阻塞页面渲染，阻塞js执行，但是不阻塞外部脚本加载 js阻塞不用defer和async直接用&lt;script src&gt;会阻塞页面渲染，不阻塞资源加载，阻塞执行async 不会阻塞页面加载，放弃了js依赖关系 懒加载 zepto.js 图片 进入可视区域再加载，浏览器并发上限如果图片和静态资源在的cdn是同一个，图片加载会阻塞js加载 img的src并不是图片的url是只有1px的占位符，图片标签被放在data-url属性上，js监听scroll事件。 lazyload=true。触发时链接放到background-image中 dom上底边(clientHeight) 到页面顶部的距离小于 手机屏高 则可视 addEventListener(&#39;scroll&#39;,lazyload) 遍历所有懒加载标签document.querySelectorAll(&#39;div[lazyload]&#39;) 获取距离顶部的位置 12345element.getBoundingclientRect()&gt;document.querySelectorAll('img[src]')[0].getBoundingClientRect()//输出 DOMRect &#123;x: 0, y: 0, width: 0, height: 0, top: 0, …&#125;&gt;document.querySelectorAll('img[src]')[99].getBoundingClientRect()//输出 DOMRect &#123;x: 835, y: -1604, width: 22, height: 22, top: -1604, …&#125; NodeList，它里面没有.forEach方法 123456789Array.prototype.forEach.call(nodes,function(item,index))&#123;var image = new Image()//请求图片资源image.src=dataurl//赋值到item上image.onload = function()&#123;item.src = img.src&#125;item.removeAttribute('data-original')item.removeAttribute('lazyload')&#125; 预加载preloadjs 九宫格抽奖 style=&quot;display:none&quot; 使用new Image() XMLhttpRequest2加了对请求过程的监控xmlhttprequest.onprogress 会有跨域问题123456789var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callback;xmlhttprequest.open("GET",".jpg",true)xmlhttprequest.send() //请求返回时会 onreadystatechangefunction callback()&#123; if(xmlhttprequest.readyState==4&amp;&amp;xmlhttprequest.status==200)&#123; var responseText = xmlhttprequest.responseText; &#125;&#125;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F04%2F11%2Fwebpack%2F</url>
    <content type="text"><![CDATA[npm init 生成package.json文件 npm i webpack 新建build文件夹 放配置文件 webpack.config.js: 仍出一个webpack配置对象module.exports = { } entry 入口文件 防止系统差异引用const path= require(&#39;path&#39;) app:path.join(__dirname,&#39;../app.js&#39;):__dirname 当前文件夹 output:{filename:&#39;[name].[hash].js} 中括号表示变量,[name]表示entry下对应的名字,加上打包后的hash值，有任何文件改动hash变化，浏览器刷新缓存 publicPath:”” (js,css404:”/“绝对路径，”./“相对路径)静态资源引用时的路径，区分静态资源还是api请求，如果部署到CDN，写CDN前缀 配置moudle识别jsxtest后面跟正则表达式（以jsx的）表示文件类型loader是编译工具，编译成ES5 安装babel-core 1234moudle:&#123;rule:[ test:'/.jsx$/'， loader：'babel-loader' ]&#125; 配置babel（默认编译ES6）的配置文件.babelrc presets 支持的语法 123456&#123; "presets":[ ["es2015",&#123;"loose":true&#125;], "react" ]&#125; 用松散模式编译ES6,用react语法 安装babel的3个包 安装html-webpack-plugin -D并 require 能生成一个html页面把entry里的都注入，路径根据output 123plugins:[new HTMLplugin()] 没有启动服务器没有做路径映射所以访问不到js文件将publicPath设置为’’变成相对路径react的js文件也需要babel但是nodemodules里面都是js 1234567&#123; test:/.js$/, loader:'babel-loader', exclude:[ path.join(_direname,'../node_modules') ]&#125; 服务端渲染：单页js写的应用SEO不友好、请求时间长webpack.config中的内容复制到webpack.config.servertarget:&#39;node打包完在哪执行可以是node/web（浏览器 entry:app： export default的js libraryTarget：’AMD’ 模块加载方案 nodejs：commonjs2 服务端渲染不需要htmlplugin rimraf dist 是nodejs的包 专门用来删除文件夹 moudle.exports nodejs的导出方式 commonjs2 的写法 export default。 require的时候加.default 将node启动后渲染出server.js的插入html 新建html文件new HTMLPlugin({template:path.join(__dirname,&#39;../client/template.html&#39;)})生成的html以template为模板 server端读template文件 同步读12const template = fs.readFileSync(path.join(,index.html),'utf8')res.send(template.replace('&lt;app&gt;&lt;/app&gt;'),appString) Webpack-dev-server安装 contentBase:静态文件地址 hot启动 hot-module-replacement 数据请求也刷新？ 黑色弹窗报错overlay:{ errors:true } cross-env不同系统环境变量配置 mac上可执行的在windows上可能不行 historyApiFailback:{index:’/index.html’404路径返回index webpack.bace放client和server相同的js代码 hot-module-replacement 在babel配置文件中配置]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mySQL]]></title>
    <url>%2F2018%2F04%2F08%2Fmysql%2F</url>
    <content type="text"><![CDATA[开启mysql查询日志https://blog.csdn.net/leshami/article/details/39779225123456789101112131415show variables like '%general%';+------------------+------------------------------+| Variable_name | Value |+------------------+------------------------------+| general_log | ON || general_log_file | /var/lib/mysql/localhost.log |+------------------+------------------------------+set @@global.general_log=1;cat /var/lib/mysql/localhost.log/usr/sbin/mysqld, Version: 5.6.41 (MySQL Community Server (GPL)). started with:Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sockTime Id Command Argument180905 18:24:55 5 Query select id,name from poi where lng between 116.3284 and 116.3296 and lat between 39.9682 and 39.9694180905 18:26:00 5 Query show variables like '%general%'180905 18:28:44 5 Query select * from poi where 1=1 mybatis逆向工程generatorConfig.xmlexplain执行计划 ：select,update,insert,replace,delete 分区show plugins;可以看到partition 则可以分区。逻辑上一个表，物理上多个文件中。在create table的最后加上partition by hash(id) partitions 4.frm存储表数据.ibdinndb数据文件分区之后.ibd会有好几个 hash分区 利用表中的int列或者by hash(UNIX_TIMESTAMP(login_time))将timestamp转成intrange分区 log推荐使用 日期/时间 查询的时候包含分区键 适合定期清理历史数据1234partition by range(id)( partition p0 values less than(10000), partition p1 values less than(20000), partition p3 values less than maxvalue); list分区 按枚举123partition by list(type)( partition p0 values in (1,3,5,7,9), partition p1 values in (2,4,6,8)); 到了新的一年添加分区1alter table t1 add partition (partition p4 values less than(2018)); 删除分区1alter table t1 drop partition p0; 归档新建一个和t1结构相同的 非分区表t2 .一般迁移后删除分区，切换归档表的存储引擎分区表只能查询不能写 分区表梗适合用mysam引擎123alter table t1 exchange partition p0 with table t2;#--drop之后切换引擎alter table t2 ENGINE=ARCHIVE; password用char(32)timestamp on update CURRENT_TIMESTAMP字段会在表被修改时自动更新 Mybatis mybatis-3-config.dtd: 可以用&lt;properties&gt;导入配置文件在&lt;mappers&gt;里可以用&lt;package&gt;导入整个有mapper.xml的文件夹 mybatis-3-mapper.dtd&lt;typeAliases&gt;中添加&lt;package&gt;自动扫描包，将类名作为别名 PageHelper.orderBy(&quot;price desc&quot;)按价格降序（sql中的order by 之后的格式） mysql like通配符% 任意多个字符 ER图矩形：实体特化：自顶向下继承设计概化：底向上菱形：联系集：把多对多变成1对多 用虚线连接联系集的属性 双线：全参与：表示在联系集中的参与度&lt;advisor&gt;=student表示每个学生都要有导师，双边菱形：表示弱实体集和它依附的实体集。当弱实体集里放入依赖的实体集的id，则不需要联系集 椭圆：属性角色：&lt;先修课联系集&gt;和[课程]的联系通过course_id和prereq_id角色标识区分派生属性：可以通过其它属性计算得到复合型属性应该拆分成2个属性多值型（一个老师对应多个电话）应该用另一个(id,phone)(1,phone1)(1,phone2)每个属性映射到单行映射基数：1：1，1：n,n:1,n:n基数约束：导师&lt;-&lt;advisor&gt;-学生 一对一：箭头从关系指向实体：导师&lt;-&lt;advisor&gt; 一名学生只有一名导师 一对多：没有箭头表示多端，有箭头表示“一”端 &lt;advisor&gt;-学生 一名老师可以有多名学生。导师 0..* &lt;advisor&gt; 1..1 学生 参与的上限..下限，0表示老师参与的下线是0，不是全参与，是半参与。 天然的三元关系 导师 项目 学生 通过一个联系集不能拆分成2个二元关系。 什么时候作为实体:instructor/ins-phone/phone三张表什么时候作为属性instructor(phone) 只对名字和单值（不是多值（对应多个电话））感兴趣则为属性：性别。 一个对象除了名字意外，还有其它属性要描述则定义成实体：电话、住址、部门。 是实体集还是用联系集（对象之间的动作）：考虑映射的基数customer-&lt;loan&gt;-branch 但是当要表示一个客户在一个银行里多笔贷款customer-&lt;borrow&gt;-loan(实体)-&lt;Loan-bra&gt;-branch客户与贷款多对多，贷款对支行一对多。 用属性student(supervisior-id,supervisior-name)还是用联系集&lt;stu-sub&gt;,&lt;stu-class&gt; innodb有索引组织表 IP地址字符串转intINET_ATON(&#39;255,255,255,255&#39;)=4292967295(无符号int最大值)INET_NTOA(&#39;4292967295&#39;)=’255,255,255,255’Varchar(255)utf-8汉字3个字节 总共765字节避免使用TEXT64k,BLOB 可以用varchar mysql内存映射表不持支，所以排序只能用磁盘映射表 timestamp只能存到2038年01-19 decimal精确浮点类型 预编译语句 每次执行只需要传递参数 节省带宽12345prepare stmt1 from 'select sqrt(pow(?,2)+pow(?,2)) as hypotenuse';set @a=3;set @b=4;execute stmt1 using @a,@b;deallocate prepare stmt1 将where date(ctime)=&quot;20160901&quot;改成where ctime&gt;=&#39;20160901 and ctime&lt;&#39;20160902可以使用索引 第三范式 不存在 传递函数依赖关系 名字可以决定分类；分类可以决定分类描述 则存在非关键字段 分类描述 对名称的依赖 范围查询会使联合索引失效 要把范围查询的表放到索引右侧使用leftjoin/not exists代替 not in（会使索引失效 索引列的循序 区分度(列中唯一值数量/总行数)高的放在联合索引左边不使用外键 外键用于数据参照完整性（数据一致性）但是降低写性能，可以用其它方式保证一致性 但是要在表之间的关联键上建立索引 慢查询开启慢查询日志 SQL监控1show variables like 'slow_query_log'; 记录没有使用索引的sqllog_queries_not_using_indexes 变量123show variables like '%log%';set global log_queries_not_using_indexe=on;set long_query_time = 1; long_query_time超过多少秒之后的查询记录在日志中查看慢查询日志的位置1show variables like 'slow%'; 慢查询分析工具mysqldumpslowcount(1)和count(*)和count(*)count(1)比count（*）效率高一些123create table t(id int);insert into t value(1),value(2),(null);select count(*),count(id),count(1) from t; count(*) count(id) count(1) 3 2 3 内置类型now() 数据类型 int(11)和int(21)都占4个字节，区别在于补零位数 123create table t(a int(11) zerofill, b int(21) zerofill);insert into t values (1, 1);select * from t; char和varchar存储字符数。 char 存储255个字符，varchar根据类型计算字符数，上限是65535个字节 char会自动补空，varchar&lt;=255用一个字节&gt;255用两个字节存储长度length desc 查看表结构 mysql join inner join内连接，两张表的公共部分 数据库会先在每个表里先查条件再生成笛卡儿积select a.name from a A inner join b B on A.name =B.name; left outer join左外连接，以左表为基础 内链接当左表中查询条件是null的时候被忽略，外连接则有用左外连接查询只存在A中不存在B中的where B.Key is NULL (优化not in不会使用索引)select * from b left outer join a on a.name =b.name where a.Id is null; right outer joinselect * from a right outer join b on a.name =b.name where a.Id is null; full join count(*),min(p.&#39;price&#39;) group by p.&quot;id&quot;,&quot;name&quot;数据库Myisam表锁 -&gt; Innodb 行锁 从大锁到小锁提升并行度MyISAM引擎不持支事务，优点是读写快,列存储5.5之前的默认Innodb支持事务ACID 行级锁，高并发场景好 JDBCstatic final String JDBC_DRIVER=&quot;com.mysql.jdbc.Driver&quot;; close放在finally里，保证执行 防止空指针异常 12345finally&#123; if(conn!=null)conn.close(); if(stmt!=null)stmt.close(); if(rs!=null) rs.close(); &#125; 游标：读取记录太多，内存放不下。DB_URL:useCursorFetch=true 1static final String DB_URL ="jdbc:mysql://localhost/scraping?characterEncoding=utf8&amp;useCursorFetch=true&amp;useSSL=true"; ptmt=conn.prepareStatement(sql); 每次从服务器端取回记录的数量ptmt.setFetchSize(1); rs = ptmt.executeQuery(); 流方式:记录中存在大字段内容：博文。读一条记录内存可能放不下。 变成二进制流读取小区间 InputStream in = ResultSet.getBinaryStream(&quot;blog&quot;) 在外部生成一个文件，每次读取一行输出到外部文件1234567File f = new File(FILE_URL);OutputStream out = null;out = new FileOutputStream(f);int tmp = 0;while((tmp= in.read)!==-1)out.write(tmp);in.close();out.close(); 连接池 DriverManager.getConnection流程客户端利用密码种子和自己保存的数据库密码按加密算法得到加密密码 每个线程使用数据库连接后不销毁，每个请求从连接池中【租借】连接 数据库服务器端处理请求时要分配资源，请求结束后被释放。服务器设置最大并发连接数。抛toomanyConnection异常。应在客户端中实现业务线程排队获取数据库连接。 DBCP是一组jar包：commons-dbcp,jar,commons-pool.jar,commons-logging.jar dbcp重写了Connection的close方法，把销毁数据库连接改成了归还给连接池 12345678public static void dbpoolInit()&#123; db = new BasicDataSource(); db.setUrl(DB_URL); db.setDriverClassName(JDBC_DRIVER); db.setUsername(USER); db.setPassword(PASSWORD); db.setMaxTotal(2);&#125; 优化连接池 提高第一次访问数据库的速度，在连接池中预制一定数量的连接.setInitialSize(1) .setMaxTotal()设置客户端的最大连接数，超过的不创建新连接，而是进入等待队列 .setMaxWaitMillis()设置最大等待时间 .setMaxIdel()空闲连接数的最大值，超过则销毁 setMinIdel()空闲数低于则创建，建议于MaxIdel相同 DBCP定期检查，服务端会自动关闭空闲连接，连接池可能租借失效的连接 定期检查连接池中连接的空闲时间 开启.setTestWhileIdel(True) 应该销毁的最小空闲时间.setMinEvictableIdleTimeMillis() 检查的时间间隔,应小于服务器自动关闭连接的时间（Mysql 8小时).setTimeBetweenEvictionRunsMillis() Mysql show processlist;查看连接数 防范SQL注入&#39;-- 参数化sql conn.prepareStatement(sql)传入格式化sql,需要传入的参数用？占位 1Select * from user where userName = ? And password=? 传入参数ptmt.setString(1,username) 参数位置从左往右1开始 数据库权限、封装数据库异常 mysql AES_ENCRYPT/AES_DECRYPTstring加密/解密 事务：单个逻辑工作单元执行的一系列操作，逻辑工作单元满足ACID(原子、一致、隔离、持久) ，并发控制的基本单位。1234567try&#123;Connection.setAutoCommit(false)//开启事务Connection.commit()//提交事务Connection.rollback()//事务回滚&#125;catch(SQLException e)&#123; if(Connection!=null)Connection.rollback()&#125; 检查点12Savepoint sp = Connection.setSavepoint();Connection.rollback(sp); 事务的隔离级别 脏读：一个事务读取了一个事务未提交的更新 不可重复读：同一个事务，两次读取值不一样。 幻读：同一个事务，两次读取行记录数目不一样。插入了新记录 隔离级别 脏读 可重复读 幻读 读未提交 √ X √ 读提交 X X √ 可重复读 X √ √ 串行化 X √ X 读未提交：允许脏读 读提交：不允许脏读，可以不可重复读 重复读：可能出现幻读。 MySQL的事务隔离级别。 1set 串行化：最高隔离级别，所有事务串行执行，不能幻读。 设置和获取事务隔离级别12Connection.getTransactionIsolation()Connection.setTransactionIsolation() MySQL的锁 排他锁X：与任何锁都冲突，等待。（写锁） 共享锁S：多个事务共享一把锁。其它事务不会被阻塞。（读锁）加锁方式 外部加锁：SQL语句 共享 select * from table lock in share mode 排他 select * from table for update 内部自动加锁 加锁粒度和策略：表锁table lock：开销少；行锁（row lock): innoDB MySQL所有的select读都是快照读。存储引擎Innodb实现了多版本控制（MVCC)，不加锁快照读。所以一个事务内部保证select数据一致要外部加锁 MVCC 在每行记录后面保存两个隐藏的列：行创建时间，过期时间。通过版本号记录时间，每开始新的事务，系统版本递增。 Update 对行加排他锁X 分析MySQL处理死锁：show engine innodb status Mybatis 底层基于JDBC SqlSessionFactory实例能将对象操作转换成数据库操作事务管理器transactionManager type = &quot;jdbcdataSource驱动、url、用户名、密码 对象类、操作接口 映射文件&lt;mapper namespace = &quot;操作接口&quot;&gt; 将映射文件加载到配置文件&lt;mappers&gt;&lt;mapper resource=&quot;&quot;&gt; 测试123456789101112131415161718192021public static void main(String[] args) &#123; // 1. 声明配置⽂文件的⺫⽬目录渎职 String resource = "confAnnotation.xml"; // 2. 加载应⽤用配置⽂文件 InputStream is = HelloMyBatisAnnotation.class.getClassLoader().getResourceAsStream(resource); // 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder() .build(is); // 4. 获取Session SqlSession session = sessionFactory.openSession(); try &#123; // 5. 获取操作类（接口） GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class); // 6. 完成查询操作 User user = getUserInfo.getUser(11); System.out.println(user.getId() + " " + user.getUserName() + " " + user.getCorp()); &#125; finally &#123; // 7.关闭Session session.close(); &#125; &#125; 在操作接口上用注解@select ResultMap 构造方法 mapper.xml1234567891011&lt;resultMap id="UserMap" type="com.micro.profession.mybatis.resultMapTest.User"&gt; &lt;constructor&gt; &lt;idArg column="userId" javaType="int" /&gt; &lt;arg column="userName" javaType="String" /&gt; &lt;arg column="corp" javaType="String" /&gt; &lt;/constructor&gt; &lt;collection&gt; &lt;association&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F04%2F04%2Fcanvas%2F</url>
    <content type="text"><![CDATA[创建1. canvas正确绘制时，标签内容会被忽略 不能在css中定大小123&lt;canvas id="canvas" width="800" height="600" style="border: 1px solid red;"&gt; 当前浏览器不持支Canvas&lt;/canvas&gt; 2. 判断当前浏览器12345678window.onload= function()&#123; var canvas = document.getElementById('canvas') if(canvas.getContext("2d")) &#123; var context = canvas.getContext('2d') &#125;else&#123; alert("当前浏览器不支持canvas") &#125; &#125; 3. 设置画布大小不需要px12canvas.width=1024canvas.height=768 4. 画路径:.colsePath不是封闭路径时 会自动封闭1.begin 重新规划2.close 自动封闭3..arc(圆心坐标x,y,半径r,开始弧度起始点,结束弧度起始点,是否逆时针false)12345678for(var i = 0;i&lt;10;i++)&#123; context.beginPath() context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10) //只使用beginPath不使用closePath就不会有封闭线段 context.closePath() context.stroke() //下一次.bgeinPath会重新规划路径&#125; 5. context.fill()会把边框内测一半像素覆盖，fill写在路径和stroke中间1234context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10)context.fillStyle= "yellow"context.fill()context.stroke() 6. 矩形 路径：.rect(左上角坐标x,y,width,height) 直接绘制： 填充、边框.fillRect(x,y,width,height).strokeRect(x,y,width,height) 7. 线条两端属性lineCapcontext.lineCap=&quot;round&quot; 超出原来的长度的部分是圆形context.lineCap=&quot;squre&quot; 8. 画星 5个角，一个角隔72° 大圆半径300，小圆半径150123456789context.beginPath()for(var i =0;i&lt;5;i++)&#123; context.lineTo(x=Math.cos((18+i*72)/180*Math.PI)*300+400, y=-Math.sin((18+i*72)/180*Math.PI)*300+400) context.lineTo(x=Math.cos((54+i*72)/180*Math.PI)*150+400, y=-Math.sin((54+i*72)/180*Math.PI)*150+400)&#125;context.stroke()context.closePath() 9. lineJoin 线段连接处bevel线条顶端不会衍生自然形成尖角，形成纸带折叠效果context.lineJoin=&quot;miter&quot; context.miterLimit=0.01内角和外角的最大值。超过则使用bevel显示 10. 保存绘图状态,图形变换时123context.save() context.translate(100,100)context.restore() 11. 与鼠标事件交互 down up out move1234567891011121314151617181920var isMouseDown = falsecanvas.onmousedown=function (e) &#123; e.preventDefault() isMouseDown= true&#125;canvas.onmouseup=function (e) &#123; e.preventDefault() isMouseDown= false&#125;//按着画布出画布也是不想画canvas.onmouseout=function (e) &#123; e.preventDefault() isMouseDown= false&#125;canvas.onmousemove=function (e) &#123; e.preventDefault() if(isMouseDown== true)&#123; 画图() &#125;&#125; preventDefault在pc端作用不大，移动端和键盘操作例如：小游戏中的角色运动：上下，同时是浏览器上下移动翻页操作 1. 转换鼠标位置为相对canvas内的位置1234 function window2canvas(x,y)&#123; var canvasbox = canvas.getBoundingClientRect() return &#123;x:Math.round(x-canvasbox.left),y:Math.round(y-canvasbox.top)&#125;&#125; 2. 鼠标移动在canvas上画 onmousemove执行频繁只要绘制直线就能达到曲线 设置变量记录上一个位置var lastLoc = {x:0,y:0} down时记录lastloc,move记录currentloc 123context.moveTo(lastLoc.x,lastLoc.y)context.lineTo(curloc.x,curloc.y) //context.stroke()lastLoc = curloc 平滑移动 12context.lineCap = "round"context.lineJoin = "round" 笔压:速度 = 距离/时间 距离 12function calculateDistance(loc1,loc2) &#123; return Math.sqrt((loc1.x-loc2.x)*(loc1.x-loc2.x)+(loc1.y-loc2.y)*(loc1.y-loc2.y))&#125; 时间var lastTimestamp =0 mouseover:var curstamp = new Date().getTime()var timedif = curstamp-lastTimestamp 宽度1234567891011121314151617function calLineWidth(t,s) &#123; var width var speed = s/t //1. 速度最小，宽度最大 if(speed&lt;=0.1) width= MAXWIDTH //2. 速度很大，宽度最小 else if (speed&gt;10) width = 1 //3. 中间宽度：（当前速度-最小速度）/（最大速度-最小速度）*宽度取值范围 else width = MAXWIDTH- (speed-0.1)/(10-0.1)*(MAXWIDTH-1) console.log(width) if (lastWidth==-1) return width else width = lastWidth*4/5+width*1/5 lastWidth = width return width &#125; 清除画布 context.clearRect(0,0,canvasWidth,canvasHeight) 12. 移动端自适应1234567&lt;meta name="viewport" content = "height = device-height, width = device-width, initial-scale = 1.0, minimum-scale = 1.0, maximum-scale = 1.0, user-scalable=no"/&gt; 13. 触控touch时间 start move end touch = e.touchs[0]从多点触控TouchList中获取touch clientX/Y -&gt;Y:568 pageX/Y -&gt;Y:650 将 e.x/y封装到point.x/y 1234567 canvas.addEventListener("touchmove",function(e)&#123; e.preventDefault() if(isMouseDown) touch = e.touches[0] moveStroke(&#123;x:touch.pageX,y:touch.pageY&#125;)&#125;)]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2018%2F04%2F02%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx1. 环境 基本库yum -y install gcc gcc-c++ autoconf pcr^Cpcre-devel make automake 工具yum -y install wget httpd-tools vim 确认yum源可用yum list|grep gcc 关闭iptables规则iptables -L iptables -F 停用selinuxgetenforce setenforce 0 cd /opt mkdir 重启 nginx -s reload IO多路复用 使用epoll模型Linux文件描述符 文件描述符（file descriptor 是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。sysctl -a|grep fs.file-max系统级别的最大打开文件数ulimit -n 单个进程最大打开文件数 每一个文件描述符会与一个打开文件相对应，不同的文件描述符也会指向同一个文件。 rpm -ql nginx rpm包有哪些配置文件/usr/share/nginx/html HSTS（HTTP Strict-Transport-Security） 是Web安全策略机制（web security policy mechanism）HSTS： 建立起HTTPS连接之前存在一次明文的HTTP请求和重定向（上图中的第1、2步），使得攻击者可以以中间人的方式劫持这次请求，从而进行后续的攻击，例如窃听数据，篡改请求和响应，跳转到钓鱼网站等。 攻击者直接劫持了HTTP请求，并返回了内容给浏览器，根本不给浏览器同真实网站建立HTTPS连接的机会 当用户让浏览器发起HTTP请求时，浏览器将其转换为HTTPS请求，直接略过上述的HTTP请求和重定向，从而使得中间人攻击失效，规避风险。 HSTS 响应 Header：让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload] max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。 ncludeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。 preload是可选参数，只有当申请将自己的域名加入到浏览器内置列表的时候才需要使用到它 对于启用了浏览器HSTS保护的网站，如果浏览器发现当前连接不安全，它将仅仅警告用户，而不再给用户提供是否继续访问的选择 第一次访问：Preload List： 在浏览器里内置一个列表，只要是在这个列表里的域名，无论何时、何种情况，浏览器都只使用HTTPS发起连接。这个列表由Google Chromium维护，FireFox、Safari、IE等主流浏览器均在使用。 nginx: hstsadd_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always; 一旦浏览器接收到HSTS Header（假如有效期是1年），但是网站的证书又恰好出了问题，那么用户将在接下来的1年时间内都无法访问到你的网站，直到证书错误被修复，或者用户主动清除浏览器缓存。先将max-age的值设置小一些]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密]]></title>
    <url>%2F2018%2F03%2F27%2Fcryption%2F</url>
    <content type="text"><![CDATA[安全java MDMD家族长128，MD2,MD5 JDK有实现 MD4（电驴)Bouncy Castle 报文摘要：固定长度的摘要 类似消息验证码MAC关键：找到两段内容不同而摘要相同的数据在计算上是不可能的 消息验证码MAC：计算过程用了密钥javax.crypto.Mac 数据用散列函数计算出消息验证码HMAC 消息验证码加载原始数据后 用密钥对整个数据加密后传输 数字签名security.Signature 用于验证身份A要验证B的身份： B用私钥对消息加密发送给A A用公钥解密 SSL协议 身份验证（钓鱼网站）数字签名证书 数据窃取：数据传输加密 数据串改：数据+消息验证码，接收者完整性验证流程 客户端向服务器确认SSL协议和加密算法。（可请求验证服务器身份） 服务器 发送数字签名给客户端 也可以向客户端验证身份 客户端用私钥对自己的数字证书加密发送给服务器。生成[数据传输]用的密钥，用服务器的公钥加密发送给服务器。（数据传输是对称加密，客服端和服务器使用相同密钥） 服务端验证完客户端身份，切换到数据传输直到关闭。 数字证书=身份信息+公钥。被信任机构的私钥加密，浏览器公钥验证证书合法。HTTPSRSA 非对称加密算法： 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 n = a*b(a，b质数) n-&gt;二进制位数为密钥长度（1024） 计算n的欧拉函数φ(n) 选择65537 or 其它小于φ(n)并与φ(n)互质的整数e 计算e对φ(n)的【模反元素】dex + φ(n)y = 1求解数对x,y中的x扩展欧几里得 (n,e)为公钥(n,d)为私钥 当n被因式分解，d可以算出 被破解 AES安全漏洞Network-Doc http请求 Referer 防止CSRF漏洞 http响应 302 跳转 Location:跳转地址 Set-Cookie:颁发凭证 Application 查看Cookie BOM document.cookie 添加cookie document.cookie=”aaaa” window.location.href获取页面URL window.navigator.userAgent 获取浏览器信息 window.open(“http://baidu.com&quot;) 打开页面 XSS漏洞测试prompt(,)提示弹窗 WEB服务架构 SQL union 连接两个select 不显示重复的；union all socket路径：show global variables like ‘socket’; 客户端：XSS(跨站脚本注入):CSRF(跨站请求伪造) 点击劫持，URL跳转服务端：SQL注入 命令注入 文件类操作 XSS漏洞：Cross Site Script存储型 反射型 DOM型 存储型 &lt;img src=&quot;#&quot; onerror=&quot;alert()&quot;&gt;写在评论框，发送给后台 图片加载失败触发onerror事件 XSS 脚本存储在数据库中 反射型 后端写入url的参数中 ?name = &lt;image src = @ onerror= alert()&gt; DOM型window.location.hashurl的hash中#后面的值填到innerHTML CSRF（XSRF）用已登录身份以用户名义非法操作&lt;body onload = &quot;sbm()&quot;页面加载自动提交表单smt(){ .getbyID(&quot;id&quot;).submit()调用表单提交form表单提交有明显页面跳转，将恶意页面用iframe嵌入 width,height=0防止触发查看源代码： view-source:url 点击劫持 UI覆盖攻击用iframe设置height,width:100%,opaocity:0;z-index=2;将iframe上的提交按钮隐藏在页面按钮之下 url页面跳转META跳转 等待5秒后跳转?url = 短链接1&lt;meta http-equiv = "Refresh" content = "5;url&lt;?php echo $url?&gt;" SQL注入mysql注释--闭合、注释 where name = ‘admin&#39;-- and passwd = ‘’数据和代码未分离 union 查看mysql版本 2. 用户名和密码 DOS命令 net user用户名]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apriori_FP]]></title>
    <url>%2F2018%2F03%2F24%2FApriori-FP%2F</url>
    <content type="text"><![CDATA[Apriori 算法 频繁项集：经常出现在一块的物品的集合； 关联规则（association rules）暗示两种物品之间可能存在很强的关系。 频繁的定义：支持度、可信度 支持度：项集{豆奶，尿布}在记录中的出现频率有多少比例的交易记录包含该集合 confidentce： 关联规则{尿布}-&gt;{葡萄酒}的可信度为：“支持度({尿布, 葡萄酒})/支持度({尿布})”。 表示对于包含”尿布”的规则，规则对其中（可信度）%的记录适用。 原理 假设想找到支持度大于0.8的所有项集；4种物品的集合要遍历数据15次 对于包含N种物品的数据集共有2N-1种项集组合。 连线表明两个或者更多集合可以组合成一个更大集合 某个项集是频繁的，那么它的所有子集也是频繁的 算法 发现频繁项集：输入：最小支持度，数据集 生成候选集 从{1个元素集合}计数数据集中出现次数 算每个元素出现频次，超出阈值的保留 按计算k=2;k-2求k-2个项相同的并集 12a[:k-2]==b[:k-2].append(a|b)#|set的并，出现在a或b中的元素#a.union(b) 计算{2个元素的集合}的频率(1、2) //+1个元素的集合 当3.的并集为空 得到 #L[0] 1项的频繁集[1]两项 [2]3项的 [3]4 [4]空集#都是支持度超过support的子集 关联规则： 有一个频繁项集{豆奶, 莴苣}，那么就可能有一条关联规则“豆奶 ➞ 莴苣”。P ➞ H的可信度定义为support(P | H)/support(P)。 生成一个可能的规则列表，然后测试每条规则的可信度。如果可信度不满足最小要求，则去掉该规则。 从一个频繁项集开始，接着创建一个规则列表，其中规则右部只包含一个元素，然后对这些规则进行测试。接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。这种方法也被称作分级法。 FP-growth FP树-频繁集-自动补全 FP只需要对数据库进行两次扫描，Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁， FP树（频繁模式（Frequent Pattern））编码数据集 一个元素项可以在一棵FP树中出现多次。 FP树会存储项集的出现频率，而每个项集会以路径的方式存储在树中。 存在相似元素的集合会共享树的一部分。 算法 对原始数据集扫描两遍。第一遍对所有元素项的出现次数进行计数。 只考虑频繁元素]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alg]]></title>
    <url>%2F2018%2F03%2F24%2Falg%2F</url>
    <content type="text"><![CDATA[刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://blog.csdn.net/v_july_v/article/details/6803368https://www.cnblogs.com/JuneWang/p/3773880.html https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001 https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html 笔试题todohttps://www.nowcoder.com/test/4575457/summary 火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼 3节车厢，按照1，2，3依次入轨编组，可以在左边形成1 2 3，1 3 2，2 1 3，2 3 1，321。问1-2-3-4能否编程4，1，3，2 123456789101112131415161718//假设序列是1,2,3,4public static void main(String[] args) &#123; int[] train = &#123;4,1,3,2&#125;; boolean flag = false; int m = train.length; for (int i = 0; i &lt; m ; i++) &#123; for (int j = i+1; j &lt; m; j++) &#123; for (int k = j+1; k &lt; m ; k++) &#123; if(train[i]&gt;train[j]&amp;&amp;train[i]&gt;train[k]&amp;&amp;train[k]&gt;train[j])&#123; flag = true; break; &#125; &#125; &#125; &#125; if(!flag) System.out.println("Yes"); else System.out.println("No");&#125; 区间dplt476石子合并 区间dp 有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小in : 4 1 1 4 out: 18 二叉树深度1234public int maxDepth(TreeNode root) &#123; if(root== null)return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1;&#125; dfs12 bfs12345678910111213141516public static int maxDepth(TreeNode root) &#123; if(root == null)return 0; Deque&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); que.add(root); int cnt = 0; while (!que.isEmpty())&#123; int size = que.size(); while (size--&gt;0)&#123; TreeNode cur = que.poll(); if(cur.left!=null)que.add(cur.left); if(cur.right!=null)que.add(cur.right); &#125; cnt++; &#125; return cnt;&#125; lc84直方图中的最大矩形poj25591//todo next 矩阵乘法相关题目：http://www.matrix67.com/blog/archives/276 poj3734790 L型，XX型骨牌覆盖2xN的board Input: 3Output: 5Explanation:The five different ways are listed below, different letters indicates different tiles:XYZ XXZ XYY XXY XYYXYZ YYZ XZZ XYY XXY 1.如果只XX骨牌dp[i] 表示N = i的时候有多少种解其实是费fib数列 poj 2411http://poj.org/problem?id=2411输入：大矩阵的h高，和w宽输出:用宽2，高1的骨牌一共有多少种拼法 图中长度为k的路径计数https://www.nowcoder.com/acm/contest/185/B 求出从 1 号点 到 n 号点长度为k的路径的数目. 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.Scanner;public class Main &#123; //AC// final static int M = 10000; public static long[][] mul(long[][] A,long[][] B)&#123; long[][] rst = new long[A.length][B[0].length]; for (int i = 0; i &lt;A.length ; i++) &#123; for (int k = 0; k &lt;B.length ; k++) &#123; for (int j = 0; j &lt;B[0].length ; j++) &#123; rst[i][j] = (rst[i][j]+A[i][k]*B[k][j]); &#125; &#125; &#125; return rst; &#125; public static long[][] pow(long[][] A,int n)&#123; long[][] rst =new long[A.length][A.length]; for (int i = 0; i &lt;A.length ; i++) &#123; rst[i][i] = 1; &#125; while (n&gt;0)&#123; if((n&amp;1)!=0)&#123; rst = mul(rst,A ); &#125; A = mul(A, A); n&gt;&gt;=1; &#125; return rst; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = sc.nextInt(); long[][] graph = new long[n][n]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;n ; j++) &#123; graph[i][j] = sc.nextInt(); &#125; &#125; long[][] Gn = pow(graph, k); System.out.println(Gn[0][n-1]); &#125;&#125; 有向图 从A点走K步到达B(边可重复)的方案数G[u][v]表示u到v 长度为k的路径数量k=1 1条边可达的点 G1是图的邻接矩阵 快速幂logN完成幂运算carmichael number12//this^exponent mod mpublic BigInteger modPow(BigInteger exponent, BigInteger m) 递推公式实际上求m项地推公式的第n项 可以用初项线性表示，通过快速幂O(m^2logn) fibo递推公式特征方程1.二阶递推公式的特征方程递推公式Xn = aXn-1 - bXn-2特征方程x^2-ax+b =0解得x1,x2则存在F(n) = Ax1+Bx2带入F(0),F(1) 可得通项 2.矩阵解法二阶递推式存在2x2矩阵A 矩阵乘法：123456789101112final int M = 10000;public int[][] mul(int[][] A,int[][] B)&#123; int[][] rst = new int[A.length][B[0].length]; for (int i = 0; i &lt;A.length ; i++) &#123; for (int k = 0; k &lt;B.length ; k++) &#123; for (int j = 0; j &lt;B[0].length ; j++) &#123; rst[i][j] = (rst[i][j]+A[i][k]*B[k][j])%M; &#125; &#125; &#125; return rst;&#125; 快速幂，将n用二进制表示，5-&gt;101表示A^5 = A^4+A^1,A每次翻倍，n一直右移，n最右为1的时候加上当前A翻倍的结果。矩阵的幂1234567891011121314public int[][] pow(int[][] A,int n)&#123; int[][] rst =new int[A.length][A.length]; for (int i = 0; i &lt;A.length ; i++) &#123; rst[i][i] = 1; &#125; //for(;n&gt;0;n&gt;&gt;=1) while (n&gt;0)&#123; //快速幂 if((n&amp;1)!=0)rst = mul(rst,A ); A = mul(A, A); n&gt;&gt;=1; &#125; return rst;&#125; 解fibo：123int[][] A = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;int[][] rst = sl.pow(A, n);System.out.println(rst[1][0]); 763 划分尽可能多字母区间 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。ababcba 从第一个a到最后一个a是必须包含的长度 123456789101112131415161718192021//45%public List&lt;Integer&gt; partitionLabels(String S) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); //每个字母最后出现的index int[] last = new int[26]; for(int i=0;i&lt;S.length();i++)&#123; last[S.charAt(i)-'a'] = i; &#125; int start=0,end=0; for(int i = 0;i&lt;S.length();i++)&#123; //更新当前字母的区间 end = Math.max(end,last[S.charAt(i)-'a']); //关键 if(i==end)&#123; rst.add(end-start+1); start = end+1; &#125; &#125; return rst;&#125; 769 0-n的排列切割，块排序后连接是排序的原数组 输入: arr = [1,0,2,3,4]输出: 4解释:我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。 1234idx:0 1 2 3 4arr:1 0 2 3 4max:0 1 2 3 4当前index==当前max 表示可以切分 12345678public int maxChunksToSorted(int[] arr) &#123; int res = 0; for(int i =0,max = 0;i&lt;arr.length;i++)&#123; if(i==(max=Math.max(max,arr[i]))) res++; &#125; return res;&#125; 768532 数组中有几个相差k的pair 输入: [3, 1, 4, 1, 5], k = 2输出: 2解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。 set的解法33% //todo比双指针慢 15 3sum a + b + c = 0 Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 关键：去重技巧1234567891011121314151617181920212223//75%public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num.length-2; i++) &#123; //关键去重 if(i==0||(i&gt;0&amp;&amp;num[i]!=num[i-1]))&#123; int lo = i+1,hi=num.length-1,sum = 0-num[i]; //关键 while (lo&lt;hi)&#123; if(num[lo]+num[hi] == sum)&#123; res.add(Arrays.asList(num[i],num[lo],num[hi])); //去重 while (lo&lt;hi&amp;&amp;num[lo]==num[lo+1])lo++; while (lo&lt;hi&amp;&amp;num[hi]==num[hi-1])hi--; lo++;hi--; &#125;else if(num[lo]+num[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res;&#125; 16 3sum 最接近target的值//todo nexttime 18 4sum 外层for 用3sum找target-nums[i]454 4 sum 2 poj2785 4 Values whose Sum is 0用poj的方法11%4个分别有n个数字的数组ABCD，每个数组中取一个，合为0的组合数。c+d = -a-b从A,B中找出n^2种组合，从C,D中找出n^2种组合，排序二分找到lowerbound和upbound。 正确方法：计算c+d的时候放入hashmap计数12345678910111213141516public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt;C.length ; i++) &#123; for (int j = 0; j &lt;D.length ; j++) &#123; int sum = C[i] + D[j]; map.put(sum,map.getOrDefault(sum,0 )+1 ); &#125; &#125; int res = 0; for (int i = 0; i &lt;A.length ; i++) &#123; for (int j = 0; j &lt;B.length ; j++) &#123; res += map.getOrDefault(-(A[i]+B[j]),0 ); &#125; &#125; return res;&#125; 914 相同数字的牌划分成一组，每组数量相同 能否划分 输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 计数，求最大公约数123456789101112public boolean hasGroupsSizeX(int[] deck) &#123; if(deck==null||deck.length&lt;2)return false; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); int res = 0; for (int i : deck) count.put(i, count.getOrDefault(i, 0) + 1); for (int i : count.values()) res = gcd(i, res); return res &gt; 1;&#125;public int gcd(int a, int b) &#123; return b &gt; 0 ? gcd(b, a % b) : a;&#125; 915 Max(left)&lt;=Min(right)画折线图，当前A[i]&lt;left 则把切分线抬到globalMax7ms 60%12345678910111213public int partitionDisjoint(int[] A) &#123; int n = A.length; int leftMax = A[0]; int global = leftMax; int parti = 0; for(int i = 1;i&lt;n;i++)&#123; if(leftMax&gt;A[i])&#123; leftMax = global; parti = i; &#125;else global = Math.max(global,A[i]); &#125; return parti+1;&#125; 916 b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称单词 b 是单词 a 的子集。 例如，“wrr” 是 “warrior” 的子集，但不是 “world” 7 整数反转 integer越界展开代码 123456789101112public int reverse(int x) &#123; int flag = x&lt;0?-1:1; int rst = 0; while(x!=0)&#123; int add = x%10; x/=10; if(rst&gt;Integer.MAX_VALUE/10||(rst==Integer.MAX_VALUE/10&amp;&amp;add&gt;7))return 0; if(rst&lt;Integer.MIN_VALUE/10||(rst==Integer.MIN_VALUE/10&amp;&amp;add&lt;-8))return 0; rst = rst*10+add; &#125; return rst;&#125; 319 n个灯泡 n轮开关初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 输入: 3输出: 1解释:初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。123int bulbSwitch(int n) &#123; return sqrt(n);&#125; 被按奇数下的灯泡还亮着。当第d轮可以整除i灯泡i被按下。所以如果i有奇个除数，则最后是开的。例如12， 451 字符串按频率排序 桶排序lt168 吹气球每次吹气球i可以得到的分数为 nums[left] * nums[i] * nums[right]， in [4, 1, 5, 10]out 返回 27012345nums = [4, 1, 5, 10] burst 1, 得分 4 * 1 * 5 = 20nums = [4, 5, 10] burst 5, 得分 4 * 5 * 10 = 200 nums = [4, 10] burst 4, 得分 1 * 4 * 10 = 40nums = [10] burst 10, 得分 1 * 10 * 1 = 10总共的分数为 20 + 200 + 40 + 10 = 270 矩阵链乘法O(n^3)的dpinterval max overLaphttps://www.geeksforgeeks.org/find-the-point-where-maximum-intervals-overlap/1234567891011121314151617 arr[] = &#123;1, 2, 10, 5, 5&#125; dep[] = &#123;4, 5, 12, 9, 12&#125;Below are all events sorted by time. Note that in sorting, if twoevents have same time, then arrival is preferred over exit. Time Event Type Total Number of Guests Present------------------------------------------------------------ 1 Arrival 1 2 Arrival 2 4 Exit 1 5 Arrival 2 5 Arrival 3 // Max Guests 5 Exit 2 9 Exit 1 10 Arrival 2 12 Exit 1 12 Exit 0 最大值为k的不重叠子数组的长度和？??https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/ Input : arr[] = {2, 1, 4, 9, 2, 3, 8, 3, 4} k = 4Output : 5{2, 1, 4} =&gt; Length = 3{3, 4} =&gt; Length = 2So, 3 + 2 = 5 is the answer 123456789101112131415161718public int lensum(int[] arr,int k)&#123; int n = arr.length; int ans = 0; for (int i = 0; i &lt; n ; i++) &#123; int cnt=0; int flag = 0; while (i&lt;n&amp;&amp;arr[i]&lt;=k)&#123; cnt++; if(arr[i] == k)flag = 1; i++; &#125; //？？？ if(flag == 1) ans+=cnt; while (i&lt;n&amp;&amp;arr[i]&gt;k)i++; &#125; return ans;&#125; 689!!!高频题 找到三个长度为k互不重叠的子数组的最大和 Input: [1,2,1,2,6,7,5,1], 2不重叠窗口为2的数组的和 [1, 2], [2, 6], [7, 5]返回 起始索引为 [0, 3, 5]。也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。 https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/ 121 只能买卖一次 买卖股票的利润 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 方法1：两次for，找最大差值 10% 262ms方法2：Kadane算法(maximum subarray)先找到最低值，保留并更新最低值，并更新最大差值 2ms 36% 12345678910public int maxProfit(int[] prices)&#123; int minP = Integer.MAX_VALUE; int maxP = 0; int n = prices.length; for(int i =0;i&lt;n;i++)&#123; if(prices[i]&lt;minP)minP = prices[i]; else if(prices[i]-minP&gt;maxP)maxP = prices[i]-minP; &#125; return maxP;&#125; dp 保留前i天的最低值 更新第i天的最大差值 3ms 19%1234567891011121314 public int maxProfit(int[] prices) &#123; int n = prices.length; if(n&lt;1)return 0; int[] mindp = new int[n]; int[] maxdp = new int[n]; mindp[0] = prices[0]; maxdp[0] =0; for(int i =1;i&lt;n;i++)&#123; mindp[i] = Math.min(mindp[i-1],prices[i]); //当天的股价-前i-1天的min价格 maxdp[i] = Math.max(maxdp[i-1],prices[i]-mindp[i-1]); &#125; return maxdp[n-1];&#125; dp2: 4 ms 15%转换成53 将price reduce成每天的收益[7,1,5,3,6,4]-&gt;[ ,-6,4,-2,3,-2]在[4,-2,3]持有股票，从day2 [1]买进后的累积和最大123456789101112131415```#### 53!!!最大subarray sumKadane 14ms 19%```javapublic int maxSubArray(int[] nums)&#123; int sum = nums[0],rst = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; sum = Math.max(nums[i],sum+nums[i]); rst = Math.max(rst,sum); &#125; return rst;&#125; greedy: 122 可以买卖多次 买股票的利润 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 123 最多买卖2次的 买股票利润 考到 输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 188 最多k次买卖的 买卖股票利润 输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 重复元素很多的数组排序https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/ AVL or Red-Black to sort in O(n Log m) time where m is number of distinct elements.//todo 621 todo26 种不同种类的任务 每个任务都可以在 1 个单位时间内执行完两个相同种类的任务之间必须有长度为 n 的冷却时间 输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2输出: 8 执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 516 最长回文子序列Rearrange a stringhttps://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/ !!386 字典序数字 tododfs 112ms 71%123 1 2 3 ... /\ /\ /\10 ...19 20...29 30...39 .... 1234567891011121314151617public List&lt;Integer&gt; lexicalOrder(int n) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 10; i++) &#123; dfs(rst,n,i); &#125; return rst;&#125;private void dfs(List&lt;Integer&gt; rst,int n,int cur)&#123; if(cur&gt;n)return; else&#123; rst.add(cur); for (int i = 0; i &lt;10 ; i++) &#123; if(cur*10+i&gt;n)return; dfs(rst,n,10*cur+i); &#125; &#125;&#125; 相关：permutation的字典序思想：字典序全排列算法：保证尽可能长的前缀不变，后缀慢慢增加 abc 保证前面不变，后面增加一点点 -&gt; acb ，cb不能增大了，-&gt;bac 从右向左扫描 例如 321 是递增的 表示不能再增加 从右向左扫描到第一次增大的位置，和右边比较大的数交换。1 2 3 扫描到2，和3交换。 1 3 2 扫描到1降了，1和2交换 2 3 1 31不是最小后缀 变成2 1 3 算法： 1.从右想左 找到第一次下降位置 2.用后缀中比当前位置大的最小数字交换 3.保证后缀最小（翻转？） 636日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：”0:start:0” 表示函数 0 从 0 时刻开始运行。”0:end:0” 表示函数 0 在 0 时刻结束。 函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。 输入 n = 2logs =[“0:start:0”, “1:start:2”, “1:end:5”, “0:end:6”]输出：[3, 4] 函数 0 在时刻 0 开始，在执行了 2个时间单位结束于时刻 1。现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。 stack + start[] ac 15% 378 矩阵从左到右从上到下有序，找第k小的元素1.全部放进k大的PriorityQueue,最后poll掉k-1个，return peek 28%123456789101112public int kthSmallest(int[][] matrix, int k) &#123; PriorityQueue&lt;Integer&gt; que = new PriorityQueue(k); for(int[] row:matrix)&#123; for(int x :row)&#123; que.add(x); &#125; &#125; for(int i = 0;i&lt;k-1;i++)&#123; que.poll(); &#125; return que.peek();&#125; 2. 373概率生成函数 概率母函数1.x的系数是a1,a2,…an 的单个组合的全体。 x^2的系数是a1,a2,…a2的两个组合的全体。………n. x^n的系数是a1,a2,….an的n个组合的全体（只有1个）。 有1克、2克、3克、4克的砝码各一枚，能称出哪几种重量？每种重量各有几种可能方案？ 设x表示砝码，x的指数表示砝码的重量1个1克的砝码可以用函数1+1x^1表示，1个2克的砝码可以用函数1+1x^2表示，1个3克的砝码可以用函数1+1x^3表示，1个4克的砝码可以用函数1+1x^4表示， 1表示数量0个例如1个2克的砝码：1+x^21其实应该写为：1*x^0,即1代表重量为2的砝码数量为0个。 系数表示状态数（方案数）1+x^2，也就是1x^0 + 1x^2，不取2克砝码，有1种状态；或者取2克砝码，也有1种状态。 (1+x)(1+x^2)(1+x^3)(1+x^4)=(1+x+x^2+x^4)(1+x^3+^4+x^7)=1 + x + x^2 + 2x^3 + 2x^4 + 2x^5 + 2x^6 + 2x^7 + x^8 + x^9 + x^10从上面的函数知道：可称出从1克到10克，系数便是方案数。有2x^5 项，即称出5克的方案有2种：5=3+2=4+1； 求用1分、2分、3分的邮票贴出不同数值的方案数：每种是无限的。 分配问题及应用 硬币相关问题http://www.raychase.net/3144正正反 甲赢 正反反 乙赢 Penney’s game 使用长度为3字节的序列，玩家B相对玩家A有优势。这是因为这个游戏是一个非传递博弈，所以无论如何选定第一个序列，总会有一个序列有更大的获胜概率。 反反正:正反反 = 1：3因为只要出现一次正，想得到反反正的人就必输了，他肯定得先看到两次反，我就得到正反反了。两个硬币4种情况有3种有正 正正反：反正正 = 1：3只要出现一次反，反正正就赢了。 正反反HTT：正正反HHT = 1:2反正正thh:反反正tth = 1：2 https://en.wikipedia.org/wiki/Penney%27s_game对于二号玩家：1-2-3 -&gt; (not-2)-1-2第一个字节与1号玩家的第二个字节相反，第二个字节与1号玩家的第一个字节相同，第三个字节与1号玩家的第二个字节相同。 http://www.matrix67.com/blog/archives/3638 所有 1 都不相邻的 k 位 01 串有 Fk+2 个 Fi 表示 Fibonacci 数列中的第 i 项 抛掷第 k 次才出现连续两个正面”的意思就是， k 位 01 串的末三位是 011，并且前面 k – 3 位中的数字 1 都不相邻。 k-3位的01不相邻的串有F(k-1)个 平均需要抛掷多少次硬币，才会首次出现连续的 n 个正面？ 答案是 2^(n+1) – 2神奇的模式概率与“鞅”//todohttp://www.math-engineering.uestc.edu.cn/模式的平均等待时间：模式 HHHHHH 的平均等待时间 126 扔硬币直到连续两次出现正面，求扔的期望次数 • 扔到的是反面，那么还期望抛 E 次，因为抛到反面完全没用，总数就期望抛 E+1，所以是0.5(1 + E)• 扔到的是正面，如果下一次是反面，那么相当于重头来过，总数就期望抛，则是0.25(2 + E)• 扔到两次，都是正面，总数是 2，则是0.252所以递归来看E = 0.5(1 + E) + 0.25(2 + E) + 0.252，解得E = 6 A赢： 先正后反， B赢 连续两次反面：A胜的概率 3/4 B 赢概率是1/2*1/2 = 1/4 多重排列：pingpang中有重复2个p 2个n 2个g 标记为p1p2n1n2g1g2ia 全排列个数是8! p的重复度 为p1p2的全排列 2! P(N,r1,r2…rt) 标记为P(8;2,2,2,1,1) P(8;2,2,2,1,1)*2!*2!*2! = 8! 理解二项式定理(a+b)^n通项是a^k b^(n-k) 前面的系数表示 n个数的可重排列，a有k个，b有n-k个 不仅是二项式通项是a1^(r1) a2^(r2) at^(rt)(x1+x2+…+xm)^n 展开式的项数等于C(n+m-1,n). 有6个洞 编号1-9个球，求球入洞的方案数 隔板法： 划分6个洞需要5个隔板，用1~9填充隔板的空间。变成5个隔板和9个球的全排列。 5个隔板是相同的，P（14,5,1,1,1,1,1,1,1,1,1,1) = 14!/5! 另一种方法： 1号球可以放6个位置 1号球等于把空间又划分成了1前和1后，2球有5+2种可能 同理 3号球有7-1+2 =8个可能… 6乘到14 = 14!/5! 52张牌分发给4个人，每人13张，问每人有一张A的概率有多少？10.55% 52张牌分发给4个人，每人13张的方法数为52！/(13!)^4 。每人发一张A的方法数为4！* 48！/(12!)^4 . 4个相同的桔子和6个不同的苹果放到5个不同的盒子中，问每个盒子里有2个水果的概率有多大？7.4% 把4个相同桔子放入5个不同盒子的放法数为C(5,4),把6个不同苹果放入5个不同盒子的放法数为5^6 .因此总的分配方法数为C(5,4)*5^6 . 每个盒子有2个水果，有如下三种情况：1、（AA)(AA)(AA)(OO)(OO)C(5,2)6!/2!/2!/2!2、AA)(AA)(OA)(OA)(OO)C(5,1)\C(4,2)*6!/2!/2!3.（AA)(OA)(OA)(OA)(OA)C(5,4)*6!/2! 将n个不同的球放入编号为1,2,…,k的k个盒子中，试求： 第一个盒子是空盒的概率: 第一个盒子是空盒的方案数为(k－1) n 。 设k≥n,求n个球落入n个不同盒子的概率: n个球落入n个不同盒子的方案数为C(k,n)n!。 第一盒或第二盒两盒中至少一个是空盒的概率。该方案数为第一个盒子是空盒的方案数加上第二个盒子是空盒的方案数，再减去两个盒子都是空盒的方案数。 随机地将15名插班生分配到三个班级，每班各5名。设15名插班生中有3为女生。试求：将15名插班生分配到三个班级，每班各5名的方案数为C(15,5)C(10,5)C(5,5)=15!/(5!5!5!)。 每一个班级分到一名女生的概率:3!*12!/(4!4!4!) 三名女生分到同一班的概率: 3*12!/(5!5!2!) 649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。 输入: “RD”输出: “Radiant”解释: 第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人 输入: “RDD”输出: “Dire”解释:第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 495 给定攻击时间和中毒状态持续时间，问中毒状态总时长 Input: [1,2], 2Output: 3 (1-2-4) 8ms12345678910public int findPoisonedDuration(int[] timeSeries, int duration) &#123; if(timeSeries==null||timeSeries.length&lt;1||duration==0)return 0; int rst = 0; for(int i =0;i&lt;timeSeries.length-1;i++)&#123; //每次取间隔或者duration rst += Math.min(duration,timeSeries[i+1]-timeSeries[i]); &#125; rst += duration; return rst;&#125; //todo again按 区间的做法：100% 4ms12345678910111213141516public int findPoisonedDuration(int[] timeSeries, int duration) &#123; if(timeSeries==null||timeSeries.length&lt;1||duration==0)return 0; int rst = 0; int start = timeSeries[0]; int end = timeSeries[0]+duration; for(int i = 1;i&lt;timeSeries.length;i++)&#123; //Input: [1,4], 2 if(timeSeries[i]&gt;end)&#123; result += (end-start); start = timeSeries[i]; &#125; end = timeSeries[i]+duration; &#125; result+=(end-start); return result;&#125; 899 操作字符串前k个字符放到最后 输出字典序最小的 Input: S = “cba”, K = 1Output: “acb” Input: S = “baaca”, K = 3Output: “aaabc”Explanation:In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”. 当k=1 字符串只能旋转当k&gt;1的时候，固定第一位，可以把后面任意一位转到第二位，即确定第一位，可以和后面所有数字比较，然后放到最后，冒泡排序。 77combinations C(n,k)=C(n-1,k-1)+C(n-1,k)C(n-1,k-1)表示选这个数，C(n-1,k)表示不选这个数88%的写法：1234567891011121314public List&lt;List&lt;Integer&gt;&gt; combineFast(int n,int k) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(k&gt;n||k&lt;0)return result; if(k==0)&#123; result.add(new ArrayList&lt;&gt;()); return result; &#125; result = combine(n-1,k-1 ); for(List&lt;Integer&gt; list:result)&#123; list.add(n); &#125; result.addAll(combine(n-1,k )); return result;&#125; 1234567891011121314// math 8% C(n,k)=C(n-1,k-1)+C(n-1,k)public List&lt;List&lt;Integer&gt;&gt; combineMath(int n,int k)&#123; if(k==n||k==0)&#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;=k ; i++) &#123; row.add(i); &#125; return new ArrayList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combineMath(n-1,k-1 ); result.forEach(e-&gt;e.add(n)); result.addAll(this.combineMath(n-1,k )); return result;&#125; 24两个一组交换链表NqueenBBN – 1’ in the backslash code is there to ensure that the codes are never negative because we will be using the codes as indices in an array.123456789slash / 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 2 3 4 5 6 7 8 9 3 4 5 6 7 8 9 10 4 5 6 7 8 9 10 11 5 6 7 8 9 10 11 12 6 7 8 9 10 11 12 13 7 8 9 10 11 12 13 14 123456789backslash \ 7 6 5 4 3 2 1 0 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 10 9 8 7 6 5 4 3 11 10 9 8 7 6 5 4 12 11 10 9 8 7 6 5 13 12 11 10 9 8 7 6 14 13 12 11 10 9 8 7 123456for (int r = 0; r &lt;N ; r++) &#123; for (int c = 0; c &lt;N ; c++) &#123; slashCode[r][c]=r+c; backslashCode[r][c]=r-c+(N-1); &#125;&#125; bb 5ms 78%123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int[][] slashCode, backslashCode;//记录这个code是不是已经占用了boolean[] rowocc;boolean[] slashocc,backslashocc;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; rst = new ArrayList&lt;&gt;(); int[][] board = new int[n][n]; slashCode = new int[n][n]; backslashCode = new int[n][n]; rowocc = new boolean[n]; slashocc = new boolean[2*n-1]; backslashocc = new boolean[2*n-1]; for (int r = 0; r &lt;n ; r++) &#123; for (int c = 0; c &lt;n ; c++) &#123; slashCode[r][c]=r+c; backslashCode[r][c]=r-c+(n-1); &#125; &#125; nqueen(rst,0,n,board); return rst;&#125;private List&lt;String&gt; addBoard(int[][] board)&#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); for(int[] row:board)&#123; StringBuilder sb = new StringBuilder(); for(int i:row)&#123; sb.append((i==0?".":"Q")); &#125; rst.add(sb.toString()); &#125; return rst;&#125;boolean isSafe(int[][] board,int row, int col)&#123; if (slashocc[slashCode[row][col]] || backslashocc[backslashCode[row][col]] || rowocc[row]) return false; return true;&#125;private void nqueen(List&lt;List&lt;String&gt;&gt; rst,int col,int n,int[][] board)&#123; if(col&gt;=n)&#123; rst.add(addBoard(board)); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(isSafe(board,i,col))&#123; board[i][col] = 1; rowocc[i] = true; slashocc[slashCode[i][col]] = true; backslashocc[backslashCode[i][col]] = true; nqueen(rst,col+1,n,board); rowocc[i] = false; slashocc[slashCode[i][col]] = false; backslashocc[backslashCode[i][col]] = false; board[i][col] =0; &#125; &#125;&#125; check whether slash code ( j + i ) or backslash code ( j – i + 7 ) are used (keep two arrays that will tell us which diagonals are occupied). 179 一组非负数，拼接成最大的正整数 Input: [10,2]Output: “210” String s1 = “9”;String s2 = “31”; String case1 = s1 + s2; // 931String case2 = s2 + s1; // 319 String concatenation may be O(n^2) in Java (depends on if the compiler optimizes). Using StringBuilder is O(n). 12345678910111213141516public String largestNumber(int[] nums) &#123; if(nums==null||nums.length&lt;1)return ""; String[] strs = new String[nums.length]; //变成String数组 for (int i = 0; i &lt;nums.length ; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; //关键 Arrays.sort(strs,(a,b)-&gt;(b+a).compareTo(a+b)); if(strs[0].equals("0"))return "0"; StringBuilder sb = new StringBuilder(); for(String str:strs)&#123; sb.append(str); &#125; return sb.toString();&#125; 500 判断字符串是不是在键盘的同一行流： 正则很慢 流也很慢123public String[] findWords(String[] words)&#123; return Stream.of(words).parallel().filter(s-&gt;s.toLowerCase().matches("[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*")).toArray(String[]::new);&#125; 42683 - K Empty Slots最长01串倒水问题 BFSpoj 3414 Potshttp://poj.org/problem?id=3414 输入：3 5 4输出容量A3 B5 获得4升水的最短序列6FILL(2)POUR(2,1)DROP(1)POUR(2,1)FILL(2)POUR(2,1) Accepted 3128K 1125MS Java 3840B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class pathNode&#123; int a,b; int t; public pathNode(int a, int b, int t) &#123; this.a = a; this.b = b; this.t = t; &#125;&#125;class Cell&#123; int a,b; public Cell(int a, int b) &#123; this.a = a; this.b = b; &#125;&#125;void Bfs(int A,int B,int C)&#123; int cnt = 0; int[][] marked = new int[A+1][B+1]; pathNode[] pathNodes = new pathNode[A+B+5]; int[][] pre = new int[A+1][B+1]; Deque&lt;Cell&gt; que = new ArrayDeque&lt;Cell&gt;(); //初始状态 2个空桶 que.add(new Cell(0,0)); marked[0][0] = 1; while (!que.isEmpty())&#123; Cell cell = que.poll(); int a = cell.a,b = cell.b; //6种操作 满，空，互相倒 x2 for (int d = 0; d &lt;6 ; d++) &#123; int na=0,nb=0; //装满A if(d==0)&#123;na=A;nb=b;&#125; else if(d==1)&#123;na= a;nb=B;&#125; else if(d==2)&#123;na=0;nb=b;&#125; else if(d==3)&#123;na=a; nb=0;&#125; //A-&gt;B else if(d==4)&#123; int all = a+b; na = all&gt;=B?all-B:0; nb = all&gt;=B?B:all; &#125; //B-&gt;A else if(d==5)&#123; int all = a+b; na = all&gt;=A?A:all; nb = all&gt;=A?all-A:0; &#125; //这个桶状态没试过 if(marked[na][nb]==0)&#123; marked[na][nb] =1; //关键：记录当前操作序号cnt是在node(a,b)是做d操作得来的 pathNodes[cnt] = new pathNode(a,b,d); //可以查到对上一个的操作 pre[na][nb] = cnt; cnt++; if(na == C||nb==C)&#123; Deque&lt;Integer&gt; op = new ArrayDeque&lt;Integer&gt;(); int enda = na,endb = nb; while (enda!=0||endb!=0)&#123; int p = pre[enda][endb]; op.push(pathNodes[p].t); enda = pathNodes[p].a; endb = pathNodes[p].b; &#125; System.out.println(op.size()); while (!op.isEmpty())&#123; int x = op.poll(); if(x==0||x==1) System.out.printf("FILL(%d)\n",x+1); else if(x==2||x==3)System.out.printf("DROP(%d)\n",x-1); else if(x==4) System.out.printf("POUR(1,2)\n"); else if(x==5)System.out.printf("POUR(2,1)\n"); &#125; return; &#125; que.add(new Cell(na,nb)); &#125; &#125;// System.out.println("下一层"); &#125; System.out.println("impossible");&#125; poj 16062^N 大整数287 O(1)空间，找到数组中重复的数字查找第二小/大的元素12345678910111213141516171819202122static int secondMin2(int[] arr)&#123; int first = Integer.MAX_VALUE,second = Integer.MAX_VALUE; for (int j = 0; j &lt; arr.length; j++) &#123; if(arr[j]&lt;=first)&#123; second = first; first = arr[j]; &#125;else if(arr[j]&lt;=second&amp;&amp;arr[j]!=first) second = arr[j]; &#125; return second;&#125;static int secondMax(int[] arr)&#123; int first = Integer.MIN_VALUE,second = Integer.MIN_VALUE; for (int j = 0; j &lt; arr.length; j++) &#123; if(arr[j]&gt;=first)&#123; second = first; first = arr[j]; &#125;else if(arr[j]&gt;=second&amp;&amp;arr[j]!=first) second = arr[j]; &#125; return second;&#125; 排序数组中小于target的2 4 6 8 9 target=14 2+9&lt;14 cnt+=4 4+9&lt;14 cnt+=3 6+9&gt;14,6+8==14,start==end 结束 给定一个数字范围，找到其中有几个首尾相同的数字 百万数字中找最大20个用开始20个数字构造20个node的最小堆，接下来的数字比root大则replace，insert 每秒最大桶数量减半，求t时刻一共消耗了多少方法1：按递减排序，减半，再排序，一共排序t次方法2：维持最大堆，每次取root减半再插入 ？445 链表数字相加 Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 ？递归写法 896有正负的数列判断单调用首尾判断up/down，中间相邻遍历判断up/down和之前不符return false20ms12345678910public boolean isMonotonic(int[] A) &#123; if (A.length==1) return true; int n=A.length; //关键 boolean up= (A[n-1]-A[0])&gt;0; for (int i=0; i&lt;n-1; i++) if (A[i+1]!=A[i] &amp;&amp; (A[i+1]-A[i]&gt;0)!=up) return false; return true;&#125; 14 最长公共前缀1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs==null||strs.length&lt;1)return ""; String rst = strs[0]; for(int i =1;i&lt;strs.length;i++)&#123; //削减rst以匹配每个后面的单词 while(strs[i].indexOf(rst)!=0)&#123; rst =rst.substring(0,Math.min(rst.length()-1,strs[i].length())); &#125; &#125; return rst;&#125; 718 最长公共子串40ms 90%123456789101112public int findLength(int[] a,int[] b)&#123; int m = a.length,n = b.length; if(m==0||n==0)return 0; int[][] dp = new int[m+1][n+1]; int max= 0; for(int i=m-1;i&gt;=0;i--)&#123; for(int j=n-1;j&gt;=0;j--)&#123; max = Math.max(max,dp[i][j]=a[i]==b[j]?1+dp[i+1][j+1]:0); &#125; &#125; return max;&#125; rolling hashhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/solution/ 括号串达到匹配需要最小的逆转次数 Input: exp = “}}}{“Output: 2 将匹配的括号都去掉，{的个数是m=3，}的个数是n=3m/3+n/2 = 2+1=312345678910111213141516171819202122private int minReversal(String s)&#123; int len = s.length(); if((len&amp;1)!=0)return -1; Deque&lt;Character&gt; que = new ArrayDeque&lt;&gt;(); int n=0; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(c=='&#125;'&amp;&amp;!s.isEmpty())&#123; if(que.peek()=='&#123;')que.pop(); else &#123; que.push(c); &#125; &#125; &#125; int mn = que.size(); while (!que.isEmpty()&amp;&amp;que.peek()=='&#123;')&#123; que.pop(); n++; &#125; //当m+n是偶数的时候ceil(n/2)+ceil(m/2)= return (mn/2+n%2);&#125; 28字符串indexOf匹配暴力 Substring Search各种字符串匹配算法http://www-igm.univ-mlv.fr/~lecroq/string/https://algs4.cs.princeton.edu/53substring/方法1是维持一个pattern长度的buffer流的情况下 没有backup123ADA B RACADA[C]R i-=j ADACR !!!Boyer-Moore 74% 5ms 亚线性alg41.构建right表示target中字符的最右位置是NEEDLE2.source从左到右扫描，target从右向左如果出现不匹配T是target里没有的，i到j+1如果出现不匹配N是target里的，则用right，将target里N的位置和它对齐当前j=3,right[‘N’] = 0,skip=3第三种情况，至少保证i不能回退 123456789101112131415161718192021222324 public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int[] right = new int[R]; for (int c = 0; c &lt; R; c++) right[c] = -1; for (int j = 0; j &lt; target.length(); j++) right[target.charAt(j)] = j; int m = target.length(); int n = source.length(); int skip; for (int i = 0; i &lt;= n - m; i += skip) &#123; skip = 0; for (int j = m-1; j &gt;= 0; j--) &#123; if (target.charAt(j) != source.charAt(i+j)) &#123; skip = Math.max(1, j - right[source.charAt(i+j)]); break; &#125; &#125; if (skip == 0) return i; &#125; return -1;&#125; RabinKarp 31% 8ms 线性 正确性：线性求mod123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// private long longRandomPrime()&#123;// BigInteger prime = BigInteger.probablePrime(31,new Random());// return prime.longValue();// &#125;int R = 256;long q;private long hash(String key, int m) &#123; long h = 0; for (int j = 0; j &lt; m; j++) h = (R * h + key.charAt(j)) % q; return h;&#125; //变成拉斯维加斯算法private boolean check(String source,String target, int i) &#123; for (int j = 0; j &lt;target.length() ; j++) if (target.charAt(j) != source.charAt(i + j)) return false; return true;&#125;public int searchRabinKarp(String source,String target)&#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int m = target.length(); int n = source.length(); long RM = 1; q = 1877124611;//保证不冲突 for (int i = 1; i &lt;=m-1 ; i++) &#123; RM = (R * RM) % q; &#125; long patHash = hash(target,m); long txtHash = hash(source, m); //一开始就匹配成功 if ((patHash == txtHash) &amp;&amp; check(source,target, 0)) return 0; // check for hash match; if hash match, check for exact match for (int i = m; i &lt; n; i++) &#123; // Remove leading digit, add trailing digit, check for match. txtHash = (txtHash + q - RM*source.charAt(i-m) % q) % q; txtHash = (txtHash*R + source.charAt(i)) % q; // match int offset = i - m + 1; if ((patHash == txtHash) &amp;&amp; check(source, target,offset)) return offset; &#125; // no match return -1;&#125; 187 rolling-hash DNA序列中出现2次以上长为10的子串//todo 暴力 O（MN）双指针i的位置是txt已匹配过的最后位置15% 13ms123456789101112131415public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(source==null||source.length()==0)return 0; int i,N = source.length(); int j,M = target.length(); for (i = 0,j=0; i &lt;N&amp;&amp;j&lt;M ; i++) &#123; if(source.charAt(i)==target.charAt(j))j++; else&#123; i-=j; j=0; &#125; &#125; if(j==M)return i-M; else return -1;&#125; 按indexOf简化 43% 7ms12345678910111213141516171819202122public int strStr(String source, String target) &#123;if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int lens = source.length(); int tar = target.length(); char[] targetArr = target.toCharArray(); char[] sourceArr = source.toCharArray(); char first = targetArr[0]; int max = lens-tar; for (int i = 0; i &lt;= max ; i++) &#123; if(sourceArr[i]!=first)&#123; while (++i&lt;=max&amp;&amp;sourceArr[i]!=first); &#125; if(i&lt;=max)&#123; int j = i+1; int end = j+tar-1; for (int k = 1; j &lt;end&amp;&amp;sourceArr[j]==targetArr[k] ; k++,j++) ; if(j == end)return i; &#125; &#125; return -1;&#125; java indexOf实现 最长公共前缀：indexOf73% 5ms123public int strStr(String source, String target) &#123; return indexOf( source.toCharArray(),0,source.length(),target.toCharArray(),0,target.length(),0);&#125; 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*@param source:左值（被查找）@param count长度*/ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; // 查找位置&gt;=左值长度 if (fromIndex &gt;= sourceCount) &#123; //traget空？返回左值长度 return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; // 右值为0，返回查找位置 if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; //最后一个匹配的下标，至少减去右值的长度 int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍基于DFA用一个dfa[][]记录j回退多远1对target构建dfa构造DFA的时间是O（MR）的，可以对每个状态设置一个匹配/非匹配去掉R9ms 24%12345678910111213141516171819202122232425262728293031323334public static int serachByKMP(String source,String target)&#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int M = target.length(); int N = source.length(); int[] dfa = new int[M]; int k = 0; dfa[0] =0; //For the pattern “AAACAAAAAC”, //lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] for (int i = 1; i &lt; M; i++) &#123; while (k&gt;0&amp;&amp;target.charAt(k)!=target.charAt(i)) k = dfa[k-1]; if(target.charAt(k)==target.charAt(i))&#123; k++; &#125; dfa[i]=k; &#125; int q = 0; //[0, 0, 0, 1, 0] //"mississippi", // "issip" q=4 i=5 dfa[3]=1 // "issip" q=1 i=5 // "issip" for (int i = 0; i &lt;N ; i++) &#123; while(q&gt;0&amp;&amp;target.charAt(q)!=source.charAt(i)) q = dfa[q-1]; if(target.charAt(q)==source.charAt(i)) q++; if(q==M) return i-M+1; &#125; return -1;&#125; 2.对source遍历一遍dfa12.44% 39ms12345678910111213141516171819202122public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int M = target.length(); int[][] dfa = new int[R][M]; //构建DFA dfa[target.charAt(0)][0] =1; for(int X = 0,j=1;j&lt;M;j++)&#123; for (int c = 0; c &lt; R; c++) dfa[c][j] = dfa[c][X];//复制上一列匹配失败 dfa[target.charAt(j)][j] = j+1;//更新匹配成功 X = dfa[target.charAt(j)][X];//重启状态 &#125; //模拟一遍DFA int i,j,N = source.length(); for (i = 0,j=0; i &lt; N&amp;&amp;j&lt; M; i++) &#123; j = dfa[source.charAt(i)][j]; &#125; if(j==M) return i-M; else return -1;&#125; 文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。1 子序列 不连续 2 字串 连续KMP:getIndexOfd之前【最长前缀】和【最长后缀】的匹配长度(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)所以最长匹配是3：abc,记录在d位置上int[]next = f(“abcabcd”)={-1,0,0,1，2，3}关键加速求解匹配 3 最长不重复字串18%1234567891011121314public int LS(String s)&#123; int max = 0; int start = 0; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i =0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(map.containsKey(c))&#123; start = Math.max(start,map.get(c)+1); &#125; max = Math.max(max,i-start+1); map.put(c,i); &#125; return max;&#125; 879G 名成员 第i种犯罪会产生profit[i] 利润，需要group[i]名成员参与。计划产生P利润有多少种方案。 Input: G = 5, P = 3, group = [2,2], profit = [2,3]output: 2 dp[k][i][j] 产生i利润 用j个人 完成前k个任务 的方案数 576 无向图访问所有点的最短边数fraction 背包问题Items can be broen down 贪心按value/weight排序 顶点覆盖 最大团：在一个无向图中找出一个点数最多的完全图任务分配问题一般可以在多项式时间内转化成最大流量问题hdu 1813 IDA搜索Iterative Deepening A,tsp最小生成树解TSP这样求得的最优解不超过真正最优解的2倍证明：2-近似算法任何一个哈密顿回路OPT删去一条边就是一个生成树。我们找的是最小生成树T肯定小于哈密顿回路减1条边的生成树长度所以T&lt;OPT所以欧拉回路&lt;2OPT因为抄近路不会增加长度所以MST生成的结果不会超过2OPT 最小权匹配算法MM1.奇数度的顶点一定是偶数个，将偶数个奇数度定点两两配对2.将每个匹配加入最小生成树，每个顶点都变成偶数度，得到欧拉图3.沿着欧拉回路跳过走过的点抄近路 得到哈密顿回路证明：不超过最优解的1.5倍 代价函数：在搜索树结点计算的最大化问题以该节点为根的值（可行解/目标函数）的上界。父节点不小于子节点（最大化问题） 界：到达叶节点得到的最优值 optaPlanner 数学公式定义 随机算法模板2.1 迭代局部搜索 tsp数据集https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/ https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournamentTSPP:tsp with profit（在顶点上）分3种 PTP(profitable tour problem)找到最小 cost-profit 的circuit OP(orienteering problem),也叫selective TSP(STSP)。cost是约束，求不超过cost的最大profit PCTSP（prize-collecting)profit是约束，目的是找到不低于profit的最小cost。 数据：遗传算法：最大效益中國郵差問題 time window on vertex OP VRP 0~3的tspdp解法 17 九宫格输入法数字对应的字符串12345678910111213private String[] letters = &#123;"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;;private void help(List&lt;String&gt; rst,int idx,String digits,String cur)&#123; if(cur.length()==digits.length())&#123; rst.add(cur); return; &#125; if(digits.charAt(idx)&gt;='2'&amp;&amp;digits.charAt(idx)&lt;='9')&#123; String num2letter = letters[digits.charAt(idx)-'0']; for(int i =0;i&lt;num2letter.length();i++)&#123; help(rst,idx+1,digits,cur+num2letter.charAt(i)); &#125; &#125;&#125; 93 分解Ip地址dfs123456789101112private void dfs(List&lt;String&gt; rst,String s,int idx,String cur,int cnt)&#123; if(cnt&gt;4)return; if(cnt==4&amp;&amp;idx==s.length())&#123; rst.add(cur); &#125; for(int i =1;i&lt;4;i++)&#123; if(idx+i&gt;s.length())break; String tmp = s.substring(idx,idx+i); if((tmp.startsWith("0")&amp;&amp;tmp.length()&gt;1)||(i==3&amp;&amp;Integer.parseInt(tmp)&gt;=256))continue; dfs(rst,s,idx+i,cur+tmp+(cnt==3?"":"."),cnt+1); &#125;&#125; ip2cidr找末尾1的位置x &amp; -x 13154旋转矩阵top=0,bot=3,left=0,right = 3n是矩阵大小n&gt;1的时候继续，每一圈，矩阵大小-=2将2赋值给8：[top+i][right]=[top][left+i]i=3:3赋值给12每个i要赋值4遍，上下左右外层完了之后子问题是top++,left++,right–,bot–,n-=2 方法2：翻转？ 59 生成nxn的旋转矩阵49直接拿CharArray的sort重建String当key 49% 435 去掉最少区间使区间不重叠1Arrays.sort(intervals,(a,b)-&gt;&#123;a.end!=b.end?(a.end-b.end):(a.start-b.start)&#125;); 性能很慢44ms换 提升到2ms 打败了100%123456Arrays.sort(intervals,new Comparator&lt;Inteval&gt;()&#123; public int compare(Interval a,Interval b)&#123; if(a.start==b.start)return a.end-b.end; return a.start-b.start; &#125;&#125;) 算法：按start排序，如果重叠了，end更新成min(end1,end2) 697 保留数组中最高频出现数字频数的最短数组长度 Input: [1,2,2,3,1,4,2]最小连续子数组，使得子数组的度与原数组的度相同。返回子数组的长度Output: 6 最高频是2-&gt;【2,2,3,1,4,2】用3个hashmap扫一遍记录每个数字出现的cnt,left,right最后cnt最大的right-left+1合并成一个hashmap&lt;Integer,int[3]&gt; 819 找出句子中出现频率最高没被ban掉的词正则去掉所有标点 “Bob hit a ball, the hit BALL flew far after it was hit.” pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。 大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。其他六个是L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符P：各种标点 123456//busymannote// [Bob, hit, a, ball, the, hit, BALL, flew, far, after, it, was, hit]paragraph.split("\\PL+");// Bob hit a ball the hit BALL flew far after it was hitparagraph.replaceAll("\\pP","");paragraph.replaceAll("[^a-zA-Z ]", "") 1234567public String mostCommonWord(String paragraph, String[] banned) &#123; Set&lt;String&gt; ban = new HashSet&lt;&gt;(Arrays.asList(banned)); Map&lt;String,Integer&gt; cnt = new HashMap&lt;&gt;(); String[] split = paragraph.toLowerCase().split("\\PL+"); for(String s:split)if(!ban.contains(s))cnt.put(s,cnt.getOrDefault(s,0 )+1); return Collections.max(cnt.entrySet(),Map.Entry.comparingByValue()).getKey();&#125; 亚线性算法o(n)小于输入规模亚线性时间：scale-free networkS：大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接。网络中随机抽取一个节点，它的度是多少呢？这个概率分布就称为节点的度分布顶点的度满足幂律分布（也称为帕累托分布）,所以不能均匀采样计算每个人的平均度数。 亚线性空间中位数问题，知道所有的输入，有O(n)的分治算法 水库抽样Reservpor Sampling 亚线性空间 “给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。” 当扫描到前n个数字时，保留数组中k个均匀的抽样1.k大小的数组2.填充k个元素3.收到第i个元素t。以k/i的概率替换A中的元素。这样保证收到第i个数字的时候，i在k中的概率是k/i。实现：生成[1..k..i]中随机数j，如果j&lt;=k（k/i的概率),A[j]=t证明：第i个数接收时有k/i的概率在k数组中，当第i+1个数接收时,i+1有k/(i+1)概率在数组k中，并且刚好替换掉的是第i个数的概率是k中选i：1/k，所以第i+1个数来之后i还在k中的概率是（1-k/(i+1)*1/k)=（1-1/(1+i)）123456789101112private void select(int[] stream,int n,int k)&#123; int[] reserve = new int[k]; int i; for(i=0;i&lt;k;i++)&#123; reserve[i]=stream[i]; &#125; Random r = new Random(); for(;i&lt;n;i++)&#123; int j = r.nextInt(i+1); if(j&lt;k)reserve[j]=stream[i]; &#125;//sout&#125; 398 数组中重复元素随机返回index int[] nums = new int[] {1,2,3,3,3};Solution solution = new Solution(nums); // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3); // pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 水库抽样：流式处理，空间复杂度O(1),pick O(N)如果用hashmap，初始化O(N)时间，O（N）空间，数组太大就不行。1234567891011121314151617181920212223class Solution &#123; int[] nums; Random r; public Solution(int[] nums) &#123; this.nums=nums; this.r = new Random(); &#125; public int pick(int target) &#123; int cnt =0; int rst =-1; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]!=target)continue; //以1/++cnt的概率抽这个数 // int j = r.nextInt(++cnt); // if(j==0)rst=i; else&#123;//不赋值变量从180ms-&gt;127ms if(r.nextInt(++cnt)==0)rst=i; &#125; &#125; return rst; &#125;&#125; ？？382 随机链表 extremely large and its length is unknown长度不知，读到第三个node，让它的概率变成1/3，用1/3的概率替换掉之前选择的item 由于计算机产生的随机数都是伪随机数，对于相同的随机数引擎会产生一个相同的随机数序列，因此，如果不使用静态变量（static），会出现每次调用包含随机数引擎的函数时，随机数会重新开始产生随机数，因此会产生相同的一串随机数。比如你第一次调用产生100个随机数，第二次调用仍然会产生这一百个随机数。如果将随机数引擎设置为静态变量，那么第一次调用会产生随机数序列中的前100个随机数，第二次调用则会产生第100到200的随机数。 频繁元素计算 Misra Gries(MG)算法最小生成树笛卡尔树链式前向星堆排序不稳定测试：6 5 12 至少都比内置的快展开代码 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; String str="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; String[] words2 = new String[10000]; Random random=new Random(); for (int j= 0; j &lt;words2.length ; j++) &#123; StringBuffer sb=new StringBuffer(); int length = random.nextInt(30); for(int i=0;i&lt;length;i++)&#123; int number=random.nextInt(62); sb.append(str.charAt(number)); &#125; words2[j] = sb.toString(); &#125; String[] word3 = words2.clone(); String[] word4 = words2.clone(); long start = System.currentTimeMillis(); sort(words2, 0,words2.length-1 ,0 ); long end = System.currentTimeMillis(); System.out.println(end-start); long start2 = System.currentTimeMillis(); MSD.sort(word3); long end2 = System.currentTimeMillis(); System.out.println(end2-start2); long start3 = System.currentTimeMillis(); Arrays.sort(word4); long end3 = System.currentTimeMillis(); System.out.println(end3-start3); &#125; 三向快速排序 不稳定取第一位，将所有字符串分成3份展开代码 1234567891011121314151617181920212223242526272829303132public class threewaypart &#123; private static int charAt(String s,int d)&#123; if(s.length()&gt;d)return s.charAt(d); else return -1; &#125; private static void swap(String[] a ,int i,int j)&#123; String tmp = a[i]; a[i]=a[j]; a[j]=tmp; &#125; private static void sort(String[] a,int lo,int hi,int d)&#123; if(hi&lt;=lo)return; int lt = lo,gt = hi; int v = charAt(a[lo],d); int i = lo+1; while (i&lt;=gt)&#123; int t = charAt(a[i],d); if(t&lt;v)swap(a,lt++,i++); else if(t&gt;v)swap(a,i,gt--); else i++; &#125; sort(a,lo,lt-1,d); if(v&gt;=0)sort(a, lt, gt, d+1); sort(a,gt+1,hi , d ); &#125; public static void main(String[] args) &#123; String[] words = &#123;"4PGC938","2iye230","2iye231","3cio720","fds","1","4PGC933","4PGC9382","4PGC9384","4PGC9385","4PGC9387","4PGC9388","4PGC9389"&#125;; sort(words,0 , words.length-1,0 ); System.out.println(Arrays.toString(words)); &#125;&#125; MSD most-significant-digit-first 不用长度相同从左开始一般也是NW复杂度，对于N很大的情况可以达到$Nlog_RN$ASCII的R是256，需要count[258]Unicode需要65536，可能要几小时按第0位分组，对每组递归按第1位分组…n当前前d位都相同的组，组内字符串个数小于15，用插入排序展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class MSD &#123;private static String[] aux;private static int R = 256;private static final int M = 3;private static int charAt(String s,int d)&#123; if(s.length()&gt;d)return s.charAt(d); else return -1;&#125;public static void sort(String[] a)&#123; aux = new String[a.length]; sort(a,0,a.length-1,0);&#125;private static boolean less(String v,String w,int d)&#123; for (int i = d; i &lt;Math.min(v.length(),w.length()) ; i++) &#123; if(v.charAt(i)&lt;w.charAt(i))return true; if(v.charAt(i)&gt;w.charAt(i))return false; &#125; return v.length()&lt;w.length();// return v.substring(d).compareTo(w.substring(d))&lt;0;&#125;private static void sort(String[] a,int lo,int hi,int d)&#123; if(hi&lt;=lo)return; //添加一步阈值，如果a长度太小，直接用插入排序 if(hi&lt;=lo+M)&#123; for (int i = lo; i &lt;=hi ; i++) &#123; for (int j = i; j &gt;lo&amp;&amp;less(a[j],a[j-1],d);j--) &#123; String tmp = a[j]; a[j]=a[j-1]; a[j-1]=tmp; &#125; &#125; return; &#125; //0位留作字符串结尾？ int[] count = new int[R+2 ]; for (int i = lo; i &lt;=hi ; i++) &#123; count[charAt(a[i],d)+2]++; &#125; for (int i = 0; i &lt;R+1 ; i++) &#123; count[i+1]+=count[i]; &#125; for (int i = lo; i &lt;=hi ; i++) &#123; aux[count[charAt(a[i],d)+1]++] = a[i]; &#125; for (int i = lo; i &lt;=hi ; i++) &#123; a[i] =aux[i-lo]; &#125; for (int i = 0; i &lt;R ; i++) &#123; sort(a,lo+count[i],lo+count[i+1]-1,d+1); &#125;&#125;public static void main(String[] args) &#123; String[] words = &#123;"4PGC938","2iye230","2iye231","3cio720","fds","1","4PGC933","4PGC9382","4PGC9384","4PGC9385","4PGC9387","4PGC9388","4PGC9389"&#125;; sort(words); System.out.println(Arrays.toString(words));&#125;&#125; LSD 基数排序radix sort 定长字符串 复杂度WN 低位优先长度相同的字符串，从最后一位开始排序（如何应用到变长字符串？）123456789101112131415161718192021222324public static void sort(String[] a,int w)&#123; int N = a.length; int R = 256; //只初始化一次 String[] aux = new String[N]; for (int d = w-1; d &gt;=0 ; d--) &#123; int[] count = new int[R+1]; for (int i = 0; i &lt;N ; i++) &#123; count[a[i].charAt(d)+1]++; &#125; for (int i = 0; i &lt;R ; i++) &#123; count[i+1]+=count[i]; &#125; for (int i = 0; i &lt;N ; i++) &#123; aux[count[a[i].charAt(d)]++]=a[i]; &#125; for (int i = 0; i &lt; N; i++) &#123; a[i]=aux[i]; &#125; &#125;&#125; key-index count sort键索引计数法 稳定的count:[0, 2, 3, 1, 2, 1, 3]累加cnt[0, 2, 5, 6, 8, 9, 12] 起始索引结果[a, a, b, b, b, c, d, d, e, f, f, f]123456789101112131415161718192021222324252627static int[] count = new int[7];static private int[] countt(String s)&#123; int N = s.length(); for (int i = 0; i &lt;N ; i++) &#123; //关键 +1 count[s.charAt(i)-'a'+1]++; &#125; return count;&#125;static private int[] acu()&#123; for (int i = 0; i &lt; count.length-1; i++) &#123; count[i+1]+=count[i]; &#125; return count;&#125;static private char[] axuu(String s)&#123; char[] axu = new char[s.length()]; for (int i = 0; i &lt; s.length(); i++) &#123; //关键 ++ axu[count[s.charAt(i)-'a']++] = s.charAt(i); &#125; return axu;&#125;System.out.println(Arrays.toString(countt("dacffbdbfbea")));System.out.println(Arrays.toString(acu()));String dacffbdbfbea = Arrays.toString(axuu("dacffbdbfbea")); 611数组中符合三角形边长的对数线性扫描 复杂度n^2 数组组成三角形的最大周长nlogn贪心，排序，如果 $a[i]&lt;a[i-1]+a[i-2]$ 则没有其他两条边可以两边之和&gt;第三边了，换下一条当最长边。12345678public int maxC(int[] A)&#123; Arrays.sort(A); int n = A.length; for (int i = n-1; i &gt;=2 ; i--) &#123; if(A[i]&lt;A[i-1]+A[i-2])return A[i]+A[i-1]+A[i-2]; &#125; return 0;&#125; MST：将图的点分成2个集合，用边连接两个集合中的点，最小的边集是MST MST和聚类：连通图将图的点分成2个集合，边两端连的是不同集合，最小的边集是MST假设分为6和其它点2个集合，在6-2 3-6 6-0 6-4四条连接两个集合的边中取最小边，标记成黑色。再随机分两个集合，不要让黑色边跨集合 kruskalkruskal遍历所有边(优先队列)，判断边的两点是否在一个集合里(find)，如果在则说明这条边加上会有环，如果不在，则union(v,w)并且将这条边加入mst。直到找到n-1条边。复杂度$ElogE$ 空间E 因为不仅维护优先队列还要union-find所以效率一般比prim慢 primprim复杂度$ElogV$ 空间Vprim优化：将marked[]和emst[] 替换为两个顶点索引数组edgeTo[] 和distTo[]每个没在MST中的顶点只保留(更新)离mst中点最短的边。 聚类：single link 前序ABCDEFGH-&gt;中序不可能是145 后序遍历二叉树1.函数式编程 不用help函数（可变数组），复制数组 展开代码 12345678910public List&lt;Integer&gt; post(TreeNode root)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null)return list; List&lt;Integer&gt; left = post(root.left); List&lt;Integer&gt; right = post(root.right); list.addAll(left); list.addAll(right); list.add(root.val); return list;&#125; 原理：123456rev_post(root): # 全部反过来刚好是后序遍历 print(root-&gt;val); rev_post(root-&gt;right) rev_post(root-&gt;left)reverse(rev_post(root)); 方法1：12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if(root==null)return list; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; root = stack.pop(); list.addFirst(root.val); if(root.left!=null)stack.push(root.left); //下一次poll出的是右子树 if(root.right!=null)stack.push(root.right); &#125; // 如果使用ArrayList 1% //Collections.reverse(list); return list;&#125; 753 输出能包含所有密码可能性的最短串 Input: n = 2, k = 2Output: “00110” 包含了00,01,10,11 官方解de Bruijn Card Trick 方法1每个点1次写出n个数的组合(11,12,22,21) 并找出哈密尔顿路径 方法2每条边1次写出(n-1)个数的组合(1,2) 的完全图，找出欧拉环路(circuit)。de Bruijn 序列的数量为欧拉环的数量。用k个数字，长度有n的组合有$k^n$种，但是因为可以首尾相连，总共de Bruijn的数量是$\frac{k! k^{n-1}}{k^n}$ 方法3 用不重复的最小字典序Lyndon Word例子：1.列出所有长度为4的组合1111,1112…以及能被4整除的长度(1,2)的组合1,2,11,22.2.所有按字典序排序3.去除所有旋转之后相同的组合，只保留字典序最小的：01和10只保留01 n = 6, k = 20 000001 000011 000101 000111 001 001011 001101 001111 01 010111 011 011111 1 连起来就是最小的de Bruijin sequence Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.332 欧拉路径 每条边一次(这道题不用判断)只有1个点入度比出度少1（起点）&amp;&amp; 只有一个点入度比出度多1（终点）其余点入度==出度 Hierholzer：O(e)删除边e(u,v)，并dfs(v)，不断寻找封闭回路， 从v点出发一定会回到v。因为入度出度相等。虽然可能不包含所有点和边。总是可以回到以前的点，从另一条路走，把其它所有的边全部遍历掉。 不是拓扑排序，拓扑排序每个点仅1次path里加入{0},{2}头插法{2,0}//保证远的在后面dfs回到1，继续找封闭回路 Input: tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] 用hashmap记录每个点的出度的点，建图 输出字典序靠前的序列，用优先队列，先访问的会后回溯到dfs插到链表头。（后序遍历：全部遍历完了再加入（退栈)） 123456789101112131415161718public List&lt;String&gt; findItinerary(String[][] tickets) &#123; LinkedList&lt;String&gt; rst = new LinkedList&lt;&gt;(); Map&lt;String,PriorityQueue&lt;String&gt; &gt; map = new HashMap&lt;&gt;(); for(String[] edge:tickets)&#123; PriorityQueue&lt;String&gt; nei = map.getOrDefault(edge[0],new PriorityQueue&lt;String&gt;()); nei.add(edge[1]); map.put(edge[0],nei); &#125; dfs(rst,map,"JFK"); return rst;&#125;private void dfs(LinkedList&lt;String&gt; rst,Map&lt;String,PriorityQueue&lt;String&gt; &gt; map,String start)&#123; PriorityQueue&lt;String&gt; pri = map.get(start); while(pri!=null&amp;&amp;!pri.isEmpty()) dfs(rst,map,pri.poll()); rst.addFirst(start); &#125; 后序遍历stack：12 两个帅不能处在同一条直线上的所有可行位置1231 2 34 5 67 8 9 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; int i = 81; while(i--)&#123; if(i/9%3==i%9%3)continue; cout&lt;&lt;i/9+1&lt;&lt;" "&lt;&lt;i%9+1&lt;&lt;endl; &#125;&#125; 翻煎饼排序的最少次数279完美平方数？？？198164 桶排序找区间最大值求数组的最大gap二分图 让每条边的两个顶点属于不同的集合max match：没有两点共享1点，最多的边数maximal:再加一条边就有两条边有共同顶点了maximum：有两种matching的画法，3条边的为max 室友分配问题不是二分图，因为有3人团，是最大团问题 出租车和乘客匹配问题 问题是求最小边和 分配老师给班级是二分图max match问题 785 是否是二分图1234567输入[0]=&#123;1,3&#125;0的邻点是1,3[[1,3], [0,2], [1,3], [0,2]]The graph looks like this:0----1| || |3----2 不用建图，已经是邻接表了。按算法4上75%还可以优化mark和color为一个数组，用位运算变更状态，变成boolean的dfs123456789101112131415161718boolean[] marked;boolean[] color;boolean isTwo = true;public boolean isBiartie(int[][] graph)&#123; marked = new int[graph.length]; color = new int[graph.length]; for(int s =0;s&lt;graph.length;s++)&#123; if(!marked[s])dfs(graph,s); &#125; return isTwo;&#125;private void dfs(int[][] G,int v)&#123; marked[v]=true; for(int w :G[v])&#123; color[w]=!color[v]; dfs(G,w); &#125;else if(color[w]==color[v])isTwo=false;&#125; 改成boolean的dfs-&gt;100%12345678910111213141516171819202122boolean[] marked;boolean[] color;public boolean isBipartite(int[][] graph) &#123; marked = new boolean[graph.length]; color = new boolean[graph.length]; for (int s = 0; s &lt;graph.length ; s++) &#123; if(!marked[s]&amp;&amp;!dfs(graph,s))return false; &#125; return true;&#125;private boolean dfs(int[][] graph,int v)&#123; marked[v]=true; for(int w:graph[v])&#123; //*关键 if(!marked[w])&#123; color[w]=!color[v]; if(!dfs(graph,w))return false; &#125; else if(color[w]==color[v])return false; &#125; return true;&#125; 886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人边集-&gt;邻接表-&gt;二分图 494 在数字中间放正负号使之==target递归的2种写法另一种void用全局变量累加？？为什么递归中不能写dfs(idx++)O(2^n)12345678private int dfs(int[] nums,int S,int idx)&#123; if(idx == nums.length)&#123; if(S==0)return 1; else return 0; &#125; int cnt =dfs(nums, S+nums[pos], pos+1)+dfs(nums, S-nums[pos], pos+1); return cnt;&#125; 53%优化记忆化：用当前的idx和当前的S当key 注意如果用String key=idx+&quot;&quot;+S有一个case会报错，应该是数字大的时候混淆了。sum不会超过1000所以Integer key = idx*10000+S就可以通过。 dp??：所有可能的target最大值是全部正号sum(a),或者全部负号）dp[2*sum(a)+1]题目sum最大2k，则dp[4001] 图的度1.顶点v的度1234567public static int degree(Map&lt;Integer,List&lt;Integer&gt;&gt; graph,int v)&#123; int degree = 0; for(int w :graph.get(v))&#123; degree++; &#125; return degree;&#125; 2.所有顶点的最大度1234567public static int maxDegree(Map&lt;Integer,List&lt;Integer&gt;&gt; graph)&#123; int max = 0; for(int v:graph.keySet())&#123; max = Math.max(degree(graph,v ),max); &#125; return max;&#125; 3. 图的遍历顺序展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DepthFirstOrder &#123; private boolean[] marked; private List&lt;Integer&gt; pre; private List&lt;Integer&gt; post; private Deque&lt;Integer&gt; reversePost; public DepthFirstOrder(int n,int[][] edges)&#123; List&lt;Integer&gt;[] graph = new ArrayList[n]; for (int i = 0; i &lt;n ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int[] edge:edges)&#123; graph[edge[0]].add(edge[1]); &#125; marked = new boolean[n]; pre = new ArrayList&lt;&gt;(); post = new ArrayList&lt;&gt;(); reversePost = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt;n ; i++) &#123; if(!marked[i])dfs(graph,i); &#125; &#125; private void dfs( List&lt;Integer&gt;[] graph ,int v)&#123; pre.add(v); marked[v] = true; for(int w :graph[v])&#123; if(!marked[w]) dfs(graph,w); &#125; post.add(v); reversePost.push(v); &#125;/*[0, 1, 5, 4, 6, 9, 10, 11, 12, 2, 3, 7, 8][1, 4, 5, 10, 12, 11, 9, 6, 0, 3, 2, 7, 8][8, 7, 2, 3, 0, 6, 9, 11, 12, 10, 5, 4, 1]*/ public static void main(String[] args) &#123; DepthFirstOrder sl = new DepthFirstOrder(13,new int[][]&#123;&#123;0,1&#125;,&#123;0,5&#125;,&#123;0,6&#125;,&#123;2,0&#125;,&#123;2,3&#125;,&#123;3,5&#125;,&#123;5,4&#125;,&#123;6,4&#125;,&#123;6,9&#125;,&#123;7,6&#125;,&#123;8,7&#125;,&#123;9,10&#125;,&#123;9,11&#125;,&#123;9,12&#125;,&#123;11,12&#125;&#125;); System.out.println(sl.pre); System.out.println(sl.post); System.out.println(sl.reversePost); &#125;&#125; 调度问题：给定一组任务，安排执行时间-&gt;拓扑排序DAG的拓扑排序是dfs逆后排序将一张图拉成边全部向下的图 拓扑排序：有向环 {0, 3}, {1, 3}, {3, 2}, {2, 1} 0-&gt; 3-&gt;2-&gt;1-&gt;3 展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243//算法4 p386private boolean[] marked;private int[] edgeTo;private Deque&lt;Integer&gt; cycle;//环private boolean[] onStack;public Deque cycle(int numCourses, int[][] prerequisites) &#123; onStack = new boolean[numCourses]; edgeTo = new int[numCourses]; marked =new boolean[numCourses]; List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; for (int i = 0; i &lt;numCourses ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for (int[] edge :prerequisites) &#123; graph[edge[0]].add(edge[1]); &#125; System.out.println(Arrays.toString(graph)); for (int i = 0; i &lt; numCourses; i++) &#123; if(!marked[i])dfs(graph,i); &#125; return cycle;&#125;private void dfs(List&lt;Integer&gt;[] graph,int v)&#123; onStack[v] =true; marked[v] =true; if(graph[v].size()&lt;1)return; for(int w:graph[v])&#123; if(cycle!=null) return; else if(!marked[w])&#123; edgeTo[w] = v; dfs(graph,w); &#125; else if(onStack[w])&#123; cycle = new ArrayDeque&lt;&gt;(); for (int x = v; x !=w ; x=edgeTo[x]) &#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v] =false;&#125; ?207 先修课程有环则返回false 拓扑排序??和并查集的区别（？按算法4上88.45%1234567891011121314151617181920212223242526272829303132333435private boolean[] marked;private boolean cycle = true;private boolean[] onStack;public boolean canFinish(int numCourses, int[][] prerequisites) &#123; onStack = new boolean[numCourses]; marked =new boolean[numCourses]; List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; for (int i = 0; i &lt;numCourses ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; //&#123;2,0&#125;,&#123;1,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;,&#123;1,3&#125;&#125;-&gt;[[], [0, 3], [0], [1, 2]] for (int[] edge :prerequisites) &#123; graph[edge[0]].add(edge[1]); &#125; for (int i = 0; i &lt; numCourses; i++) &#123; if(!marked[i])dfs(graph,i); &#125; return cycle;&#125;private void dfs(List&lt;Integer&gt;[] graph,int v)&#123; if(graph[v].size()&lt;1)return; //dfs是从起点到v的有向路径，onstack保存了递归中经历的点 onStack[v] = true; marked[v] = true; for(int w :graph[v])&#123; if(!marked[w]) dfs(graph,w); else if(onStack[w])&#123; cycle = false; return; &#125; &#125; //这个点出发没有环 onStack[v] = false;&#125; 56% 有可以优化到100%4ms的方法1.邻接表存储课程依赖图L12345678910List[] graph_;public boolean canFinish(int numCourses, int[][] prerequisites) graph_ = new ArrayList[numCourses]; for(int i =0;i&lt;numCourses;i++) &#123;graph_[i] = new ArrayList&lt;Integer&gt;();&#125; for(int[] back:prerequisites)&#123; int pre = back[0]; int lesson = back[1]; graph_[lesson].add(pre); &#125; 2.定义状态int[] visit = new int[numCourses];3.dfs每个顶点1234for(int i =0;i&lt;numCourses;i++)&#123; if(hasCircle(i,visit))return false;&#125;return true; 4.dfs 检查有没有环12345678910boolean hasCircle(int idx,int[] visited)&#123; if(visited[idx]==1)return true; if(visited[idx]==2)return false; List&lt;Integer&gt; neib = graph_[idx]; for(int i:neib)&#123; if(hasCircle(i,visited))return true; &#125; visited[idx]=2; return false;&#125; 210 输出修课顺序 Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] 用onStack和post 11% kolakoski序列找规律 lc481 返回kolakoski前N中有几个1174 骑士从左上到右下找公主，求初始血量dp[i][j]表示到i,j的最少血量，因为右下角一格也要减dp[n-1][m],dp[n][m-1]=1表示走完了右下角还剩下1点血dp[0~n-2][m]和dp[n][0~m-2]都是非法值，为了取min设置MAX_VALUE1dp[i][j]=Math.max(1,Math.min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]); 671 根的值&lt;=子树的值的二叉树中的第二小元素123 2 2 54 3(out) 1.dfs在set中加入所有节点，遍历set123456int min = root.val;int ans = Long.MAX_VALUE;for(int v:set)&#123; if(min&lt;v&amp;&amp;v&lt;ans)ans = v;&#125;return ans&lt;Long.MAX_VALUE?(int) ans:-1; 2.在dfs的时候只有node.val == root.val的时候表示这个分支需要继续遍历1234567891011min = root.val;int ans = Long.MAX_VALUE;private dfs(TreeNode rote)&#123; if(root!=null)&#123; if(min&lt;root.val&amp;&amp;root.val&lt;ans) ans = root.val; &#125;else if(min == root.val)&#123; dfs(root.left); dfs(root.right); &#125;&#125; 伪多项式时间一个整数是否是素数123def isPrime(n): for i in range(2,n): if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ !!97 s1和s2是否交错组成s3Solution状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中任意位置s3[i]一定是由s1[m],s2[n]组成的123s1=&quot;aa bc c&quot;s2=&quot; db bca&quot;s3=&quot;aadbbcbcac&quot; dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况12345遍历s3的位置： 遍历s1的长度，s3+1-s1为s2的长度 如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了 ||s3当前与s1当前匹配并且dp[s1-1][s2]: dp[s1][s2] = true 可以用滚动数组降成1维 ？？？按背包问题递减更新 99%ct的意义动态规划中的ct123456789101112131415161718public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1.length() + s2.length() != s3.length()) return false; boolean[] dp = new boolean[s1.length() + 1]; dp[0] = true; for (int i = 0; i &lt; s3.length(); i++) &#123; boolean ct = true; for (int j = Math.min(s1.length(), i + 1); j &gt; 0; j--) &#123; if (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = false; else if (dp[j - 1] &amp;&amp; s1.charAt(j- 1) == s3.charAt(i))&#123; dp[j] = true; ct = false; &#125;else dp[j] = false; &#125; if(dp[0]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = false; if(ct)return false; &#125; return true;&#125; 62 从左上角走到右下角总共有多少种不同方式f[m][n] = f[m-1][n]+f[m][n-1]简化成一维dp1234567891011public int uniPath(int m,int n)&#123; int[] res = new int[n]; for(int i =0;i&lt;m;i++)&#123; //一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法 for(int j =1;j&lt;n;j++)&#123; //加上左边走过来的走法 res[j]+=res[j-1]; &#125; &#125; return res[n-1];&#125; !数学公式m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。$C_{m+n-2}^{m-1}$12345long rst=1;for(int i =0;i&lt;Math.min(m-1,n-1);i++)&#123; rst=rst*(m+n-2-i)/(i+1);&#125;return (int)rst; 63 有障碍物的左上到右下dp[i][j]定义为走到i,j的方法数，障碍物则为01if(obs[i][j]==1)continue;//dp[i][j]=0//res[j]=0; 64 从左上角走到右下角的最少sumgrid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]); 32 ?括号字符串中合法的括号对方法1. stack:栈底放-1，当栈空&amp;&amp;读到是)将)的index当栈底。每次读到)弹栈，并更新i-peek()，因为peek为没消掉的(的前一个位置方法22. 从左向右扫描，当左括号数==右括号数更新max，当右括号&gt;左括号置0. 从右向左扫描，同理更新max，当左括号&gt;右括号重置0. 本福特定律以1为首位的数字的概率为30% 719!!!169 众数 Boyer-Moore Voting Algorithm1.hashmap,直到有计数&gt;n/2 break-&gt;return 11%2.随机数44% 因为一半以上都是这个数，可能只要循环两边就找到了1234567891011public int majorityElement(int[] nums)&#123; Random random = new Random(System.currentTimeMillis()); while(true)&#123; int idx = random.nextInt(nums.length); int choose = nums[idx]; int cnt = 0; for(int num:nums)&#123; if(num==cur&amp;&amp;++cnt&gt;nums.length/2)return num; &#125; &#125;&#125; 3.39% 计算用每个数字的每一位投票，1的个数&gt;n/2则为11234567891011121314public int majorityElement(int[] nums)&#123; int n = nums.length; int rst =0; int mask =0; for(int i=0;i&lt;32;i++)&#123; mask = 1&lt;&lt;i; int cnt =0; for(int num:nums)&#123; if((num&amp;mask)!=0)cnt++; &#125; if(cnt&gt;n/2)rst|=mask; &#125; return rst;&#125; 4.moore voting 在线算法92%123456789101112131415public int majorityElement(int[] nums)&#123; //假设就是第一个数 int maj = nums[0]; int cnt=0; for(int num:nums)&#123; //第一个数就cnt=1 if(num==maj)cnt++; else if(--cnt==0)&#123; //等于0 从头开始做 cnt=1; maj = num; &#125; &#125; return maj;&#125; 优化100%每次取两个不同的数删除，最后剩下的返回展开代码 1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums==null)return -1; int res=0; int count=0; for(int e : nums)&#123; if(count==0)&#123; res=e; &#125; if(res!=e)&#123; count--;//删除这个数 &#125; else count++; &#125; return res; &#125;&#125; 5.排序取中间的数6.C++专有 部分排序1234int majorityElement(vector&lt;int&gt; &amp; nums)&#123; nth_element(nums.begin(),nums.begin()+nums.size()/2,nums.end()); return nums[nums.size()/2];&#125; 7.分治??? 80 数组每个元素只保留&lt;=2次cnt表示插入位置，i用于遍历123456int cnt=2;for(int i =2;i&lt;nums.length;i++)&#123; if(nums[i]!=nums[cnt-2])&#123; nums[cnt++] = nums[i]; &#125;&#125; 节点是随机变量的有向无环图=贝叶斯网络BN求联合概率会用到最小生成树 如果$84*148=B6A8$成立，则公式采用的是__进制表示的$(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8$$=&gt;(3x^2+6x+2)(x-12)=0$$=&gt;x=12$ 快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数24表示在这种进制下个位应该为0 逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A 树的前/中/后序遍历本质都是DFS 402 去掉数字串中k个数字留下最小的数字Input: num = “1432219”, k = 3Output: “1219”找最小数字：从高位，越高位越小的数。算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉用栈，下一个位置比栈顶小，则把栈顶换掉。注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。1234567891011num="1234567890";k=9;for(int i =0;i&lt;len;i++)&#123; // len=10,k=9 但是0比所有前9个都小，则while(top!=0&amp;&amp;num.charAt(i)&lt;stack[top-1]&amp;&amp;k&gt;0)&#123; top--; k--; &#125; //0覆盖掉1 之后截取stack中len-k=1长度并且去掉0 stack[top++]=num.charAt(i);&#125; 236 最低的二叉树公共祖先LCA方法1：找出两条从root开始的路径，返回路径不开始不相同的前一个点27%空间两个array展开代码 12345678910111213141516171819202122public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; List&lt;TreeNode&gt; pathp = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; pathq = new ArrayList&lt;&gt;(); // if(!findPath(root,p,pathp)||!findPath(root,p,pathp))return findPath(root,p,pathp); findPath(root,q,pathq); int i; for(i = 0;i&lt;Math.min(pathp.size(),pathq.size());i++)&#123; if(pathp.get(i).val!=pathq.get(i).val) break; &#125; return pathp.get(i-1);&#125;private boolean findPath(TreeNode root,TreeNode node,List&lt;TreeNode&gt; path)&#123; if(root == null)return false; path.add(root); if(root.val == node.val)return true; if(root.left!=null&amp;&amp;findPath(root.left,node,path))return true; if(root.right!=null&amp;&amp;findPath(root.right,node,path))return true; path.remove(path.size()-1); return false;&#125; 方法二：只遍历一次树，这种方法如果其中一个q不在树中，会返会p,应该返回null13%12345678public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null)return null; if(root.val==p.val||root.val==q.val)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left!=null&amp;&amp;right!=null)return root; return left!=null?left:right;&#125; 这道题两个点都保证存在，可以absent的 终止条件root==null|root==q||root=p 在左/右子树找p|q，两边都能找到一个值（因为值不重复） 则返回当前root 如果左边没找到p|q，右边找到了p|q，最低的祖先就是找到的p|q，(因为保证p|q一定在树中) 235 BST的LCA8.9%123456TreeNode lcaBST(TreeNode root,TreeNode p,TreeNode q)&#123; if(root== null)return null; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)return lcaBST(root.left,p ,q ); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)return lcaBST(root.right,p ,q ); return root;&#125; 优化1： 13% 9ms123456789public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125;else&#123; return root; &#125;&#125; 222 完全二叉树的节点数83% DLS可以达到BFS一样空间的DFSword search用全局mark数组58%，改用char修改board98%展开代码 12345678910111213141516171819202122232425262728293031// boolean[][] marked;public boolean exist(char[][] board, String word) &#123; int n = board.length; int m = board[0].length;// marked = new boolean[n][m]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;m ; j++) &#123; if(word.charAt(0)!=board[i][j])continue; if(dfs(board,0,i,j,word))return true; &#125; &#125; return false;&#125;private boolean dfs(char[][] board,int idx,int i,int j,String word)&#123; if(i&gt;board.length-1||i&lt;0||j&gt;board[0].length-1||j&lt;0||word.charAt(idx)!=board[i][j])return false; if(idx==word.length()-1)return true; char tmp = board[i][j];// marked[i][j] = true;board[i][j]='0'; boolean ans = dfs(board,idx+1,i+1,j,word)|| dfs(board,idx+1,i,j+1,word)||dfs(board,idx+1,i-1,j,word) ||dfs(board,idx+1,i,j-1,word);// marked[i][j]=false; board[i][j]=tmp; return ans;&#125; Boggle 12345678910&gt; board =&gt; [ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]&gt; Given word = &quot;ABCCED&quot;, return true.&gt; Given word = &quot;SEE&quot;, return true.&gt; Given word = &quot;ABCB&quot;, return false.&gt; 后缀树字典树 每层多一个字符的字典树后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)后缀数组 A[]后缀的起始位置“alohomora”1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀 [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra A[i]的i是字典序的i，值是真实位置 例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8); 生成后缀数组Manber-Myers O(n)但是太复杂 排序后缀目录：桶排序 Aho-Corasick1添加失败链接2缝衣针字符串序号数组 A,B两人选k种可乐达到期望最大A选m个，B选(n-m)个每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大输出 买k种可乐的数量期望和：$m/n*a+(m-n)/n*b$的最大值 全部买期望最大那种输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1m/n=.50.5x1+0.5x2=0.5+1=1.50.5x3+0.5x1 = 2 全部买第二种可乐输出:0 2 ??火车换乘保证每个车错过能在30分钟以后换车输入：城市n 火车数mfrom1 to3 cost800 18:00 21:00…输出从1到n的最小花费 16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)*(P(C进入1/8)*P(A赢了C)+P(D进入1/8)*P(A赢了D))A进入1/2需要赢没比过的另外4个队A变成冠军需要赢没比过的另外8个队分组问题：如果1/4赛 1234 5678是一组4个是一组如果1/2赛 8个是一组 1234567891011for(int i =1;i&lt;4;i++)&#123; int inergroup = 1&lt;&lt;i; int group= 1&lt;&lt;i+1; for (int j = 0; j &lt;16 ; j++) &#123; for(int k=0;k&lt;16;k++) &#123; //在同一个大组 if(j/group==k/group) &#123; //不在同一个小组 if (j / inergroup != k / inergroup) &#123; dp[i][j] += dp[i - 1][j] * dp[i - 1][k] * p[j][k];&#125;&#125;&#125;&#125;&#125; 展开代码 第一轮：1进入1/8赢的概率是[1][2] 1打败2的概率=0.133第二轮：1赢了1/8进入1/4赢的概率是12341在第2轮的获胜概率是0加上1在上一轮胜利的概率0.133 ×3在上一轮获胜的概率0.335×1赢3的概率0.211 2 0.009356551在第2轮的获胜概率是0.00935655加上1在上一轮胜利的概率0.133 ×4在上一轮获胜的概率0.665×1赢4的概率0.2921 2 0.0351825 第三轮：1赢了1/4在1/2半决赛赢的概率是123456781在第3轮的获胜概率是0加上1在上一轮胜利的概率0.0351825 ×5在上一轮获胜的概率0.336947×1赢5的概率0.671 3 0.007942611在第3轮的获胜概率是0.00794261加上1在上一轮胜利的概率0.0351825 ×6在上一轮获胜的概率0.198831×1赢6的概率0.271 3 0.009831361在第3轮的获胜概率是0.00983136加上1在上一轮胜利的概率0.0351825 ×7在上一轮获胜的概率0.0229419×1赢7的概率0.9531 3 0.01060061在第3轮的获胜概率是0.0106006加上1在上一轮胜利的概率0.0351825 ×8在上一轮获胜的概率0.44128×1赢8的概率0.3531 3 0.016081 第四轮：1赢了1/2变成冠军的概率123456789101112131415161在第4轮的获胜概率是0加上1在上一轮胜利的概率0.016081 ×9在上一轮获胜的概率0.0606261×1赢9的概率0.3281 4 0.0003197771在第4轮的获胜概率是0.000319777加上1在上一轮胜利的概率0.016081 ×10在上一轮获胜的概率0.0113548×1赢10的概率0.1281 4 0.0003431491在第4轮的获胜概率是0.000343149加上1在上一轮胜利的概率0.016081 ×11在上一轮获胜的概率0.203126×1赢11的概率0.8731 4 0.003194781在第4轮的获胜概率是0.00319478加上1在上一轮胜利的概率0.016081 ×12在上一轮获胜的概率0.147508×1赢12的概率0.0821 4 0.003389291在第4轮的获胜概率是0.00338929加上1在上一轮胜利的概率0.016081 ×13在上一轮获胜的概率0.160952×1赢13的概率0.7711 4 0.005384851在第4轮的获胜概率是0.00538485加上1在上一轮胜利的概率0.016081 ×14在上一轮获胜的概率0.0877648×1赢14的概率0.31 4 0.005808261在第4轮的获胜概率是0.00580826加上1在上一轮胜利的概率0.016081 ×15在上一轮获胜的概率0.240971×1赢15的概率0.4051 4 0.007377661在第4轮的获胜概率是0.00737766加上1在上一轮胜利的概率0.016081 ×16在上一轮获胜的概率0.0876971×1赢16的概率0.4551 4 0.00801932 !815 换公交 BFSroutes = [[1, 2, 7], [3, 6, 7]]表示环线1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;求从S-&gt;T的最少公交车数量（不是少的站点） Input: routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6Output: 2乘坐 routes[0]到7，换routes[1]到6 易错点1： bfs的size保留当前层的定点数易错点2： deque的add和poll 展开代码 1234567&#123;&#123;0,1,6,16,22,23&#125;, &#123;14,15,24,32&#125;, &#123;4,10,12,20,24,28,33&#125;, &#123;1,10,11,19,27,33&#125;, &#123;11,23,25,28&#125;, &#123;15,20,21,23,29&#125;, &#123;29&#125;&#125;; S=4 T=21bfs，起点入队，遍历起点可以到达的所有公交(4可以达公交2)，遍历所有公交2上的可达stop{4,10,12,20,24,28,33},如果没到T，则4乘的公交换一辆，再遍历有4公交上的其他可达stop。用size保留当前层的定点数 4的bus全部遍历完后size==0。下一轮重新获取que.size()如果4的所有公交都不能达到T，则必须换乘cnt+1。当前起点变成stop{10}，遍历它的公交和stop，不行就{12}这些都是cnt+1可达的。直到stop{20}-&gt;bus{2,5}遍历公交5的stop找到T，bfs换乘1层找到的。 注意deque的add是addLast，push是addFirst,poll是pollFirst，pop是poolFirst 队列应该是add+poll,bfs如果用栈，则会在这一层还没找完先找下一层cnt=1{4}-&gt;cnt=2{33:[2, 3]}-&gt;将{1,10,11,19,27,33}入队所以回到下一次size–的时候取到了下一层的点33,两个bus都标记过了然后就全乱了{27:[3]}-&gt;{19:[3]}-&gt;{11:[3,4]}-&gt;bus4的最后{28:[2,4]}-&gt;25:[4]-&gt;cnt=3{23:[0,4,5]}-&gt;bus5找到21本来应该bus[2]-&gt;20-&gt;bus[5]结果bus[2]-&gt;bus[4]-&gt;bus[5] 数据结构： {站点：list&lt;经过的公交车id&gt;} list&lt;公交车id&gt; 标记已经乘过的公交 BFS连通分量while(!que.empty)， 遍历一辆车的连通分量while(que.size()&gt;0) 遍历当前节点相邻的busid是否乘过for(int car:list)， 并标记这个车的连通分量已乘过，遍历这个连通分量for(int t:routes[car])中有没有T，有则结束，没有则将整个连通分量入队。1//todonexttime fib123456int fib(int n)&#123; num++;//计数 if(n==0||n==1)return n; if(memo[n] == -1)memo[n] = fib(n-1)+fib(n-2); return memo[n];&#125; 11 数组index当底边，值当杯子两侧，最大面积 ?347桶排序 int数组中最常出现的n个桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。 242 Anagram 相同字母的单词22 卡特兰数括号left括号数量小于n，right括号数量必须小于left不然(()))肯定不合理1234if(left&gt;right)return;if(left==0&amp;&amp;right==0)&#123;rst.add(s);return;&#125;if(left&gt;0)help(rst,s+"(",left-1,right);if(right&lt;0)help(rst,s+")",left,right+1); 344 reverse String转成char数组/位运算做法77%比stringbuilder好 238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法left数组：自己左边数的乘积[1,1,2,6]right数组:自己右边的乘积（包括自己）[24,12,4,1]left和right对应位置相乘不用extra space12345678910res[0]=1;for(1 to n-1)&#123; res[i]=res[i-1]*nums[i-1];&#125;int right=1;for(n-1 to 0)&#123; res[i]*right; right*=nums[i];&#125;return res; 371 不用’+’用位运算完成求和123456public int getSum(int a, int b) &#123; int rst = a^b;//0^0=0,0^1=1,1^1=0 int carry = (a&amp;b)&lt;&lt;1;//当ab相等的时候需要进位 //a+b=（a xor b）+ （(a and b) &lt;&lt; 1） if(carry!=0)return getSum(rst,carry); return rst;&#125; 412 遇到3||5和3&amp;5的倍数变成特定字符不用%最快方法!对于CPU取余数的运算相对来说效率很低1234567891011121314151617for(int i=1,fizz=0,buzz=0;i&lt;=n ;i++)&#123; fizz++; buzz++; if(fizz==3 &amp;&amp; buzz==5)&#123; ret.add("FizzBuzz"); fizz=0; buzz=0; &#125;else if(fizz==3)&#123; ret.add("Fizz"); fizz=0; &#125;else if(buzz==5)&#123; ret.add("Buzz"); buzz=0; &#125;else&#123; ret.add(String.valueOf(i)); &#125; &#125; 551 出现两个以上A或者3个以上L为false1return s.indexOf("A")==s.lastIndexOf("A") &amp;&amp; s.indexOf("LLL") == -1; 476前导012345678910//找到左边第一个1，然后后面全置0public static int highestOneBit(int i) &#123; // HD, Figure 3-1 i |= (i &gt;&gt; 1);//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx i |= (i &gt;&gt; 2);//连续4个1 但是如果位数不够就只有3个1或者更少 i |= (i &gt;&gt; 4); i |= (i &gt;&gt; 8); i |= (i &gt;&gt; 16); return i - (i &gt;&gt;&gt; 1);//让全1的无符号右移1格1111-0111得到1000&#125; 292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree TraversalMorris Inorder(中序) Tree Traversal先把每个中缀的前缀（左子树最右）指向中缀，遍历完后把这些链接都删除还原为 null 找root的前趋：root 的中序前趋是左子树(第一个左结点)cur的最右标记为pre， pre.right = root12345678//找前趋Node cur = root;if(cur.left!=null)&#123; Node pre = current.left; while(pre.right!=null&amp;&amp;pre.right!=cur)&#123; pre=pre.right; &#125;&#125; 12345//创建链接：第一次到达这个最右的结点，cur的左边其实还有结点if(pre.right==null)&#123; pre.right = cur; cur=cur.left;&#125; 找root.left的前趋：cur向左（相当于新的root（1）的状态），找到cur的最右，标识成pre.right = cur 当cur向左是null则找到中序遍历的第一个输出，cur向右 123if(cur.left==null)&#123; sout(current.val); current=current.right;&#125; 当cur的left==null并且右链接已经建立到上一层。cur移动到上一层，找到前趋pre就是右链接的cur.left。 把这个右链接(pre.right)删除，输出（中），然后继续向右（上）并删除这种从前趋right过来的线。 123456//pre.right=curelse if(pre.right!=null)&#123; pre.right = null; sout(cur.val); cur=cur.right;&#125; 110 判断树平衡 在计算高度时同时判断平衡只需要O(n)123456789101112private boolean balance =true;public boolean isbalance(TreeNode root)&#123; height(root); return balance;&#125;private int height(TreeNode root)&#123; if(root==null) return 0; int left = height(root.left); int right = height(root.right); if(Math.abs(left-right)&gt;1)balance = false; return Math.max(left,right)+1;&#125; 2-3树10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间 红黑树：将3-结点变成左二叉树，将2-3变成二叉树有二叉树高效查找和2-3树高效平衡插入红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$ 插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转） 581 需要排序的最小子串，整个串都被排序了 递增40大于35，只排序到右边遍历过来第一个n&lt;n-1是不够的要找到[30~31]中的min和max1234567891011public static int fid(int[]A)&#123; //1,3,2,2,2 int n = A.length, beg = -1, end = -2, min = A[n-1], max = A[0]; for (int i=1;i&lt;n;i++) &#123; max = Math.max(max, A[i]);//从前往后，找到最大值max=3 min = Math.min(min, A[n-1-i]);//从后往前找到最小值min=2 if (A[i] &lt; max) end = i; //a=2&lt;3 end = 2-&gt;3-&gt;4 直到找到a[i]&gt;max if (A[n-1-i] &gt; min) beg = n-1-i;//begin =1 直到找到a[i]&lt;min &#125; return end - beg + 1; &#125; 136 Single Number异或 0^12=12,12^12=0single number$$2(a+b+c)-(a+a+b+b+c)$$ 2*sum(set(list))-sum(list) 141链表环检测空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针最坏情况，快指针和慢指针相差环长q -1步cpp练习 1234567891011121314class Solution&#123; public: bool hasCycle(ListNode *head) &#123; auto slow = head; auto fast = head; while(fast)&#123; if(!fast-&gt;next)return false; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 160 链表相交于哪一点12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val思路2：将a,b连成m+n长的链表遍历两遍12345a1 → a2 c1 → c2 → c3 -null- b1 → b2 → b3 c1 → c2 → c3 // ↘ // c1 → c2 → c3 // ↗ b1 → b2 → b3 c1 → c2 → c3 -null- a1 → a2 c1 → c2 → c3 展开代码 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null)return null; ListNode a = headA; ListNode b = headB; while(a!=b)&#123; if(a==null)&#123;a=headB;&#125;else&#123;a=a.next;&#125; if(b==null)&#123;b=headA;&#125;else&#123;b=b.next;&#125; &#125; return a; &#125;&#125; 168 lt13501 -&gt; A2 -&gt; B3 -&gt; C…26 -&gt; Z27 -&gt; AA28 -&gt; AB递归26进制123 public String convertToTitle(int n) &#123; return n == 0 ? "" : convertToTitle(--n / 26) + (char)('A' + (n % 26));&#125; 88%1234567StringBuilder sb = new StringBuilder();while (n!=0)&#123; --n; sb.insert(0,(char)(n%26+'A' )); n/=26;&#125;return sb.toString(); 1. 爬山：局部贪心，快速找到可行解，局部最优 8数码:启发函数：当前状态和目标状态的距离：错位方块个数。 深度优先 每次将当前节点S的子节点按启发式函数由大到小压入栈 8数码BFS优先队列展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void swap(int[][] matrix,int x,int y,int newX,int newY)&#123; int tmp = matrix[x][y]; matrix[x][y] = matrix[newX][newY]; matrix[newX][newY] = tmp;&#125;void printPath(Node root)&#123; if(root == null)return; printPath(root.parent); print2D(root.mat); System.out.println();&#125;Node createNode(int[][] matrix,int x,int y,int newX,int newY,int level,Node parent)&#123; Node node = new Node(); node.parent = parent; node.mat = new int[matrix.length][]; for (int i = 0; i &lt; matrix.length; i++) &#123; node.mat[i] = matrix[i].clone(); &#125; swap(node.mat,x ,y , newX,newY); node.cost = Integer.MAX_VALUE; node.x = newX; node.y = newY; return node;&#125;void slove(int[][] from,int x,int y,int[][] end)&#123; //扩展距离小的 PriorityQueue&lt;Node&gt; que = new PriorityQueue&lt;&gt;( Comparator.comparingInt(node -&gt; (node.cost + node.level)) ); Node root = createNode(from,x ,y ,x ,y ,0 , null); root.cost = calCost(from,end ); que.add(root); while(!que.isEmpty())&#123; Node min = que.poll(); //结果，从子节点向上递归打印 if(min.cost==0) &#123; printPath(min); return; &#125; //4个方向挪动白块四个方向为什么不会重复状态死循环 for (int i = 0; i &lt; 4; i++) &#123; if(isInBoard(min.x+row[i],min.y+col[i]))&#123; Node child = createNode(min.mat,min.x ,min.y , min.x+row[i], min.y+col[i], min.level+1, min); child.cost = calCost(child.mat,end ); que.add(child); &#125; &#125; &#125;&#125; Best-First搜索：全局最优贪心 当前所有可扩展节点中启发函数最优点 用堆 分支界限：组合优化 多阶段图搜索：最短路径 爬山与BF算法得到最优解都需要遍历整个空间 用爬山生成界限(可行解or最优解的上限) Rabin-KarpO(MN) 1. 枚举： 小于N的完美立方 $a^3=b^3+c^3+d^3$ 按a的值从小到大输出a&gt;b&gt;c&gt;d a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1] 称硬币:已经分组称了3次12枚硬币，找出假币 ABCD EFGH evenABI EFJK upABIJ EFGH even输出假的硬币 数据结构 char Left[3][7]`char Right[3][7]char result[3][7]` 一共称3次，每边最多放6个硬币，result（天平右边的情况） isFake(char c,bool light )假设函数：c是轻的 for(char c= &#39;A&#39; to &#39;L&#39;)枚举假硬币 for(3)三次称重情况都匹配 如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换 switch result[i][0] 选择三种u,e,d的情况 如果 第一次实验为up,右边高，则c应该出现在right,当right.indexOf(c)==null//没出现 return false 如果even 判断出现在left||right d 判断出现在left 熄灯问题(deng.java) 按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4给定每盏灯的初始状态，求按钮方案，使灯全熄灭输入 01矩阵 输出 01矩阵一个按钮按两次及以上是无意义的，按钮次序无关{0,1,1,0,1,0},{1,0,0,1,1,1},{0,0,1,0,0,1},{1,0,0,1,0,1},{0,1,1,1,0,0} 枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数） 只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按 一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1] 一个bit异或1 反转1^1-&gt;0反转0^1-&gt;1反转； j位 置1 |=(1&lt;&lt;j) j位 置0 &amp;=~(1&lt;&lt;j) 取第j 位的值 &gt;&gt;j&amp;1 主循环：1.遍历第一行开关状态 2.每次换第一行重置原来灯状态lighting[]=输入 3.对每一行，每一个灯，按switch更新lighting 123456for (int j = 0;j&lt;6;j++)&#123; if(getBit(result,i,j)==1)&#123;if(j&gt;0)FlipBit(lights,i,j-1);FlipBit(lights,i,j);if(j&lt;5)FlipBit(lights,i,j+1);&#125;&#125;if(i&lt;4)&#123;lights[i+1]^= switchs;&#125; &gt; 4.更新开关，下一行开关为上一行还亮着灯的位置回3 &gt; 5.当lighting最后一行为0，结束 递归 汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2) A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c) 再将B上n-1个移动到C，用A中转 回到0 A上n-2个移动到C，用B中转 n皇后 递归代替多重循环 链表DELETE_IF12 创建链表list-&gt;nodelist 会stackOverflow123456Node create(List&lt;Integer&gt; data)&#123; Node first = new Node(data.get(0)); Node sub = create(data.subList(1,data.size())); first.next=sub; return first;&#125; 迭代：123456789101112Node pre = null;Node head =null;for(1 to size)&#123; Node node = new Node(i); if(pre!=null)&#123; pre.next =node; &#125;else&#123; head = node; &#125; pre = node;&#125;return head; 反转链表12345678Node reverse(Nodde head)&#123; if(head==null)return null; if(head.next == null)return head; Node second = reverse(head.next); second.next = head; head.next = null; return second;&#125; 迭代：中间状态null&lt;-1&lt;-25-&gt;null3是newhead 反转成功的链表 | 4curhead是还没反转的链表newhead=null开始，curhead从第一个node开始，两个同时向右每次移一格，直到curhead=null123456789Node newhead = null;Node curhead = head;while(head!=null)&#123; Node tmp = curhead.next; curhead.next = newhead; curhead=tmp; newhead = curhead;&#125;return newhead; 转成栈浪费空间并且代码复杂 654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树stack：[3,2,1,6,0,5]1.栈底是数组最大值，即树根1234567891011123left-&gt; right-&gt;2-&gt;1 stack:3,2,1将栈里比cur小的右链变成当前最大值的左链，pop所有比6小的元素6left-&gt;3 -&gt;right-&gt;2-&gt;1 stack：66left-&gt;3 right-&gt;0 stack:6,05left-&gt;0,6right-&gt;56-&gt;left-&gt;3 -&gt;right-&gt;2-&gt;1 -&gt;right-&gt;5 -&gt;left-&gt;0 68%1234567891011Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();for(int i =0;i&lt;nums.length;i++)&#123; TreeNode cur = nums[i]; while(!stack.isEmpty()&amp;&amp;stack.peek().val&lt;cur.val)&#123; cur.left = stack.pop(); &#125; if(!stack.isEmpty()) stack.peek().right=cur; stack.push(cur); &#125;return stack.isEmpty()?null:stack.removeLast(); 递归95% 递归熟练 11ms123456789101112build(nums,0,nums.length-1);private TreeNode build(int[] nums,int start,int end)&#123; if(start&gt;end)return null; int max = start; for(int i =start+1;i&lt;=end;i++)&#123; max = nums[] &#125; TreeNode root = new TreeNode(nums[max]); root.left = build(nums,start,max-1); root.right = build(nums,max+1,end); return root;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busyman Notes]]></title>
    <url>%2F2018%2F03%2F21%2Fbusyman%2F</url>
    <content type="text"><![CDATA[signature???方法签名就由方法名+形参列表构成 并行 计算很长数组的总和1long sum = IntStream.of(a).parallel().sum(); Stream 统计一本书中的长单词 \PL 拆分单词 12String contents = new String(Files.readAllBytes(Paths.get(""),StandardCharsets.UTF_8));List&lt;String&gt; words = Arrays.asList(contents.split("\PL+")); stream代替迭代 12long count = aaa.stream().filter(w-&gt;w.length()&gt;12).count();System.out.println(count); 所有单词转换成小写 1Stream&lt;String&gt; lower = words.stream().map(String::toLowerCase); 每个单词的第一个字母 1Stream&lt;String&gt; first = words.stream().map(s-&gt;s.substring(0,1)); 创建流 集合-&gt;流：Collection.stream() 数组-&gt;流：Stream.of Arrays.stream(array,from,to) 方法 Stream&lt;Stream&lt;String&gt;&gt;用.flatMap(lambda) .limit(int)前int N个元素；.skip(n)丢弃前n个元素；.concat(stream,stream)拼接流 .distinct()删除重复元素 Optional防止空指针引用，对null封装默认值 收集 toArray stream.collect(Collectors.toList/toSet/toCollection(TreeSet::new)) 收集一个国家的语言Map&lt;String,List&lt;Local&gt;&gt;&#39;处理相同键 分类函数：.collect(Collectors.groupingBy(Local::getCountry)) 当分类函数是布尔值.partitioningBy(l-&gt;l.getLanguage().equal(&quot;en&quot;)); groupingBy可以针对List&lt;Local&gt;加下游收集器参数toSet()等 求一个流所有字符串总长度,reduce要求(T,T)-&gt;T返回值和参数 类型一样累加器函数：(total,word)-&gt;total+word reduce并行所以最后total要汇总（注意线程安全）12int result = aaa.stream().reduce(0,(total,word)-&gt;total+word.length(), (total1,total2)-&gt;total1+total2); 映射到一个数字流1int m2i=aaa.stream().mapToInt(String::length).sum(); 避免装箱，基本类型流 byte\short\char\boolean使用IntStream.of(1,2,3,4)和Arrays.stream 并行流 不能使用paralineStream.forEach forEach中的函数会在多个线程中并发执行，更新共享的数组 按长度将字符串进行分组并计数123Map&lt;Integer,Long&gt; shortWordCount = aaa.parallelStream() .filter(s-&gt;s.length()&lt;10) .collect(groupingBy(String::length,counting())); 并发收集123Map&lt;Integer,List&lt;String&gt;&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length)); 值是次数123Map&lt;Integer,Long&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length,counting())); Properities12345Properties st = new Properties();st.put("",);try(OutputStream out = Files.newOutputStream(path))&#123; st.store(out,"name");&#125; EnumSetEnumSet没有公共构造函数，使用静态工厂方法构造EnumSet：12enum Weekday&#123;MONDAY&#125;;Set&lt;Weekday&gt; alwarys = EnumSet.allof(Weekday.class); EnumMap指定[键]类型1EnumMap&lt;Weekday,String&gt; personInChange = new EnumMap&lt;&gt;(Weekday.class); BitSet用户标识位序列 第i个位置位1表示i在集合内栈、队列等 栈没有Stack接口，有Stack类，避免使用。使用ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); 优先队列和作业调度PriorityQueue&lt;Job&gt; jobs = new PriorityQueue&lt;&gt;();容纳实现了Comparable的类 WeakHashMap:当键的唯一引用来自哈希表条目，删除键/值 视图 KeySet、values、asList方法生成视图 范围range 任何子列表的添加删除都会影响原先列表 12List&lt;String&gt; st = ;List&lt;String&gt; nextfive = st.subList(5,10); 有序集合通过上下界 输出[1,2] 1234 TreeSet&lt;String&gt; words = new TreeSet&lt;&gt;();words.addAll(Arrays.asList(new String[]&#123;"1","2","3","4","5","6"&#125;));SortedSet&lt;String&gt; asOnly = words.subSet("1","3");System.out.println(asOnly); 轻量级创建map类型的属性12Collections.emptyMap()System.out.println(Collections.singletonMap("id","222")); 检查视图，检查错误类型（堆污染）,监视ArrayList 1List&lt;String&gt; strings = Collections.checkedList(new ArrayList&lt;&gt;(),String.class); 不要使用Collections的同步视图，并发使用util.concurrent的数据结构 迭代器Iterator&lt;String&gt; iter= coll.iterator() coll.removeIf(e-&gt;e fulfill the condition iter.remove()移除最后一个访问的元素，不是指向元素，不能两次连用remove 异常 已检查错误：可提前预知 IOException。Integer.parseInt(str)检查str是否是整数是可能的 覆盖方法时，不能抛出比父类方法中声明更多的已检查异常 @throws异常注释文档化 实现了AutoCloseable/Closeable的类 try(PrintWriter out = new PrintWriter(&quot;out.txt&quot;){}保证了out.close()必会调用，替换finally{in.close()}因为close可能异常 ·ex.getSuppressed()捕获了主要异常时检测得到第二个异常 可以catch到已检查异常后连接到未检查异常 检测非空值123public void process(String directions)&#123; this.directions = Object.requireNonNull(directions,"空指针");&#125; 会抛出空指针异常 Logger代替print：7种级别默认会记录INFO及更高级别。CONFIG/FINE/FINER.FINEST对用户无意义12Logger.getGlobal().info(()-&gt;ex.getMessage());Logger logger = Logger.getLogger("com.Logger"); log输出到文件用户文件夹下javan.log12FileHandler handler = new FileHandler();logger.addHandler(handler); 未检查：逻辑错误：NullPointerExcepterClass.forName(str)不可能知道类能否成功加载。 接口 要使用子类的方法，强制cast，先检查类型 123if (a instanceof B)&#123; B b = (B)a;&#125; Collection/AbstractCollection/Collections,Path/Paths default Stream stream() 接口中添加了，为了保持兼容以前版本，写了默认方法 Comparable 接口 返回不一定是1,-1,0； 当两个大负数相减可能变正，用Integer.compare() 浮点数 Double.compare() Arrays.sort()可以对Comparable对象数组进行排序 Comparator 接口不能更改String的compareTO,创建一个Comparator实现类。 创建Comparator comp 对象=new 实现了接口的对象(); 在Comparator对象上调用.compare(,) compare方法不是静态方法！ （？？？） Arrays.sort(obj,new Comparatorobj) Runable 接口 A implements Runnable{run(){}} new Thread(A).start UI回调 EventHandler lambda表达式 带有自由变量值的代码块是闭包。捕获闭合作用域中变量值 lambda中只能引用值不变的量，不能捕获变量，也不能改变 123for(int i =0;i&lt;n;i++)&#123; new Thread( ()-&gt; sout(i) ).start(); //报错&#125; for(Sting arg:args)中的变量是final的，作用域是单个迭代 可以捕获；每个底碟会创建新的arg变量；for(i)的作用域是整个循环。 只有一个抽象方法的接口对象，函数式接口 将lambda表达式放入类型为函数式接口的变量中，转化成接口的实例 ArrayList removeIf(Predictae) //e-&gt;e==nullremoveIf(Object::isNull)123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; 函数式接口@FunctionalInterface 单个方法的接口 高阶函数：返回函数的函数1. Comparator `public static &lt;T, U&gt; Comparator comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)` key提取器将类型T映射到可比较的类型 comparingDouble避免装箱 nullsLast`nullsFirst`避免null抛出异常 naturalOrder()适合实现了Comparable的类 thenComparing 局部内部类，实现接口的类。 方法中的类，可以接受方法中的值，不需要构造函数和存储在实例变量中。 匿名 继承和反射 代理对象实现接口，将所有方法路由到一个handler super() 因为子类不能访问父类的私有变量，所有要通过父类的构造函数初始化。]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库锁]]></title>
    <url>%2F2018%2F03%2F16%2FDDB%2F</url>
    <content type="text"><![CDATA[B+树数据库中，B+树的高度一般在2到3层。也就是说查找某一键值的记录，最多只需要2到3次IO开销。按磁盘每秒100次IO来计算，查询时间只需0.0.2到0.03秒 不确定：100w个Integer B+树需要多少层 磁盘最小单位扇区512字节文件系统最小单位 块 4kInnoDB最小单元 页 16k指针大小在6字节都是16的整数倍1234567mysql&gt; show variables like 'innodb_page_size';+------------------+-------+| Variable_name | Value |+------------------+-------+| innodb_page_size | 16384 |+------------------+-------+1 row in set, 1 warning (0.00 sec) 单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。 那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。 根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170117016=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。 隔离级别是对一致性的破坏。事务之间的Happen-before关系：4种 【读写，写读，读读】，写写 排他锁 排队：序列化读写 不需要冲突控制，无死锁 排他锁：用n个队列，发生共享数据冲突就并行，不然就串行。对数据加锁，只允许一个线程访问。 读写锁：读写分离。读可以并行（可重复读），写写、写读、读写依然串行。对于读多写少的应用性能提升并行度。针对读读、读写优化。 读写锁的第二种（读已提交，不可重复读）：实现读后写并行。读锁可以被写锁升级。读锁-&gt;写锁。 写读还不能并行。死锁：读写：事务1申请A的读锁，事务2也加读锁并行读A。当事务1想把A升级成写锁需要等2释放读锁。反过来2要等1释放读锁。Update set A=A-1 where id=100先读查where再写会死锁U锁：先判断事务中的写操作，申请锁时把原来的读锁改写锁。事务2想要先read再update写A的时候就等待。 读写锁第三种（读未提交）：把读锁去掉，读不加锁。写后读并行，写后的读可提前。但是可能会读到读的中间状态。 mvcc多版本并发控制 本质：copy on write。每次写都是写一个新的数据，写在log里，不是原地更新。针对写读场景优化，例如：当前数据版本号v10,读版本号v5则去log里找v5的数据。在写操作加锁时，依然可以并发读。现在主流做法：实现写读、读读、读写不冲突。当写&gt;读 记录的日志很多 会增加延迟。 减小锁的覆盖范围：原地锁-&gt;MVCC多版本锁增加锁上可并行的线程数：读写分离 有的数据库不能支持大事务原因在于写读冲突，读在外面等待。 隔离性的扩展：SNAPSHOT 快照隔离级别：就是mvcc copy on write 无锁编程。 快照读：读事务开始之前的版本。达到读未提交的并行度。保证读到一致性的数据。 悲观锁：数据加锁使线程bloking状态，等到等待的锁ok回到runnable状态。把寄存器的数据换成另一个线程，把缓存清空，cpu的cache清空，增加系统开销。适合并发争抢严重的场景。乐观锁： 持久性延迟：RAID Controller 保证一个操作写两个以上磁盘group commit 组提交 mvcc：读应该读哪一个写之后的数据：逻辑时间戳(保证顺序) 说明事务内单元的先后SCN(Oracle)Trx_id（Innodb) 原子性：记录了undo操作，可以全部成功/失败 故障恢复： 业务属性不匹配：记录事务前的数据锁定bob、smith的账户-&gt;检查bob账户是否有100元-X不满足-&gt;回滚 死锁检测：碰撞检测/等锁超时https://www.cloudera.com/developers/get-started-with-hadoop-tutorial.htmlFragmentation: process of partitioning the database into disjoint fragments, Data allocation, degree of replication 事务(transaction)：对数据库进行读或写的一个操作序列.mysql 中 myisam innodb LVM（逻辑卷） Hash 分片 round robin ：每次新+物理机$hash(key)mod(K+1)$都要重新分配，在线系统缺乏灵活性 将物理机映射和数据分片映射由一个hash函数承担，机器个数K出现在映射函数中，紧耦合。 虚拟桶 virtual buckets:虚拟桶作为数据分片，用hash映射；物理机映射采用表格 3. 一致性哈希：和弦（chord）系统中提出。 哈希长度为5，哈希空间为32，节点映射到环的位置随机 每个机器节点负责存储一段哈希空间的数据，N14存储6-14的数据；N5存储0-5， 查询 N14接收到查询请求，Hash(key)=27,不在下一个节点20 查找每个机器节点都有的路由表，找到小于27的最大节点N25（前趋） 路由表存储距离$2^k$距离的节点($14+2^3&lt;25&lt;14+2^4$),路由表存储哈希空间长度条路由信息 回1，29返回数据给14 新节点 查找后继 更新前趋，新节点，后继的前趋后继信息 将后继节点s上存储的数据分片迁移到新节点 稳定性检测当有多个新节点插入，新节点的前趋节点置空 加入N8，将N8后继置N14，前趋置空开始稳定性检测 询问后继的前趋指向是N5 不是自己 N5不在N8和N14中间，通知后继修改前趋指向N8 N14中hash6-8的值迁移到N8完成稳定性检测 对前趋N5稳定性检测 N5询问后继的前趋不是自己 ，N8介于自己和N14之间，N5修改后继 完成检测 定期更新路由表 CAP 一致性(多副本对外单副本) 可用性（延迟） 分区容忍性（网络分区现象仍工作）改进：先识别网络分区，网络分区发生时记录每个分区的状态，执行各自操作，当分区恢复，融合产生新状态。P出现时每个分区经可能执行ACID 数据无副本，发生网络分区现象or宕机数据不可访问，不满足P 副本存储在不同机器上： 选择强一致性。数据同步前拒绝读，不能满足A可用信 选择可用性并不是最新数据，不满足C 幂等性：反复执行多次和一次的效果相同。$f(f(x))=f(x)$(取绝对值)$f(x,x) = x$ max(x,x) =x ; a AND a = a 最终一致性:不一致窗口 一致性协议脏读对象存储？？？ 大数据日知录]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flowRecommend图计算]]></title>
    <url>%2F2018%2F03%2F15%2FflowRecommend%2F</url>
    <content type="text"><![CDATA[偏态系数 和 峰态系数中位数和均值的偏差，均值大叫正偏分布集中强度，正太分布的峰态是3，如果有一个分布的峰态5则可以拒绝正太分布假设 三大分布1.卡方分布：几个标准正太分布的平方和的分布2.t分布：正太分布的随机变量/卡方分布的变量 用于小样本估计成正太分布方差未知的总体的均值3.f分布：两个卡方分布的商 抽样误差数据分类定距（间隔）可以测量差值，但无绝对零点（温度）乘法，除法，比例是无意义的 判断正太分布84.5%的样本比 均值-标准差 大正太分布+-1倍标准差之间的累计值占69%，其它两边各占15.5%如果偏态系数绝对值大(0.x)， 极大似然 TUX GraphChi Preference 偏好 Goal model系统：自然语言偏好表达-&gt;用目标模型解释的正式的偏好说明。组成： 正则、统计语义相似性，基于语料库的偏好强度分级。目标：基于优先级的软件个性化定制接口。 流程推荐 流程结构相似度 相似度-&gt; 目的：检索、合并、重组计算流程相似度 计算优化分解策略 聚合策略 mapreduce 建模【流程模型】： 用图 邻接矩阵、流程模型： PTN:probabilistic time Petri net 流程信息 控制流、数据流、资源 流程文本、流程结构、流程语义 相似度方法结构相似度 MDS：matrix distance similarity MWT最小加权时间 方法-&gt;时间效率最高 图的编辑距离： greedyalgorithm､exhaustivealgorithm withpruning､processheuristicalgorithm､Astaralgorithm,其中平均性能最好的是 greedyalgorithm｡ 图挖掘算法：gSpan 频繁子图 流程相似度 执行轨迹 可达状态 因果关系 原则路径：根据流程结构可能发生的路径表示成一个集合 变迁系统（节点空间爆炸） 流程中的数据走向: 活动发生的概率。矩阵间距离 绝对值距离：非负、同一、对称、三角不等式-&gt;只比较部分对象 差异矩阵的所有元素 树的编辑距离现状：基于图的相似度检测复杂流程：计算路径的相似度 匹配搜索的效率并行！分解和合并得到拟合出来的相似度与串行计算的准确度计算 编辑距离(geeksforgeeks)[https://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/] 123456789i=len(a);j=len(b); d[i][j] 表示a转换成b的编辑距离 for (i = 0; i &lt;= lena; i++) &#123; d[i][0] = i; &#125; 长度为j的字符串转换成长度为0的字符串最小步数。 for (j = 0; j &lt;= lenb; j++) &#123; d[0][j] = j; &#125; 表示a[0]-a[j] -&gt;"" 123456（1）当a[i]==b[i],d[i][j]=d[i-1][j-1] // fxy -&gt; fay 的编辑距离等于 fx -&gt; fa (2) 当≠，min（ &lt;1&gt; fxy -&gt; fab 删除a[i] d[i-1][j]+1 fx-&gt;fab &lt;2&gt; fxy -&gt; fab 插入b[j] d[i][j-1]+1 fxyb-&gt;fab-&gt;(1)-&gt;fxy-&gt;fa &lt;3&gt; fxy-&gt;fab 替换a[i]为b[j] d[i-1][j-1]-&gt;fxb-&gt;fab) (3) 边界：a[i][0]=i CART -&gt; MARCH c-&gt;m t-&gt;c +H [] a只需要d[i]一行 MPI]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>grap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQueryCode]]></title>
    <url>%2F2018%2F03%2F15%2FjQueryCodee%2F</url>
    <content type="text"><![CDATA[browser sync自动刷新 npm install -g browser-sync 进入监听文件夹// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 腻子？ JavaScript代码，能够赋予浏览器未曾有过的功能 HTML5shiv 原理？ jq 目录 代码风格：.editorconfig 不同程序员和IDE协作文件 代码规范：eslintrc- node(后端) -brower(前端);.eslintrc.json继承，便于替换 项目版本：git 基于nodejs开发 使用grunt进行工程化管理 package.json devDependencies开发阶段依赖的包 转换规则babel-plugin-transform-es2015-for-of&quot;: &quot;7.0.0-beta.0&quot; 转换命令grunt-babel自动化任务 husky阻止git中不好的操作 .git/hooks commitplease保证git提交注释的格式规则 core-jses5\6\7的腻子 eslint-config-jquery 代码规范的配置 grunt-eslint grunt- grunt-cli(一般全局安装）控制台命令接口，安装对应的自动化插件 测试相关 require.js AMD规范 sizzle 纯js选择器 scripts可以运行的脚本npm commitplease 插件配置 npm install -g全局安装，操作系统任意路径都能找到 –save 本地安装 项目目录里 –save-dev 只在开发环境依赖 运行环境不依赖 npm install grunt --save-dev 加到devdependenceis grunt Gruntfile.js初始化grunt ，加载grunt插件的脚本文件，创建自动化任务 测试环境nodejs测试环境 chrome://inspect 控制台 node --inspect-brk .\app.js 第一行里加断点浏览器测试环境 &lt;script&gt;插入require.js;并设置入口文件data-main=&quot;index.js&quot; 123456789index.js 1. 默认路径配置require.config(&#123; baseUrl:"../src"&#125;)2. 声明依赖模块 路径是src/css.js(返回jqrery)require(['css'],function($)&#123; $('div')&#125;) jquery.js core.js define(依赖的模块,function(依赖模块返回的对象)) toArray: return slice.call( this ); 关联的对象转成数组return [].slice .call(this) 绑定上下文 [].slice.call(this)返回[window]类数组 get: return num &lt; 0 ? this[ num + this.length ] : this[ num ];从后往前数数组 pushStack:jQuery.merge(构建新的jQ对象 ES5普通的创建对象 每个构造函数都有一个原型对象 constructor属性指向构造函数123456789101112131415//1.创建构造函数function Student(name,sex)&#123; this.name = name ...&#125;//2. 创建构造函数原型对象Student.prototype=&#123; constructor:Student, //添加实例共享的方法 study:function()&#123; &#125;&#125;//3. 使用构造函数必须要用new 可以返回thisvar stu = new Student(a,b);stu.study(); jquery 构造函数 core.js:return new init(,) 避免使用new 但return的是init类型，prototype的方法不能用 init.js:init = jQuery.fn.init = function放到了jq的原型里； init.prototype = jQuery.fn;两个原型相等，解决原型方法 让两个构造函数引用同一个原型对象 jQuery.fn = jQuery.prototype添加fn属性，其实是prototype的简写 init.js创建DOM对象 if ( selector.nodeType )DOM元素有nodetype属性 slector不是string/DOM/functionreturn jQuery.makeArray( selector, this );是js对象 如果是string:判断是html标签 123if ( selector[ 0 ] === "&lt;" &amp;&amp; selector[ selector.length - 1 ] === "&gt;" &amp;&amp; selector.length &gt;= 3 ) parseHTML.js 1/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i ^&lt; 第一个符号是&lt; [^\/\0&gt;:\x20\t\r\n\f]*不是/,\0匹配NULL (U+0000) 字符,&gt;，:，\x20空格… [\x20\t\r\n\f]*很多空格 \/?可以有一个/ (?:)非捕获组。 捕获组：([a-zA-Z])\1:\1捕获组 $1捕获组的引用 &lt;\/\1&gt;:\1捕获前面([a-z][^\/\0&gt;:\x20\t\r\n\f]*)小括号中的内容 /i (忽略大小写)添加属性 $(html, props) 添加属性props是js对象this.attr( match, context[ match ] ); 是string但不是&lt;&gt;开头结尾： 正则html标签rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/, 非捕获+很多空白+&lt;任意一个字母或数字或下划线\和所有字母、数字、下划线以外的字符&gt;[^&gt;]* 除了&gt;之外的符号可以有很多个 或者 是id 是string 是css选择器 .class: findFilter.js document.find(selector)-&gt;jQuery.fn.extend( { find: function( selector ) 使用了第三方的Filter库 ？？？？使用sizzle $(“.face”,”#box”)在box找.facereturn this.constructor( context ).find( selector ); 重新返回构造#box的jquery中查找.face 是string 是function 传给jQuery.Deferred(); DOM加载完毕后执行 window.onload = function(){} 所有资源加载完毕后执行,只能绑定一次事件处理函数，绑定多次会覆盖 $(function(){});只要dom加载好，图片,css,js等不需要，可以绑定多次 callbacks 等待耗时操作执行完后自动执行的函数 字符串转对象 option可选参数12 sizzlesizzle $().ready(function(){ }) Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。 门面接口底层接口快捷方法ready和load事件ready先执行，load后执行 DOM文档加载的步骤： (1) 解析HTML结构。(2) 加载外部脚本和样式表文件。(3) 解析并执行脚本代码。(4) 构造HTML DOM模型。//ready(5) 加载图片等外部文件。(6) 页面加载完毕。//load promise1document.addEventListener( "DOMContentLoaded", completed, false ); 类数组对象 jquery实现了9种方法的重载 123456789101112131415var aQuery = function(selector) &#123; //强制为对象 if (!(this instanceof aQuery)) &#123; return new aQuery(selector); &#125; var elem = document.getElementById(/[^#].*/.exec(selector)[0]); this.length = 1; this[0] = elem; this.context = document; this.selector = selector; this.get = function(num) &#123; return this[num]; &#125; return this;&#125; 属性与方法作为对象的key与value的方式给映射到this上 立即调用表达式12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery; &#125;)(window); 减少变量查找所经过的scope作用域:当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量 挂在到window下执行 在外面就可以用$()执行函数 自执行 匿名函数，不存在外部引用.防止全局变量污染。 jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）小括号把表达式组合分块，每个小伙好把匿名函数括起来返回一个匿名函数Function对象。（function（）{})()目的：使匿名函数像有名字一样，可以取得它的引用位置。（单利模式）在这个引用位置后面加参数列表，实现普通函数调用。 1234(function(window)&#123; var jQuery=function()&#123;console.log("jqqqqqqq");&#125; window.aaa=jQuery//保留jquery定义的变量，只暴露为aaa() &#125;)(window); zepto的方式 12345var Zepto=(function() &#123; var Zepto= function()&#123;&#125;; return Zepto&#125;)();Zepto()]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javanet]]></title>
    <url>%2F2018%2F03%2F11%2Fjavanet%2F</url>
    <content type="text"><![CDATA[模块化开发 按业务层次划分，将dao层和service层单独划分成模块 功能划分：管理和销售模块 重复使用的模块：Util，Quartz，Swagger 构建工具 Gradle模块：jar/war可以独立部署创建gradle java项目 使用本地gradle修改构建脚本 添加单独文件dependencies.gradle12345678910111213141516171819202122232425262728293031323334353637383940ext &#123; versions = [ springBootVersion: '2.0.0.RELEASE' ] libs = [ common : [ "org.springframework.boot:spring-boot-starter-web:$&#123;versions.springBootVersion&#125;", "org.springframework.boot:spring-boot-starter-data-jpa:$&#123;versions.springBootVersion&#125;", "org.apache.commons:commons-lang3:3.5" , "com.h2database:h2:1.4.195" ], findbugs: [ "com.google.code.findbugs:jsr305:1.3.9" ], mysql : [ "mysql:mysql-connector-java:5.1.29" ], jsonrpc:[ "com.github.briandilley.jsonrpc4j:jsonrpc4j:1.5.1" ], swagger: [ "io.springfox:springfox-swagger2:2.7.0", "io.springfox:springfox-swagger-ui:2.7.0" ], hazelcast:[ 'com.hazelcast:hazelcast:3.8.6', 'com.hazelcast:hazelcast-spring:3.8.6', ], activemq:[ "org.springframework.boot:spring-boot-starter-activemq:$&#123;versions.springBootVersion&#125;", ], rsa:[ 'commons-codec:commons-codec:1.8' ], test : [ "org.springframework.boot:spring-boot-starter-test:$&#123;versions.springBootVersion&#125;" ] ]&#125; 修改build.gradle123456789101112131415161718192021apply from: "$rootDir/dependencies.gradle"subprojects &#123; apply plugin: 'java' apply plugin: 'war' sourceCompatibility = 1.8 targetCompatibility = 1.8 repositories &#123; mavenLocal() mavenCentral() &#125; dependencies &#123; compile libs.common testCompile libs.test &#125; [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'&#125; 在工程上新建Module 因为subprojects定义过了所有模块，将util的build.gradle清空新建其他api,entity,manager,quartz,swagger,saller模块。删除根目录下的src 数据库设计1.管理端：产品表 datetime 保存的时间更广，timestamp有时区信息 编号varchar50、名称varchar50、收益率decimal5,3、锁定期smallint、状态varchar20、起投金额decimal 15,3、投资步长decimal 15,3、备注创建时间datetime、创建者varchar20、更新时间datetime、更新者varchar201234567891011121314151617use managerDROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `Id` varchar(50) NOT NULL DEFAULT '' COMMENT '产品编号', `name` varchar(50) NOT NULL DEFAULT '' COMMENT '产品名称', `threshold_amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '起投金额', `step_amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '投资补偿', `lock_term` smallint(6) NOT NULL DEFAULT '0' COMMENT '锁定期', `reward_rate` decimal(5,3) NOT NULL DEFAULT '0.000' COMMENT '收益率', `status` varchar(20) CHARACTER SET latin1 NOT NULL DEFAULT '' COMMENT 'audining审核中', `memo` varchar(200) DEFAULT NULL, `create_at` datetime DEFAULT NULL COMMENT '创建时间', `create_user` varchar(20) DEFAULT NULL, `update_at` datetime DEFAULT NULL, `update_user` varchar(20) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2.销售端：订单表order_t (order是关键字)订单编号varchar50 渠道编号varchar50 产品编号varchar50 用户编号varchar50 外部订单编号varchar50 类型varchar50 状态varchar50 金额decimal15,3 备注varchar200 创建时间datetime 更新时间datetime1234567891011121314151617create database seller;use seller;DROP TABLE IF EXISTS `oreder_t`;CREATE TABLE `oreder_t` ( `order_id` varchar(50) NOT NULL DEFAULT '', `ch_id` varchar(50) NOT NULL DEFAULT '' COMMENT '渠道编号', `product_id` varchar(50) NOT NULL DEFAULT '' COMMENT '产品编号', `chan_user_id` varchar(50) NOT NULL DEFAULT '', `order_type` varchar(50) NOT NULL DEFAULT '' COMMENT '状态购买赎回', `order_status` varchar(50) NOT NULL DEFAULT '' COMMENT '状态初始化处理中成功失败', `outer_order_id` varchar(50) NOT NULL DEFAULT '' COMMENT '外部订单编号', `amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '金额', `memo` varchar(200) DEFAULT NULL COMMENT '备注', `create_at` datetime DEFAULT NULL COMMENT '创建时间', `update_at` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`order_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; entityentity的java里新建包entity新建Product和Order类12345678910111213141516@Entitypublic class Product &#123; @Id private String id; private String name; private String status; private BigDecimal thresholdAmount; private BigDecimal stepAmount; private Integer lockTerm; private BigDecimal rewardRate; private String memo; private Date createAt; private Date updateAt; private String createUser; private String updateUser;&#125; 重写toString（apache.commons）123@Overridepublic String toString() &#123; return ReflectionToStringBuilder.toString(this, ToStringStyle.SIMPLE_STYLE); 产品status的枚举类 新建enums包12345678910public enum ProductStatus &#123; AUDITING("审核中"), IN_SELL("销售中"), LOCKED("暂停销售"), FINISHED("已结束"); ProductStatus(String desc) &#123; this.desc = desc; &#125; private String desc;&#125; 在Product类中添加说明1234/*** @see entity.enums.ProductStatus*/private String status; Order类1234567891011121314@Entity(name = "order_t")public class Order &#123; @Id private String orderId; private String chanId; private String chanUserId; private String orderType; private String orderStatus; private String outerOrderId; private BigDecimal amount; private String memo; private Date createAt; private Date updateAt;&#125; 订单状态和订单种类的枚举类1234567891011public enum OrderType &#123; APPLY("申购"), REDEEM("赎回"); private String desc; OrderType(String desc) &#123; this.desc = desc; &#125; public String getDesc() &#123; return desc; &#125;&#125; 添加doc12345678/** * @see entity.enums.OrderType */private String orderType;/** * @see entity.enums.OrderStatus */private String orderStatus; 123456789101112131415public enum OrderStatus &#123; INIT("初始化"), PROCESS("处理中"), SUCCESS("成功"), FAIL("失败"); private String desc; OrderStatus(String desc) &#123; this.desc = desc; &#125; public String getDesc() &#123; return desc; &#125;&#125; manager 添加新建mannager-ManagerApp.javaentity不在manager里要手动添加扫描路径1234567@SpringBootApplication@EntityScan(basePackages = &#123;"entity"&#125;)public class ManagerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ManagerApp.class); &#125;&#125; 在resources添加jpa配置文件123456789spring: datasource: url: jdbc:mysql://192.168.3.109:3306/manager?user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=utf-8 jpa: show-sql: trueserver: servlet: context-path: /manager port: 8081 新建controller，repository,service包dao层ProductRepository 12public interface ProductRepository extends JpaRepository&lt;Product,String&gt;,JpaSpecificationExecutor&lt;Product&gt;&#123;&#125; int会有默认值 Integer不会有默认值判断整数的方法service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Servicepublic class ProductService &#123; private static Logger LOG = LoggerFactory.getLogger(ProductService.class); @Autowired private ProductRepository repository; public Product addProduct(Product product)&#123; LOG.debug("创建产品，参数：&#123;&#125;",product); //数据校验 checkProduct(product); setDefault(product); Product rst = repository.save(product); LOG.debug("创建产品，结果:&#123;&#125;",rst); return rst; &#125; /** * 产品：编号 步长 收益率 校验 * @param product */ private void checkProduct(Product product) &#123; Assert.notNull(product.getId(), "编号不可为空"); Assert.isTrue(BigDecimal.ZERO.compareTo(product.getRewardRate())&lt;0&amp;&amp;BigDecimal.valueOf(30).compareTo(product.getRewardRate())&gt;=0,"收益率范围错误" ); Assert.isTrue(BigDecimal.valueOf(product.getStepAmount().longValue()).compareTo(product.getStepAmount())==0, "投资步长需为整数"); &#125; /** * 产品默认值：创建更新时间，步长，状态，锁定期 * @param product */ public void setDefault(Product product) &#123; if(product.getCreateAt()==null)&#123; product.setCreateAt(new Date()); &#125; if(product.getUpdateAt()==null)&#123; product.setUpdateAt(new Date()); &#125; if(product.getStepAmount()==null)&#123; product.setStepAmount(BigDecimal.ZERO); &#125; if(product.getLockTerm()== null)&#123; product.setLockTerm(0); &#125; if(product.getStatus()==null)&#123; product.setStatus(ProductStatus.AUDITING.name()); &#125; &#125;&#125; controller info级别的log123456789101112131415@RestController@RequestMapping("/products")public class ProductController &#123; private static Logger LOG = LoggerFactory.getLogger(ProductController.class); @Autowired private ProductService service; @RequestMapping(value = "",method= RequestMethod.POST) public Product addProduct(@RequestBody Product product)&#123; LOG.info("创建产品，参数:&#123;&#125;",product); Product rst = service.addProduct(product); LOG.info("创建产品，参数:&#123;&#125;",product); return rst; &#125;&#125; manager 查询service1234567public Product findOne(String id)&#123; Assert.notNull(id,"需要产编号参数"); LOG.debug("查询单个产品,id=&#123;&#125;",id); Product product = repository.findById(id).orElse(null); LOG.debug("查询单个产品,结果=&#123;&#125;",product); return product;&#125; controller1234567@RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.GET)public Product findOne(@PathVariable String id)&#123; LOG.info("查询单个产品，id:&#123;&#125;",id); Product product = service.findOne(id); LOG.info("查询单个产品，结果:&#123;&#125;",product); return product;&#125; 分页查询service123456789101112131415161718192021222324252627282930313233343536public Page&lt;Product&gt; query(List&lt;String&gt; idList, BigDecimal minRewardRate, BigDecimal maxRewardRate, List&lt;String&gt; statusList, Pageable pageable)&#123; LOG.debug("查询产品,idList=&#123;&#125;,min=&#123;&#125;,max:&#123;&#125;,status=&#123;&#125;,pageable=&#123;&#125;",idList,minRewardRate,maxRewardRate,statusList,pageable); Specification&lt;Product&gt; specification = new Specification&lt;Product&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Product&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //获得列 Expression&lt;String&gt; idCol = root.get("id"); Expression&lt;BigDecimal&gt; rewardRateCol = root.get("rewardRate"); Expression&lt;String&gt; statusCol = root.get("status"); //断言列表 List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if(idList!=null &amp;&amp;idList.size()&gt;0)&#123; predicates.add(idCol.in(idList)); &#125; if(minRewardRate!=null&amp;&amp;BigDecimal.ZERO.compareTo(minRewardRate)&lt;0)&#123; predicates.add(cb.ge(rewardRateCol,minRewardRate)); &#125; if(maxRewardRate!=null&amp;&amp;BigDecimal.ZERO.compareTo(maxRewardRate)&lt;0)&#123; predicates.add(cb.le(rewardRateCol,maxRewardRate)); &#125; if(statusList!=null&amp;&amp;statusList.size()&gt;0)&#123; predicates.add(statusCol.in(statusList)); &#125; query.where(predicates.toArray(new Predicate[0])); return null; &#125; &#125;; Page&lt;Product&gt; page = repository.findAll(specification, pageable); LOG.debug("查询产品，结果=&#123;&#125;",page); return page;&#125; controller1234567891011121314151617@RequestMapping(value = "",method = RequestMethod.GET) public Page&lt;Product&gt; query(String ids, BigDecimal minRewardRate,BigDecimal maxRewardRate, String status,@RequestParam(defaultValue = "0") int pageNum,@RequestParam(defaultValue = "10")int pageSize)&#123; LOG.info("查询产品,ids=&#123;&#125;,min=&#123;&#125;,max=&#123;&#125;,status=&#123;&#125;,pagenum =&#123;&#125;,pagesize=&#123;&#125;", ids,minRewardRate,maxRewardRate,status,pageNum,pageSize); List&lt;String&gt; idList = null,statusList = null; if(!StringUtils.isEmpty(ids))&#123; idList = Arrays.asList(ids.split(",")); &#125; if(!StringUtils.isEmpty(status))&#123; statusList = Arrays.asList(status.split(",")); &#125; Pageable pageable = new PageRequest(pageNum,pageSize); Page&lt;Product&gt; page = service.query(idList, minRewardRate, maxRewardRate, statusList, pageable); LOG.info("=&#123;&#125;",page ); return page; &#125; 测试启动MangerAPP添加post:http://localhost:8081/manager/productsContent-Type: application/json123456789&#123; "id":"001", "name":"金融1号", "thresholdAmount":10, "stepAmount":1, "lockTerm":0, "rewardRate":3.86, "status":"AUDITING"&#125; 查询get：http://localhost:8081/manager/products/001 搜索功能：get:http://localhost:8081/manager/products?minRewardRate=3&amp;maxRewardRate=5&amp;status=AUDITING&amp;pageNum=0&amp;pageSize=10 统一错误处理https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-error-handlingspring boot提供了默认的/error全局错误处理对于machine clients(程序，jar包，http client ,ajax发起的), it produces a JSON response 包括HTTP status, the exception message.对于浏览器（browser clients会自动添加accept: text/html到报文头）发起的请求renders the same data in HTML format 如果用postman加上Accept:text/html就返回html通过实现ErrorController接口注册到容器中或者添加一个ErrorAttributesbean还可以用@ControllerAdvice拦截controller的错误 源码：变成html的实现方法BasicErrorController123@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController 所以可以通过修改server.error.path修改默认配置1234567891011@RequestMapping(produces = "text/html")public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); //如果没有视图，用error视图 return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);&#125; 注册过程1234567@Bean//条件表达式，如果没有则新建@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers);&#125; html错误形式1234567891011121314151617181920212223242526272829@Configuration@ConditionalOnProperty(prefix = "server.error.whitelabel", name = "enabled", matchIfMissing = true)@Conditional(ErrorTemplateMissingCondition.class)protected static class WhitelabelErrorViewConfiguration &#123; private final SpelView defaultErrorView = new SpelView( "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;" + "&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;" + "&lt;div id='created'&gt;$&#123;timestamp&#125;&lt;/div&gt;" + "&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;" + "&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"); //注册了一个View名字叫error @Bean(name = "error") @ConditionalOnMissingBean(name = "error") public View defaultErrorView() &#123; return this.defaultErrorView; &#125; // If the user adds @EnableWebMvc then the bean name view resolver from // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment. @Bean @ConditionalOnMissingBean(BeanNameViewResolver.class) public BeanNameViewResolver beanNameViewResolver() &#123; BeanNameViewResolver resolver = new BeanNameViewResolver(); resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; &#125;&#125; post：http://localhost:8081/manager/products/12345678&#123; "name":"金融1号", "thresholdAmount":10, "stepAmount":1, "lockTerm":0, "rewardRate":3.86, "status":"AUDITING"&#125; 返回1234567&#123; "timestamp": "2018-08-29 19:38:21", "status": 500, "error": "Internal Server Error", "message": "编号不可为空", "path": "/manager/products/"&#125; 新建错误页面123456789src/ +- main/ +- java/ | + &lt;source code&gt; +- resources/ +- public/ +- error/ | +- 404.html +- &lt;other public assets&gt; 方法1新建resources-static.error-5xx.html 方法2新建error包 新建类继承BasicErrorController重写返回错误的方法，去掉不要的信息123456789101112131415public class MyErrorController extends BasicErrorController&#123; public MyErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties, List&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; super(errorAttributes, errorProperties, errorViewResolvers); &#125; @Override protected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(request, includeStackTrace); errorAttributes.remove("timestamp"); errorAttributes.remove("error"); errorAttributes.remove("path"); return errorAttributes; &#125;&#125; 添加配置类注册bean 参考BasicError的注册类ErrorMvcAutoConfiguration123456789@Configurationpublic class ErrorConfiguration &#123; @Bean public MyErrorController basicErrorController(ErrorAttributes errorAttributes, ServerProperties serverProperties, ObjectProvider&lt;List&lt;ErrorViewResolver&gt;&gt; errorViewResolversProvider) &#123; return new MyErrorController(errorAttributes, serverProperties.getError(),errorViewResolversProvider.getIfAvailable()); &#125;&#125; 添加错误枚举类(注意 枚举类中的类方法)1234567891011121314151617181920public enum ErrorEnum &#123; ID_NOT_NULL("F001","编号不可空",false), UNKNOWN("999","未知异常",false); private String code; private String message; private boolean canRetry; ErrorEnum(String code, String message, boolean canRetry) &#123; this.code = code; this.message = message; this.canRetry = canRetry; &#125; public static ErrorEnum getByCode(String code)&#123; for(ErrorEnum errorEnum:ErrorEnum.values())&#123; if(errorEnum.code.equals(code))&#123; return errorEnum; &#125; &#125; return UNKNOWN; &#125; 修改service中的check抛出的不是message而是自己定义的错误code12private void checkProduct(Product product) &#123;Assert.notNull(product.getId(), ErrorEnum.ID_NOT_NULL.getCode());&#125; 修改MyErrorController,只输出自己定义的错误信息12345678910111213141516 @Overrideprotected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(request, includeStackTrace); errorAttributes.remove("timestamp"); errorAttributes.remove("error"); errorAttributes.remove("path"); String message = (String)errorAttributes.get("message"); errorAttributes.remove("message"); ErrorEnum errorEnum = ErrorEnum.getByCode(message); errorAttributes.put("message",errorEnum.getMessage() ); errorAttributes.put("code",errorEnum.getCode() ); errorAttributes.put("canRetry",errorEnum.isCanRetry() ); return errorAttributes;&#125; 输出12345&#123; "message": "编号不可空", "code": "F001", "canRetry": false&#125; 方法3：@ControllerAdvice优先级比方法2高，controller异常后直接这个然后返回response123456789101112131415161718@ControllerAdvice(basePackages = &#123;"manager.controller"&#125;)public class ErrorControllerAdvice &#123; @ExceptionHandler(Exception.class) @ResponseBody public ResponseEntity handleException(Exception e)&#123; Map&lt;String, Object&gt; errorAttributes = new HashMap&lt;&gt;(); String errorcode = e.getMessage(); ErrorEnum errorEnum = ErrorEnum.getByCode(errorcode); errorAttributes.put("message",errorEnum.getMessage() ); errorAttributes.put("code",errorEnum.getCode() ); errorAttributes.put("canRetry",errorEnum.isCanRetry() ); //这里再抛一个异常就到basicerror里了 Assert.isNull(errorAttributes,"advice" ); errorAttributes.put("type","advice"); return new ResponseEntity(errorAttributes, HttpStatus.INTERNAL_SERVER_ERROR); &#125; jackson格式化 好像并不用1234spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 自动化测试功能测试，工具类还是要用单元测试新建Util类1.JsonUtil:Object-&gt;Json 用于log输出12345678910111213141516171819202122public class JsonUtil &#123; private static final Logger LOG = LoggerFactory.getLogger(JsonUtil.class); private final static ObjectMapper mapper = new ObjectMapper(); public static String toJson(Object obj) &#123; try &#123; return mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; LOG.error("to json exception.", e); throw new JSONException("把对象转换为JSON时出错了", e); &#125; &#125;&#125;final class JSONException extends RuntimeException &#123; public JSONException(final String message) &#123; super(message); &#125; public JSONException(final String message, final Throwable cause) &#123; super(message, cause); &#125;&#125; 2.RestUtil:发送Http请求12345678910111213141516171819public class RestUtil &#123; static Logger log = LoggerFactory.getLogger(RestUtil.class); public static HttpEntity&lt;String&gt; makePostJSONEntiry(Object param) &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON_UTF8); headers.add("Accept", MediaType.APPLICATION_JSON_VALUE); HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;( JsonUtil.toJson(param), headers); log.info("rest-post-json-请求参数:&#123;&#125;", formEntity.toString()); return formEntity; &#125; public static &lt;T&gt; T postJSON(RestTemplate restTemplate, String url, Object param, Class&lt;T&gt; responseType) &#123; HttpEntity&lt;String&gt; formEntity = makePostJSONEntiry(param); T result = restTemplate.postForObject(url, formEntity, responseType); log.info("rest-post-json 响应信息:&#123;&#125;", JsonUtil.toJson(result)); return result; &#125;&#125; 在manager添加util依赖1compile project(":util") 新建测试类test-manager.controller-ProductControllerTest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RunWith(SpringRunner.class)//随机端口@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class ProductControllerTest &#123; private static RestTemplate rest =new RestTemplate(); @Value("http://localhost:$&#123;local.server.port&#125;/manager") private String baseUrl; //正常的测试用例 private static List&lt;Product&gt; normals = new ArrayList&lt;&gt;(); //异常测试用例 private static List&lt;Product&gt; exceptions = new ArrayList&lt;&gt;(); @BeforeClass public static void init()&#123; Product p1 = new Product("T001", "灵活宝1号", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(1), BigDecimal.valueOf(3.42)); Product p2 = new Product("T002", "活期盈-金色人生", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(0), BigDecimal.valueOf(3.28)); Product p3 = new Product("T003", "朝朝盈-聚财", ProductStatus.AUDITING.name(), BigDecimal.valueOf(100), BigDecimal.valueOf(10), BigDecimal.valueOf(3.86)); normals.add(p1); normals.add(p2); normals.add(p3); //异常 Product e1 = new Product(null, "编号空", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(1), BigDecimal.valueOf(3.42)); Product e2 = new Product("E002", "收益&gt;30", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(0), BigDecimal.valueOf(31)); Product e3 = new Product("E003", "投资步长是小数", ProductStatus.AUDITING.name(), BigDecimal.valueOf(100), BigDecimal.valueOf(1.01), BigDecimal.valueOf(3.86)); exceptions.add(e1); exceptions.add(e2); exceptions.add(e3); &#125; @Test public void create()&#123; normals.forEach(product -&gt; &#123; Product rst = RestUtil.postJSON(rest, baseUrl + "/products", product, Product.class); Assert.notNull(rst.getCreateAt(),"插入失败" ); &#125;); exceptions.forEach(product -&gt; &#123; Product rst = RestUtil.postJSON(rest, baseUrl + "/products", product, Product.class); Assert.notNull(rst.getCreateAt(),"插入失败" ); &#125;); &#125;&#125; 对错误的测试用例添加异常捕获//todo 3-6,3-6 查询的测试 文档管理工具swagger//todo销售端产品查询 申购赎回 对账jsonrpc添加全局依赖123456ext &#123;libs = [jsonrpc:[ "com.github.briandilley.jsonrpc4j:jsonrpc4j:1.5.1"],]&#125; 添加到api模块123dependencies&#123; compile libs.jsonrpc&#125; 添加entity依赖新建接口api-ProductRpc123456789101112131415@JsonRpcService("rpc/products")public interface ProductRpc &#123; /** * 查询多个产品 * @param req * @return */ List&lt;Product&gt; query(ProductRpcReq req); /** * 查单个产品 * @param id * @return */ Product findOne(String id); 将参数复杂的接口的参数封装到请求对象api-domain123456public class ProductRpcReq &#123; private List&lt;String&gt; idList; private BigDecimal minRewardRate; private BigDecimal maxRewardRate; private List&lt;String&gt; statusList; &#125; 修改manger添加api依赖1compile project(":api") 在管理端新建包rpcrpc实现类12345678910111213141516171819202122232425@AutoJsonRpcServiceImpl@Servicepublic class ProductRpcImpl implements ProductRpc &#123; private static Logger LOG = LoggerFactory.getLogger(ProductRpcImpl.class); @Autowired private ProductService productService; @Override public List&lt;Product&gt; query(ProductRpcReq req) &#123; LOG.info("查询多个产品：&#123;&#125;",req ); Pageable pageable = new PageRequest(0,1000, Sort.Direction.DESC,"rewardRate"); Page&lt;Product&gt; page = productService.query(req.getIdList(), req.getMinRewardRate(), req.getMaxRewardRate(), req.getStatusList(), pageable); LOG.info("查询多个结果：&#123;&#125;",page ); return page.getContent(); &#125; @Override public Product findOne(String id) &#123; LOG.info("请求id:&#123;&#125;",id); Product rst = productService.findOne(id); LOG.info("结果id:&#123;&#125;",rst); return rst; &#125;&#125; 将rpc地址交给spring管理的配置类在manager新建包configuration rpc服务端1234567@Configurationpublic class RpcConfiguration &#123; @Bean public AutoJsonRpcServiceImplExporter rpcServiceImplExporter()&#123; return new AutoJsonRpcServiceImplExporter(); &#125;&#125; 可以看到日志信息 说明在manager的rpc实现导出到api中的地址成功122018-08-30 13:17:37.832 WARN 21224 --- [ main] o.s.c.a.ConfigurationClassEnhancer : @Bean method RpcConfiguration.rpcServiceImplExporter is non-static and returns an object assignable to Spring&apos;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&apos;s declaring @Configuration class. Add the &apos;static&apos; modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details.2018-08-30 13:17:37.846 INFO 21224 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : exporting bean [productRpcImpl] ---&gt; [/products] saller模块：添加api依赖，新建saller包并添加启动类123dependencies&#123; compile project(":api")&#125; 123456@SpringBootApplicationpublic class SellerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(SellerApp.class); &#125;&#125; 新建service包1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class ProductRpcService &#123; private static Logger LOG = LoggerFactory.getLogger(ProductRpcService.class); @Autowired private ProductRpc productRpc; /** * 查询全部产品 暂时不分页返回 * @return List */ public List&lt;Product&gt; findAll()&#123; ProductRpcReq req = new ProductRpcReq(); List&lt;String&gt; status = new ArrayList&lt;&gt;(); //只能查询销售中的 status.add(ProductStatus.IN_SELL.name()); req.setStatusList(status); LOG.info("rpc查询全部产品 请求:&#123;&#125;",req); List&lt;Product&gt; result = productRpc.query(req); LOG.info("rpc查询全部产品 结果:&#123;&#125;",result); return result; &#125; //测试类 @PostConstruct public void testFindAll()&#123; findAll(); &#125; public Product findOne(String id)&#123; LOG.info("单个产品请求:&#123;&#125;", id); Product rst = productRpc.findOne(id); LOG.info("单个产品 结果:&#123;&#125;", rst); return rst; &#125; @PostConstruct public void testfindone()&#123; findOne("001"); &#125; 添加配置文件映射rpc路径application.yml123456server: servlet: context-path: /seller port: 8082rpc.manager.url: http://localhost:8081/manager/ 新建configuration包 导出bean创建rpc客户端123456789101112131415161718@Configuration@ComponentScan(basePackageClasses = &#123;ProductRpc.class&#125;)public class RpcConfiguration &#123; private static Logger LOG = LoggerFactory.getLogger(RpcConfiguration.class); @Bean public AutoJsonRpcClientProxyCreator rpcClientProxyCreator(@Value("$&#123;rpc.manager.url&#125;") String url)&#123; AutoJsonRpcClientProxyCreator creator = new AutoJsonRpcClientProxyCreator(); //设置地址 try&#123; creator.setBaseUrl(new URL(url)); &#125;catch (MalformedURLException e)&#123; LOG.error("创建rpc服务地址错误",e); &#125; //扫描接口 creator.setScanPackage(ProductRpc.class.getPackage().getName()); return creator; &#125;&#125; 修改路径1bean [productRpcImpl] ---&gt; [rpc/products] jsonRPC注意点：1.不能传递复杂参数不要传递分页对象2.路径rpc路径前不能有/3.RPC配置类的扫描路径 JSONRPC 客户端原理123logging: level: com.googlecode.jsonrpc4j: debug 开启客户端debug log122018-08-30 15:28:40.612 DEBUG 31512 --- [ main] c.g.j.s.AutoJsonRpcClientProxyCreator : Scanning 'classpath:api/**/*.class' for JSON-RPC service interfaces.2018-08-30 15:28:40.613 DEBUG 31512 --- [ main] c.g.j.s.AutoJsonRpcClientProxyCreator : Found JSON-RPC service to proxy [api.ProductRpc] on path 'rpc/products'. 12342018-08-30 15:28:42.819 INFO 31512 --- [ main] saller.service.ProductRpcService : 单个产品请求:0012018-08-30 15:28:42.836 DEBUG 31512 --- [ main] c.g.jsonrpc4j.JsonRpcHttpClient : Request &#123;"id":"1269662779","jsonrpc":"2.0","method":"findOne","params":["001"]&#125;2018-08-30 15:28:42.872 DEBUG 31512 --- [ main] c.g.jsonrpc4j.JsonRpcHttpClient : JSON-PRC Response: &#123;"jsonrpc":"2.0","id":"1269662779","result":&#123;"id":"001","name":"金融1号","status":"AUDITING","thresholdAmount":10.0,"stepAmount":1,"lockTerm":0,"rewardRate":3.86,"memo":null,"createAt":"2018-08-29T11:38:02.000+0000","updateAt":"2018-08-29T11:38:02.000+0000","createUser":null,"updateUser":null&#125;&#125;2018-08-30 15:28:42.905 INFO 31512 --- [ main] saller.service.ProductRpcService : 单个产品 结果:entity.Product@12fcc71f[id=001,name=金融1号,status=AUDITING,thresholdAmount=10.0,stepAmount=1,lockTerm=0,rewardRate=3.86,memo=&lt;null&gt;,createAt=Wed Aug 29 19:38:02 CST 2018,updateAt=Wed Aug 29 19:38:02 CST 2018,createUser=&lt;null&gt;,updateUser=&lt;null&gt;] AutoJsonRpcClientProxyCreator源码展开代码 自动注入Application从容器中获取bean之后会调用方法postProcessBeanFactory1implements BeanFactoryPostProcessor, ApplicationContextAware 1234567891011121314151617181920212223242526272829303132private String resolvePackageToScan() &#123; return CLASSPATH_URL_PREFIX + convertClassNameToResourcePath(scanPackage) + "/**/*.class";&#125;@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; SimpleMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory(applicationContext); DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) beanFactory; //配置的包路径 String resolvedPath = resolvePackageToScan(); logger.debug("Scanning '&#123;&#125;' for JSON-RPC service interfaces.", resolvedPath); try &#123; for (Resource resource : applicationContext.getResources(resolvedPath)) &#123; if (resource.isReadable()) &#123; MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource); ClassMetadata classMetadata = metadataReader.getClassMetadata(); //扫描注解 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); String jsonRpcPathAnnotation = JsonRpcService.class.getName(); //如果是jsonRpc服务 if (annotationMetadata.isAnnotated(jsonRpcPathAnnotation)) &#123; String className = classMetadata.getClassName(); String path = (String) annotationMetadata.getAnnotationAttributes(jsonRpcPathAnnotation).get("value"); logger.debug("Found JSON-RPC service to proxy [&#123;&#125;] on path '&#123;&#125;'.", className, path); //注册到容器 registerJsonProxyBean(defaultListableBeanFactory, className, path); &#125; &#125; &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(format("Cannot scan package '%s' for classes.", resolvedPath), e); &#125;&#125; 注册到容器1234567891011121314151617181920/** * Registers a new proxy bean with the bean factory. */private void registerJsonProxyBean(DefaultListableBeanFactory defaultListableBeanFactory, String className, String path) &#123; BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder //代理类 .rootBeanDefinition(JsonProxyFactoryBean.class) .addPropertyValue("serviceUrl", appendBasePath(path)) .addPropertyValue("serviceInterface", className); if (objectMapper != null) &#123; beanDefinitionBuilder.addPropertyValue("objectMapper", objectMapper); &#125; if (contentType != null) &#123; beanDefinitionBuilder.addPropertyValue("contentType", contentType); &#125; defaultListableBeanFactory.registerBeanDefinition(className + "-clientProxy", beanDefinitionBuilder.getBeanDefinition());&#125; JsonProxyFactoryBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JsonProxyFactoryBean extends UrlBasedRemoteAccessor implements MethodInterceptor, InitializingBean, FactoryBean&lt;Object&gt;, ApplicationContextAware &#123;@Override @SuppressWarnings("unchecked") public void afterPropertiesSet() &#123; super.afterPropertiesSet(); //根据接口创建代理对象 proxyObject = ProxyFactory.getProxy(getServiceInterface(), this); if (jsonRpcHttpClient==null) &#123; //与spring容器共用一个objectMapper if (objectMapper == null &amp;&amp; applicationContext != null &amp;&amp; applicationContext.containsBean("objectMapper")) &#123; objectMapper = (ObjectMapper) applicationContext.getBean("objectMapper"); &#125; if (objectMapper == null &amp;&amp; applicationContext != null) &#123; try &#123; objectMapper = BeanFactoryUtils.beanOfTypeIncludingAncestors(applicationContext, ObjectMapper.class); &#125; catch (Exception e) &#123; logger.debug(e); &#125; &#125; if (objectMapper == null) &#123; objectMapper = new ObjectMapper(); &#125; try &#123; //通过HTTP的方式发送数据的 jsonRpcHttpClient = new JsonRpcHttpClient(objectMapper, new URL(getServiceUrl()), extraHttpHeaders); jsonRpcHttpClient.setRequestListener(requestListener); jsonRpcHttpClient.setSslContext(sslContext); jsonRpcHttpClient.setHostNameVerifier(hostNameVerifier); if (contentType != null) &#123; jsonRpcHttpClient.setContentType(contentType); &#125; if (exceptionResolver!=null) &#123; jsonRpcHttpClient.setExceptionResolver(exceptionResolver); &#125; &#125; catch (MalformedURLException mue) &#123; throw new RuntimeException(mue); &#125; &#125; &#125;&#125; 实际与服务端交互的http方法12345678910111213@Overridepublic Object invoke(MethodInvocation invocation) throws Throwable &#123; Method method = invocation.getMethod(); if (method.getDeclaringClass() == Object.class &amp;&amp; method.getName().equals("toString")) &#123; return proxyObject.getClass().getName() + "@" + System.identityHashCode(proxyObject); &#125; Type retType = (invocation.getMethod().getGenericReturnType() != null) ? invocation.getMethod().getGenericReturnType() : invocation.getMethod().getReturnType(); Object arguments = ReflectionUtil.parseArguments(invocation.getMethod(), invocation.getArguments()); return jsonRpcHttpClient.invoke(invocation.getMethod().getName(), arguments, retType, extraHttpHeaders);&#125; jsonRpcHttpClient.java12345678910111213141516171819private HttpURLConnection prepareConnection(Map&lt;String, String&gt; extraHeaders) throws IOException &#123; // create URLConnection HttpURLConnection connection = (HttpURLConnection) serviceUrl.openConnection(connectionProxy); connection.setConnectTimeout(connectionTimeoutMillis); connection.setReadTimeout(readTimeoutMillis); connection.setAllowUserInteraction(false); connection.setDefaultUseCaches(false); connection.setDoInput(true); connection.setDoOutput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); setupSsl(connection); addHeaders(extraHeaders, connection); return connection;&#125; 测试调用rpc路径bug1234567891011121314151617181920212223242526272829/** * Appends the base path to the path found in the interface. */private String appendBasePath(String path) &#123; try &#123; return new URL(baseUrl, path).toString(); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException(format("Cannot combine URLs '%s' and '%s' to valid URL.", baseUrl, path), e); &#125;&#125; public static void main(String[] args) throws MalformedURLException &#123; URL baseUrl = new URL("http://localhost:8081/manager/"); String path = "rpc/products"; //只有这种是对的 //http://localhost:8081/manager/rpc/products System.out.println(new URL(baseUrl, path).toString()); URL baseUrl = new URL("http://localhost:8081/manager"); String path = "/rpc/products"; //少了manager //http://localhost:8081/rpc/products System.out.println(new URL(baseUrl, path).toString()); URL baseUrl = new URL("http://localhost:8081/manager/"); String path = "/rpc/products"; //http://localhost:8081/rpc/products System.out.println(new URL(baseUrl, path).toString());&#125; 服务端的运行原理123logging: level: com.googlecode.jsonrpc4j: debug 导出bean 注册接口 创建服务 映射到handler12342018-08-30 21:48:37.315 INFO 20852 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : exporting bean [productRpcImpl] ---&gt; [rpc/products]2018-08-30 21:48:37.328 DEBUG 20852 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : Registering interface 'api.ProductRpc' for JSON-RPC bean [productRpcImpl].2018-08-30 21:48:40.683 DEBUG 20852 --- [ main] c.g.jsonrpc4j.JsonRpcBasicServer : created server for interface interface api.ProductRpc with handler class com.sun.proxy.$Proxy892018-08-30 21:48:40.685 INFO 20852 --- [ main] o.s.w.s.h.BeanNameUrlHandlerMapping : Mapped URL path [/rpc/products] onto handler '/rpc/products' 启动客户端收到http请求 参数是 调用方法findOne 1232018-08-30 21:53:22.947 DEBUG 20852 --- [nio-8081-exec-2] com.googlecode.jsonrpc4j.JsonRpcServer : Handling HttpServletRequest org.apache.catalina.connector.RequestFacade@5681e8732018-08-30 21:53:22.962 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Request: &#123;"id":"425662322","jsonrpc":"2.0","method":"findOne","params":["001"]&#125;2018-08-30 21:53:22.964 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Invoking method: findOne with args ["001"] 结果 响应信息122018-08-30 21:53:23.025 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Invoked method: findOne, result entity.Product@1f724803[id=001,name=金融1号,status=AUDITING,thresholdAmount=10.000,stepAmount=1.000,lockTerm=0,rewardRate=3.860,memo=&lt;null&gt;,createAt=2018-08-29 19:38:02.0,updateAt=2018-08-29 19:38:02.0,createUser=&lt;null&gt;,updateUser=&lt;null&gt;]2018-08-30 21:53:23.064 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Response: &#123;"jsonrpc":"2.0","id":"425662322","result":&#123;"id":"001","name":"金融1号","status":"AUDITING","thresholdAmount":1E+1,"stepAmount":1,"lockTerm":0,"rewardRate":3.86,"memo":null,"createAt":"2018-08-29T11:38:02.000+0000","updateAt":"2018-08-29T11:38:02.000+0000","createUser":null,"updateUser":null&#125;&#125; 服务端配置类AutoJsonRpcServiceImplExporter实现BeanFactoryPostProcessor的方法12345678public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) beanFactory; //&lt;path,bean名称&gt; Map&lt;String, String&gt; servicePathToBeanName = findServiceBeanDefinitions(defaultListableBeanFactory); for (Entry&lt;String, String&gt; entry : servicePathToBeanName.entrySet()) &#123; registerServiceProxy(defaultListableBeanFactory, makeUrlPath(entry.getKey()), entry.getValue()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041private static Map&lt;String, String&gt; findServiceBeanDefinitions(ConfigurableListableBeanFactory beanFactory) &#123; final Map&lt;String, String&gt; serviceBeanNames = new HashMap&lt;&gt;(); //遍历所有bean for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; //是否添加了auto rpc的注解 AutoJsonRpcServiceImpl autoJsonRpcServiceImplAnnotation = beanFactory.findAnnotationOnBean(beanName, AutoJsonRpcServiceImpl.class); //判断jsonrpcservice的注解 JsonRpcService jsonRpcServiceAnnotation = beanFactory.findAnnotationOnBean(beanName, JsonRpcService.class); //如果有Impl没有jsonrpcservice的注解 就报错 if (null != autoJsonRpcServiceImplAnnotation) &#123; if (null == jsonRpcServiceAnnotation) &#123; throw new IllegalStateException("on the bean [" + beanName + "], @" + AutoJsonRpcServiceImpl.class.getSimpleName() + " was found, but not @" + JsonRpcService.class.getSimpleName() + " -- both are required"); &#125; List&lt;String&gt; paths = new ArrayList&lt;&gt;(); //auto上的注解会作为path，实现类上可以有额外的additionPath //一个rpc服务可以映射到多个服务 Collections.addAll(paths, autoJsonRpcServiceImplAnnotation.additionalPaths()); paths.add(jsonRpcServiceAnnotation.value()); for (String path : paths) &#123; //判断格式是否合法 if (!PATTERN_JSONRPC_PATH.matcher(path).matches()) &#123; throw new RuntimeException("the path [" + path + "] for the bean [" + beanName + "] is not valid"); &#125; logger.info(String.format("exporting bean [%s] ---&gt; [%s]", beanName, path)); //判断是否是重复的服务，放到&lt;路径，名称&gt;的bean目录里 if (isNotDuplicateService(serviceBeanNames, beanName, path)) serviceBeanNames.put(path, beanName); &#125; &#125; &#125; collectFromParentBeans(beanFactory, serviceBeanNames); return serviceBeanNames; &#125; 1.前后台json格式12345class Result&lt;T&gt; &#123; private int code; private String msg; private T data;&#125; 为实现controller中的返回：123456@RequestMapping("/hello")@ResponseBodypublic Result&lt;String&gt; hello() &#123; return Result.success("hello"); // return new Result(0, "success", "hello");&#125; 给Result添加静态方法和对应的构造函数12345678public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123; return new Result&lt;T&gt; (data)&#125;private Result(T data)&#123; this.code = 200; this.message = "success"; this.data = data;&#125; 封装错误信息类，用于生成各种各样的错误信息（枚举类？）12345678910111213141516public enum CodeMsg &#123; SUCCESS(0,"success"), SERVER_ERROR(500100,"服务端异常"); private final int code; private final String msg; private CodeMsg( int code,String msg ) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125;&#125; 1return Result.error(CodeMsg.SERVER_ERROR); 2.配置文件配置项https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-propertiesaplication.properties1234567spring.thymeleaf.cache=falsespring.thymeleaf.content-type=text/htmlspring.thymeleaf.enabled=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html controller返回页面1234567@RequestMapping("/hel")public String thymeleaf(Model model) &#123; //写入model的属性可以在页面中取到 model.addAttribute("name", "名字"); //找的是prefix+hello+sufix -&gt;/templates/hello.html return "hello";&#125; hello.html12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text="'hello:'+$&#123;name&#125;" &gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3. Mybatis123456mybatis.type-aliases-package=package.model#下划线转驼峰mybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=3000mybatis.mapperLocations = classpath:package/dao/*.xml 数据源druid123456789&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718spring.datasource.url=jdbc:mysql://:3306/datasets?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=spring.datasource.password=spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters=statspring.datasource.maxActive=2spring.datasource.initialSize=1spring.datasource.maxWait=60000spring.datasource.minIdle=1spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=select &apos;x&apos;spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxOpenPreparedStatements=20 新建数据库并添加user表新建domain对象1234public class User &#123; private int id; private String name;&#125; 新建dao层interface UserDao12345@Mapperpublic interface UserDao &#123; @Select("select * from user where id = #&#123;id&#125;") public User getById(@Param("id")int id );&#125; 写service12345678@Servicepublic class UserService &#123; @AutowiredUserDao userDao;public User getById(int id) &#123; return userDao.getById(id);&#125; 添加到controller12345678@AutowiredUserService userService;@RequestMapping("/db/get")@ResponseBodypublic Result&lt;User&gt; dbGet() &#123; User user = userService.getById(1); return Result.success(user);&#125; 测试事务：数据库中已经有id=1的数据，连插入id=2，id=1的数据，如果能回滚就行dao:12@Insert("insert into user(id, name)values(#&#123;id&#125;, #&#123;name&#125;)")public int insert(User user); service:1234567891011121314//注解注释掉 报错但插入了id=2@Transactionalpublic boolean tx() &#123; User u1= new User(); u1.setId(2); u1.setName("2222"); userDao.insert(u1); User u2= new User(); u2.setId(1); u2.setName("11111"); userDao.insert(u2); return true;&#125; controller:123456@RequestMapping("/db/tx")@ResponseBodypublic Result&lt;Boolean&gt; dbTx() &#123; userService.tx(); return Result.success(true);&#125; 结果：Duplicate entry ‘1’ for key ‘PRIMARY’MySQLIntegrityConstraintViolationException: 5.集成Redis12345678910&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.38&lt;/version&gt;&lt;/dependency&gt; 配置：123456redis.host=192.168.3.109redis.port=6379redis.timeout=3redis.password=123456redis.poolMaxTotal=10redis.poolMaxIdle=10 新建redis包配置类123456789101112@Component//配置里的前缀@ConfigurationProperties(prefix="redis")public class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; Service通过service提供Redis的get/set1234567891011121314151617181920@Servicepublic class RedisService&#123; @Autowired JedisPool jedisPool; public&lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = jedisPool.getResource(); &#125; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 查看源码找JedisPool中的timeout是什么单位123456789101112JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0);//JedisPool.javapublic JedisPool(final GenericObjectPoolConfig poolConfig, final String host, int port,int timeout, final String password, final int database) &#123; this(poolConfig, host, port, timeout, password, database, null);&#125;//thispublic JedisPool(final GenericObjectPoolConfig poolConfig, final String host, int port,final int connectionTimeout, final int soTimeout, final String password, final int database, final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(poolConfig, new JedisFactory(host, port, connectionTimeout, soTimeout, password, database, clientName, ssl, sslSocketFactory, sslParameters, hostnameVerifier));&#125; JedisFactory12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public JedisFactory(final String host, final int port, final int connectionTimeout, final int soTimeout, final String password, final int database, final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;this.hostAndPort.set(new HostAndPort(host, port));//找用到connect time的地方this.connectionTimeout = connectionTimeout;this.soTimeout = soTimeout;this.password = password;this.database = database;this.clientName = clientName;this.ssl = ssl;this.sslSocketFactory = sslSocketFactory;this.sslParameters = sslParameters;this.hostnameVerifier = hostnameVerifier;&#125;//connectionTimeout用的地方PooledObject类final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout, soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);//Jedis.javapublic Jedis(final String host, final int port, final int connectionTimeout, final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, connectionTimeout, soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super BinaryJedis.javapublic BinaryJedis(final String host, final int port, final int connectionTimeout, final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;client = new Client(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);//timeout的地方是Clientclient.setConnectionTimeout(connectionTimeout);client.setSoTimeout(soTimeout);&#125;//Connection.javasocket.connect(new InetSocketAddress(host, port), connectionTimeout);socket.setSoTimeout(soTimeout);//Socket.java//!!!毫秒@param timeout the specified timeout, in milliseconds.public synchronized void setSoTimeout(int timeout) throws SocketException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (timeout &lt; 0) throw new IllegalArgumentException("timeout can't be negative"); getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));&#125; 所以回到最开始redis.timeout=3是秒1JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); //Client.java展开代码 1234567891011121314151617181920212223//Client.javapublic Client(final String host, final int port, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super-&gt;BinaryClient.javapublic BinaryClient(final String host, final int port, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super-&gt;Connection.javapublic Connection(final String host, final int port, final boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters, HostnameVerifier hostnameVerifier) &#123;this.host = host;this.port = port;this.ssl = ssl;this.sslSocketFactory = sslSocketFactory;this.sslParameters = sslParameters;this.hostnameVerifier = hostnameVerifier;&#125; 修改上面Service 加上释放连接池的代码查看Jedis的close方法源码123456789101112public void close() &#123;if (dataSource != null) &#123; if (client.isBroken()) &#123; //不关掉 返回到连接池 this.dataSource.returnBrokenResource(this); &#125; else &#123; this.dataSource.returnResource(this); &#125;&#125; else &#123; client.close();&#125;&#125; set方法BeanToStrnig用fastjson将bean对象变成string1234567891011121314151617181920212223242526272829public &lt;T&gt; boolean set(String key,T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String str = beanToString(value); if(str == null||str.length()&lt;=0)return false; jedis.set(key,str); return true; &#125;finally&#123; returnToPool(jedis); &#125;&#125;//任意类型转化成字符串import com.alibaba.fastjson.JSON;private &lt;T&gt; String beanToString(T value)&#123; //2. 添加空判断 if(value == null)return null; //3. 如果是数字，字符串，Long Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125;&#125; get方法 StringToBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class RedisService&#123; @Autowired JedisPool jedisPool; @SuppressWarnings("unchecked")//屏蔽警告 private &lt;T&gt; T stringToBean(String str,Class&lt;T&gt; clazz)&#123; //1. 参数校验 if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //2 如果是int，string，Long if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; //fastJson 其他List类型要再写 return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; public&lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jdeis = jedisPool.getResource(); //2.get的逻辑：get是String类型，需要的是T类型 String value = jedis.get(key); T t = stringToBean(value,clazz); return t; //1. 添加关闭代码 &#125;finally&#123; returnToPool(jedis); &#125; &#125; private void returnToPool(Jedis jedis)&#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; controller get测试:127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; set key1 1OK123456789@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;String&gt; redisGet() &#123; String name = redisService.get("key1", String.class); return Result.success(name);&#125; 报错： [redis.clients.jedis.JedisPool]: Circular reference involving containing bean ‘redisService’ - consider declaring the factory method as static for independence from its containing instance. Factory method ‘JedisFactory’ threw exception; nested exception is java.lang.NullPointerException 因为Service里注入了pool12@AutowiredJedisPool jedisPool; 但是 JedisPool是实例方法 创建这个Bean需要RedisSevice12@Beanpublic JedisPool JedisFactory() 所以独立出JedisPool1234567891011121314@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp;&#125; controller set测试:123456789@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; redisSet() &#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set("key3",user);//UserKey:id1 return Result.success(true);&#125; 127.0.0.1:6379&gt; get key3“{\”id\”:1,\”name\”:\”1111\”}” 模板模式：封装缓存key，加上前缀优化：将key加上Prefix，按业务模块区分缓存的key接口：123456public interface Prefix()&#123; //有效期 public int expireSeconds(); //前缀 public String getPrefix(); &#125; 实现的抽象类 防止被创建12345678910111213141516public abstract class BasePrefix implements Prefix&#123; private int expireSeconds; private String prefix; //0表示永不过期 public BasePrefix(String prefix) &#123;//0代表永不过期 this(0, prefix); &#125; public int expireSeconds()&#123; return expireSeconds; &#125; //用类名当前缀 public String getPrefix()&#123; String className = getClass().getSimpleName(); return className+":"+perfix; &#125;&#125; 实现类：用户key123456public class UserKey extends BasePrefix&#123; //私有 防实例化 private UserKey(String prefix)&#123;super(prefix);&#125; public static UserKey getById = new UserKey("id"); public static UserKey getByName = new UserKey("name");&#125; 实现类：订单key1public class OrderKey extends BasePrefix controller使用:classname+prefix+key1234567891011121314151617@RequestMapping("/redis/get") @ResponseBody public Result&lt;User&gt; redisGet() &#123; User user = redisService.get(UserKey.getById, "1", User.class); return Result.success(user); &#125; @RequestMapping("/redis/set") @ResponseBody public Result&lt;Boolean&gt; redisSet() &#123; User user = new User(); user.setId(1); user.setName("1111"); //UserKey:id1 redisService.set(UserKey.getById,"1",user); return Result.success(true); &#125; 修改Service中的get和set 12345678910111213public&lt;T&gt; T get(Prefix prefix,String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String prefixKey = prefix.getPrefix()+key; String value = jedis.get(prefixKey); T t = stringToBean(value,clazz); return t; &#125;finally&#123; returnToPool(jedis); &#125;&#125; 添加失效时间127.0.0.1:6379&gt; expire key1 3(integer) 11234567891011121314151617181920public &lt;T&gt; boolean set(KeyPrefix prefix,String key,T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String str = beanToString(value); if(str == null||str.length()&lt;=0)return false; String prefixKey = prefix.getPrefix()+key; int expire = prefix.expireSeconds(); //永不过期 if(expire&lt;=0)&#123; jedis.set(prefixKey,str); &#125;else&#123; jedis.setex(prefixKey,expire,str); &#125; return true; &#125;finally&#123; returnToPool(jedis); &#125;&#125; setex:等于set+expire命令12345public String setex(final String key, final int seconds, final String value) &#123; checkIsInMultiOrPipeline(); client.setex(key, seconds, value); return client.getStatusCodeReply(); &#125; 添加其他API:127.0.0.1:6379&gt; exists key1(integer) 1123456789public &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); String prefixKey = prefix.getPrefix()+key; return jedis.exists(prefixKey); &#125;finally &#123; returnToPool(jedis); &#125; 127.0.0.1:6379&gt; incr key1(integer) 2127.0.0.1:6379&gt; incr key1(integer) 3127.0.0.1:6379&gt; set key222 fdafdaOK127.0.0.1:6379&gt; incr key222(error) ERR value is not an integer or out of range incr1234567891011public &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 127.0.0.1:6379&gt; incr key1(integer) 5127.0.0.1:6379&gt; decr key1(integer) 4 decr1234567891011public &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 6.实现登陆数据库设计1234567891011create table `miaosha_user`( `id` bigint(20) not null comment '用户ID，手机号', `nickname` varchar(256) not null, `password` varchar(32) default null comment 'MD5(md5+salt)+salt', `salt` varchar(10) default null, `head` varchar(128) default null comment '头像', `register_date` datetime default null comment '注册时间', `last_login_date` datetime default null comment '上次登录时间', `login_cnt` int(11) default '0' comment '登陆次数', primary key (`id`))ENGINE=InnoDB DEFAULT CHARSET=utf8; 密码用户传给数据库先MDB(明文+salt)服务端存再一次md5(明文+随机salt)123456789&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt;&lt;/dependency&gt; 新建util包MD5加密123456789101112131415161718192021222324252627import org.apache.commons.codec.digest.DigestUtils;public static String md5(String src)&#123; return DigestUtils.md5Hex(src);&#125;//添加一个salt//前端form表单提交上来的密码//一次加密"123456"-&gt; 26718c17fe0b7862a27dd7dc1b532f29public static String inputPassFormPass(String inputPass)&#123; String passsalt = salt.charAt(0)+salt.charAt(2)+inputPass+salt.charAt(5); return md5(passsalt);&#125;//第二次加密，放入数据库public static String formPassToDBPass(String formPass, String salt) &#123; String toDB = ""+salt.charAt(0)+salt.charAt(2) + formPass +salt.charAt(5) + salt.charAt(4); return md5(toDB);&#125;//两次合并成1次public static String inputPassToDbPass(String inputPass, String saltDB) &#123; String formPass = inputPassToFormPass(inputPass); String dbPass = formPassToDBPass(formPass, saltDB); return dbPass;&#125;public static void main(String[] args) &#123; //c996054adec06904c675b89aa68de2ec System.out.println(inputPassToFormPass("123456")); //bef054e9b1abb70963943f32b41a3f6d System.out.println(formPassToDBPass(inputPassToFormPass("123456"), "secondsalt")); 在controller添加path1234@RequestMapping("/login") public String toLogin() &#123; return "login"; &#125; 登陆页面 登陆html页面：12345678910111213141516171819&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;!-- jquery --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/jquery.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- bootstrap --&gt; &lt;link rel="stylesheet" type="text/css" th:href="@&#123;/bootstrap/css/bootstrap.min.css&#125;" /&gt; &lt;script type="text/javascript" th:src="@&#123;/bootstrap/js/bootstrap.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- jquery-validator --&gt; &lt;script type="text/javascript" th:src="@&#123;/jquery-validation/jquery.validate.min.js&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript" th:src="@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- layer --&gt; &lt;script type="text/javascript" th:src="@&#123;/layer/layer.js&#125;"&gt;&lt;/script&gt; &lt;!-- md5.js --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/md5.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- common.js --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/common.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt; bootstrap+jquery验证:展开代码 1234567891011121314151617181920212223242526272829303132&lt;!-- 50%宽度 居中 margin: 0 auto --&gt;&lt;form name="loginForm" id="loginForm" method="post" style="width:50%; margin:0 auto"&gt; &lt;h2 style="text-align:center; margin-bottom: 20px"&gt;用户登录&lt;/h2&gt; &lt;div class="form-group"&gt; &lt;div class="row"&gt; &lt;label class="form-label col-md-4"&gt;请输入手机号码&lt;/label&gt; &lt;div class="col-md-5"&gt; &lt;input id="mobile" name = "mobile" class="form-control" type="text" placeholder="手机号码" required="true" minlength="11" maxlength="11" /&gt; &lt;/div&gt; &lt;div class="col-md-1"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="row"&gt; &lt;label class="form-label col-md-4"&gt;请输入密码&lt;/label&gt; &lt;div class="col-md-5"&gt; &lt;input id="password" name="password" class="form-control" type="password" placeholder="密码" required="true" minlength="6" maxlength="16" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-5"&gt; &lt;button class="btn btn-primary btn-block" type="reset" onclick="reset()"&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;div class="col-md-5"&gt; &lt;button class="btn btn-primary btn-block" type="submit" onclick="login()"&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; jquery validate:http://www.runoob.com/jquery/jquery-plugin-validate.html1234function login()&#123; $("#loginForm").validate(&#123; submitHandler:function(form)&#123;doLogin()&#125; &#125;) layer.js弹窗http://layer.layui.com/common.js1234function g_showLoading()&#123; var idx = layer.msg('处理中...', &#123;icon: 16,shade: [0.5, '#f5f5f5'],scrollbar: false,offset: '0px', time:100000&#125;) ; return idx;&#125; 在js中设置salt1var g_passsword_salt="abcd1234" 使用ajax异步提交1234567891011121314151617181920212223242526272829303132function doLogin()&#123; //每次提交loading框 g_showLoading() //md5加密密码 与后台规则一样 var inputpwd = $("#password").val() var str = salt.charAt(0)+salt.charAt(2)+inputpwd+salt.charAt(5) //123456-&gt;c996054adec06904c675b89aa68de2ec var password = md5(str) $.ajax(&#123; url:"/login/do_login", type:"POST", data:&#123; mobile:$("#mobile").val(), password:password &#125;, success:function(data)&#123; //无论成功失败都关闭框 layer.closeAll(); console.log("login") console.log(password) /* &#123;code: 0, msg: null, data: "登录成功"&#125; */ if(data.code==0)&#123; layer.msg("成功") console.log(data) &#125; &#125;, error:function()&#123; layer.closeAll() &#125; &#125;)&#125; 后台添加vo接收前端数据的类：1234public class LoginVo &#123; private String mobile; private String password;&#125; 添加controller：添加errormessageCodeMsg.java12345PASSWORD_EMPTY(500211, "登录密码不能为空"),MOBILE_EMPTY(500212, "手机号不能为空"),MOBILE_ERROR(500213, "手机号格式错误"),MOBILE_NOT_EXIST(500214, "手机号不存在"),PASSWORD_ERROR(500215, "密码错误"); 1234567891011121314151617181920//添加log 可以查看前端传过来的form数据是什么import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger log = LoggerFactory.getLogger(LoginController.class);@RequestMapping("/do_login")@ResponseBodypublic Result&lt;Boolean&gt; doLogin(LoginVo loginVo) &#123; log.info(loginVo.toString()); //参数校验 String password = loginVo.getPassword(); String mobile = loginVo.getMobile(); if(StringUtils.isEmpty(mobile))&#123; return Result.error(CodeMsg.MOBILE_EMPTY); &#125; if(StringUtils.isEmpty(password))&#123; return Result.error(CodeMsg.PASSWORD_EMPTY); &#125; if(!ValidatorUtil.isMobile(mobile)) return Result.error(CodeMsg.MOBILE_ERROR); &#125; 手机号验证类ValidatorUtil.java12345678910111213141516171819import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.commons.lang3.StringUtils;public class ValidatorUtil &#123; private static final Pattern mobile_pattern = Pattern.compile("^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$"); public static boolean isMobile(String str)&#123; if(StringUtils.isEmpty(str))&#123; return false; &#125; Matcher m = mobile_pattern.matcher(str); return m.matches(); &#125; public static void main(String[] args) &#123; //true System.out.println(isMobile("18912341234")); //false System.out.println(isMobile("12345678900")); &#125;&#125; 新建与数据库关联的domain对象1234567891011public class MiaoshaUser &#123; //bigint private Long id; private String nickname; private String password; private String salt; private String head; private Date registerDate; private Date lastLoginDate; private Integer loginCount;&#125; 新建dao,通过id找用户12345@Mapperpublic interface MiaoshaUserDao&#123; @Select（"select * from miaosha user where id = #&#123;id&#125;") public MiaoshaUser getById(@Param("id") long id);&#125; service获取用户及登陆:123456789101112131415161718192021222324252627282930@Servicepublic class MiaoshaUserService&#123; @Autowired MiaoshaUserDao miaoshaUserDao; public MiaoshaUser getById(long id) &#123; return miaoshaUserDao.getById(id); &#125; public CodeMsg login(LoginVo loginVo)&#123; if(loginVo == null) &#123; throw CodeMsg.SERVER_ERROR; &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); //数据库查询手机号 MiaoshaUser user = getById(Long.parseLong(mobile)); if(user == null) &#123; //用户/手机号不存在 throw new CodeMsg.MOBILE_NOT_EXIST; &#125; //数据库中的密码,salt String dbPass = user.getPassword(); String saltDB = user.getSalt(); //用前端密码+数据库salt是否等于数据库密码 String gassDBpass = MD5Util.formPassToDBPass(formPass, saltDB); if(!calcPass.equals(dbPass)) &#123; throw CodeMsg.PASSWORD_ERROR; &#125; return CodeMsg.SUCCESS; &#125;&#125; 在controller中注入12345678910@Autowired MiaoshaUserService userService; @RequestMapping("/do_login") @ResponseBody public Result&lt;String&gt; doLogin(LoginVo loginVo) &#123; //..参数校验 //登录 CodeMsg code = userService.login(loginVo); if(code.getCode()==0)return Result.success("登录成功"); else return Result.error(code); 7.JSR303参数校验+全局异常1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在controller要校验的实体前打@Valid1public Result&lt;String&gt; doLogin(@Valid LoginVo loginVo) 在实体类加注解1234public class LoginVo &#123;@NotNull@Length(min=32)private String password; 对手机号添加自定义验证注解新建validator包,新建IsMobile.java参考java.validation.constrains里的NotNull,将class改成class必须的，添加1234567891011121314@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123; &#125;)public @interface IsMobile&#123; //不能为空 boolean required() default true; //默认信息 String message() default "手机号码格式错误"; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; 新建类IsMobileValidator并在@interface里添加@Constraint(validatedBy = {IsMobileValidator.class})创建类&lt;注解,检测的类型&gt;，用上之前创建的ValidatorUtil123456789101112131415161718192021public class MobileValidator implements ConstraintValidator&lt;Mobile,String&gt; &#123; //成员变量，接收注解定义 private boolean required = false; @Override public void initialize(Mobile constraintAnnotation) &#123; required = constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if(required)&#123; //如果是必须的，判断是否合法 return ValidatorUtil.isMobile(value); &#125;else//如果不是必须的 if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125;&#125; 在LoginVo上加上123@NotNull@Mobile(required = true,message = "手机号错")private String mobile; 返回controller的doLogin的参数校验12345678@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(@Valid LoginVo loginVo) &#123; log.info(loginVo.toString()); CodeMsg code = userService.login(loginVo); if(code.getCode()==0)return Result.success("登录成功"); else return Result.error(code);&#125; 可以得到完整错误信息 错误处理新建exception包添加@ControllerAdvice 和controller是一样的123456789101112131415161718@ControllerAdvice@ResponseBodypublic class BindExceptionHandler &#123; @ExceptionHandler(Exception.class) public Result&lt;String&gt; bindexp(HttpServletRequest request,Exception e)&#123; if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError objectError = errors.get(0); String defaultMessage = objectError.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(defaultMessage)); &#125;else&#123; //通用异常 return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 可传递参数的错误信息，原来定义的枚举类不能newCodeMsg.BIND_ERROR.fillArgs(msg)12345678910111213141516171819202122232425public class CodeMsg &#123; private int code; private String msg; private CodeMsg( int code,String msg ) &#123; this.code = code; this.msg = msg; &#125; //通用的错误码 public static CodeMsg SUCCESS = new CodeMsg(0, "success"); public static CodeMsg SERVER_ERROR = new CodeMsg(500100, "服务端异常"); public static CodeMsg BIND_ERROR = new CodeMsg(500101, "参数校验异常：%s"); //登录模块 5002XX public static CodeMsg SESSION_ERROR = new CodeMsg(500210, "Session不存在或者已经失效"); public static CodeMsg PASSWORD_EMPTY = new CodeMsg(500211, "登录密码不能为空"); public static CodeMsg MOBILE_EMPTY = new CodeMsg(500212, "手机号不能为空"); public static CodeMsg MOBILE_ERROR = new CodeMsg(500213, "手机号格式错误"); public static CodeMsg MOBILE_NOT_EXIST = new CodeMsg(500214, "手机号不存在"); public static CodeMsg PASSWORD_ERROR = new CodeMsg(500215, "密码错误"); //参数校验异常：%s public CodeMsg fillArgs(Object... args) &#123; int code = this.code; String message = String.format(this.msg,args); return new CodeMsg(code,message); &#125;&#125; 测试：200返回{&quot;code&quot;:500101,&quot;msg&quot;:&quot;参数校验异常：手机号错&quot;,&quot;data&quot;:null} 定义全局异常1234567891011public class GlobalException extends RuntimeException&#123; private static final long serialVersionUID = 1L; private CodeMsg cm; public GlobalException(CodeMsg cm) &#123; super(cm.toString()); this.cm = cm; &#125;//get&#125; UserService.java修改业务代码直接抛异常而不是返回CodeMsg123456789101112public boolean login( LoginVo loginVo) &#123;if(loginVo == null) &#123; throw new GlobalException(CodeMsg.SERVER_ERROR);&#125;if(user == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST);&#125;if(!calcPass.equals(dbPass)) &#123; throw new GlobalException(CodeMsg.PASSWORD_ERROR);&#125;return true;&#125; 添加全局异常处理类,注意合并成一个异常处理，不要覆盖123456789101112131415161718192021ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; //拦截任何的异常 @ExceptionHandler(value=Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e)&#123; e.printStackTrace(); if(e instanceof BindException) &#123; BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException)e; return Result.error(ex.getCm()); &#125;else &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; &#125;&#125; 修改controllor中service的返回值，异常已经处理了，不用返回值12userService.login(loginVo);return Result.success("登录成功"); 8.分布式Session1.容器session同步 比较复杂2.登陆成功后生成sessionID写道cookie传递给客户端，客户端每次访问上传cookie用uuid，原生UUID带‘-’，去掉12345public class UUIDUtil &#123; public static String uuid() &#123; return UUID.randomUUID().toString().replace("-", ""); &#125;&#125; service中login比对密码正确后，生成token，并写到redis中新建redis前缀tokenKey123456public class tokenKey extends BasePrefix &#123; public tokenKey(String prefix) &#123; super(prefix); &#125; public static tokenKey token = new tokenKey("tk");&#125; 在service中引入，设置cookie中的token name123456789101112131415161718192021222324252627282930313233public static final String COOKI_NAME_TOKEN = "token";@AutowiredRedisService redisService;public boolean login( HttpServletResponse response,@Valid LoginVo loginVo) &#123; if(loginVo == null) &#123; System.out.println("loginvonull"); throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); //判断手机号是否存在 MiaoshaUser user = getById(Long.parseLong(mobile)); if(user == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //验证密码 String dbPass = user.getPassword(); String saltDB = user.getSalt(); String calcPass = MD5Util.formPassToDBPass(formPass, saltDB); if(!calcPass.equals(dbPass)) &#123; throw new GlobalException(CodeMsg.PASSWORD_ERROR); &#125; //生成cookie String token= UUIDUtil.uuid(); redisService.set(tokenKey.token, token, user); Cookie cookie = new Cookie(COOKI_NAME_TOKEN,token); cookie.setMaxAge(tokenKey.token.expireSeconds()); cookie.setPath("./"); //写到response要HttpResponse response.addCookie(cookie); return true;&#125; 修改login controller1234567@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(HttpServletResponse response,@Valid LoginVo loginVo) &#123; log.info(loginVo.toString()); userService.login(response,loginVo); return Result.success("登录成功");&#125; 登录成功跳转页12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;商品列表&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text="'hello:'+$&#123;user.nickname&#125;" &gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 创建新的controller类12345678@Controller@RequestMapping("/goods")public class GoodsController &#123; @RequestMapping("/to_list") public String list(Model model,MiaoshaUser user) &#123; return "goods_list"; &#125;&#125; login.html ajax成功后跳转1234567891011121314151617181920$.ajax(&#123; url: "/login/do_login", type: "POST", data:&#123; mobile:$("#mobile").val(), password: password &#125;, success:function(data)&#123; layer.closeAll(); if(data.code == 0)&#123; layer.msg("成功"); window.location.href="/goods/to_list"; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.closeAll(); &#125;&#125;); chrome-network-preserve log spring中自建exception类要继承RuntimeException只有RuntimeException才会事务回滚，继承Exception不会。 使用PUT方式body要设置成x-www-from-urlencoded 过滤器：登陆、加密、解密、会话检查、图片转换。 spring通知、事务传播行为 maven依赖子类不用版本号 抓包记得开隐身窗口注意dp[one++][two++]=dp[one-1][two-1];的执行顺序 1,1不会等于0,0 分页 List.subList(,) SQL的limit或者Oraclerownumselect * from t_student limit 0,10从0取10条PostgerSQL：select * from t_student limit 10 offset 0 hibernate:123456String hql = "from Student";//创建Query或者Criteria对象Query q = session.createQuery(hql);q.setFirstResult(0);q.setMaxResults(10);List l = q.list(); 对象123456789public class Pager&lt;T&gt; implements Serializable&#123; //每页显示几条记录 private int pageSize; //当前页 private int currentPage; private int totalPage; private int totalRecord; private List&lt;T&gt; dataList;&#125; InternalResourceViewResolverbean配置页面的jsp路径和后缀名JstlView处理?clouseID=123用12(@RequestParam("courseId") Integer courseId,Model model)model.addAttribute(course); 处理rest风格的/{courseId}123@RequestMapping(value="/view2/&#123;courseId&#125;")(@PathVariable("courseId") Integer courseId,Map&lt;String,Object&gt;model)model.put("course",course); 在SpringMVC中使用HttpServletRequest等对象引入12&lt;groupId&gt;javax.servlet&lt;/groupId&gt;&lt;artifactId&gt;servlet-api&lt;/artifactId&gt; 12request.getParameter("courseId");request.setAttribute("course",course); @ModelAttribute模型自动绑定12//请求重定向return "redirect:view/"+course.getCourseId(); 文件上传表单属性enctype=&quot;multipart/from-dataaction页面拦截12//自动转型(@RequestParam("file") MultipartFile file) common-io中的文件流操作1FileUtils.copyInputStreamToFile(file.getInputStream,new File("")); Json 添加依赖1234@ResponseBody Course getCourseInJson(@PathVariable Integer courseId)ResponseEntity&lt;Course&gt; getCourseInJson(@PathVariable Integer courseId)&#123; return new ResponseEntity&lt;Course&gt;(course,HttpStatus.OK);&#125; 数据绑定 基本类型int当参数不能为空，包装类型可以为null 传数组?name=tom&amp;name=jack&amp;name=lucy用String[] name接收 横向越权不同用户相同权限的数据，A可以查看B的订单 纵向：变成管理员 封装响应对象status,msg,T dataJSP 指令&lt;%@ page属性=&quot;&quot; %&gt;属性 language，import，contentTypeinclude，taglib 脚本元素&lt;% out.println(&quot;&quot;) %&gt; 声明 12&lt;%! String s = " ";int add(int x,int y)&#123;return x+y;&#125;%&gt; 表达式&lt;% =s %&gt;不以分号结束 JSP声明周期 第一次用户请求.jsp，JSP引擎转为Servelet类（.java)，生成字节码文件，执行jspInit()初始化 解析执行字节码文件的jspService() jspService()处理客户端请求每个客户端一个线程。Servlet常驻内存。 JSP9大内置对象 out对象是JspWriter类实例。8k缓冲区 表单get提交数据小于2k action=&quot;.jsp&quot; request是HttpServletRequest的实例，接收action的js：12//修改接收的字符集 与表单页面的编码一致&lt;% request.setCharaterEncoding("utf-8")%&gt; URL传参，但这种方法设置request的字符集无效，要修改tomcat的server.xml的Connetor标签1&lt;a href="接收请求的.jsp?username=a"&gt;接收参数并跳转&lt;/a&gt; response.sendRedirect(&quot;.jsp&quot;)重定向 response中的.getWriter得到的PrintWriter总是先于out对象输出，可以使用out.flush强制刷新输出 session对象是HttpSession类的实例。保存在服务器的内存中，保存一个用户访问一个服务器页面切换仍然是同一个用户。用&lt;a href=&quot;.jsp&quot;&gt;后另一个页面仍能获得相同的session application对象是ServletContext类的实例。服务器的启动和关闭。get/setAttribute(,) page对象就是页面object pageContext对象可以获得所有session，response等对象 Config对象servlet初始化要用到的参数 请求重定向 请求转发重定向.sendRedirect：客户端行为response对象，两次请求，第一次请求对象不被保存（重定向到的页面无法获得原来的request内容。地址栏URL变化。 （登陆失败）转发：服务器行为。request.getRequestDispatcher().forward(req,resp)一次请求，转发后请求对象被保存（把request也转发，再把response传回原jsp），URL地址不变。（登陆成功）登陆成功12session.setAttribute("loginUser",username);request.getRequestDispatcher("success.jsp").forward(request,response); 在success.jsp获取1&lt;%=session.getAttribute("loginUser"); jsp动作标签和javaBean12345&lt;jsp:useBean id="u" class="U" scope="page"/&gt;&lt;jsp:setProperty name="u" property="*"&gt; 根据表单name自动和javabean的类自动匹配传统的表达式方式：&lt;%= u.getUsername()%&gt; &lt;jsp:getProperty name="u" property="username"&gt; 还可以用property+value设置值，可以通过param获得url传的参数 bean的四个作用域：page，request，session，application动作include、forward&lt;jsp:forward page=&quot;url&quot;/&gt;等同于request.getRequestDispatcher(“/url”).forward(request,response); mina创建连接1234//服务端SocketAcceptor acceptor = new NioSocketAcceptor();//客户端NioSocketConnector connector = new NioSocketConnector(); 设定过滤规则123456789101112DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();chain.addLast("obj",new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));//设置消息处理器 服务端acceptor.setHandler(new minaHandler());//服务器acceptor.bind(new InetSocketAddress(port));//客户端连接服务器ConnectFuture cf = connector.connect(new InetSocketAddress("localhost",9999));//客户端等待连接成功cf.awaitUninterruptibly();//客户端 发送cf.getSession().write(msg); 消息处理器extends IoHandlerAdapter重写session接收的方法 Spring配置文件读取bean declarationtx声明式事务配置文件 struts2 加入jar包：asm 替代反射，字节码操控框架；ognl struts2的标签库；xwork和webwork整合的包 sturts.xml放入src负责Action映射和Result定义、拦截器； &lt;include&gt;把每个功能的配置放到不同的xml文件里导入动态方法调用： 解决action太多&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value = &quot;true&quot;&gt; &lt;action name = &quot;addAction&quot; method=&quot;add&quot; class=&quot;&quot;&gt;遇到add.action时调用指定类中的add 方法 通过!add.action访问&lt;action&gt;&lt;result name=&quot;add&quot;&gt;/result.jsp&lt;/result&gt;对应action的方法中return &quot;add&quot;对应result的name字符串 通配符name = &quot;{2}_*&quot; method={1} class=&quot;..{1}Action&quot;访问helloworld_add.action可以匹配add和helloword默认错误路径 &lt;default-action-ref name=&quot;index&gt;并配置名为index的action 参数：&lt;contant name=&quot;struts.action.extension value=&quot;&quot;&gt;不用输入.action后缀 struts.properties 全局属性文件；可以不用，在struts.xml用constant元素 在web.xml配置核心过滤器 core包下的;/*.jsp和.html不拦截12345678&lt;filter&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;filter-class&gt;...dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;url-pattern&gt;\*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Struts原理 HttpServltRequest经过ActionContextCleanUp、各种Filter .action的请求会到ActionMapper返回Filter Filter发给ActionProxy 并读取struts的配置文件，找到具体的action类，通过ActionProxy代理创建Action实例 经过拦截器执行到action返回result是字符串对象对应视图（JSP/FreeMaker） 继续经过拦截器 通过HttpServletResponse返回到用户实例进行显示 Action搜索顺序: 顺着不存在的包名向上查，包名存在则查找action 动态方法调用： URL读取html1234567891011121314import java.net.*;import java.io.*;public class URLReader&#123; public static void main(String[] args) throws Exception&#123; URL cs = new URL("http://www.sina.com"); //直接获得inputStream BufferedReader in = new BufferedReader( new InputStreamReader(cs.openStream())); String inputLine; while((inputLine = in.readLine())!= null) sout(inputLine); in.close(); &#125;&#125; 意外处理try{}catch(MalformedURLexception e) 不符合URL常规的url异常-123URL url = new URL("https://baidu.com");HttpURLConnection conn = (HttpURLConnection)url.openConnection();BufferedInputStream in = new BufferedInputStream(conn.getInputStream()); tomcat server.xml 12345678910111213&lt;server&gt; &lt;service&gt; &lt;Connector&gt; &lt;/Connector&gt; &lt;Engine&gt; &lt;host&gt; 可以有多个host虚拟主机 &lt;Context&gt; web应用 &lt;/Context&gt; &lt;/host&gt; &lt;/Engine&gt;&lt;/server&gt; Connector 接收用户请求，Coyote实现(BIO)阻塞式IO adddress只监听的地址 acceptCount 没有空闲线程时的排队长度默认100 maxConnections 线程池的最大值 -1 不限制 线程池：事先创建一定数目的线程，减少了线程创建与销毁的过程12&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/&gt; Engine 处理Connector接收到的用户请求 mavenpom 项目对象模型 &lt;properties&gt;中配置的常量属性可以用${property}取 子pom和父pom可以继承覆盖 Super POM中有默认设置 user/.m2/repository本地缓存的仓库 中央仓库生命周期clean:清理项目pre-clean clean post-clean default: 构建项目 validate，process-resources运行package会自动运行compile、testsite:生成站点文档&lt;scope&gt;provided&lt;/scope&gt;只在编译和测试时运行 依赖范围：&lt;scope&gt;6种 compile：默认。编译测试运行都有效。 provided在编译和测试时有效，运行无效。例如servlet-api因为web容器已经有api了 runtime：运行、测试有效。例如jdbc驱动api test:测试时有效。例如junit system：编译和测试有效，不可移植，与系统相关联。例如引入本地的JAVA_HOME import:只用在dependencyManagement中，表示从其它pom中继承的依赖。 命令mvn complie编译 test测试 package打包 clean删除target install安装jar包到本地仓库 archetype插件 建立符合规定的目录骨架mvn archetype:generate gitgit push -u origin master Servelet:运行在server端的java程序 1.java类 没有main方法 2.运行于容器 提供请求-响应的web服务 servlet处理流程 pom.xml:tomcat: 123&lt;configuration&gt; &lt;path&gt;/web_project_template&lt;/path&gt;&lt;/configuration&gt; servlet容器的配置文件web.xml找到对应的Servlet,转发到service方法 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;..TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;servlet-mapping&gt; 客户端请求http对象的时候service方法被调用 客户端使用get方法访问时doGet方法被调用TestServlet.java12345678910@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("doGet method"); PrintWriter pw = resp.getWriter(); //设置文件类型 response.setContentType("text/html;charset=utf-8") pw.print("/hello"); pw.close(); &#125; Servlet 生命周期生命周期方法由服务器调用 默认web客户端第一次请求容器，创建servlet实例 调用init(ServletConfig) 请求处理 转发请求 destory get通过header传输数据，post通过body传输 ServletConfig：以servlet为单位 123456789101112&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;data1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;data2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt; 12ServletConfig config = this.getServletConfig();String v1 = config.getInitParameter("data1"); context-param ：全局配置 ServletContext对象 web应用中全局唯一 1234&lt;context-param&gt; &lt;param-name&gt;globalData1&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt;&lt;/context-param&gt; 12ServletContext ctx = this.getServletContext();String v1 = ctx.getInitParameter("data1"); servletContext 可以CLUD共享不是事先知道的动态信息 12//在context中设置属性ctx.setAttribute("attribute1", "111"); 读取外部资源配置文件信息： ServletContext.getResource :URL .getResourceAsStream .getRealPath:File ??? Properties 对象 web.xml 部署描述符为一个servlet配置多个url-pattern、/*模糊匹配 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 匹配优先级规则 监听器 用途： 统计在线人数和在线用户 HttpSession 系统启动时加载初始化信息 缓存、数据库链接ServletContext 统计网站访问量 spring相关 用法： impletemts ServletContextListener 在web.xml注册 1&lt;listener&gt;&lt;listener-class&gt;&lt;/listener-class&gt;&lt;/listener&gt; 上下文对象，web启动时创建，web销毁 销毁 监听器的启动循序按注册顺序。 优先级：监听器&gt;过滤器&gt;servlet加载 监听器种类 ServletContext监听应用程序环境对象 HttpSession用户会话对象 ServletRequest请求消息对象 MIME 多用途 互联网 邮件 扩展 类型设定某种扩展名的文件用什么应用打开 1234&lt;mime-mapping&gt; &lt;extension&gt;java&lt;/extension&gt; 扩展名映射类型 &lt;mime-type&gt;text/plain&lt;/mime-type&gt;&lt;/mime-mapping&gt; Session &amp; Cookie Cookie 短时间，数据频繁访问 保存在客户端 V0: Set-Cookie: userName= “”; Domain= “” V1: Max-Age= 1000 实际： Version= “1” Session NANE为JSESIONID的 Cookie 保存在服务端 Cookie 会话cookie 关闭浏览器消失，保存在内存中 setMaxAge 设置cookie有效期，浏览器会把cookie保存到硬盘上 一个站点最多能保存20个cookie，每个4k以内cookie12345678910111213141516171819202122/***第一次请求把cookie设置好**/Cookie userNameCookie = new Cookie("userName", userName);Cookie pwdCookie = new Cookie("pwd", userPassword);/***设置时间**/userNameCookie.setMaxAge(10 * 60);pwdCookie.setMaxAge(10 * 60);/***把cookie放到响应中**/response.addCookie(userNameCookie);response.addCookie(pwdCookie);/***第二次从请求中获取cookies数组**/Cookie[] cookies = request.getCookies();//第二次if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals("userName")) &#123; userName = cookie.getValue(); &#125; if (cookie.getName().equals("pwd")) &#123; userPassword = cookie.getValue(); &#125; &#125;&#125; Session 默认有效期30分钟 setMaxInactiveInterval设置有效期 部署描述符设置有效期 invalidate Session失效 第一次请求：服务器创建session对象，把SessionID作为cookie发送给浏览器 12345678910//创建Session对象HttpSession session = request.getSession();session.setAttribute("userName", userName);// 第二次请求String name = (String) session.getAttribute("userName");if (name != null) &#123; //服务器已经保存了session System.out.println("second login: " + name); &#125; 第二次 Request:Cookie: JSESSIONID=B2980D3ABAB39EF6EA09F278F261C2A4; Session钝化：不不常使用的session对象序列化到文件/数据库tomcat两种钝化管理器 StandardManger tomcat 关闭重启时，web应用重启时（覆盖了web.xml)，钝化到文件。钝化到/work/Catalina/hostname/applicationname/SESSION.ser重启时加载删除 Persistentmanager Servlet3.0 @WebListner免注册声明为监听器转发与重定向 转发对象：RequestDispatcher(&quot;.jsp&quot;).forward(request,response) 重定向：是两次请求 获取不到原来的req tail -f 监视日志输出 javax.servlet Servlet 所有Servlet必须实现的方法 Config Servlet配置信息 Context 容器信息 GenericServlet底层（实现了5个servlet中的方法） javax.servlet.http HttpSession标识并存储客户端信息 HttpServletRequest getParameter(String key)获得第一个name和key一样的表单控件的数据 getParameterValues同上返回数组 getParameterMap 返回kv getParameterNames 返回所有表单控件的name值 HttpServlet 扩展GenericServlet Cookie 存储Servlet发送给客户端的信息 javax.servlet.annotation 注解 javaWeb域对象：存、取数据（Map） Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mlpractice]]></title>
    <url>%2F2018%2F03%2F09%2Fmlpractice%2F</url>
    <content type="text"><![CDATA[矩阵乘法12345678&gt;&gt;&gt; a = np.array([[1,1],[1,0]])# 对应元素相乘&gt;&gt;&gt; np.multiply(a,a)array([[1, 1], [1, 0]])&gt;&gt;&gt; np.dot(a,a) #线代的乘积array([[2, 1], [1, 1]]) standardscaler（x-列均值）/ 列标准差 hausdorff距离衡量2个点集的距离度量了两个点集间的最大不匹配程度 location相关数据和数据处理关于time/location 数据处理https://www.kaggle.com/bqlearner/location-based-recommendation-systemGowalla数据集：https://snap.stanford.edu/data/loc-gowalla.html 垃圾短信分类 练习TODOhttps://blog.csdn.net/github_36922345/article/details/53455401 很详细的中文泰坦尼克号 pandas操作： 读csv多了一列unname pd.read_csv(&quot;Osaka_user_localtime.csv&quot;,index_col=0) 1.userpd.columns=userpd.columns.droplevel([0,1])2.df.set_index(&#39;date&#39;, inplace=True)列 -&gt;索引3.df[&#39;index&#39;] = df.index,df.reset_index(level=0, inplace=True)4.user_ca_ph.unstack(level=1)5.去掉不用的复合索引user_ca_ph_cnt.columns=user_ca_ph_cnt.columns.droplevel([0,1])6.填空user_ca_ph_cnt=user_ca_ph_cnt.fillna(0.)7.train_data[[&quot;Age_int&quot;, &quot;Survived&quot;]].groupby([&#39;Age_int&#39;],as_index=False).mean()8.找nullage_df_isnull = age_df.loc[(train_data[&#39;Age&#39;].isnull())]9.用dict替换掉一列123user_weight =[i/sum([30,53,334,16]) for i in [30,53,334,16]]dict(zip(["Amusement","Entertainment","Historical","Park"],user_weight))Osaka_cost["userweight"]=Osaka_cost["category"].map(usr_weight) 10.全部onehotpd.get_dummies(df)11.离散化，分桶,再向量化/onehot123456789101112train_data['Fare_bin'] = pd.qcut(train_data['Fare'], 5)0 (-0.001, 7.854]1 (39.688, 512.329]2 (7.854, 10.5]3 (39.688, 512.329]4 (7.854, 10.5] # factorizetrain_data['Fare_bin_id'] = pd.factorize(train_data['Fare_bin'])[0]# dummiesfare_bin_dummies_df = pd.get_dummies(train_data['Fare_bin']).rename(columns=lambda x: 'Fare_' + str(x))train_data = pd.concat([train_data, fare_bin_dummies_df], axis=1) pip镜像1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyclustering UTC 时间戳转localtime123456# 1346844688 -&gt; 2012-09-05 11:31:28Tor_user["UTCtime"] = pd.to_datetime(Tor_user['dateTaken'],unit='s')# 2012-09-05 11:31:28 -&gt; 2012-09-05 07:31:28-04:00Tor_user["Localtime"]=Tor_user.UTCtime.dt.tz_localize('UTC').dt.tz_convert('America/Toronto')# 2012-09-05 07:31:28-04:00 -&gt; 2012-09-05 07:31:28Tor_user["Localtime"]=Tor_user["Localtime"].apply(lambda x:x.strftime("%Y-%m-%d %H:%M:%S")) 标签传播LP算法（基于图）1.半监督学习的假设： 1）Smoothness平滑假设：相似的数据具有相同的label。 2）Cluster聚类假设：处于同一个聚类下的数据具有相同label。 3）Manifold流形假设：处于同一流形结构下的数据具有相同label。 2.相似度矩阵数据点为节点，包括labeled和unlabeled数据。边表示两点的相似度。假设图是全连接.边ij的权重$W_{ij}=exp(\frac{-||x_i-x_j||^2}{α^2})$ α是超参。另外可以构建KNN图 稀疏相似矩阵，指保留每个节点的k近邻权重，其它为0。 3.传播，权重越大传播概率越高 转移概率$P_{ij}=P(i-&gt;j)=\frac{w_{ij}}{\sum_{k=1}^nw_{ik}}$ 假设C个类，L个labeled的样本，则LxC矩阵$Y_L$i行是第i个样本的标签指示向量。如果第i个样本类别是j，则[i][j]为1，其它为0。 建立unlabeled的矩阵$Y_U$UxC同理。 合并得到NxC句矩阵。F=[Y_L;Y_U] (L+U=N行）保留样本i属于每个类别的概率。 4.算法步骤 F=PF：每个节点以P的概率传播给其它节点。 $F_L=Y_L$ (Y_L的标签是已知的，要保留，覆盖回原来的值) 重复以上两步直到F收敛。5.优化算法。$F_L$部分是不变的.浪费的计算。将概率转移矩阵变成$$P=\begin{bmatrix} P_{LL} &amp; P_{LU} \\ P_{UL} &amp; P_{uU} \\\end{bmatrix}$$只计算$F_U=P_{UU}F_U+P_{UL}Y_{L}$ 取决于无标签转移概率、有标签的相似度矩阵、无标签当前标签的转移概率。算法可以优化成并行的，切分F_U 1. Logistic 损失函数L：单个训练样本 $\hat{y}=p(y=1|x)$ 给定样本x的条件下，输出y=1的概率 成本(cost)函数J:全体训练样本$\frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})$ cost：每个样本的乘积的最大似然估计 *1/m Logistic损失函数 $L(\hat{y},y) = -(ylog\hat{y}+(1-y)log(1-\hat{y}))$ 当y=1,$L =-log\hat{y}$ 让误差最小，则让$\hat{y}$大，$\hat{y}$经过sigmoid小于1 当y=0,$L = -log(1-\hat{y})$,则$\hat{y}=0$ 矩阵乘法：左向量组，列数是向量的维度；右线性空间；相乘：将向量组线性变换到新的线性空间。 右边的行数最少要满足由基地向量构成的线性空间维度。 特征向量：向量值发生了伸缩变换，没有旋转。伸缩比例是特征值。 梯度下降 $w=w-\alpha\frac{dJ(w,b)}{dw}$ $b=b-\alpha\frac{dJ(w,b)}{db}$ 反向传播 计算loss对每个变量的梯度，通过链式法则a=sigmoid($\hat{y}$)正向传播:1.计算wx+b 2.经过sigmoid求出$\hat{y}$ 3.计算loss反向传播: da=loss对$\hat{y}$求导 dz = da*sigmoid求导 dw1 =dz*z对w1求导 向量化：不用一个for循环 正向传播 1.$z=w^Tx+b$ 2.np.dot(w.T,x)+b 3.$\hat{y}$=simgmoid(z) 反向传播 4.$dz = \hat{y} - y$ 5.dw = 1/m*np.dot(x,dz.T) 6.db = 1/m*np.sum(dz) 梯度下降 7.w = w-αdw 8.b = b-αdb以上for 梯度下降多少次 dcost = 1/m*np.sum(dz)- 创建一维向量不用要np.random.randn(5)因为a.shape=(5,)用： 列向量np.random.randn(5,1);行向量np.random.randn(1,5) 2. 浅层NNtanh是sigmoid的平移tanh效果好因为 激活函数平均值接近0，tanh在所有场景几乎最优 不用sigmoid了输出层用sigmoid：因为（0，1）之间的二分类问题 tanh和sigmoid的问题是z很大时，梯度很小，梯度下降效率低 $g’(tanh(z))=1-(tanh(z))^2$ ,$1-a^2$ ReLu:修正线性单元(rectified linear unit):ReLU:= $a=max(0,z)$ 只要z&gt;0,导数=1；z&lt;0,导数=0除了输出层，都用ReLU为激活函数 Leaky-ReLU：z&lt;0时让导数不为零，有一个很小低梯度max(0.01*z,z) 虽然有一半导数=0，但因为有足够多的隐藏单元另z&gt;0 $g’=1 if z&gt;0$ 神经网络初始化：不能初始化为0，这样两个隐藏单元会相同。$W^{[1]}$ = np.random.randn((2,2))0.01 使梯度较大$b^{[1]}$ = np.zero((2,1))$W^{[1]}$ = np.random.randn((2,2))0.01 二分类问题时da 最后一层$L(a,y) = -(ylog(a)+(1-y)log(1-a))$$da^{[1]} = -y/a + (1-y)/(1-a)$ bias偏差/variance方差 high bias -&gt; 欠拟合 -&gt;选择新的网络直到至少可以拟合训练集 high variance -&gt; 过拟合 -&gt;更多数据/正则化/回到1换模型 正则化- 高variance 过拟合 L2正则:w通常是一个高维参数矢量已经可以表达high variance 问题$+\frac{λ}2m||w||_2^2$ L1正则:$\frac{λ}m||w||_1$ 使用L1正则化，w最终会稀疏,w向量有很多0 Dropout随机失活 多用于图像 a3 表示三层网络各节点的值, $a3=[a^{[1]},a^{[2]},a^{[3]}]$ 权重转成0或1：d3=np.random.rand(a3.shape[0], a3.shape[1]) &lt; keepProb 删除节点：a3 = np.multiply(a3, d3) 为了不影响原来Z的期望，a3 /= keepProb http://archive.ics.uci.edu/ml/——最有名的机器学习数据资源来自美国加州大学欧文分校 http://aws.amazon.com/publicdatasets/美国人口普查数据、人类基因组注释的数据\维基百科的页面流量\维基百科的链接数据 http://www.data.gov——Data.gov启动于2009年，目的是使公众可以更加方便地访问政府的数据flavor 中加时间向量，对每一个flavor进行时序预测，sumflavor 有序字典 预测目标变量的值，则可以选择监督学习算法,需要进一步确定目标变量类型，如果目标变量是离散型，如是/否、1/2/3、A/B/C或者红/黄/黑等，则可以选择分类算法.k-近邻算法 线性回归 朴素贝叶斯算法 局部加权线性回归支持向量机 Ridge 回归决策树 Lasso 最小回归系数估计 科学函数库SciPy和NumPy使用底层语言（C和Fortran）编写，提高了相关应用程序的计算性能。 8.1 NumPy提供一个线性代数的库linalg，其中包含很多有用的函数。可以直接调用linalg.det()来计算行列式第9章 用分类算法来处理回归问题 15 MapReduce:数值型和标称型数据。 过去100年国内最高气温：每个mapper将产生一个温度，形如&lt;”max”&gt;，也就是所有的mapper都会产生相同的key：”max”字符串集成算法生成多个分类器再集成 全选分类器 求平均 pandas 时间序列关键点：极大值，极小值or拐点 用关键点代替原始时间序列。 合并关键点序列时间下标 得到等长序列 Lance距离 无量纲。欧式距离缺点L:有量纲，变差大的变量在距离中贡献大。 FCM算法 每条时间序列属于各个类的程度。 ARIMA自回归综合移动平均Auto-Regressive Integrated Moving Averages. Number of AR (Auto-Regressive) terms (p)： 现在点使用多少个过往数据计算。 Number of MA (Moving Average) terms (q)：使用多少个过往的残余错误值。 Number of Differences (d)：非季节性的个数（小编：其实是否求导数）。 日期范围 pd.date_range(‘4/1/2012’,’6/1/2022’) 默认按天 pd.date_range(start=’4/1/2012’,periods=20) 每个月最后一个工作日 “BM”频率pd.date_range(‘1/1/200’,’12/1/2000’,ferq=’BM’) 规范化到午夜 WOM日期 Week of Month freq=’WOM-3FRI’每月第3个星期五5 时区 numpy random.rand(4,4) -&gt; 4x4的 array 12arr_alice = arr[5:8]arr_alice[0] =11 arr的值也会改变np 的切片和赋值不会copy arr[5:8].copy()arr_alice = arr[5:8].copy()显示复制，arr不会被改变 多维数组 arr2d[0][2] == arr2d[0,2] np.random.randn(7,4)生成正态分布的随机数names==&#39;bob&#39; [True,Fales] list,data[names==&#39;bob] boolean数组可以用于索引data[-(names==&#39;bob&#39;)] 花式索引arr[[4,3,0,6]] 获取第4、3、0、6 行 array([1,2,3]) from numpy import array list对应元素相乘：某个向量沿着另一个向量的移动量。array(list)*array(list2)对应元素相乘 .dtype 同构数据元素的类型 zeros(10) ones(10) 全0or全1数组 empty((2,3,2)) 创建没有任何具体值的数组 np.dot(arr.T,arr) 内积nonzero(array) nonzeros(a)返回数组a中值不为零(Flase)的元素的下标 transpose([])转成array linspace(start,stop,num，endpoint=False)返回长为num的array 数值从start到stop渐变，endpoint=False递增 mat,matrix123- from numpy import mat, matrixmat([1,2,3])/matrix([1,3,4])mat([1,3,4])[0,1] #=3 矩阵相乘:矩阵相乘，multiply内积`mat(list)mat(list2).T` 内积 from numpy import shape 查看矩阵or数组的维数矩阵第一行元素jj[1,:]矩阵对应元素相乘:矩阵相乘还可以看成是列的加权求和矩阵相乘的MapReduce版本。??from numpy import multiply 1234multiply(mat(list),mat(list2))matrix([[ 2, 6, 12]])array(list)*array(list2)array([ 2, 6, 12]) 矩阵数组排序 .sort() 原地排序 结果占用原始存储空间 每个元素的排序序号： 123&gt;&gt;&gt; dd=mat([4, 5, 1])&gt;&gt;&gt; dd.argsort()matrix([[2, 0, 1]]) 数组/矩阵均值 .mean() 矩阵的逆.Ilinalg.inv(A) 矩阵要可逆必须要是方阵。如果某个矩阵不可逆，则称它为奇异（singular）或退化（degenerate）矩阵。 一种方法是对矩阵进行重排然后每个元素除以行列式。如果行列式为0，就无逆矩阵。 mat()*mat().I ≠1 计算机处理误差产生的结果 4×4的单位矩阵eye(4)/identity(4) 矩阵相关 行列式det(A) 秩 linalg.matrix_rank(A) 可逆矩阵求解 矩阵范数: 给向量赋予一个正标量值 到原点的距离 L1：Manhattan distance。z=[3,4] $||z||_1=3+4=7$各元素绝对值之和 任意阶范数公式 二阶linalg.norm([8,1,6]) 欧式距离 sqrt((v1-v2)*(v1-v2.T)) 曼哈顿距离 sum(abs(v1-v2)) 切比雪夫距离：国际象棋国王的步数abs(v1-v2).max() 夹角cosθcos = dot(v1,v2)/(linalg.norm(v1)*linalg.norm(v2)) 汉明距离 汉明距离：shape(nonzero(v1-v2)[1])[0] ？编辑距离：A=”909”，B=”090”。A与B的汉明距离H(A, B) = 3，编辑距离ED(A, B) =2。 ？文本相似度simHash Jaccard(杰卡德) 集合 相似性系数：样本集交集与样本集并集的比值，即J = |A∩B| ÷ |A∪B|：两个文档的共同都有的词除以两个文档所有的词 杰卡德距离 1-J=（并-交）/并：12import scipy.spatial.distance as distdist.pdist(mat,'jaccard') 相关系数 相关距离（线性相关）coefficient 系数；12345mv1= mean(mat[0])mv2= mean(mat[1])std1= std(mat[0])std2= std(mat[1])cor= mean(multiply(mat[0]-mv1,mat[1]-mv2))/(std1*std2) 马氏距离 协方差是对角阵、单位矩阵（两个样本向量之间独立同分布） 马氏距离为欧式距离 马氏距离 量纲无关 协方差矩阵的逆：linalg.inv(cov(mat))inv()矩阵求逆 tp =mat.T[0]-mat.T[1] dis = sqrt(dot(dot(tp,covinv),tp.T)) 特征向量特征值 evals(特征值）,evecs（特征向量） = linalg.eig(mat) ?手工求特征值 12#求方程根roots(A) 还原矩阵 $A=Q∑Q^-1$ 123#特征值构成的对角阵sigma = 特征值*eye(m)特征向量*sigma*linalg.inv(特征向量) 矩阵求导:A向量（2·1）对B（3·1）求导，得到3·2的矩阵 model = ARIMA(ts_log, order=(2, 1, 2))！qiudaoresults_ARIMA = model.fit(disp=-1)plt.plot(ts_log_diff)plt.plot(results_ARIMA.fittedvalues, color=’red’)plt.title(‘RSS: %.4f’% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))plt.show()dic:key不存在，就会触发KeyError错误 假设验证 实验结果是否有统计显著性或随机性 归一化：转换成无量纲 标准化后的值= （标准化前的值-分量的均值）/分量的标准差 标准化欧氏距离方差的倒数为权重的加权欧氏距离123456789101112# 欧氏距离mat([[1,2,3],[4,5,6]])v12 = vmat[0]-vmat[1]sqrt(v12*v12.T)# 标准化#1.方差vstd = std(mat.T,axis=0)#2.（标准化前的值-所有值的均值/方差norm = (mat-mean(mat))/vstd.T#3.欧式距离normv12 = norm[0]-norm[1]sqrt(normv12*nromv12.T)]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[problems]]></title>
    <url>%2F2018%2F03%2F09%2Fproblems%2F</url>
    <content type="text"><![CDATA[javaC 编码错误: 编码GBK的不可映射字符 //todo 鍐欑殑鐪熸槸闅剧湅 娓呴啋浜嗗啀鍐?Linux下为UTF-8编码，javac编译gbk编码的java文件时，容易出现“错误: 编码UTF8的不可映射字符”解决方法是添加encoding 参数：javac -encoding gbk WordCount.java Windows下为GBK编码，javac编译utf-8编码的java文件时，容易出现“错误: 编码GBK的不可映射字符”解决方法是添加encoding 参数：javac -encoding utf-8 WordCount.java javac -encoding UTF-8 xxx.javaidea ctrl+Q document git config –global gui.encoding utf-8 GC overhead limit exceeded 0x7fffffff指的不是单个数组的字间，而是整个用户态程序的寻址空间 32位的处理器的地址长度是32位,所以他能表示大最大地址是 2^32， 指针表示的是地址，所以指针也是32位的， 但是 windows 对内存做了分区, 进程可用的内存地址范围是 0x00010000 ~ 0x7FFFFFFF， 虚拟机traceroute超时没回应 不要把xshell的ctrl-c变成复制，不然没办法结束程序 IBM的文档总是跳转登录页面，左上角禁用js。 tampermonkey一直在向//cr-input.mxpnl.net发请求 fallthrough 是什么idea提示代码过长怎么办？ docker toolo安装 vb环境变量后面要加’\’ 获取不到ip 等 加速器DaoCloud 要在etc/docker/deamon.json里去掉最后的逗号 并且要service docker restart netty in action&gt;&gt;The POM for nia:utils:jar:2.0-SNAPSHOT is missing, no dependency information availablemvn install -pl utils java ASM coding=UTF-8 IDEA Push failed: Failed with error: fatal: Could not read from remote repositoryIDEA-&gt;setting-&gt;git -&gt; ssh executable -&gt;native PYDEVD_LOAD_VALUES_ASYNC=True; disable “Show command line afterwards”https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000749030-How-to-stop-interactive-console-running Intel MKL FATAL ERROR: Cannot load mkl_intel_thread.dll. hexo markdown的坑小胡子语法两个大括号会报错！！！！二维数组！！ windows 启动zookeeper Server闪退；环境变量里要设置JAVA_HOME变量]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231]]></title>
    <url>%2F2018%2F03%2F09%2FCS231%2F</url>
    <content type="text"><![CDATA[4.1 backprop反向传播 链式法则的递归调用反向传播可以得到损失函数L因为$\frac{\partial L}{\partial x} = \frac{\partial L}{\partial z}\frac{\partial z}{\partial x}$利用上游传回的梯度 反向计算每个节点的本地梯度 最后一个节点的梯度总是1？ 加法门是gradient distributor加法节点之前的本地梯度是1,分支与上游又相同梯度 max门通过后本地梯度分别是0，1 （max只有一个值可以影响上游） mul乘法门 对上游值缩放]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About CentOS]]></title>
    <url>%2F2018%2F03%2F08%2FAbout-CentOS%2F</url>
    <content type="text"><![CDATA[固定ipcentos 安装GLPKtar -xzvf glpk-4.60.tar.gzconfiguremakemake installglpsol --math orienteering_problem.mod --data a8.dat --output &quot;./out&quot; kill -s 9 1827 查文件123456789find / -size 1500c，字符 c 表明这个要查找的文件的大小是以bytes为单位find / -amin -10 # 查找在系统中最后10分钟访问的文件find / -atime -2 # 查找在系统中最后48小时访问的文件find / -empty # 查找在系统中为空的文件或者文件夹find / -group cat # 查找在系统中属于 groupcat的文件find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件find / -mtime -1 #查找在系统中最后24小时里修改过的文件find / -nouser #查找在系统中属于作废用户的文件find / -user fred #查找在系统中属于FRED这个用户的文件 mysql -u root -p -h 192.168.3.109 -P 3306 -D lbs 软链接验证redisps-ef |grep redisnetstat -antpl|grep redisredis-cli -h ip -p port ping lsof123456789101112-a：列出打开文件存在的进程；-c&lt;进程名&gt;：列出指定进程所打开的文件；-g：列出GID号进程详情；-d&lt;文件号&gt;：列出占用该文件号的进程；+d&lt;目录&gt;：列出目录下被打开的文件；+D&lt;目录&gt;：递归列出目录下被打开的文件；-n&lt;目录&gt;：列出使用NFS的文件；-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）-p&lt;进程号&gt;：列出指定进程号所打开的文件；-u：列出UID号进程详情；-h：显示帮助信息；-v：显示版本信息。 netstat -tunplss -t tcp连接 shell wordcount:1cat wordcount.txt |sed 's/[,.:;/!?]/ /g'|awk '&#123;for(i=1;i&lt;=NF;i++)array[$i]++;&#125;END&#123;for(i in array) print i,array[i]&#125;' centos装python3123456789101112131415161718192021222324yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc makeyum -y install epel-releaseyum install python-pipwget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz#解压xz -d Python-3.6.4.tar.xztar -xf Python-3.6.4.tar#进入解压后的目录，依次执行下面命令进行手动编译./configure prefix=/usr/local/python3make &amp;&amp; make install#将原来的链接备份mv /usr/bin/python /usr/bin/python.bak#添加python3的软链接ln -s /usr/local/python3/bin/python3.6 /usr/bin/python#测试是否安装成功了python -Vvi /usr/bin/yum把#! /usr/bin/python修改为#! /usr/bin/python2vi /usr/libexec/urlgrabber-ext-down把#! /usr/bin/python 修改为#! /usr/bin/python2 visualbox扩容全局工具-虚拟硬盘df -lh 查看磁盘使用删掉一个dockerdocker imagesdocker ps -adocker stop j1docker rm j1docker rmi d23bdf5b1b1b 如果有图形界面可以安装分区工具？12yum install epel-releaseyum install gparted 新建硬盘 新建分区 1234567fdisk -lfdisk /dev/sda n #...一直回车 p #查看 w #保存rebootfdisk -l 设备 Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 16777215 7339008 8e Linux LVM/dev/sda3 16777216 67108863 25165824 83 Linux 创建卷 合并卷 1234567891011121314151617pvcreate /dev/sda3vgcreate sda333 /dev/sda3vgscan Reading volume groups from cache. Found volume group "sda333" using metadata type lvm2 Found volume group "centos" using metadata type lvm2vgmerge centos sda333df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 6.2G 5.7G 526M 92% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sdb1 16G 227M 15G 2% /data/dev/sda1 1014M 129M 885M 13% /boottmpfs 100M 0 100M 0% /run/user/0 调整逻辑卷大小 123456789101112131415161718lvextend -l+100%FREE /dev/mapper/centos-root Size of logical volume centos/root changed from &lt;6.20 GiB (1586 extents) to 30.19 GiB (7729 extents). Logical volume centos/root successfully resized.lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 30.19g swap centos -wi-ao---- 820.00m xfs_growfs /dev/mapper/centos-rootdf -lh文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 31G 5.7G 25G 19% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sdb1 16G 227M 15G 2% /data/dev/sda1 1014M 129M 885M 13% /boottmpfs 100M 0 100M 0% /run/user/0 ip -br addr ip太多VB显示不下 perf 监视java程序上下文切换情况 windows perfmon性能监视器 JDK自带的jvisualvm、jstack 修改主机名cat /ect/hostname 查找命令which ls ll tty终端 /dev/zero 零设备文件 /dev/null回收站 /dev/random 产生随机数 useradd tmpuser会在home下创建用户文件夹 df -h 查看存储容量 du -sh /usr 80%的空间占用是/usr tree -L 1树型显示一层 yum -y install tree 创建文件touch /home/{f1,f2}用集合创建两个文件{1..20}范围 copy -v-v, –verbose explain what is being done wc -l /var/log/messages显示文件行数 head tail查看头尾 less分页显示 grep &#39;root&#39; /etc/passwd在文件中用正则查找关键字的行 ll -a &gt;list.txt重定向到文件 7种文件类型（-文件 d目录 l软链接）-rw-r--r--10位权限 （r4 w2 x1 读写执行权限 -没有权限 rwx7r-x5r-x5）设计成2的幂次因为不会歧义rw-u所有者权限r--g所属组r--其他人 chmod [] 模式 文件名 修改权限chmod u+x,g+w xxx.avi赋予执行chmod u=rwx file所有人chmod a=rwx filechomd 777 fild RPM查找文件 r:读(cat,more head,tail) 目录(ls)w:写，追加(vi,echo 111&gt;file)但是不能删除 删除是上一级的权限 目录(touch新建目录，rm，mv，cp)x： 对目录可以(cd)目录的最高权限是x，文件最高权限是w 运行javajava xxx.class要在/etc/profile加入CLASSPATH=.:$JAVA_HOME/jre/lib/ext:source /etc/profile 文件系统 FHS文件层次结构标准颜色 黄色：表示设备文件 浅蓝色：链接（快捷方式） /usr(Unix Software Resource)软件/usr里面放置的数据属于可分享的与不可变动的(shareable, static) 相当于C:/windows /usr/local相当于c:/program/opt三方协力软件/etc配置文件/var系统运作相关/proc 进程：系统内存的映射/selinux：防火墙 ls -lh 查看文件属性pwd 当键目录ls -al --full-time完整显示文件修改时间 12345678# 查看 cpu 型号sudo dmidecode -s processor-version# 查看 cpu 个数grep 'physical id' /proc/cpuinfo | sort -u | wc -l# 查看核心数grep 'core id' /proc/cpuinfo | sort -u | wc -l# 查看线程数grep 'processor' /proc/cpuinfo | sort -u | wc -l fork 启动后台进程环境变量vi /etc/profile 软连接： 零拷贝：文件传输只通过内核空间传输给socket vi :q! 备份：cp server.xml server.xml.bak]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python modules]]></title>
    <url>%2F2018%2F03%2F08%2FPython-models%2F</url>
    <content type="text"><![CDATA[方法默认参数是不可变对象12345678&gt;&gt;&gt; def add_end(L=[]):... L.append('END')... return L...&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END', 'END'] 正确方法：12345def add_end(L=None): if L is None: L = [] L.append('END') return L 协程和异步iodeque GIL线程安全的 list不安全copy：shallow copy 浅拷贝 id不一样。看起来隔离了，但是如果deque里[2]是一个可变对象list，拷贝的是索引 深拷贝：12import copyuser_deque2 = copy.deepcopy(user_deque) 多线程 global interpreter lock 全局解释器锁，python线程对应c中的线程一次只有一个线程在一个cpu上同一时刻只有一个线程在一个cpu上执行字节码。无法将多个线程映射到多个cpu上，并发受限 同时修改global变量的两个线程会不安全 py2和3不同。 按字节码行数/时间片，!!!!会释放全局解释器锁。io操作也会释放 123def add(a): a=a+1 return a 12345678&gt;&gt;&gt;dis.dis(add)2 0 LOAD_FAST 加载a 0 (a) 2 LOAD_CONST 加载1 1 (1) 4 BINARY_ADD 6 STORE_FAST 0 (a)3 8 LOAD_FAST 0 (a) 10 RETURN_VALUE Condition 条件变量两层锁：底层调用wait释放就能acquire。wait分配放入等待队列的锁，等notify。实现了__enter__和__exit__可以用with语句wait： 获得waitter锁 放到Condition的waiters双端队列里 会释放Condition的锁notify:从waiters队列弹出一个，释放waiter锁 Semaphore控制进入数量socketAF_IPX：linux进程间通信 SOCK_DGRAM：UDP 服务端.bind((&quot;0.0.0.0&quot;,8888))而不是127.0.0.1（本机局域网ip访问不到）客户端直接访问.connect((&#39;127.0.0.1&#39;,8888))并且send(&quot;&quot;.encode(&quot;utf-8&quot;))send的时候一定要发送byte类型 socket模拟http请求1234client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect((host,80))client.sent("GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection:close\r\n\r\n" .format(path,host).encode("utf8")) 装饰器 LEGB： encloseing函数内部与内嵌函数之间 【闭包】 装饰器与AOP reload 1. 函数元数据123456def f(): cc = 2 return lambda kk:cc**kk #不会因为f退出以后lambda访问不到ag = f()g.__closure__[0].cell_contents### 输出2 可以访问到cc 2. nonlocal嵌套的def中。允许修改修改嵌套作用域变量。把信息和回调函数联系起来：lambda or call timeout 是闭包内的一个自由变量，在setTimeout中timeout = k会创建本地timeout.nonlocal声明嵌套作用域下的变量 可修改参数的装饰器 为包裹函数添加一个属性函数，修改自由变量123456789101112131415161718192021from functools import wrapsimport timeimport loggingdef warn(timeout): def decorator(func): def wrapper(*args,**kargs): start = time.time() res = func(*args,**kargs) used = time.time() -start if used &gt;timeout: msg = '%s:%s&gt;%s' % (func.__name__,used,timeout) logging.warn(msg) return res #作为wrapper的一个属性 def setTimeout(k): nonlocal timeout timeout = k # 可以被调用 wrapper.setTimeout = setTimeout return wrapper return decorator 测试：123456789from random import randint@warn(1.5)def test(): print('int test') while randint(0,1): time.sleep(0.5)test.setTimeout(1)for _ in range(30): test() py2中没有nonnocal不能修改变量的引用，将timeout实现成一个可变对象12345def warn(timeout): timeout = [timeout] ... def setTimeout (k): timeout[0]=k hashable 不可哈希的元素有：list、set、dict可哈希的元素有：int、float、str、tuple unhashable type: ‘set’ ，dicc = {set([1]):222} set 不能当字典键 用frozenset12345#输出交集 if item&amp;frozenset(['2']): print item if item.intersection('2'): print item frozenset不可变 存在hash值 没用add\remove将集合作为字典的键值dict.update() 求并 123456a =frozenset([3])b =frozenset([2])list=[]list.append(a|b)listOut[12]: [frozenset(&#123;2, 3&#125;)] s.issuperset(t) 测试是否 t 中的每一个元素都在 s 中 Python虚拟机是单线程（GIL）只有I/O密集型才能发挥Py的并发行，计算密集型值需要轮询。 配置utf-8输出环境reload(sys)sys.setdefaultencoding(‘utf-8’) stringsplitlines() 按照行(‘\r’, ‘\r\n’, \n’)分隔splitlines(True)保留换行符 内置函数12345row = [p == '+' for p in line.split()[0]]#转换成T,F序列#对一个区间更改值row[i:j]=[not p for p in row[i:j]]all(row)#如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False； 返回对象的内存地址。 id(a)==id(b) issubclass(AA,A) AA是否是A的子类 python的=是引用 a=1,a=2 右值是int对象 id(a)改变数字&#39;{0:o},{1:x},{2:b}&#39;.format(64,64,64)八进制、16进制、2进制 enumerate 偏移值(index,value)for (offset,item) in enumerate(&#39;apple&#39;):print(item,offset)help(enumerate) 模块import syssys.path #模块搜索路径 roloadcopypython3 copy源码分析 immutable类型: int,float,complex |string tuple frozen set mutable: list,dict,set,byte arry copy使用各自的copy函数 12345copy.pyd[list] = list.copyd[dict] = dict.copyd[set] = set.copyd[bytearray] = bytearray.copy a= (1,2,[3]) tuple中的list可变a[1]=10 id(a) list的地址空间不变 12x= [[1,2,3]] y= x.copy(x)//y=copy.deepcopy(x) .copy(x) 浅id(x)!=id(y) id(x[0])==id(y[0]) .deepcopy(x) 深id(x[0])==id(y[0])递归调用 生成器 g = (x * x for x in range(10)) 每次调用next()遇到下一个yield返回 运算符重载 __getattr__ 点号运算 __getattribute__属性获取 __getitem__ 列表解析、元组赋值，map、for循环，索引、分片运算；L[::]分片是L(slice(,,)分片对象)的语法糖，getitem接收了slice对象 __get/setslice__已移除 __iter__ 迭代环境优先尝试iter 读文件 读文件的最佳方式for line in open(),readlines将整个文件加载到内存 while True：line = f.readline()比迭代器的for慢，因为迭代器以C语言速度运行，while循环版本通过py虚拟机运行python字节码迭代 for循环开始时，通过iter内置函数从迭代对象获得一个迭代器。返回的对象有next方法。 文件对象就是自己的迭代器。有自己的next方法 iter()启动迭代注解内置作用域 import builtins dir(builtins)前一半是内置的异常，后一半是内置的函数 LEGB法则python将最后扫描B模块 所以不需要导入 global123b=0def update(item): global w 在函数和类中对全局变量赋值，必须在该函数或者类中声明该变量为全局变量，否则经过赋值操作后，变量为本地变量。 第二章 .pyc保存py编译后的字节码（不是二进制码，py特定） PVM 虚拟机 py引擎编译得到的代码 pandas.Series是以时间戳为索引的 差分计算series.diff()切片 滞后观察（lag observation）列以及预测观察（forecast observation）resample 重采样、频率推断、生成固定频率日期范围 matplotlib动画lambda 匿名函数返回函数对象 列表解析mapord()返回单个字符的ASCII整数编码 map(f,list)将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456789101112131415161718192021res = list(map(ord,'spam'))res = [ord(x) for x in 'spam']#res =[115, 112, 97, 109][line.rstrip() for line in open('file').readlines()]list(map((lambda line:line.rstrip()),open('file')))#['aaa','bbb']listoftuple=[('bob',35,'mgr'),('amy',40,'dev')]list(map(lambda row:row[1]),listoftuple)#[35,40]#自己实现map def mymap(func,*seqs): res=[] for args in zip(*seqs): # *args 参数传递语法 可以收集多个序列 res.append(func(*args)) return resdef mymap(func,*seqs): return [func(*args) for args in zip(*seqs)] reduce:累积求和:sum(list)string2int zipzip是map的一个基本嵌套操作12list[zip([1,2,3],[2,3,4,5])]#[(1,2),(2,3),(3,4)] 列表中是表；元组为行，列是元组中的元素 cmp已经移除12345678910def tester(start): state = start #赋值过 def nested(lasted): nonlocal state #允许改变 必须已经在def作用域中赋值过 print(label,state) state+=1 return nestedF= tester(0)F('abc') #abc 0#每次调用F state都会+1 用函数属性实现nonlocal??P44012def tester(start): def nested(label): call让类看起来是一个可调用的函数123456789class tester: def __init__(self,start): self.state = start def __call__(self,lable): print(label,self,state) self.state+=1M = tester(99)M('juice')#juice 99#每次调用M state+1 operator b=operator.itemgetter(1) 获取对象的1索引 b(a) 获取 list a 的1索引 operator.itemgetter 定义了一个函数，作用到对象上获取值 与sorted一起用：sorted(dict,key = lambda x:x.values())按字典的values排序 按二维list中子元素的第三项排序 key = lambda student:student[2]/key = operator.itemgetter(2) operator.itemgetter(1,2) 第二项和第三项 panda 坑data = pd.read_csv(&#39;.\a.csv&#39;, parse_dates=[&#39;Month&#39;], index_col=&#39;Month&#39;,date_parser=dateparse) Only booleans, lists, and dictionaries are accepted for the ‘parse_dates’ parameter parse_dates=[&#39;Date&#39;] instead of parse_dates=&#39;Date&#39;]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java风格练习]]></title>
    <url>%2F2018%2F03%2F07%2Fjavastyle%2F</url>
    <content type="text"><![CDATA[BigIntegernumberOfTrailingZeros 二进制末尾0的个数 用时27比&gt;&gt;=2，while(i&amp;1==0)快很多 用时1721234567891011public static int numberOfTrailingZeros(int i) &#123; // HD, Figure 5-14 int y; if (i == 0) return 32; int n = 31; y = i &lt;&lt;16; if (y != 0) &#123; n = n -16; i = y; &#125; y = i &lt;&lt; 8; if (y != 0) &#123; n = n - 8; i = y; &#125; y = i &lt;&lt; 4; if (y != 0) &#123; n = n - 4; i = y; &#125; y = i &lt;&lt; 2; if (y != 0) &#123; n = n - 2; i = y; &#125; return n - ((i &lt;&lt; 1) &gt;&gt;&gt; 31);&#125; LinkedHashMap:LRU的写法123456@param accessOrder the ordering mode true for access-order访问顺序, false for insertion-order插入顺序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) Collections.sort-&gt;list::sort-&gt;Arrays.sort-&gt;TimSort.sort{1, 2, 3, 4, 5, 9, 7, 8, 10, 6} 输出 6{9,8,7,6,5,4, 10}输出6 并且reverse(0,6)-&gt;[4, 5, 7, 6, 8, 9, 10]展开代码 1234567891011121314151617181920212223242526private static &lt;T&gt; int countRunAndMakeAscending(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (c.compare(a[runHi++], a[lo]) &lt; 0) &#123; // Descending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123; // Ascending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo;&#125;private void reverseRange(Object[] a, int lo, int hi) &#123; hi--; while (lo &lt; hi) &#123; System.out.println(Arrays.toString(a)); Object t = a[lo]; a[lo++] = a[hi]; a[hi--] = t; &#125;&#125; StringString+” “原来的string还是在的 要等垃圾回收必用方法：1.char[] toCharArray()123456 public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;&#125; 2.String(char[]value) //offset,count123public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 3.每个字节对应的ASCII码1Arrays.toString(str.getBytes()) 4.startsWith(String prefix,int toffset)指定位置开始是否是prefix开头5.str.replaceAll(&quot;[0-9]&quot;,&quot;*&quot;),str.replaceAll(&quot;\\d&quot;,&quot;*&quot;)6.拆分返回String[]System.out.println(Arrays.toString(c1.split(&quot;\\d&quot;,4)));7.静态方法valueOf()转换各种类型为String 12final String b = "b";//变成了常量String b1=b+"1";//编译期确定 =&gt;String b2="b1" ==b1 12345678private static String getString()&#123;//方法在运行期才能确定 return "c";&#125;main&#123;final String c= getString();//加不加final都false 方法一定在运行期确定String c1=c+1;String c2="c1";System.out.println(c1==c2);//不等&#125; 源码：1.final 的常量只能定义时赋值或在【默认】构造器里赋值一次12345private final char value[];public String(String original) &#123; this.value = original.value;//将常量池中的值赋值给新创建的String this.hash = original.hash;&#125; Object1.finalize 对象被回收时调用 不建议重写2.public final native Class&lt;?&gt; getClass(); 获取对象的方法区的类信息 Math.abs(Integer.MIN_VALUE+10085)=-2147473563 DecimalFormat保留两位小数System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi));百分比new DecimalFormat(&quot;#.##%&quot;).format(pi) StringBuffer12String c = a+b+1;//常量变量相加会产生5个对象 编译器会优化String d = "a"+1+2+"b";//常量相加只有一个对象 123StringBuffer sb = new StringBuffer(32);sb.append(a).append(b).append(1);//解决常量变量相加 产生3个对象sb.toString(); StringBuilderjavap -c查看编译后的指令1.String a =&quot;a&quot;+1;会生成builder加入a12.String b = a+&quot;b&quot;;执行一次append1234String c=null;for(i in 5)&#123; c+=i;//会创建5个StringBuilder 应该用append拼接&#125; clone 不用创建过程 不用重新计算对象的大小必须重写12345678910@Overridepublic Object clone()&#123; TreeNode newT = null; try&#123; newT = (TreeNode)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return newT;&#125; Comparable Comparator1.Arrys.sort:底层实现12Comparable pivot = (Comparable) a[start];if (pivot.compareTo(a[mid]) &lt; 0) 2.Comparator面向对象，对修改关闭对扩展开放新建类123xxxComparator implements Comparator&lt;T&gt;&#123; compare(T o1,T o2)&#123;&#125;&#125; sort传入比较器Arrays.sort(t1,new xxxComparator()) System1.时间123Date nowtime = new Date(System.currentTimeMillis());DateFormat df = new SimpleDateFormat("HH:mm:ss");String now = df.format(nowtime); 2..exit()退出JVM3.当前工作目录System.getProperty(&quot;user.dir&quot;) os.name/os.version/user.name/user.home/java.home/java.version4.安卓加载三方类库System.loadLibrary Runtime 不new靠静态方法获取对象 Runtime rt = Runtime.getRuntime();可用处理器数量rt.availableProcessors()jvm总内存数rt.totalMemory()jvm空间内存rt.freeMemory()jvm最大可用内存rt.maxMemory() 执行命令行命令rt.exec(&quot;notepad&quot;) vector1.ArrayListhe和Vector在用法上完全相同addElement(Object obj)和add(Object obj)没什么区别12345 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 123456 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; Vector里有一些功能重复的方法,这些方法中方法名更短的是属于后来新增的方法.更长的是原先vector的方法.而后来ArrayList是作为List的主要实现类. 线程同步不应该使用Vector 应该使用java.util.concurrent.CopyOnWriteArrayList class Stack&lt;E&gt; extends Vector&lt;E&gt; Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();LinkedList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, ArrayDeque循环数组https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位 void addFirst(E e)12elements[head = (head - 1) &amp; (elements.length - 1)] = e;//越界处理if (head == tail) doubleCapacity(); 1.head前有空位 2.head是0，加到最后，如果最后是tail则扩容： elements.length必需是2的指数倍，elements - 1就是二进制低位全1 跟head - 1相与之后就起到了【取模】的作用 当head-1=-1;相当于对其取相对于elements.length的补码(正数就是本身) 1234int head = 10;int length = 8;//8-&gt;1000 ;7-&gt;0111;10-1=9-&gt;1001 ;-&gt;1head = (head - 1) &amp; (length - 1); addLast12elements[tail] = e;if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); void doubleCapacity()System.arraycopy12345native void arraycopy(Object src, //原数组 int srcPos,//原数组起始位置 Object dest, //目标数组 int destPos, //起始 int length); //长度 1234567int p = head;int n = elements.length;int r = n - p; // head右边元素的个数//复制右半部分，对应上图中绿色部分System.arraycopy(elements, p, a, 0, r);//复制左半部分，对应上图中灰色部分System.arraycopy(elements, 0, a, r, p); pollFirst()删除并返回Deque首端(head)元素展开代码 1234567891011 public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result;&#125; pollLast()int t =(tail-1)&amp;(element.length-1); E peekFirst()&amp;E peekLast 返回但步删除 LinkedList 双向链表Queue queue = new LinkedList();内部静态类Node map遍历：1for(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;&#125; java那些事ava API: Holder 对象 1000_000编译器会直接删除_ 十六进制p表示指数 $专门出现在自动产生的变量名中 方法外声明常量 static final （因为和对象无关，声明成类变量） 负数小心用% 浮点寄存器优化 strictfp修饰符 (int).. cast操作符警告 用Math.toIntExact会异常（越界or丢精度） java不允许对象使用操作符 必须调用方法 input.split(“\s+”)以空格分割 在null上调用方法会空指针异常，所以与字面量比较要将文字串放前&quot;word&quot;.equals(word) code point 有效的unicode值 Random (1L &lt;&lt; 48) - 1 Character也有cache1234567891011121314151617private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125;//This method will always cache values in the range '\u0000' to '\u007F', inclusive,public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; Integer12Integer i3 =100;Integer i4= 100;i3==i4;//(true)同一个对象 享元模式：共享对象 将1字节以内的数缓存 IntegerCache缓存数组 为避免重复创建对象 private static 内部静态类 只能在该类中访问,static用来做缓存new Integer(2)==new Integer(2) falseInteger.valueOf(2)==Integer.valueOf(2) true 变成1000的时候因为缓存不一样Integer.valueOf(2).intValue()==2 truenew Integer(2).equals(new Integer(2)) true 12345//缓存-128到127之间的值 cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); 12Integer i3 =1000;Integer i4= 1000;i3==i4;//(false)new了两个对象 123456public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //没用cache返回了新对象 return new Integer(i); &#125; 结论：Integer要用equals char2int: b.charAt(i–)-‘0’; StringBuilder StingBuilder线程不安全 连接大量字符串 .append .toString() StringBuffer 线程安全public synchronized StringBuffer append(String str) CharSequence字符序列类 euqals 没有实现equals的类：继承Object 1234public boolean equals(Object obj) &#123; //是否指向同一对象，equal和==相同 return (this == obj); &#125; Integer的实现 1234567891011public boolean equals(Object obj) &#123; //判断类型 if (obj instanceof Integer) &#123; //？？强制转型 return value == ((Integer)obj).intValue(); &#125; return false; &#125;public int intValue() &#123; return value; &#125; String实现 123456789101112131415161718192021222324public boolean equals(Object anObject) &#123; //指向引用 if (this == anObject) &#123; return true; &#125; //类型 写法注意！！ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; //长度？？可以调用private的value if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; ArrayList fianl修饰的变量，JVM也会提前给我们初始化好。??? 12345678//变量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;//构造函数，避免反复创建无用数组 指向同一个缓存Object[]数组this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA;&#125; .add(e) 创建Object数组，并拷贝 -&gt;ensureCapacityInternal(size+1)-&gt;ensureExplicitCapacity(size+1);-&gt;grow(size+1)-&gt;Arrays.copyOf-&gt;new Object[newLength]，System.arraycopy elementData[size++] = e; object的长度为10，size为逻辑长度，不是数组长度，minCapacity = Math.max(DEFAULT_CAPACITY=10, minCapacity 第一次扩容：就一个元素，在堆内存中占了10个位置 之后扩容：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//&gt;&gt;=/2 .remove(index) 1.将index+1后的numMoved个元素从index开始复制obj-&gt;obj12System.arraycopy(elementData, index+1, elementData, index, numMoved); 2.长度-1，最后一个null elementData[--size] = null; .romove(Object o) 循环查找o==null！=null-&gt;fastremove(index)(基本同上) 1234//当o！=null,按List规范重写equal!!if(o.equal(elementData[index]))&#123; fastRemove(index)&#125; Arrays @SuppressWarnings(&quot;unchecked&quot;)编译器消除警告 unchecked:执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 Arrays. native native是由操作系统实现的，C/C++实现，java去调用。 Arrays.copyOf-&gt;System.arraycopy(org,0,copy,0,len) Java8 default方法：接口内部有方法实现；实现两个接口有同名default名字冲突-&gt;报错 package java.util;里的常用类 Vector,Arraylist,LinkedList implements List LinkedList implents Queue List,Queue,Set implememts Collection Arraylist和Vector的区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍(可以改增量）。 vector:1int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity); 加锁和释放锁,在单线程的环境中，Vector效率要差很多。 和ArrayList和Vector一样，同样的类似关系的类还有HashMap和HashTable，StringBuilder和StringBuffer，后者是前者线程安全版本的实现。 synchronized JVM实现]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Front-end questions]]></title>
    <url>%2F2018%2F03%2F07%2FFront-end-questions%2F</url>
    <content type="text"><![CDATA[html元素&lt;base href=&quot;/&quot;&gt; 基础路径a[href,target] 默认target是当前页面（在新窗口打开）img[src,alt] alt图片显示失败的字label[for] 加上点单选框复选框的文字也可以选中框 queryURLParameter字符串拆分法熟练掌握 字符串方法 substr substring slice match展开代码 12345678910111213function queryURLParameter(url) &#123; let obj = &#123;&#125;; if (url.indexOf('?') &lt; 0) return obj; let ary = url.split('?'); url = ary[1]; ary = url.split('&amp;'); for (let i = 0; i &lt; ary.length; i++) &#123; let cur = ary[i]; curAry = cur.split('='); obj[curAry[0]]=curAry[1]; &#125; return obj;&#125; 正则12345678String.prototype.MyURLquery=function()&#123; let reg=/([^=&amp;?]+)=([^=&amp;?]+)/g, obj=&#123;&#125; this.replace(reg,(...arg)=&gt;&#123; obj[arg[1]]=arg[2]; &#125;) return obj;&#125; 闭包相关123456var a = 12;function fn()&#123;//变量提升声明var a但没有赋值 console.log(a); var a = 13;&#125;fn() //输出undefine 123//报错并不继续执行console.log(a);a=12;//没有声明var 不会变量提升 12345678var foo=1;function bar()&#123; if(!foo)&#123;//2.!undefined-&gt;true var foo=10;//1.变量提升 &#125; console.log(foo);&#125;bar()//输出10 1234567891011var n =0;function a()&#123; var n =10; function b()&#123;n++;console.log(n)&#125;&#125; b()//内部执行了一次 return b;&#125;var c=a()//执行输出11c()//输出12console.log(n)//输出0 123456function b(x,y,a)&#123; arguments[2]=10 console.log(a)&#125;c=b(1,2,3)console.log(a)//10 123456789101112var ary=[1,2,3,4]function fn(ary)&#123; //arr得到了全局arr的地址，可以改变全局 ary[0]=0 //变成另一个地址 ary=[0]//[0]是一个地址，arr指向了新的堆内存 ary[0]=100 return ary&#125;var res = fn(ary)console.log(ary)//输出(4) [0, 2, 3, 4]console.log(res)//输出[100] 12345678function fn(i)&#123; return function(n)&#123; console.log(n+(--i)) &#125;&#125;var f = fn(2)//输出f(3)//输出4f(4)//4 1234567891011121314151617var num = 10var obj = &#123;num:20&#125;//&#123;num: 30, fn: ƒ&#125;obj.fn=(function(num)&#123; console.log(this)//window this.num=num*3//自执行函数this是window num++//21 return function(n)&#123; console.log("内"+this)//window this.num+=n; num++//向上级作用域找//22 console.log(num) &#125;&#125;)(obj.num)var fn = obj.fnfn(5)//22 //this是windowobj.fn(10)//23 此时fn的this是objconsole.log(num,obj.num)//65，30 1234567891011121314151617181920function Fn()&#123; this.x=100; this.y=200; this.getX=function()&#123; console.log(this.x); &#125;&#125;;Fn.prototype=&#123; y:400, getX:function()&#123; console.log(this.x); &#125;, getY:function()&#123; console.log(this.y); &#125;, sum:function()&#123; console.log(this.x+this.y); &#125;&#125;;Fn.prototype.sum()//undefined+400=NaN 12345678910111213var name = 'window'var Tom =&#123; name:"Tom", show:function()&#123; console.log(this.name) &#125;, wait:function()&#123; var fun = this.show//Tom.show fun()//前面没有. &#125;&#125;Tom.wait()//windowTom.show()//Tom front-end @import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; H5 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; 表单控件 geolocation 对象 Web Worker js多线程:专用线程Dedicated Worker和共享线程 Shared Worker;Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享 离线缓存manifest 新建的.appcache文件的缓存机制(不是存储技术)像cookie一样缓存清单上的资源。 如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 html5shim HTML5 styling for Internet Explorer 6-9, Safari 4.x (and iPhone 3.x), and Firefox 3.x.123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; &lt;![endif]--&gt;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2F2018%2F03%2F06%2FMathJax%2F</url>
    <content type="text"><![CDATA[变量MATH$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$`$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[About SpringBoot]]></title>
    <url>%2F2018%2F03%2F06%2FAbout-SpringBoot%2F</url>
    <content type="text"><![CDATA[spring自动装配context.getBean(.class)获取对象 AnnotationConfigApplicationContext(App.class)注解形式上下文，用component标识bean,scan扫描自动执行component的构造函数,@Autowire加在有参构造函数上，自动装配参数到当前类，实现类的关联 ClassPathXmlApplicationContext(&quot;.xml&quot;)不用注解，用&lt;bean&gt;,和ref在maven下resources和java都是源码的根目录，所以在java里面读resources里的文件可以直接.xml 将组件扫描ComponentScan与启动类分离 范围是所在包和子包，可以加(“”)相当于在xml里配置&lt;context:component-scan base-package=&quot;&quot;/&gt; 1234ApplicationContext context = new ApplicationConfigApplicationContext(AppCfg.class);//AppCfg.java@Configuration@ComponentScan 引入spring test 基于junit自动引入上下文12345@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes=AppConfig.class)//不用再创建context，也不用getBean,自动注入直接用@Autowiredprivate CDplayer cdplayer; @Autowired 使用 有参构造函数 成员变量 反射 效率低 setCD(CD cd)等setter方法上 @Autowired(required=false)用接口注入成员对象时有两个实现类时，使用@Primary或者使用限定符Qualifier(&quot;&quot;)相互对应，或者把限定符写在@Component(&quot;&quot;)里。默认的限定符是类名小写使用Resource(name=&quot;&quot;) = @Autowired+@Qualifier 是jdk自带的标准 配置文件详解公共配置 DispatcherServlet 需要定义一个[servlet-name]-servlet.xml配置文件 HandlerMapping Controllers view解析相关的 定义ContextLoaderListerner 并指定配置文件 @RequestMapping:consumes:处理特定请求类型，’Content-Type’RestAPI 12@RequestMapping(Path="/users/&#123;userId&#125;")public String webMethod(@PathVariable String userId) 登陆场景表单 12public void login(@ModelAttribute User user, Writer writer)&#123; &#125; 123@RequestMapping("/user/login")@ResponseBodypublic String login(@RequestParam("name") String name,@RequestParam("password")String password)throws IOexception&#123;&#125; 上传文件定义bean1&lt;bean id = "multipartResolver"class="...CommonsMultipartResolver"&gt; 123@RequestMapping(path="/form",method = RequestMethod.POST) public String handleForm(@RequestParam("file"), MultipartFile file)&#123; &#125; IOC容器：ApplicationContext类一个ApplicationContext对象就是一个容器。属于spring-context模块 初始化 WebApplicationContext:在web应用中初始化 web.xml 1.全局参数配置 12345&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:application-context.xml &lt;/param-value&gt;&lt;/context-param&gt; 2.加载上下文环境配置 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 3.servlet入口 12345678&lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.添加servlet配置文件example-servlet.xml 名称符合spring标准：servletname-servlet &lt;bean &lt;context:component-scan base-package=&quot;&quot;/&gt;&gt; 5.@Controller @RequestMap(value=) `response.getWriter().write(&quot;&quot;);` 在测试.java的psvm中使用ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;); ApplicationContext context = new FileSystemXmlApplicationContext(&quot;.xml&quot;); Bean定义：&lt;bean id = &quot;bean类名&quot; class=&quot;类&quot;&gt; 获取对象 类名 a = context.getBean(&quot;bean类名&quot;,类.class） Bean作用域： singleton 默认&lt;bean scope=&quot;singleton&quot;&gt; prototype 每次引用创建一个实例web里仅有 Bean生命周期回调 创建&lt;bean init-method=&quot;init&gt; 销毁&lt;bean destory-method=&quot;cleanup&quot;&gt; 容器关闭:转换成支持close的子类 ((ConfigurableApplicationContext)context).close() 依赖注入 面向对象封装数据和方法，对象的依赖关系体现在对数据和方法的依赖上。把依赖注入交给框架or IOC完成，从具体对象手中交出控制（依赖关系）。Ioc容器是实现依赖控制反转的载体。在对象生成or初始化时直接将数据注入对象；？？注入对方法的调用的依赖：通过将对象引用注入对象数据域中的方法处理数据的对象和对象之间的相互依赖关系比较稳定。 强依赖（螺丝刀必须有刀头）：构造函数 可选依赖（可配置 颜色）：Setter方法 定义抽象接口，实现接口，以接口为基础注入 实现类有构造函数参数123456&lt;bean&gt; &lt;constructor-arg value = "值"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" vlaue =""&gt; &lt;constructor-arg type="java.lang.String" value=""&gt; &lt;constructor-arg name="color" value="red"&gt;&lt;/bean&gt; 注入集合Map&lt;String,String&gt; paras 每个key,value都是entry 123456&lt;constructor-arg&gt; &lt;map&gt; &lt;entry key = "color" value = "red"&gt;&lt;/entry&gt; &lt;entry key = "size" value = "15"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/constructor-arg&gt; 注入List &lt;list&gt;&lt;value&gt;14&lt;/value&gt;&lt;list&gt; &lt;set&gt;&lt;value&gt; 注入Properties对象 &lt;props&gt;&lt;prop key = &quot;color&quot;&gt;red&lt;/prop&gt; 配置文件 1234&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt;&lt;bean id = "headerProperties" class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name = "location" value = "classpath:header.properties"/&gt;&lt;/bean&gt; header-property: colr =green size =16 12Header heaer = context.getBean("header",子类.class);sout(header.getInfo()); bean 依赖 12345&lt;bean&gt; &lt;constructor-arg&gt; &lt;ref bean = "header"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 自动装配 不用构造函数&lt;constructor-arg&gt; &lt;bean autowire=&quot;byName&quot;&gt;/byType/constructor 使用setter方法 123public void setHeader(Header header)&#123; this.header = header;&#125; 用context.getBean(,.class)获取对象 注解 @Component定义Bean @Valueproperties注入Bean @Autowired&amp;@Resource自动装配依赖 如果后续会把springIOC去掉用后者(java标准javax.annotation.Resource) @PostConstruct&amp;PreDestroyBean的生命周期回调 使用注解 添加&lt;comtext:component-scan base-package=&quot;&quot;/&gt; @Component(“header”)和@value(“${color}”)替换 12&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt; 也不再需要setter函数 @Autowired 替换 &lt;bean autowire=&quot;byName&quot;&gt;不需要setter AOP完整的aop框架AspectJ Aspect非业务逻辑（日志、安全） Join point业务函数执行 Advice：切面在函数实现的功能。Aspect对函数打日志 5种类型 @Before 函数执行之前 @After returning 正常返回之后 @Around 函数执行前后 @After throwing 抛出异常之后 @After finally 函数返回之后 pointcut：匹配AOP目标函数的表达式+名称。哪些业务方法需要AOPexecution 匹配函数within 某个包某个类下面的函数*匹配所有 save*表示save开头的所有函数 所有public函数execution(public**(..)) 组合两个表达式execution(表达式1()&amp;&amp;表达式2() Aspectj使用 添加依赖 aspectjweaver.jar spring容器spring-context xml添加 xmlns:xml link space 类似于包 &lt;beans xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; http://www.springframework.org/schema/aop xsd:xml schema defination http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt; &lt;aop:aspectj-autoproxy /&gt; 新建Aspect类，定义类级别的@Aspect 添加&lt;bean&gt;配制（两个bean 切面和业务类） 定义Pointcut范围 匹配Caculator下的所有函数 123456@Aspectpublic class LoggingAspect &#123; @PointCut("execution(* ..Caculator.*(..)) &amp;&amp; args(a, ..)") private void arithmetic() &#123;//表达式的名称 &#125;&#125; 定义Advice：添加函数级别@Before(pointcut表达式/pointcut名称) Advice参数 获得上下文信息JoinPoint jp1234@Before("pointcut()")public void doLog(JoinPoint jp)&#123; //获得函数签名、函数参数 都是无类型的Object sout(jp.getSignature+","+jp.getArgs())&#125; @Around需要注入的是ProceedingJoinPoint pjp 获得函数的返回值 12@AfterReturning(pointcut="()",returning = retVal)public void doLog(Object retVal) 获得异常 是有类型的不是Exception 123@AfterThrowing(pointcut="()",throwing = "ex")public void doLog(IllegalArgumentException ex)&#123;&#125;&#125; 获得目标函数第一个参数 &amp;&amp;args(a,..) 12@Before("pc() &amp;&amp; args(a,..)")public void doLog(JoinPoint jp,int a)&#123;sout(a)&#125; Schema-based AOPaop:aspectJdbcTemplate DAO Data Access Object 数据访问接口由JDBC/Mybatis等ORM框架实现 spring-jdbc: 加载db配置文件&lt;context:property-placeholder location=&quot;db.properties&quot; /&gt; jdbc.driverClassName= com.mysql.jdbc.Driver jdbc.url= jdbc:mysql://:3306/example jdbc.username= jdbc.password= 配置数据源 1234567&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; 创建DAO类@Repository @Repository 定义一个Bean 代表DAO的bean,创建JDBC实例 1234567public class JdbcTemplateDao &#123;private JdbcTemplate jdbcTemplate;@Autowiredpublic void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource);&#125;&#125; application-context添加Autowired的搜索 1&lt;context:component-scan base-package="com.netease.course" /&gt; 数据转换成对象RowMapper 123456789new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setFirstName(rs.getString("first_name")); user.setLastName(rs.getString("last_name")); return user; &#125;&#125; NamedParameterJdbcTemplate JdbcTemplate 通过？传参，很多列的时候不明确this.jdbcTemplate.update(&quot;insert into user values (2, ?, ?)&quot;, &quot;Lei&quot;, &quot;Li&quot;); named where firest_name=:first_namequeryForObject(sql,Map&lt;Sting,?&gt;paramMap,RowMapper&lt;T&gt; rowMapper) SqlParameterSource在spring中用MapSqlParameterSource/BeanPropertySqlParameterSource(java对象（bean)) 异常处理SQLException是checked异常：需要捕获Spring的DataAccessException是unchecked异常 事务管理 MyBatisAOP 一组类共享相同行为（继承 @AspectAspectJ注解式切面 @Transcational 事务处理 @Cacheable 数据缓存 规则注解@interface 注解拦截类 @Action(name=””) 被拦截类 与（2）相同但是没有@Action 切面 @Aspect @PointCut声明切点：(“@annotation(注解(1))”) @After声明建言 反射： 电影例子 IoC控制反转 某一接口的实现控制权，从调用类中移除，由第三方决定 （导演选角色扮演者（具体实现类），放到电影中） DI 依赖注入 让调用类对某一实现类的依赖由第三方来注入。移除调用类对某一实现接口的依赖。 构造函数注入（构造函数的参数）:传入扮演者 1234567//电影 ljm; 构造函数（ljm)&#123;this.ljm = ljm&#125;//导演ljm = ldh；//(角色=演员)电影= 电影（ljm）wjd.action Setter并不是电影每个场景都要用到LJM-&gt;属性注入 123456//电影ljm;set(ljm)&#123;this.ljm=ljm;&#125;//导演电影.set(ljm)电影.action 接口注入 与属性注入没用本质区别 123456789interface&#123; void inject(ljm);&#125;电影 implements interface&#123; inject(ljm)&#123;this.ljm = ljm;&#125;&#125;导演&#123; 电影.inject(ljm)&#125; 注解 描述类和类之间的依赖关系自动完成类的初始化和依赖注入 1234//实例化&lt;bean id ="ljm" class = "ldh"/&gt; //ljm = new ldh;//建立依赖&lt;bean id ="wjd" class = "wjd" p:ljm-ref ="ljm"/&gt; 从容器中返回bean实例 SpringMVC前端调度器把请求分发给业务控制器，把生成的数据分发给视图模板。 js deguggger watch springboot遇到过的注解创建API@ResponseBody 标注返回值是json：在response的header中塞入contentType @Controller 修饰class创建http请求 @ResController -&gt; @RequestMapping(“/hello”)返回json method=RequestMethod.GET @Component -&gt; @Value(“${application.properties(属性名)}”) 单元测试： 随机数 1$&#123;random.value&#125; + $&#123;random.long&#125; + $&#123;random.int(10)&#125; + $&#123;random.int[10,20]&#125; --是对application.properties 中属性的标识-屏蔽命令行访问属性设置SpringApplication.setAddCommandLineProperties(false) -多环境配置文件格式application-{profile}.properties-激活spring.profiles.active = dev @RestController -&gt; @RequestMappint(value=”users”)等于@controller+ResponseBody 将java类用Jackason转换为JSON RequestMapping(“/“) GetMapping(“/get1”) PostMapping(“/postJson”) @RequestBody 对象 @RequestParam 接收?后的query参数 @ModelAttribute User user 绑定参数 @PathVariable url路径中的参数 绑定value=”/{id}” 12345@GetMapping("/hotels/&#123;htid&#125;/rooms/&#123;roomId&#125;")public Room getRoomById( @PathVariable String htid, @PathVariable Integer roomId)&#123;&#125; map.addAttribute(“host”,””) -&gt; th:text =”${host}” 使用Swagger2mvn依赖写法检索 mvnrepository12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; @Configuration 加载类配置 @Bean 标记的方法会在容器启动自动执行，并且创建的对象是单例的 跨域问题cors 协议、域名、端口不同 浏览器对ajax xhr的限制 jsonp 动态创建script 在script里发出请求（现在不用 只能get 原理：后台约定super(“callback”)=&gt;前台?callback=Jquery 函数名 参数值 12345678910111213$.ajax(&#123; url: base+"/get1", dataType: "jsonp", 后台约定 jsonp:"callback2", //结果可以被缓存 缓存-&gt;无&amp;_ cache: true, //返回的结果保存到result字段 success: function(json)&#123; //要求返回js代码。但是普通ajax请求，后台返回了json对象。加切面 result= json; &#125; &#125;) 查看返回类型：Network-&gt;右键-&gt;Response Headers-&gt;Content-Type ?calLback= json对象-&gt;函数调用 被调用方，返回允许调用client-&gt;另一个http服务器 在http服务器添加响应头 在应用服务器上添加跨域请求多了Origin:当前域名 @Bean FilterRegistrationBean 12bean.addUrlPatterns("/*")//所有请求都经过filterbean.setFilter(new CrosFilter()) doFilter 1234res.addHeader("Access-Control-Allow-Origin","http::")//,"*"允许所有域res.addHeader("Access-Control-Allow-Methods","GET")//,"*"//filter链chain.doFilter(,) 简单请求：GET/HEAD/POST；无自定义头；Content-Type 为&quot;text/plain&quot;`multipart/form-dataapplication/x-www-form-urlencoded` 非简单：put,delete、发送json、带自定义头的ajax； 调用方 代理，隐藏跨域http服务器-&gt;http服务器 Spring解决跨域 @CrossOrigin +类or方法上面 反向代理： 访问同一个域名的两个URL,去两个不同的服务器 J2EE架构 Apache/Nginx(处理静态请求、负载均衡）判断静态请求（js\css-&gt;直接返回给客户端； 动态请求（与用户数据有关的）客户端-&gt;http服务器-&gt;后台应用服务器(tomcat) IOC控制翻转 通过 DI依赖注入 实现spring-contextIOC容器创建Bean，将功能类Bean注入到Bean中。 配置元数据：xml配置、注解、java配置Spring容器解析配置元数据 Bean初始化、配置和管理依赖。 声明Bean的注解： @Component @Service @Repository @Controller 注入Bean @Autowired @Inject @Resource 用在set方法or属性上 编写功能类业务Bean的注解配置@Service，@Component，@Service，@Repository，@Controller 声明是Spring管理的Bean 使用功能类 @Autowired 注入Bean 添加功能 配置类（空的） @Configuration。@ComponentScan 自动扫描@Service，@Component,@Repository,@Controller的类 注册为Bean 运行 AnnotationConfigApplicationContext是Spring容器，参数：配置类(3).class 使用功能类（2） = 容器.getBean((2).class) 容器context.close() Java 配置 （1）、（2）不适用@Service和@Autowired;(2)+set (3)配置类不使用Scan包扫描 @Bean @Bean（1）返回名称为方法名（type:功能类）的Bean 法1：@Bean (2).set(1) 注入并直接调用(1) 法2：（2）直接传参(1) 123456789101112131415@Configuration //1public class JavaConfig &#123; @Bean //2 public FunctionService functionService()&#123; return new FunctionService(); &#125; @Bean public UseFunctionService useFunctionService()&#123; UseFunctionService useFunctionService = new UseFunctionService(); useFunctionService.setFunctionService(functionService()); //3 return useFunctionService; &#125;&#125; 只要容器中有Bean就可以在另一个Bean的方法参数中传入全局配置使用Java配置（数据库，MVC）]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射&静态代理&动态代理]]></title>
    <url>%2F2018%2F03%2F06%2FjavaAnnotation%2F</url>
    <content type="text"><![CDATA[注解12345@Target(ElementType.TYPE)//类注解@Retention(RetentionPolicy.SOURCE)//编译时会被忽略public @interface ThreadSafe &#123; String value() default "";&#125; 静态代理：为对象提供一种代理，控制这个对象的访问 对一个方法添加计算时间的业务 静态代理在于在运行期之前就有已经写好的actionProxy implements Action代理类展开代码 123456789101112131415161718192021222324252627282930313233//3.在真正的业务方法之前取一下时间，计算耗时//分离业务逻辑 同时实现相同的接口 代理使用（当作一个属性）业务类class actionProxy implements Action&#123; public Action action;//被代理对象 public actionProxy(Action action)&#123; this.action= action; &#125; public void doAction()&#123; //可以添加权限操作 long start = System.currentTimeMillis(); action.doAction(); long end = System.currentTimeMillis(); System.out.println("耗时"+(end-start)); &#125;&#125;//1.通过一个接口interface Action&#123; public void doAction();&#125;//2. 接口的实现类是具体的工作//没有代理的时候这个类依然能正常使用class UserAction implements Action&#123; public void doAction()&#123; System.out.println("用户工作逻辑"); &#125;&#125;public class staticproxy &#123; public static void main(String[] args) &#123; Action action = new UserAction(); actionProxy pro = new actionProxy(action); pro.doAction(); &#125;&#125; 反射 java.lang.reflect.* 在运行中分析类能力；运行中查看对象；Method对象 Class 是java基础类。虚拟机创建Class的实例。 三种方法获取class：对象.getClass。类.class。Class.forName（抛异常） 实例化对象： Class cls = Class.forName(className) （静态方法）获得类名的Class对象 cls.newInstance()调用className的默认无参构造方法，返回className类型) 获取所有构造方法 1Constructor&lt;?&gt;[] cs = acla.getDeclaredConstructors(); getModifiers()获得修饰符 获得指定参数的构造方法 会抛异常 1Constructor&lt;Bank&gt; c = b.getConstructor(Integer.class,Integer.class); 通过构造器得到实例 抛异常 1c.newInstance(1,3); 获取类的所有成员变量，get/set设置获取属性 1234//获取publicField[] fi = bb.getFields();//获取所有属性包括私有属性Field[] dd = bb.getDeclaredFields(); 获取修饰符 12int modifiers = f.getModifiers(); System.out.println(Modifier.toString(modifiers)); 获取所在的包Package getPackage() 获取公共方法（包括继承Object的 123Method[] methods = bb.getMethods();//调用方法methods[0].invoke(对象,参数); getDeclaredFields()不包含父类方法，包括私有方法。 但是私有方法不能invoke 调用私有方法:去除修饰符检查 12methods[3].setAccessible(true);methods[3].invoke(b); 动态代理可以代理多个接口 展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//1.生成代理类的类class CreateProxy implements InvocationHandler&#123; //2.被代理的对象 private Object target; //3 创建代理的方法 public Object create(Object target)&#123; this.target=target; //获得所有的接口getInterfaces Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); return proxy; &#125; //4.业务代码 @Override //代理类，被代理的方法，方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始"); method.invoke(target,args); System.out.println("结束"); return null; &#125;&#125;class Person implements Subject&#123; public void shopping()&#123; System.out.println("买东西"); &#125;&#125;interface Subject&#123; public void shopping();&#125;public class dynamicProxy &#123; public static void main(String[] args) &#123; //创建代理对象的对象 CreateProxy cp = new CreateProxy(); //被代理的对象 Subject person = new Person(); //代理 强制转换成被代理的类型 Subject proxy = (Subject)cp.create(person); //会调用invoke proxy.shopping(); &#125;&#125; 多一个接口,使用同一个代理对象1234567interface Hotel&#123;public void live();&#125;class Person implements Subject,Hotel&#123;live()&#123;&#125;&#125;@TestCreateProxy cp = new CreateProxy();Person person = new Person();Hotel proxy = (Hotel) cp.create(person);proxy.live(); proxy.getClass().getName() 是$Proxy0 不是InvocationHandler类型，是运行时动态生成的一个对象。1234Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); .newProxyInstance实现JavaCompiler编译器cglib动态代理（类）类加载器类加载器类加载：.class文件中的二进制数据，读入内存方法区，在堆中创建Class对象，封装方法区中的对象。主动引用被动引用 JavaBean规范 private,get/set能被IDE识别Apache BeanUtils 内省Java探针agent注解编译时注解 JDK：@Override，@Deprecated，@Suppvisewarnings@Autowired 自动注入 异常 未检查异常:访问null引用 不查看异常处理器（handler) 已检查异常：编译器检查是否提供了处理器&gt; 无处理器&gt; 终止 Throwable 是Exception类的超类 123catch(Exception e)&#123; e.printStackTrace()&#125;]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS224]]></title>
    <url>%2F2018%2F03%2F05%2FCS224%2F</url>
    <content type="text"><![CDATA[Word2Vec 词向量 one-hot p=[0,.,0,1,0,..0]用 Hash 表给每个词分配一个编号 维数灾难;词汇鸿沟”现象：任意两个词之间都是孤立的。 deeplearning：Distributed Representation实数向量[0.792, −0.177, −0.107, 0.109, −0.542, …]维度以 50 维和 100 维比较常见。相似的词可以计算距离or Cos Distributed representation 用来表示词，通常被称为“Word Representation”或“Word Embedding”，中文俗称“词向量”。相似词的词向量距离相近，这就让基于词向量设计的一些模型自带平滑功能，让模型看起来非常的漂亮。σ() softmax number -&gt; 分布 ??证明σ(-x) = 1-σ(x) skip gram一个词有两个向量，v 中心词向量 u 上下文向量U(like)’V(deep) 两个词共同出现的概率（max)分母是词汇表 binary logistic regression J(θ)：T窗口;j~P(w)随机抽取语料库的单词（min) 随机 unigram distribution U(w) 3/4 Stochastic gradients continuous bag of words(CBOW)：通过周围词向量的和来预测中心词而不是单个邻接词（skip gram) Cross entropy 交叉熵（loss for softmax) Context({})向模板提供数据 对co-occurrence矩阵降维： ！！！SVD singular value decomposition 奇异值分解$A=UΣV^T$ m*n的矩阵对角化-&gt;特征值、行列式、幂、指数函数 n阶矩阵相似于对角阵 &lt;=&gt;有n个线性无关的特征向量 实对称正交相似于对角阵 $Q^TAQ=Λ=diag(λ1…λn)$（特征值） 正交矩阵$Q=(v_1…v_n)$：$Av_i=λ_iv_i$ $Q^TQ=E$ $AV = UΣ$-&gt;V和U展开-&gt;Σ展开-&gt;r=rank(A)-&gt;$Av_i=σ_iu_i(i∈（1,r));Av_j=0$-&gt;两边转置-&gt;$A^TU=VΣ^T$-&gt;$A^Tu_i=σ_iv_i$ $A^TAv_i = σ_i^2v_i$(特，特向) $AA^Tu_i = σ_i^2u_i$原理 A(mxn)-&gt;$AA^T$为m阶实对称$A^TA$n阶实对称 特征值非负 证明：$x^TA^TAx = λx^Tx$-&gt;$||Ax||^2(&gt;=0)=λ||x||^2(&gt;0)$ $A^TA$与$AA^T$非零特征集合相同 证明:$r(AA^T)=r(A^T),r(A^TA)=r(A)$-&gt; $r(AA^T)=r(A^TA)=r(A)=R$几何意义：旋转、伸缩、旋转 $R^n-&gt;R^m x-&gt;Ax$变换 $x-V^Tx$旋转 $Σ$ 对前r个分量做伸缩 ??交叉熵与Kullback-Leibler derivative导数，gradient梯度 $timeit max-margin sigmoid函数求导:$ \frac{σ(y)}{dy}=σ(y)·(1-σ(y))$,接近0 梯度最大 语言模型Dynamic Memory NetworkDynamic Memory NetworkA Joint Many-Task Model:Growing a Neural Network for Multiple NLP Tasks 统计学习方法学习策略 感知机： $w·x+b=0$是平面 误分点到平面距离$(w·x_i+b)$,乘错误点的输出$·y_i$ 正确的点 输出和平面函数是一样的。 损失函数：所有误分点距离取正 min损失函数，对w,b求导；梯度下降 w+学习率(0,1]·对w求导；同理b。 损失函数3种： 结构风险函数： 正则化]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统+内存知识]]></title>
    <url>%2F2018%2F03%2F05%2Fmemory%2F</url>
    <content type="text"><![CDATA[安全序列https://www.nowcoder.com/ta/nine-chapter?query=&amp;asc=true&amp;order=&amp;page=3 软中断 和 硬中断中断和异常是随机发生、自动处理、可恢复的。 中断： 操作系统 是中断（事件）驱动的中断引入是为了支持CPU和外部设备并行操作：cpu启动输入输出设备后，设备独立工作，cpu处理其他任务。当输入/输出完成，向CPU发送中断。 异常： cpu执行指令时自身出现的问题。（算术溢出、地址越界、陷入指令）异常分3类：陷入，故障，终止事件的发生改变了处理器的控制流： cpu暂停正在执行的程序， 保留现场， 自动转去执行相应事件的处理程序， 完成后返回断点，继续执行被打断的程序。 硬件：中断/异常响应：捕获中断/异常请求，响应，交给特定处理程序 。软件：中断/异常处理程序：识别中断/异常类型 并完成处理。 中断响应： 发现中断、接受中断的过程。由中断硬件部件完成。处理器控制部件中有 中断寄存器。 CPU在每条指令执行周期的最后，会扫描 中断寄存器。中断硬件会将触发内容规定变法送入PSW程序状态字相应位，称 中断编码。硬件会去查中断向量表，调出中断处理程序。 中断向量表：操作系统设计好的一条中断向量是一个内存单元。存放：中断处理程序入口地址和程序运行时所需的处理机状态字。Linux中断向量表0~255个中断向量c 中断处理程序： 软件提前设置好，硬件执行 保存相关寄存器信息 分析中断/异常的具体原因 执行处理程序 回复现场，返回被打断的程序 I/O中断处理程序分两类处理：正常结束，唤醒等待的程序，或者继续IO出现错误：重新执行失败IO，直到判断为硬件故障 （硬件）CPU 切换到内核态 在系统栈保留上下文 PC,PSW。 X86处理器中断：硬件信号。异常：指令执行引发。 系统调用：用户态到内核态的唯一入口。 中断控制器:硬件中断信号-&gt;中断向量 引发CPU中断 实模式没有CPU状态的转换。现在一般我们是在保护模式。叫中断描述符表。用门(gate) 保护模式： 用来增强多工和系统稳定度，像是 内存保护，分页 系统，以及硬件支援的 虚拟内存 实模式下的各种代码段、数据段、堆栈段、中断服务程序仍然存在，统称为“数据段”引入描述符来描述各种数据段，所有的描述符均为8个字节（0-7)，由第5个字节说明描述符的类型，类型不同，描述符的结构也有所不同。描述符表是一张地址转换函数表。 描述符数据结构表示中断向量。中断描述符表(IDT)通过IDTR寄存器获得IDT的地址段选择符是索引，显示是GDT表还是LDT表，还有特权级，用索引查全局描述符表（GDT），得到段描述符，得到段基地址+偏移量 = 中断服务程序入口地址 要做特权级检查，要切换堆栈，用户态进内核态，堆栈指针到内核态硬件压栈，保存上下文，如果异常产生了硬件出错码 保存在栈中。 系统调用：操作系统功能调用 //todo每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护） 应用程序可以直接使用系统调用，但是一般都是通过C函数库/API接口使用系统调用。内核函数是系统调用的处理程序 经过封装，提供到了C库函数和API接口。 https://www.polarxiong.com/archives/%E8%AF%BB-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%9A%84%E6%80%BB%E7%BB%93.html 伙伴系统：Linux内存分配方案，空闲块链表伙伴：如果需要的空间s需要2^(n-1)&lt;s&lt;2^n则空间/2，两个叫伙伴。 伙伴分割与合并（每次分割小的空闲块，系统中始终保持大的空闲快） 内存管理方案装载单位： 进程1.单一连续区域:只有一个进程在内存 2.固定分区：内存分区，每个分区只装1个进程，进程在各个分区排队 3.可变分区：内存按需分配给进程外碎片：进程和进程之间的空隙memory compaction:在内存移动程序，合并空闲区域进程IO时不能移动。 进程进入内存不是连续区域，而是进入内存若干个不连续区域。//todohttps://www.coursera.org/lecture/os-pku/ji-ben-nei-cun-guan-li-fang-an-2-p4N0u1.页式如果是32位的计算机,如果页面大小4k,0~11 12位为偏移 页表项记录了逻辑页号 到页框号的一个映射关系 每个进程都有一张页表，页表放在内存，一个进程上CPU之后 这个进程的页表的起始地址要推送到某一个寄存器 页表的起始地址在哪个数据结构？用 bitmap 位图管理物理内存 死锁的4个条件Windows API让cpu使用率划出一条直线一个时钟周期可以执行多少条指令？ CPU流水线？CPU每个时钟周期可以执行两条以上代码2.4Ghz主频则1秒可以执行2.4G*2行汇编指令10毫秒接近Windows调度时间片，1毫秒会导致线程频繁被唤醒挂起资源管理器大约是1秒更新一次4核cpu一个线程死循环占用大概是25%SetThreadAffinityMask() https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html IO多路复用http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html 磁盘驱动https://my.oschina.net/manmao/blog/746492 移动磁头到磁道 转动磁盘到扇区 磁生电和内存读，电生磁 内存写 总线倒用技术DMA 扇区和内存 算出柱面磁头扇区和读写的缓冲区直接out 抽象1：通过盘块号 操作系统 计算出柱面磁头扇区CHS 磁盘调度算法电梯调度算法？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 100;int n, now, s, sum, nnow, everage, p[maxn], b[maxn], sp[maxn], lenp[maxn];//显示结果void show()&#123; sum = 0; cout &lt;&lt;" 被访问的下一磁道号 移动距离（磁道数）\n"; for(int i = 0;i &lt; n; ++i) &#123; printf(" %3d %3d\n", sp[i], lenp[i]); sum += lenp[i]; &#125; cout &lt;&lt;" 平均寻道长度： "&lt;&lt;(double)sum/n &lt;&lt;"\n";&#125;//先来先服务void FCFS()&#123; for(int i = 0;i &lt; n; ++i) &#123; sp[i] = p[i]; if(i) lenp[i] = abs(sp[i-1] - sp[i]); else lenp[i] = abs(now - sp[i]); &#125;&#125;//最短寻道优先void SSTF()&#123; nnow = now; int fl[maxn] = &#123;0&#125;; for(int i = 0;i &lt; n; ++i) &#123; int minx = 999999, pp; for(int j = 0;j &lt; n; ++j) &#123; if(!fl[j] &amp;&amp; abs(nnow - p[j]) &lt; minx) &#123; minx = abs(nnow - p[j]); pp = j; &#125; &#125; sp[i] = p[pp]; lenp[i] = minx; nnow = p[pp]; fl[pp] = 1; &#125;&#125;//扫描算法bool cmp(int a, int b)&#123; return a &gt; b;&#125;void SCAN()&#123; nnow = now; int aa[maxn], bb[maxn], ak = 0, bk = 0; for(int i = 0;i &lt; n; ++i) &#123; if(p[i] &lt; nnow) aa[ak++] = p[i]; else bb[bk++] = p[i]; &#125; sort(aa, aa+ak,cmp); sort(bb, bb+bk); int i = 0; for(int j = 0;j &lt; bk; ++j) &#123; sp[i] = bb[j]; lenp[i++] = bb[j] - nnow; nnow = bb[j]; &#125; for(int j = 0;j &lt; ak; ++j) &#123; sp[i] = aa[j]; lenp[i++] = nnow - aa[j]; nnow = aa[j]; &#125;&#125;//循环扫描算法void CSCAN()&#123; nnow = now; int aa[maxn], bb[maxn], ak = 0, bk = 0; for(int i = 0;i &lt; n; ++i) &#123; if(p[i] &lt; nnow) aa[ak++] = p[i]; else bb[bk++] = p[i]; &#125; sort(aa, aa+ak); sort(bb, bb+bk); int i = 0; for(int j = 0;j &lt; bk; ++j) &#123; sp[i] = bb[j]; lenp[i++] = bb[j] - nnow; nnow = bb[j]; &#125; for(int j = 0;j &lt; ak; ++j) &#123; sp[i] = aa[j]; lenp[i++] = abs(aa[j] - nnow); nnow = aa[j]; &#125;&#125;int main()&#123; xbegin: cout&lt;&lt;"请输入被访问的总磁道数： "; cin &gt;&gt; n; if(n &lt;= 0 || n &gt; 100) &#123; cout &lt;&lt;"输入不合法，请重新输入！\n"; goto xbegin; &#125; nowCD: cout &lt;&lt;"请输入当前磁道： "; cin &gt;&gt; now; if(now &lt; 0) &#123; cout &lt;&lt;"磁道不存在，请重新输入！"; goto nowCD; &#125; pCD: cout &lt;&lt;"请按顺序输入所有需要访问的磁道："; for(int i = 0;i &lt; n; ++i) cin &gt;&gt; p[i]; for(int i = 0;i &lt; n; ++i) &#123; b[i] = p[i]; if(p[i] &lt; 0) &#123; cout &lt;&lt;"输入中有不存在的磁道，请重新输入！\n"; goto pCD; &#125; &#125; serve: cout &lt;&lt;" 1、先来先服务算法（FCFS）\n"; cout &lt;&lt;" 2、最短寻道优先算法（SSTF）\n"; cout &lt;&lt;" 3、扫描算法（SCAN）\n"; cout &lt;&lt;" 4、循环扫描算法（CSCAN）\n"; cout &lt;&lt;"请输入所用磁盘调度的算法： "; cin &gt;&gt; s; if(s &lt; 1 || s &gt; 4) &#123; cout &lt;&lt;"输入有误，请重新输入！\n"; goto serve; &#125; work: for(int i = 0;i &lt; n; ++i) p[i] = b[i]; if(s == 1) FCFS(); else if(s == 2) SSTF(); else if(s == 3) SCAN(); else CSCAN(); show(); xend: char ch; cout &lt;&lt;"重新选择算法或重新输入数据？（输入Y选择算法，输入y重新输入数据）: "; cin &gt;&gt; ch; if(ch == 'Y') goto serve; else if(ch == 'y') goto xbegin; else cout &lt;&lt;"程序结束，谢谢使用！\n"; return 0;&#125; https://www.shiyanlou.com/courses/115 进程调度就绪队列改变-&gt;重新调度进程调度的时机4个：1.进程正常/错误终止2.创建新进程/等待进程-&gt;就绪3.进程从运行-&gt;阻塞（等待）4.进程从运行-&gt;就绪（时间片到）重新调度的时机：内核对 【中断/陷入（异常）/系统调用】等处理之后【返回用户态】需要重新调度。 调度程序从就绪队列里选择进程可以是刚刚被暂停的，也可以是新的进程，新的就发生进程切换。新的进程上cpu要用自己的地址空间 高速缓存：刚才执行进程的指令和数据TLB存放了进程的页表表项 新的进程的指令、数据、表项也要放入高速缓存和TLB 调度算法 FC: Fibre Channel集群的磁盘阵列通过驱动接口同步磁盘块 1.获得linux文件的访问次数2.获得文件和磁盘块的映射 银行家算法https://blog.csdn.net/yaopeng_2005/article/details/6935235条件：1.固定进程数2.每个进程预先申请最大需要资源数量3.不能申请比系统可用资源总数还多的资源4.进程等待资源时间有限5.进程用完会还数据结构：n：进程数m：资源类数量Avaliable[1..m]Max[1..n,1..m]每个进程对某一资源最大需求量Allocation[1..n,1..m]当前进程分配到的 资源Need[1..n,1..m]当前进程还需要多少资源Request[1..n,1..m]本次申请多少资源 系统状态：当前可用资源的数量Work[1..m]=AvailableFinish[1..n]=False//to-do遍历查找进程i：Finish[i]==false&amp;Need[i]&lt;=Work Linux IO模式及 select、poll、epoll详解https://segmentfault.com/a/1190000003063859 为什么要用反码0如果是正数000…00如果是负数100…0-1:原码：10..01-&gt;反码11..10-&gt;补码11…11用反码0-&gt;正数反码是本身000用补码0-&gt;11…1(符号位不变)+1-&gt;0..0 而且符号位可以参与运算。 内核缓冲区？运行时重定位，进程血环根据pcb切换换基地址因为进程在执行时可以换入换出内存，基地址不一样，所以每次找到空闲内存，将空闲基地址写到pcb。每次取出指令放到cpu的IR执行一条指令都要地址翻译：因为执行过程中会有上下文切换，pcb基址放到基址寄存器（cpu)，执行完switch进程时基地址寄存器写回pcb。进程切换，将当前pcb的基地址更新给基址寄存器 程序分段一个程序会将主程序、变量、函数等在内存中是分段存放，都从自己的0地址开始存放。放入内存时是分段放入，这样每一段，比如动态数组、栈可以很方便扩容。所以定位的基地址是 &lt;段号，段内偏移&gt;:move [es:bx],ax段： cs代码寄存器，ds数据寄存器 ss栈寄存器 es扩展段寄存器PCB需要记录每个段的基地址和长度假设cs是0段 GDT表 根据cs查GDT表jmpi0,8操作系统内核的段表是GDT表每个进程的段表是LDT表 流程：1.程序分成多个段，每个段在内存中找到空闲基址2.将基址写到LDT表，LDT表赋给PCB，PC指针设为初始地址，每次执行都查LDT表找物理地址。 管程：一种同步机制用一种数据结构管理共享资源，并且提供一组操作过程 进程与管程：进程只能通过管程提供的过程间接访问管程中的数据结构。 管程是互斥进入的 ！编译器保证(???) 管程通过 条件变量+wait/notify操作解决同步问题。可以让进程/线程在条件变量上 等待（同时释放管程使用权，允许其他线程进入管程），也可以唤醒等待的线程/进程。 多个进程同时在管程里出现：a进入管程，wait并释放，b进入，唤醒a，则同时两个进程。三种解决方案：1.并发pascal：规定唤醒作为管程中最后一个可执行操作-&gt;唤醒完了这个进程就出管程2.Hoare：a（被唤醒的）先执行，b等待 入口等待队列：在管程外等待的 如果进入管程的发现资源不够不能操作（生产者想insert，但是缓冲区(资源)满了)则进程wait进入不同的条件变量队列。释放，并让入口等待队列的进入管程。 后进入的进程p发现资源够了会signal条件变量队列中的进程q。 p唤醒q，p进入紧急等待队列(比入口等待队列优先级高)，q进程从条件变量队列中出来继续执行 条件变量 c链：条件变量队列可以用信号量和pv操作构造管程。用管程解决生产者消费者问题： hoare的缺点：2次额外的进程切换 3.MESA：a等待(本来在条件变量等待，现在在另一个队列等待)，b继续从hoare的signal-&gt;notify notify(x) x是条件变量，x条件变量队列上的进程得到通知，发信号的继续执行。问题：不能保证将来x条件还成立 所以notify的进程上cpu执行还要重新检查条件 用while取代if改进：给条件队列等待+计时器，自动变成就绪态(因为被调度的时候还是会检查条件)改进：broadcast 释放所有等待条件变量的进程 Pthread互斥(lock操作互斥量)同步(wait/signal条件变量)pthread线程库实现条件变量的signal 是mesa管程的语义 进程通信信号量和管程不能多处理器，也不能传大量信息（大数组） 消息传递发送进程准备好消息，但是发送进程只能在自己的地址空间，不能去接收进程的地址空间操作，必须靠操作系统的消息缓冲区。1)发送进程准备好消息，调用send2)内核，操作系统复制消息,将消息放到接受进程pcb消息队列队尾3)接收进程上cpu执行到receive4)陷入内核，操作系统复制消息到接受进程地址空间 用p,v操作实现send原语 共享内存1.物理地址空间映射到2个进程内地址空间2.通过读者写问题的方法解决互斥问题 管道通信PIPE linux，windows常用通信机制 屏障barrier一组线程完成任务到达汇合点再继续 CPU型进程和IO型进程的调度IO型进程让出CPU进入等待队列，从等待-&gt;就绪不是进入原来的就绪队列，而是进入辅助队列。调度算法首先从辅助队列里选择进程，直到辅助队列为空，去就绪队列选进程。 磁盘IO的代价主要是查找时间（磁头找到柱面）减少磁头查找的时间就把数据放在同一个盘块里。b树每个节点（关键字个数）不超过一个磁盘块。中序遍历扫库每次查找关键字，从树根读一个节点到内存，直到找到，层数就是读入内存的次数。内存查找是有序表包含n个关键字，高度为h（树根为0）,最小度数为t的B树 $ h&lt; log_t{(n+1)/2} $ 树根2只有2个孩子 B+树只要遍历叶子节点就能实现整棵树的遍历。 VSAM虚拟存储存取法。支持range-query。B*树，非叶子节点加上了兄弟指针。 R树，多维B树，解决经纬度查询。Minimal Bounding Rectangle算法。从叶子节点开始表示一个空间，越往上表示的空间越大。 并行和并发的区别并发：进程的执行是间断的。并行parallelism是并发concurrency的特例/子集。并发是一种逻辑结构的设计模式。并发是指逻辑上可以并行，并行是物理运行状态。编写一个多线程/进程的并发程序，没有多核处理器就不能并行。并行的两个进程一定是并发的。 文件/网络句柄handle 所有进程共有进程是容器 进程无法共享内存，通信通过TCP/IP端口实现/其它操作系统的方案线程：没有独立的地址空间，栈线程：PC指向进程的内存缓冲区溢出：用户名过长没有判断就放进内存，写入程序的内存部分TLS：Thread local strategy 线程的独立内存 虚拟内存 缺页中断MMU访问虚拟内存时，这页虚拟内存还没有分配物理内存。向cpu发出缺页中断。cpu初始化物理页的内容分配，在进程页表添加映射。int n = *p当p所指向的地址在虚拟内存中，不是将p的值复制给内存，而是将p所在的虚拟内存的分页放入物理内存 内存虚拟化方案 影子页表(shadow Page Table) VMM(KVM)在宿主机内核中保存 虚拟机虚拟地址到宿主机物理地址。代价在于保持影子页表和虚拟机页表同步 EPT两次页表查找 不用同步。 可执行文件格式通过file 查看文件类型 进程的虚地址空间C语言指针的大小位数与虚拟空间的位数相同0x000000000062FE44123456#include&lt;stdio.h&gt;int main()&#123; int i =0; int *p = &amp;i; printf("0x%p",p); return 0;&#125; 进程访问了非法地址windows”进程因非法操作需要关闭”，linux “Segmentation fault” Linux内存布局windows默认将高2G分配给内核.Linux默认1G栈：函数调用上下文可执行文件映像 装载器共享库 装载地址在linux2.6挪到了靠近栈的0xbfxxxxxx 栈ulimit –s 8Mesp栈顶 esb活动记录（帧指针(frame pointer))不随函数执行变化，用于定位数据，函数返回时恢复 设置好ebp esp栈指针后 开辟栈空间，保存ebx（基地址(base)寄存器） esi, edi（源/目标索引寄存器”(source/destination index)）三个寄存器 将开辟出的空间初始化为0xCC 通过eax（累加器”(accumulator)）返回 恢复5个寄存器 ret返回 ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。 1int main()&#123;char p[12];&#125; 0xCCCC（即两个连续排列的0xCC）的汉字编码就是烫，所以0xCCCC如果被当作文本就是“烫”。如果一个指针变量的值是0xCCCCCCCC就是没初始化 堆原因：1.栈上数据在函数返回时被释放，无法将数据传递函数外。2.全局变量无法动态产生。 malloc的实现程序向操作系统申请堆空间，由程序运行库自己管理。linux两种堆空间分配的系统调用 int brk(void* end_data_segment) 设置进程数据段的结束地址, mmap()与windows的VirtualAlloc相似 起始地址和大小必须是系统页的整数倍 1void *mmp(void *start,size_t length,int prot,int flags,int fd,off_t offset); flag映射类型（文件映射/匿名映射） 匿名映射可以作为堆空间小于128k会在现有堆空间中分配，大于则使用mmap申请匿名空间 用mmap实现malloc12345void *malloc(size_t nbytes)&#123; void* ret = mmap(0,nbytes,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,0,0);//可读可写，匿名 if(ret == MAP_FAILED)return 0; return ret;&#125; mmap申请空间不能超过 空闲内存+空闲swap空间 windows 虚拟地址空间虚拟地址空间windows 每个线程默认栈大小1MNTDLL.DLL堆管理器APIwindows的堆不是向上增长 堆分配算法 空闲链表pre,next并有4个字节存储大小 位图，划分成大小相同的块。用2位11表示head，10表示body，00表示空闲 int32个字节，2个字节表示一个块的状态，假设1M堆，一块128字节=&gt;1M/128=8K个块 8K/(32/2)=512个int的数组存储 Head表示已分配区的头 对象池 io指令至少是没io的10^6倍并发：一个cpu上程序交替执行只有一个cpu只能执行一个进程进程：运行中的程序 内存原理 cpp返回对象的临时对象 输出： 经过了两次构造函数1次拷贝到栈上临时对象，1次拷贝到返回值ctor（create）ctorbefore return //已经被优化了，本来之后会输出copy ctoroperator=dtordtor（销毁）展开代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct cpp_obj&#123; cpp_obj()&#123; cout&lt;&lt;"ctor\n"; &#125; cpp_obj(const cpp_obj&amp; c)&#123; cout&lt;&lt;"copy ctor\n"; &#125; cpp_obj&amp; operator=(const cpp_obj&amp; rhs)&#123; cout&lt;&lt;"operator=\n"; return *this; &#125; ~cpp_obj()&#123; cout&lt;&lt;"dtor\n"; &#125;&#125;;cpp_obj return_test()&#123; cpp_obj b; cout&lt;&lt;"before return\n"; return b; //return cpp_obj() &#125;int main()&#123; cpp_obj n; n = return_test(); return 0;&#125; 汇编寄存器 gcc hellow.c -&gt;./a.out 预编译：gcc -E .\bigthingg.c -o .\bigthingg.i 展开宏 编译：链接生成汇编 gcc -S hello.i -o hello.s 汇编gcc -c hello.s -o hello.o 链接ld….64位汇编寄存器 虚拟内存CPU通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、IO设备等等，但从CPU发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由MMU将虚拟地址转换成物理地址再从地址总线上发出.CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。虚拟内存空间被组织为一个存放在硬盘上的M个连续的字节大小的单元组成的数组。页表是一个元素为页表条目（Page Table Entry, PTE）的集合，有效位代表这个虚拟页是否被缓存在物理内存中。处理缺页异常do_page_fault() inode文件读取磁盘的最小单位是多个扇区sector组成的 块block。一般4kb,8个sectorinode：文件系统的数据结构，文件元信息查看inodestat example.txt 系统调用、POSIX、C库、系统命令和内核函数 POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准基于UNIX的可移植 操作系统标准 内核提供的每个系统调用在C库中都具有相应的封装函数。 比如malloc函数和free函数都是通过brk系统调用来扩大或缩小进程的堆栈，execl、execlp、execle、 execv、execvp和execve函数都是通过execve系统调用来执行一个可执行文件。-系统命令位于C库的更上层，是利用C库实现的可执行程序，比如最为常用的ls、cd等命令。$trace pwd pwd调用了那些系统调用 2类寄存器：用户可见/控制和状态 寄存器 ？？3种I/O操作技术：可编程：处理器忙；中断驱动：；直接存储访问DMA 空间局部性 ： 更大的缓冲块，存储器控制逻辑+预处理 多道： 交错进程 进程状态： 执行上下文； 操作系统信息不允许被进程直接访问 上下文包括操作系统管理进程以及处理器正确执行进程所需要的所有信息，包括各种处理器寄存器的内容，如程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级以及进程是否在等待特定I/O事件的完成。 虚地址指的是存在于虚拟内存中的地址，它有时候在磁盘中有时候在主存中。 实地址指的是主存中的地址。 ??单体内核和微内核 os维护信息表： 内存,I/O,文件，进程 进程控制块：标识，？？处理器状态，进程控制信息 陷阱： 当面进程的错误or异常 中断例子： 时钟，I/O，内存失效 线程模式切换：？包含状态信息少 第4章 线程、对称多处理和微内核第7章 内存管理 内存管理 ： 重定位进程-&gt;就绪进程池-&gt;处理器利用率 运行时内存保护 进程共享内存 内部碎片、外部碎片：数据&lt;分区-&gt;浪费；？动态分区，分区外存储空间变多。 页： 进程和磁盘划分块；帧：主存划分块；一页装入一帧。 段： 长度可变 第8章 虚拟内存第10章 多处理器和实时调度第11章 I/O管理和磁盘调度]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown Syntax]]></title>
    <url>%2F2018%2F03%2F03%2Fmarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[网页字体颜色浅红色文字：浅红色文字：blah blah blah Content (md partial supported)]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Vue&JS]]></title>
    <url>%2F2018%2F03%2F03%2FAbout-Vue%2F</url>
    <content type="text"><![CDATA[123app.$watch("text",(newV,oldV)=&gt;&#123; console.log(`$&#123;newV&#125;,``)&#125; value、selected、checked默认情况下会被忽略 data是函数因为这样多次引用一个组件都创建新的的data实例 钩子函数create在 data初始化后调用，this指向vm，专门用来发送ajax axios基于promise1root["axios"] = factory(); axios挂在window上 promise 回调函数：将【后续】处理逻辑传入当前函数，当前事件完成后自动执行 12345678let a = ''function buy(callback) &#123; setTimeout(()=&gt;&#123; a="蘑菇" callback(a) &#125;,2000)&#125;buy((val)=&gt;&#123;console.log(val)&#125;) promise的三个状态：等待-&gt;成功/失败 12//ES6.JSfunction Promise(executor) &#123;&#125; 传入一个执行函数1Promise.prototype.then = function(onFulfilled,onRejected) &#123;&#125;; 不用传入回调函数，自动把值传入回调函数123456789101112131415function buyPack() &#123; //回调（成功函数，失败函数） return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5)&#123; resolve('买') &#125;else&#123; reject('不买') &#125; &#125;,1000); &#125;)&#125;//then(成功函数，失败函数)buyPack().then((data)=&gt;&#123;console.log(data);&#125;, (data)=&gt;console.log(data)) promise解决异步ajax 4步实现ajax 12345678910function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// 相当于readState=4 //防止404还是要： if（xhr.status==200） &#125; xhr.send()&#125;ajax(&#123;url:'./.json'&#125;).then 使用Promise 1234567891011121314151617function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// h5的新方法，等于xhr.readState=4 xhr.status=200 resolve(xhr.response) &#125;; xhr.onerror = function(err)&#123; reject(err) &#125; xhr.send() &#125;)&#125;ajax(&#123;url:'http://localhost:8089/getUser'&#125;).then( (res)=&gt;&#123;console.log(res)&#125;, (err)=&gt;&#123;console.log(err)&#125;) fetch完全基于promiseasync await 异步的终极解决方案 call和apply的区别是apply第2个参数传数组 var vm = new Vue({el:&#39;#app&#39;})给body加#app表示body里面的dom都是vue的管理区域 弹窗效果=两个div嵌套，遮罩div width整个屏幕，显示在所有图层上，现在body最上或最上，v-if=&quot;!modal.show v-on:click=&quot;modal.show=!modal.show&quot; ready:function(){this.getData()}与methods\data同级，对象加载好执行 ,this.methods中的方法（ajax请求更新data） getData函数中的reqwest函数中的this已经不是实例本身了，取不到data数据，指的是窗口12345678910111213methods:&#123; var self = this getData:function()&#123; reqwest(&#123; url: type: method: success:function(resp)&#123; self.comments = resp.results &#125; &#125;) &#125;&#125; computed：与methods写法基本相同，有缓存并且可以绑定数据class=&quot;&quot; 12345678computed:&#123; loadingOrNot:function()&#123; if(this.comments.length==0)return 'loading' &#125;else&#123; return "" &#125; &#125;&#125; [1,2,3].filter(isBigEnough)在computed中写过滤、验证表单 1234567filterdList:function()&#123; function useRuler(people)&#123; return people.heigh&gt;100 &#125; var newList = this.comments.filter(useRuler) return newList&#125; RESTful API PUT修改已有的某个资源 get是查 post增 返回响应码：201：删除、修改、创建成功； 400：失败 tokencookie.js token认证不能在加data里1234567891011getDate:function()&#123; var self = this reqwest(&#123; url: type:'json', headers:Cookies.get&#123;'token'&#125;?&#123;'Authorization':'Token '+Cookies.get('token')&#125;:&#123;&#125; success:function(resp)&#123; &#125; &#125;)&#125; vue难点 $emit() this.$nextTick() directive 自定义指令 vuex难点dom上的行间属性1234567891011121314// 注册Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') minxins 混入123456789101112131415161718// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; "hello from mixin!" vue123var message = ` hello $&#123;name&#125;! the answer is $&#123;40+2&#125;`.toUperCase() :root 选择器匹配文档根元素。 响应式布局@media screen and (min-width: 768px)@media 的媒介查询方式根据屏幕尺寸判断手机端还是PC端 不用history模式路径会有#（hasj模式）history.pushState API完成URL跳转不需要重新加载页面 微信history push注意 npm 缺少python2.7npm pythonnpm –add-python-to-path=’true’ –debug install –global windows-build-tools Weex 适配750px， 缩略 border，background 定位： 不支持z-index ，Android的overflow为hidden 渐变：不支持 radial-gradient；box-shadow只支持ios border-top-left-radius可以，安卓不可以 所有元素默认display:flex Ajax readyState 0-4请求初始化 服务器连接已建立 请求已接收 请求处理中 请求已完成request.onreadystatechange=function(){ } post 要用Content-Type：application/x-www-form-urlencoded9 post 参数用&amp;隔开 data=”name=” .value+”&amp;number=” ; request.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”) request.send(data) request.responseText请求参数：Request Payload eval 解析json字符串 eval(‘(‘+json+”)”); eval 中 值为alert() 会被执行Json.parse(request.responseText)JSONLint 格式化校验工具标记约定 “success”:true 产生跨域 localhost-&gt;127.0.0.1 方法1： 代理 后台 JSONP解决get请求跨域访问 dataType:”json”-&gt;”jsonp” jsonp:”参数名” 后台约定 H5 XHR2 “Access-Control-Allow-Oringin：*””Navigator Chrome浏览器信息 navigator.appVersion 用userAgent判断什么浏览器123navigatior.userAgent.indexOf("Chrome")&gt;-1//IE(8-10)indexOf("MSIE") Screen 对象screen.width/.height一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 元素尺寸var w= document.documentElement.clientWidth|| document.body.clientWidth; var h= document.documentElement.clientHeight|| document.body.clientHeight; scrollTop 可见内容相对顶部高度 offsetTop相对与页面的位置]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Java]]></title>
    <url>%2F2018%2F03%2F02%2FAbout-Java%2F</url>
    <content type="text"><![CDATA[forEach 反编译是迭代器modCount在线程不安全的迭代器里会抛异常UnsupportedOperationException 从Arrays.asList()转化过来的List的不支持add()和remove()方法，这是由于从Arrays.asList()返回的是返回java.util.Arrays$ArrayList，而不是ArrayList。Arrays$ArrayList和ArrayList都是继承AbstractList，add() 和remove()等方法在AbstractList中默认throw UnsupportedOperationException而不做任何操作。ArrayList重写这些方法对List进行操作，而Arrays$ArrayList却没有重写add()和 remove()等方法，所以对从Arrays.asList()转化过来的List进行add()和remove()会出现UnsupportedOperationException异常。 Arrays.asList返回的是Arrays的内部类java.util.Arrays.ArrayList 该类继承了AbstractList但是并没有实现所有的方法，和java.util.ArrayList还是有区别的。 AbstractList的add方法： res.add(new ArrayList&lt;&gt;(Arrays.asList(num[i],num[lo],num[hi]))); 求int[]最大值的正确写法int maxa = Arrays.stream(arr).max().getAsInt(); List remove的index不能是Integer12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; String的字典序比较展开代码 123456789101112131415161718192021222324252627/** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The result is * a negative integer if this &#123;@code String&#125; object * lexicographically precedes the argument string. */public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; replace和replaceAll都是全部替换1234567891011121314151617181920public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement);&#125;/** * Replaces each substring of this string that matches the literal target * sequence with the specified literal replacement sequence. The * replacement proceeds from the beginning of the string to the end, for * example, replacing "aa" with "b" in the string "aaa" will result in * "ba" rather than "ab". * * @param target The sequence of char values to be replaced * @param replacement The replacement sequence of char values * @return The resulting string * @since 1.5 */public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString()));&#125; hashset的实现static final 静态类对象 所有实例共享 12345678910111213private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 二进制System.out.println(0b101);//二进制:5 （0b开头的）System.out.println(011); //八进制9 List&lt;String&gt; 2 String[] [Ljava.lang.Object; cannot be cast to [Ljava.lang.String; rst.toArray(new String[rst.size()]); http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html 二维数组clone1234this.mat = new int[matrix.length][]; for (int i = 0; i &lt; matrix.length; i++) &#123; this.mat[i] = matrix[i].clone(); &#125; ThreadLocalTimer对象头8字节前4保存对象hash(3)，锁状态(1)后4存储对象所属类的引用。 数组还有4字节保存数组大小。 java内存https://algs4.cs.princeton.edu/14analysis/http://yueyemaitian.iteye.com/blog/2034305https://blog.csdn.net/zhxdick/article/details/52003123 objectobject overhead 16+int 4 padded到4的倍数(-XX:-UseCompressedOops:)如果用压缩则-XX:+UseCompressedOops: mark/4 + metedata/8 + 4 = 16默认是启动压缩的 Objects. To determine the memory usage of an object, we add the amount of memory used by each instance variable to the overhead associated with each object, typically 16 bytes. Moreover, the memory usage is typically padded to be a multiple of 8 bytes (on a 64-bit machine). paddingThis can waste some memory but it speeds up memory access and garbage collection. reference// todo引用类型是内存地址，8字节2*ref(8)+enclosing(8)+16head = 40非静态有encolsing instance？指针的大小在bit模式下或64bit开启指针压缩下默认为4byte UseCompressOops开启和关闭，对对象头大小是有影响的，开启压缩，对象头是4+8=12byte；关闭压缩，对象头是8+8=16bytes。java -Xmx31g -XX:+PrintFlagsFinal |findstr Compress123uintx CompressedClassSpaceSize = 1073741824 &#123;product&#125;bool UseCompressedClassPointers := true &#123;lp64_product&#125;bool UseCompressedOops := true &#123;lp64_product&#125; References. A reference to an object typically is a memory address and thus uses 8 bytes of memory (on a 64-bit machine). arrays Arrays. Arrays in Java are implemented as objects, typically with extra overhead for the length. An array of primitive-type values typically requires 24 bytes of header information (16 bytes of object overhead, 4 bytes for the length, and 4 bytes of padding) plus the memory needed to store the values. 基本类型 16的obj head+4(len)+4padding = 24 +存的类型*长度 stringchar[] ref(8)+int(4)+head(16)+padding-&gt;32+char)=56+2N 打印整数的二进制表示0x8000000 表示100000…0 123456int a = -6;for(int i =0;i&lt;32;i++)&#123; //取第一位，右移 int t = (a&amp;0x8000000&gt;&gt;&gt;i)&gt;&gt;&gt;(31-i); out(t);&#125; System.exit结束一个jvm。 状态0是正常退出123//非零是异常by convention, a nonzero status code indicates abnormal termination.public static void exit(int status) forEach： ConcurrentModificationException报错代码：123456for(List&lt;Integer&gt; list :subsets) &#123; List&lt;Integer&gt; before = new ArrayList&lt;&gt;(list); before.add(i); //subsets的大小在不断增加！终止不了 subsets.add(before);&#125; at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。 在使用迭代器遍历的时候，如果使用ArrayList中的remove(int index) remove(Object o) remove(int fromIndex ,int toIndex) add等方法的时候都会修改modCount，在迭代的时候需要保持单线程的唯一操作，如果期间进行了插入或者删除，就会被迭代器检查获知，从而出现运行时异常 被动加载和主动加载final static List menu = Arrays.asList{}import static A.menu;A类不会被初始化 不会占用任何内存去掉final变成主动加载 位运算取模只要5个CPU周期 %至少26个CPU周期Character 内部静态类做cache 1234567891011121314private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; 2.123int digit(char ch, int radix) &#123; return digit((int)ch, radix);&#125; 当radix基数大于传入的数字，返回-1，只能传入小于radix的数字 @FunctionalInterface适合用lambda表达式 JIN123456System.loadLibrary("NativeMath");//中的sqrt c++实现#include&lt;math.h&gt;JNIEXPORT jdouble JNICALL Java_包名_sqrt(JNIEnv *env,jobject obj,jdouble value)&#123; return sqrt(value);&#125; 回调(控制反转)与代理回调:展开代码 123456789101112131415161718192021222324interface ICallBack&#123; public void callBack();&#125;class Caller&#123; public void call(ICallBack callBack)&#123; System.out.println("start"); callBack.callBack(); System.out.println("end"); &#125;&#125;public class callbackk &#123; public static void main(String[] args) &#123; Caller call = new Caller(); call.call(new ICallBack() &#123; @Override public void callBack() &#123; System.out.println("这个叫回调"); &#125; &#125;); &#125; &#125; 线程Thread是回调者，Runnable回调接口12345new Thread(new Runnable()&#123; @Override public void run()&#123; &#125;&#125;).start(); 观察者模式/回调函数 事件处理机制RPC基于TCP/IP的会话层协议set的contain时间复杂度是O(1),list的contain时间复杂度是O(n)chrome的source根据域名不同存放资源 可以打断点调试 丢失精度一定要用BigDecimal的string构造器devide(b,2,BigDecimal.Round_HALF_UP)保留两位小数四舍五入guaga:String-&gt;listSplitter.on(&quot;,&quot;).splitToList(&quot;a,b,c&quot;); simditor1.8中文API 全文搜索引擎Lucene Charactor.isLetterOrDigit()MD5增加复杂度saltUUID重置密码之前：验证完密码问题则写入token123String Token = UUID.randomUUID().toString();//放入本地缓存 防止空，放个前缀`token_`TokenCache.setKey("token_"+username,forgetToken); 生成的是一个永远不会重复的字符串把token放到本地cache中设置有效期 Guava中的本地缓存LoadingCache调用链模式没有顺序1234567891011121314151617181920212223242526//TokenCache::private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder() .initialCapacity(1000)//缓存的初始化容量1000 .maximumSize(10000)//缓存的最大容量，超过则会使用LRU（最少使用）算法移除 .expireAfterAccess(12,TimeUnit.HOURS)//有效期12个小时 .build(new CacheLoader&lt;String,String&gt;()&#123; //默认数据加载，调用get时，key没有命中，则调用这个 @Override public String load(String s) throws Exception&#123; //防空指针 return "null"; &#125; &#125;);public static void setKey(String key,String value)&#123; localCache.put(key,value);&#125;public static String getKey(String key)&#123; String value = null; try&#123; value = localCache.get(key); if("null".equals(value))return null; return value; &#125;catch (...)&#123;&#125; return null;&#125; joda.time字符串-&gt;Date()123DateTimeFormatter df = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");DateTime dt = df.parseDateTime("2015-04-20 2:2:2");return dt.toDate(); StringUtils.isBlank(&quot; &quot;)true CollectionUtils.isEmpty(List)枚举：限制取值 封装响应编码ResponseCode扩展的时候加枚举对象123456789101112131415161718public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 用法 在response对象里：12345@JsonIgnorepublic boolean isSuccess()&#123; //0 return this.status== ResponseCode.SUCCESS.getCode();&#125; 1234567enum color&#123; //枚举的3个实例化对象 外部不允许定义新的color对象 green,red,yellow&#125;color coenum;coenum = color.red;color[] values = color.values(); EnumSet1EnumSet&lt;color&gt; set = EnumSet.allOf(color.class); EnumMap&lt;color,String&gt;12EnumMap&lt;color,String&gt; map = new EnumMap&lt;color, String&gt;(color.class);map.put(color.red,"red"); 构造方法（私有）1234567891011enum Color&#123; red(10),green(20),yellow; private int color; private Color()&#123; System.out.println("无参构造器"); &#125; private Color(int color)&#123; this.color = color; System.out.println("有参构造器"+color); &#125;&#125; 当用Color.red时，会调用3次构造器创建red,green,yellow三个对象 实现接口添加方法12345public int getColor()&#123; return color;&#125;//输出0 Color.red.getColor输出10Color.yellow.getColor(); 也可以单独定义方法 添加抽象方法，每个对象要都实现.getBytes(&#39;iso8859-1&#39;)以iso编码读new String(,&quot;gb2312&quot;)静态代码块：用staitc声明，jvm加载类时执行，仅执行一次 printf(&quot;%n&quot;)总是输出正确的平台特定行分隔符，所以它是跨平台的 内部类 方法内部类只能在方法内实例化，并且不能使用方法内的非final变量方法结束局部变量弹栈，但内部类对象可能需要对象回收 比方法生命周期长。用final在类加载会放入常量池，jdk1.8开始不需要final 编译器自动final，所以不能改变 静态内部类 能使用外部类的静态成员和方法 不用new外部类也能访问 使用内部类可以使用多继承 优先选择静态内部类(防止内存泄漏) 原因：因为java里传参是传值在里面引用外面的参数，外面的参数不应该被修改。不然里面变量和外面变量就会有二义性。如果是传引用两个会同时修改不会有二义性 适配器安卓开发中常用，用A接口的子类转换B接口的子类 代理模式与AOP与模板方法不同：代理是控制对象 模板是延迟到子类定义操作，定义骨架 工厂模式 依赖注入策略模式和依赖倒置原则（面向接口编程）模板方法（设计模式） 权限管理 算法骨架不改变算法的结构，重新定义算法的特定步骤展开代码 1234567891011121314151617181920212223242526package javacoretest;abstract class BaseManager&#123; public void action(String username,String method)&#123; if("admin".equals(username))&#123; execute(method); &#125; else&#123; System.out.println("没有权限"); &#125; &#125; public abstract void execute(String Method);&#125;//延迟到子类实现ClassManager...子类有不同的实现class UserManager extends BaseManager&#123; @Override public void execute(String method)&#123; if("add".equals(method)) System.out.println("添加"); else if("del".equals(method)) System.out.println("删除"); &#125;&#125;public class Templete &#123; public static void main(String[] args) &#123; UserManager um = new UserManager(); um.action("admin","add"); &#125;&#125; MD5密码处理展开代码 1234567891011121314151617181920212223242526272829303132import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class MD5demo &#123; //数据库 所以密码只能重置不能查看 private static String savePassWord ="pmq7VoTEWWLYh1ZPCDRujQ=="; public static void main(String[] args) &#123; System.out.println(login("admin123456")); &#125; private static boolean login(String password)&#123; if(savePassWord.equals(md5(password)))&#123; return true; &#125;else &#123; return false; &#125; &#125; private static String md5(String password)&#123; try &#123; MessageDigest md = MessageDigest.getInstance("md5"); byte[] bytes = md.digest(password.getBytes("UTF-8")); String str = Base64.getEncoder().encodeToString(bytes); return str; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 位运算应用 判断奇偶：a&amp;1 = 0 偶数 a&amp;1 = 1 奇数 取模a &amp; (2^n - 1) 12System.out.println(999999&amp;7);System.out.println(999999%8);//相等 &amp;00001111是取get后4位 |00001111是set后4位为1 ^00001111是翻转后4位 java8时间LocalDate LocalTime LocalDateTime 国际化ResourceBundle simpledateformat??? 抗锯齿 异常e.getMassage()printStackTrace();调用堆栈 char 和 byte c++的char 8位，1字节。无byte。typedef unsigned char byte; java byte 静态方法没有this引用 包：保证类名的唯一性 工厂方法：返回一个类的新实例的静态方法 数组用Arraylist 因为内部管理数组，自动创建内部数组转移元素 扩容。 泛型类，自动装箱、自动拆箱 new ArrayList&lt;&gt;(Arrays.asList()) //[]-&gt;ArrayList asList固定长度 不支持add 输入输出 int.next() 读取空格分割的单词 ？？？？？读取密码用Console javaw runs Java code without association with current terminal/console (which is useful for GUI applications),there is no associated console window System.console() returns null.空指针异常 格式化字符串 System.out.printf(“%8.2f”,1000.0/3.0); (Integer).intValue() Object.clone()protected native Object clone() throws CloneNotSupportedException;浅拷贝，子类只能调用被保护的clone自己 Cloneable接口是空的。 实现了Cloneable只是标识 惯例重写Object.clone() 定义成public 1public A clone() throws CloneNotSupportedException 在没有实现Cloneable接口的实例上调用Object的clone方法会导致引发异常CloneNotSupportedException。 标记接口（tagging interface): 空的。使用目的：可以用instanceof Cloneable检查 ??enum toString的逆方法是valueOf super不是对象的引用。不能赋值给对象变量，是只是编译器调用超类方法的关键字 sout(char[]) √ char数组的打印有点特殊，int数组打印是打印出来一个地址，而char数组是打印数组里的内容。 如果重写了equals方法，请一并重写hashCode方法 重写类的equals方法-&gt;支持List 重写+hashCode方法-&gt;支持Set(HashMap,HashSet,LinkedHashMap,ConcurrentHashMap) (obj instanceof Person) 8种基本类型，其它都是对象（引用类型）-&gt; 包装类型 整型 byte short int long 浮点 float double 字符型 char 逻辑型 boolean 方法体里声明的基本数据类型在栈内存里 基本数据类型来说，赋值（=号）就相当于拷贝了一份值 当执行到new这个关键字，会在堆内存分配内存空间，并把该内存空间的地址赋值给arr1 注解 @interface元注解 注解只有一个成员，成员必须取名value（） 没有成员 标识注解 @Target（{}）作用域 @Retention（）生命周期 @Inherited 允许继承 Thread线程共享 *代码和数据空间线程由独立的运行栈和*程序计数器 线程的概念模型 虚拟cpu，在THREAD类中 将代码和数据传给thread类 线程体方法run()中的代码 构造线程的方法 定义线程类，重写run方法，通过start启动 12345678publc class FactorialThreadTester&#123; public static void main(String[] args)&#123; System.out.println("main thread starts"); FactorialThread thread = new FactorialThread(10); thread.start(); System.out.println("main thread ends"); &#125; &#125; runable 主方法main中创建一个新线程会等main执行完后再new 互斥锁 保证同一时刻有且只有一个线程在操作共享数据 解决端口占用123netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80 tasklist | findstr 2000 //端口号taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。 忽略序列化private transient String passwd;生命周期仅存于调用者的内存中而不会写到磁盘里持久化 final变量经常和static关键字一起使用，作为常量 final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写，只能被继承 final的类无法被继承 public void setLength(final int size)表示不能修改size的值 。对象则不能改变引用 类不能多继承，抽象类的方法可以不实现接口可以多继承 InterruptedException: 如何使HashMap线程安全的123Map&lt;,&gt; ht = new Hashtable&lt;&gt;();Map&lt;,&gt; sy = new Collections.synchronizedMap(new HashMap&lt;,&gt;())Map&lt;,&gt; concurr = new ConcurrentHashMap&lt;&gt;(); CHM（ConcurrentHashMap)性能最佳* Hashtable使用public synchronized阻塞，保证线程安全 .mf 是bean的JAR清单 迭代文件1234try(DirectoryStream&lt;Path&gt; entries = files.newDirectoryStream(dir))&#123; for(Path entry : entries)&#123; &#125;&#125; Map的方法put putAll 1@Native public static final int MAX_VALUE = 0x7fffffff; 0x7fffffff是补码表示的Integer的最小值(-2^31)和最大值(2^31-1),int是4字节。 String内部是通过char数组表示，数组的长度在Java中限制为一个int型所能表示的最大值 最小值 Math.min(,) substring(,)前闭后开 in-place 原地算法 删除重复元素 用!=略过并用unique的覆盖]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
