<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[dockermysql]]></title>
    <url>%2F2018%2F07%2F05%2Fdockermysql%2F</url>
    <content type="text"><![CDATA[redis 高速缓存集群docker mysql集群PXC防火墙? 拉镜像 12docker pull percona/percona-xtradb-clusterdocker load &lt;pxc.tar.gz 改名 123docker imagesdocker tag docker.io/precona/percona-xtradb-cluster pxcdocker rmi docker.io/precona/percona-xtradb-cluster 创建容器要先划分Docker内部网段 docker自带的是172.17.0.x 123docker network create net1 / docker network create --subnet=172.18.0.0/24 net1docker network insepct net1docker network rm net1 业务数据映射到宿主机，pxc不能直接用目录映射要用docker卷 123docker volume create v1docer inspect v1 #//var/lib/docker/volumes/v1/_datadocker volume rm v1 创建pxc容器 -d 后台运行 -t 交互界面 -p 端口映射 -v 路径映射 -e 启动参数 XTRABACKUP_PASSWORD=abc123456 数据库同步用的密码 --preivileged 最高权限 --ip 内部网段中分到的ip地址 注意：容器创建很快，但是mysql初始化可能要2min以上，能连接到一个后再创建第二个 123456789docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxcdocker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxcdocker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxcdocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc 6.用navicat连接5个数据库在db1create schema test1; 刷新，其他节点也更新了。 负载均衡 Haproxy请求转发器nginx 支持http协议负载均衡，最近才支持TCP/IPhaproxy配置 docker pull haproxy 在宿主机创建配置文件mkdir /home/soft/haproxy/touch /home/soft/haproxy/haproxy.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657global #工作目录 chroot /usr/local/etc/haproxy #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info log 127.0.0.1 local5 info #守护进程运行 daemondefaults log global mode http #日志格式 option httplog #日志中不记录负载均衡的心跳检测记录 option dontlognull #连接超时（毫秒） timeout connect 5000 #客户端超时（毫秒） timeout client 50000 #服务器超时（毫秒） timeout server 50000#监控界面 listen admin_stats #监控界面的访问的IP和端口 bind 0.0.0.0:8888 #访问协议 mode http #URI相对地址 stats uri /dbs #统计报告格式 stats realm Global\ statistics #登陆帐户信息 stats auth admin:abc123456#数据库负载均衡listen proxy-mysql #访问的IP和端口 bind 0.0.0.0:3306 #网络协议 mode tcp #负载均衡算法（轮询算法） #轮询算法：roundrobin #权重算法：static-rr #最少连接算法：leastconn #请求源IP算法：source balance roundrobin #日志格式 option tcplog #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测 option mysql-check user haproxy server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000 server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000 server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 server MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000 server MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000 #使用keepalive检测死链 option tcpka bind 0.0.0.0:3306 表示任何ip地址都可以访问3306端口如果有应用向3306端口发数据库请求，会被转发给具体的pxc数据库实例 haroxy 端口3306 映射到宿主机4002 ，后台监控8888映射到4001可以手动分配haroxy的ip地址，docker也会自动分配 123docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 haproxy 进入容器 12docker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg 在mysql创建haproxy用户 haproxy中间件用这个账号登陆数据库，发心跳检测%表示ip都可以用这个账号登陆mysql数据库 密码为空 1create user 'haproxy'@'%' identified by ''; 登陆 http://192.168.3.109:4001/dbs 看监控画面docker stop node1可以看到MySQL_1变红色用navicat连接haproxy192.168.3.109:4002 root:abc123456向haproxy使用的sql都会均匀分发给真实的mysql实例，然后同步 haproxy双机热备 虚拟ip linux一个网卡可以定义多个ip地址，可以把ip地址分配给对应的程序在两个haproxy容器中部署keepalived抢占一个虚拟ip172.18.0.15,抢到的叫主服务器，没抢到的叫备服务器，有心跳检测，检测到主服务器挂了就抢占ip1.1. 进入容器docker exec -it h1 bashharpoxy是用Ubuntu创建的 所以要用apt-getapt-get update #可能要换源 安装vim 不是viapt-get install keepalived 1.2. keepalived配置文件/etc/keepalived/keepalived.confstate:MASTER/BACKUP为主/备服务器 抢占虚拟IP,备用不会抢。都master都抢占，没抢到的自动变成salveinterface:虚拟ip写到docker的网卡里,eth0局域网里看不见的，后续虚拟ip映射到局域网的虚拟ipvirtual_router_id：0-255之间 虚拟路由ippriority 权重，优先抢占advert_int:心跳检测间隔authentication 心跳检测的账号密码virtual_ipaddress 虚拟ip 1234567891011121314vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 123456 &#125; virtual_ipaddress &#123; 172.18.0.201 &#125;&#125; 启动keepalived:service keepalived startexit宿主机 ping 172.18.0.201 在宿主机安装keepalived把宿主机ip映射到docker的虚拟ip 展开代码 1234567891011121314151617181920212223242526272829303132333435363738vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.99.150 &#125;&#125;virtual_server 192.168.99.150 8888 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 8888 &#123; weight 1 &#125;&#125;virtual_server 192.168.99.150 3306 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 3306 &#123; weight 1 &#125;&#125; 数据库热备份冷备份mysql dump热备份LVM要锁表 XtraBackup不锁表docker stop/rm node1docker volume create backup 1234docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged -e CLUSTER_JOIN=node2 --name=node1 --net=net1 --ip 172.18.0.2 pxc 全量备份 在PXC容器中安装XtraBackup 1234567docker exec -it --user root node1 bashapt-get updateapt-get install percona-xtrabackup-24innobackupex --user=root --password=abc123456 /data/backup/full#备份在/data/backup/full/2018-07-05_04-54-31/xtrabackup_infoexitdocker inspect backup 恢复 冷还原 1解散PXC集群，2删除节点，3创建新的节点并还原，4创建其他节点，并同步 重建集群 12345678910111213141516171819docker stop node1 node2 node3 node4 node5docker rm node1 node2 node3 node4 node5docker volume rm v1 v2 v3 v4 v5docker volume create v1docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker exec -it node1 bashrm -rf /var/lib/mysql/*innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-07-05_04-54-31innobackupex --user=root --password=abc123456 --copy-back /data/backup/full/2018-07-05_04-54-31exitdocker stop node1docker start node1]]></content>
  </entry>
  <entry>
    <title><![CDATA[java8]]></title>
    <url>%2F2018%2F06%2F06%2Fjava8%2F</url>
    <content type="text"><![CDATA[其它库Guava，Apache Commons Collections ,ambdaj Collector.java接口提供者 the type of input elements to the reduction operation the mutable accumulation type of the reduction operation (often hidden as an implementation detail) the result type of the reduction operation 1234567891011public interface Collector&lt;T, A, R&gt; &#123; //container容器 Supplier&lt;A&gt; supplier(); //操作 BiConsumer&lt;A, T&gt; accumulator(); //并行计算 BinaryOperator&lt;A&gt; combiner(); //返回结果 Function&lt;A, R&gt; finisher(); Set&lt;Characteristics&gt; characteristics();&#125; toList()123456public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123; return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; &#123; left.addAll(right); return left; &#125;, CH_ID);&#125; 1.CH_ID:12static final Set&lt;Collector.Characteristics&gt; CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); 2.Set characteristics();Collecter的特征1234567enum Characteristics &#123;//可以并行处理 CONCURRENT,//一般true 是否保持原来的顺序 UNORDERED, IDENTITY_FINISH&#125; stream().collect()12345678910111213141516public final &lt;R, A&gt; R collect(Collector&lt;? super P_OUT, A, R&gt; collector) &#123; A container; if (isParallel() &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT)) &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123; container = collector.supplier().get(); BiConsumer&lt;A, ? super P_OUT&gt; accumulator = collector.accumulator(); forEach(u -&gt; accumulator.accept(container, u)); &#125; else &#123; container = evaluate(ReduceOps.makeRef(collector)); &#125; return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH) ? (R) container : collector.finisher().apply(container);&#125; .Collectors1..groupingBy(Apple::getColor))1Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType)); 2.计算平均数averaging[Int/Long/Double]都返回&lt;T&gt; Collector&lt;T, ?, Double&gt;1Optional.ofNullable(menu.stream().collect(Collectors.averagingInt(Dish::getCalories))).ifPresent(System.out::println); 3..collectingAndThen附加返回值1Optional.ofNullable(menu.stream().collect(Collectors.collectingAndThen(Collectors.averagingInt(Dish::getCalories),a-&gt;"The ave"+a))).ifPresent(System.out::println); 变成不可变对象1List&lt;Dish&gt; collect = menu.stream().filter(d -&gt; d.getType().equals(Dish.Type.MEAT)).collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); 4.计数12Optional.of(menu.stream().collect(Collectors.counting())).ifPresent(System.out::println);Optional.ofNullable(menu.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.counting()))).ifPresent(System.out::println); 5.转化成TreeMap1TreeMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType, TreeMap::new, Collectors.averagingInt(Dish::getCalories))); 6.Summary12345public class IntSummaryStatistics implements IntConsumer &#123; private long count; private long sum; private int min = Integer.MAX_VALUE; private int max = Integer.MIN_VALUE;&#125; 1IntSummaryStatistics collect = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories)); 7.groupingByConcurrent1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); 8.Collector&lt;CharSequence, ?, String&gt; joining()前面必须是CharSequence类型,join中还可添加delimiter分隔符1String collect = menu.stream().map(Dish::getName).collect(Collectors.joining(",")); 前后加上分隔符joining(“,”,”Names[“,”]”)输出：Names[pork,…,salmon] 另一种mapping方法IDEA会提示可以使用map().collect()1.collect(Collectors.mapping(Dish::getName, Collectors.joining(","))) 9.maxBy/minBy获得卡路里最高的1Optional&lt;Dish&gt; collect = menu.stream().collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories))); 10.partitioningBy1Map&lt;Boolean, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian)); 输出是/不是水果的卡路里平均值{false=530.0, true=387.5}12Map&lt;Boolean, Double&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian, Collectors.averagingDouble(Dish::getCalories))); Optional.ofNullable(collect).ifPresent(System.out::println); 11 .reducing 可以加入map 相当于map(::).reduce(0,(,)-&gt;)1Integer collect = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (d1, d2) -&gt; d1 + d2)); 12 .summingDdouble1Double collect = menu.stream().collect(Collectors.summingDouble(Dish::getCalories)); 13 .toCollection(LinkedList::new)123Optional.ofNullable(menu.stream().collect(Collectors.toCollection(LinkedList::new))).ifPresent(System.out::println);//可以变成Optional.ofNullable(new LinkedList&lt;&gt;(menu)).ifPresent(System.out::println); lambdaexecute around 环绕执行模式泛型限制public static &lt;T&gt; List filter(List, Predicate p) lambda访问lambda主体中的引用（实例变量，静态变量） 在堆中外层变量 在栈中 局部变量是final的，访问的是原始变量的副本。 12345678910111213list.sort(Comparator.comparing(Integer::intValue));public interface Comparator&lt;T&gt; &#123; public static &lt;T, U&gt; Comparator&lt;T&gt; comparing( Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)&#123; Objects.requireNonNull(keyExtractor); Objects.requireNonNull(keyComparator); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1), keyExtractor.apply(c2));&#125;&#125; 比较器链1list.sort(Comparator.comparing(Integer::intValue).reversed().thenComparing(Integer::byteValue)); 谓词复合.negate(),.and(),.or()函数符合1.andThen12345//g(f(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.andThen(g);int result = h.apply(1);//4 2.compose12345//f(g(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.compose(g);int result = h.apply(1);//3 3.创建流水线123456789class Letter&#123; String addHeader(String text)&#123;return "From:";&#125; String addFooter(String text)&#123;return "Kind regards";&#125; String checkSpelling(String text)&#123;return text.replaceAll("labda","lambda");&#125;&#125;Fucntion&lt;String,String&gt; addHeader = Letter::addHeader;Fucntion&lt;String,String&gt; pipeline = addHeader. addThen(Letter::checkSpelling). addThen(Letter::addFooter); 闭包：函数的实例，可以无限制地访问函数的非本地变量。lambda作闭包不能修改局部变量内容，lambda在新线程运行。会造成线程不安全。栈在线程之间不共享，堆在线程间共享。 ::方法引用 用::将方法名称与类/对象分隔开 类::实例方法 类::静态方法 Integer::valueOf 对象::实例方法 list::add 类::构造方法 ArrayList::new Streampipelining 流水线式操作，方法返回一个流，可以链式操作Collection.java根据核数划分123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; 查看线程：jconsoleFinalizer是垃圾回收器的线程测试代码：展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Arrays;import java.util.Comparator;import java.util.List;import static java.util.stream.Collectors.toList;class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public enum Type &#123; MEAT, FISH, OTHER &#125;&#125;public class streamm &#123; private static List&lt;String&gt; byStream(List&lt;Dish&gt; menu)&#123; return menu.parallelStream().filter(d-&gt;&#123; try&#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return d.getCalories()&lt;400; &#125;).sorted(Comparator.comparing(Dish::getCalories)).map(Dish::getName).collect(toList()); &#125; public static void main(String[] args) &#123; List&lt;Dish&gt; menu = Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT), new Dish("beef", false, 700, Dish.Type.MEAT), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHER), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHER), new Dish("pizza", true, 550, Dish.Type.OTHER), new Dish("prawns", false, 300, Dish.Type.FISH), new Dish("salmon", false, 450, Dish.Type.FISH) ); List&lt;String&gt; dishNamesByStream = byStream(menu); System.out.println(dishNamesByStream); &#125;&#125; 线程：多了3个ForkJoinPool.commonPool-worker-1/2/3 intermediate 中间方法1.Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);:intermediate将流删选减少数量 1str.filter((s)-&gt;s.length()&gt;4).forEach(System.out::println); 2.&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 投影：映射成数量相同的另一个新流 1str.map(s -&gt; s.toUpperCase()).forEach(System.out::print); IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); 产生一个intStreamStream&lt;T&gt; limit(long maxSize); :intermediate 删掉后面 terminal的void forEach(Consumer&lt;? super T&gt; action); : terminal的void forEachOrdered(Consumer&lt;? super T&gt; action); :terminal&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); :terminalOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); :terminalboolean anyMatch(Predicate&lt;? super T&gt; predicate); :terminal求和，最大值Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);)12Optional&lt;String&gt; opt = str.reduce((s1,s2)-&gt;s1+s2)String res = opt.get(); 静态方法builder,of,empty of 12Stream&lt;String&gt;str = Stream.of("good","study","good");str.forEach((strr)-&gt; System.out.println(strr)); 合并两个Stream 123public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values); &#125; 其它操作去重distinct1str.distinct().forEach(System.out::print); 创建流Collection可以创建流通过文件创建123456789101112private static Stream&lt;String&gt; createStream()&#123; Path path = Paths.get("./src/java8/aaa"); try(Stream&lt;String&gt; lines = Files.lines(path)) &#123; lines.forEach(System.out::print); return lines; &#125; catch (IOException e) &#123; throw new RuntimeException(); &#125;&#125;public static void main(String[] args) &#123; Stream&lt;String&gt; s = createStream();&#125; 无限流123456private static Stream&lt;Integer&gt; createfromiterator()&#123; Stream&lt;Integer&gt; stream = Stream.iterate(0,n-&gt;n+2).limit(100); return stream;&#125;createfromiterator().forEach(System.out::println);//输出0，2，..198 无限随机数1234private static Stream&lt;Double&gt; fromgenerate()&#123; return Stream.generate(Math::random);&#125;fromgenerate().forEach(System.out::println); fib:123Stream.iterate(new int[]&#123;0,1&#125;, t-&gt;new int[]&#123;t[1],t[0]+t[1]&#125;) .limit(20).map(t-&gt;t[0]) .forEach(System.out::print); 扁平化flatMap两个集合一起12Stream&lt;List&lt;Integer&gt;&gt; ss=Stream.of(Arrays.asList(1,2,3),Arrays.asList(4,5));ss.flatMap(list-&gt;list.stream()).forEach(System.out::print); 1234String[] words = &#123;"hello","word"&#125;;//&#123;h,e,l,l,o&#125;,&#123;w,o,r,l,d&#125;Stream&lt;String[]&gt; stream = Arrays.stream(words).map(w-&gt;w.split(""));Stream&lt;String&gt; stringStream = stream.flatMap(Arrays::stream); {1,2,3},{3,4}-&gt;{[1,3],[1,4]…[3,4]}123456List&lt;Integer&gt; numbers1 = Arrays.asList(1,2,3);List&lt;Integer&gt; numbers2 = Arrays.asList(3,4);List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList());pairs.forEach(ints -&gt; &#123; System.out.println(Arrays.toString(ints));&#125;); 只返回[2,4],[3,3]加起来是%3=0123List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream() .filter(j-&gt;(i+j)%3==0) .map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList()); 查找匹配allMatchfind：12Optional&lt;Integer&gt; first = stream.filter(i -&gt; i % 2 == 0).findFirst();int sum = intStream.filter(i -&gt; i &gt; 3).sum(); reduce:.reduce(Integer::max)拆箱：节省内存mapToInt:IntStream intStream = stream.mapToInt(i -&gt; i.intValue());1234@FunctionalInterfacepublic interface ToIntFunction&lt;T&gt; &#123; int applyAsInt(T value);&#125; 装箱：.boxed(),.mapToObj()给一个数a求1-100里找一个数可以与a勾股定理sqrt(a^2+b^2)%1=0（sqrt后不带小数）.rangeClose(start,end)生成start-end中的所有数字range(1,100)是开区间 不包括结束值12345int a =9;IntStream.rangeClosed(1, 100).filter(b -&gt; Math.sqrt(a * a + b * b) % 1 == 0) .boxed()//IntStream的map只能每个元素返回另一个int 应该流中每个元素是数组（onj） .map(x -&gt; new int[]&#123;a, x, (int) Math.sqrt(x * x + a * a)&#125;) .forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); a也需要自动生成123456789Stream&lt;int[]&gt; stream1 = IntStream.rangeClosed(1, 100) .boxed() //把三元流扁平成一个流 //第二个值生成的range从第一个数c开始，去重复(3,4,5)(4,3,5) .flatMap(c -&gt; IntStream.rangeClosed(c, 100) .filter(b -&gt; Math.sqrt(c * c + b * b) % 1 == 0) //创建了三元流 .mapToObj(b -&gt; new int[]&#123;a, b, (int) Math.sqrt(a * a + b * b)&#125;));stream1.forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); 更紧凑的做法 只计算一次sqrt1234IntStream.rangeClosed(1,100).boxed().flatMap(a-&gt; IntStream.rangeClosed(a,100).mapToObj( b-&gt;new double[]&#123;a,b,Math.sqrt(a*a+b*b)&#125;) .filter(t-&gt;t[2]%1==0)); 拼接字符串效率不高，每次迭代都要新建String对象reduce可以设置初始值1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .reduce("", (n1, n2) -&gt; n1 + n2); 使用joining，内部用到StringBuilder1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .collect(joining()); 找最大值最小值.stream().min(comparing(Transaction::getValue));]]></content>
  </entry>
  <entry>
    <title><![CDATA[netty]]></title>
    <url>%2F2018%2F06%2F04%2Fnetty%2F</url>
    <content type="text"><![CDATA[子网掩码得到子网的网络地址 以太网 Frame帧IP packet 分组（不是分片TCP segment 分节应用层 message消息 NIO:Reactor模式reactor对所有客户端的socket套接字做事件处理，派发到不同的线程。 AIO:Proactor模式动作完成后调用handler 网络计时Timekeeping时间：一天86400秒 365天 假设70年 精度为10位有效数字时钟：振荡器oscillator(14.318MHz+计数器counter Timestamp时间点。是指针 不能相加 只能相减。算中间时间：T1+(T2-T1)/2Time interval 是int时间的一阶导是频率二阶导是jittertsc cpu内部的周期计数器 现在不随cpu频率变化。cpu频率以G 10^9 能精度到1ns NTP网络时间同步 基于UDP算出时间差error:[(T4+T1)-(T2+T3)]/2后调整offset和frequency连续调整 避免时钟跳变。如果时间差小于128ms 缓慢调下去。频率跳变时间会阶越效应 当同一个ip后面多个服务器，没有session会发到不同的服务器上NTP在服务端有两个误差，1从网卡内核到用户进程接收计时 2用户进程开始发送计时到内核网卡发出。两个时间可能不对称。 以太网最小帧长64字节ip20字节 udp 8字节 tcp头20字节tcp还有时间戳option12字节ip-tcp52字节 TCP close发送太早可能发生RST分解。连接重置。netcat光发，不接收响应，ttcp接收到服务器ack再发第二个包 本机测试从/dev/zero读取1G的速度nc -l 5000 &gt;/dev/null &amp;dd if = /dev/zero bs = 1M count = 1000 |nc localhost 5000用io重定向测试本地文件传输速度time nc localhost 5001 &lt; file.file用irb计算 10^10(1G)/9.4(s)/10^6 = M/s 得到磁盘性能 第二次time会快很多因为已经在缓存里了 监测数据nc -l 50001 |pv -W &gt; /dev/null pv的单位是二进制，dd用的十进制文件-&gt;tcp-&gt;文件dd |nc,nc -l &gt;/dev/null6次用户与内核间拷贝 /dev/zero-&gt;dd dd-&gt;pipe pipe-&gt;nc nc-&gt;TCP TCP-&gt;服务端nc sysctl -A |grep range本机端口范围 TCP自连接1发起链接时会从ipv4.ip_local_port_range中选择临时端口号2向服务器发送SYNTCP的同时打开，3000端口无进程监听，但是tcp链接打开了3000端口，当作有监听，形成自连接 pipelining数，连发n个收一个ack用阻塞编程 有上限，超过会收不到ack TTCP tcp实现的检测性能muduo 用非阻塞的muduo库写的ttcp.ccstream-&gt;setNoDelay(true) 不用等ack发送 Epoll 可扩展I/O时间通知特性比旧的POSIX select和poll系统调用性能更好。epoll是linux非阻塞网络编程的事实标准。Linux下：将NioEventLoopGroup换成EpollEventLoopGroupNioServerSocketChannel.class换成EpollServerSocketChannel.class 回调方法：指向已经被提供给另一个方法的 方法的引用OutboundHandler出站：从客户端到服务端 ：链尾取到链头Inbound 入站：链头取到链尾handler添加到pipline时会被分配一个ChannelHandlerContext表示绑定。1.直接写道channel中，从Pipeline尾端开始流动2.写到handler关联的Context对象 从从pipeline从下一个handler开始流动 ChannelHandler的三个子类：编码器，解码器 SimpleC..Inbound..nettyIoc 好莱坞原则Reactor模型 应用向中间人注册回调(event handler) 中间人轮询，IO就绪后中间人产生事件，通知handler处理。 第三种reactor模型，将reactor分两部分。mainReactor负责监听server socket的链接（外部client的链接）subReactor 负责读写网络数据。 netty支持单线程、多线程、主从reactor模型。 创建2个线程组多个线程 线程内串行化 避免线程竞争 无锁 操作系统维护TCP 的SYN队列 将网络请求插入队列，返回SYN/ACK 两次握手 半链接（SYN_RCVD) （主reactor） 第三次握手，收到ACK请求，操作系统将SYN队列中的请求转移到ACCEPT队列（阻塞队列）全链接(ESTABLISHED) （子reacotr） 服务器上的应用队列监听阻塞队列（ACCEPT)accept+SYN队列=backlog长度syn长度：/proc/sys/net/ipv4/tcp_max_syn_backlog =1024accept长度：/proc/sys/net/core/somaxconn =128 引导 构建netty的配置服务端12serverBootstrap.group(pgroup,cgroup).channel(NioSocketChannel.class).option(ChannelOption.SO_RCVBUF,32*1024)//接收缓存大小 客户端引导Bootstrap 连接到主机和端口服务端引导ServerBootstrap 绑定一个本地端口客户端只需一个EventLoopGroup客户端需要2个，管理两组不同的Channel。 ServerChannel绑定本地端口并监听 连接请求创建channel 第二组处理传入客户端连接的channel 给channel分配eventloop Netty的buffer有两个指针，读写指针互不影响，NIO只有一个指针要flipdirectByteBuf堆外 零拷贝 客户端 写给服务端12//直接把字节数组包装成bufferctx.writeAndFlush(Unpooled.wrappedBuffer("响应".getBytes())); 服务器端读取1234567try&#123;ByteBuf buf =(ByteBuf)msg;byte[] responseData = new byte[buf.readableBytes()];buf.readBytes(responseData);&#125;finally&#123; ReferenceCountUtil.release(msg);&#125; Netty阻塞io服务端123456789101112131415161718192021222324252627EventLoopGroup group = new OioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(OioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) //用于回调 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( new ChannelInboundHandlerAdapter() &#123; @Override public void channelActive( ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) .addListener( ChannelFutureListener.CLOSE); &#125; &#125;); &#125; &#125;); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync();&#125; 非阻塞服务端1234567NioEventLoopGroup group = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group).channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) ... &#125; 客户端：12345678910111213141516171819202122232425public void start()throws Exception &#123;EventLoopGroup group = new NioEventLoopGroup();try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; //Pipeline为handler编排顺序 ch.pipeline().addLast( //自定义的handler new EchoClientHandler()); &#125; &#125;); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync();&#125; finally &#123; group.shutdownGracefully().sync();&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud]]></title>
    <url>%2F2018%2F05%2F08%2Fspring-cloud%2F</url>
    <content type="text"><![CDATA[@EnableEurekaServer 静态文件用Nginx+Lua实现高性能网关文件服务器 FastDFSzk客户端 curator解决watcher注册一次就失效分布式锁 dockerservice docker startrun:-it 开启交互界面--name 容器的名字 端口映射-p 9000:8080将docker容器8080端口映射到宿主机端口9000文件目录映射-v /home/project:/soft 映射到容器的soft目录 --privileged可以读写执行宿主机文件 停止容器：docker stop name删除容器：docker rm name ZooKeeper1.安装jdk到/usr/ 安装zookeeper到/usr/local/2.cp zoo_sample.cfg zoo.cfgtickTime 时间单元 session超时等initLimit=N 集群 初始化链接时间 表示是tickTime的N倍syncLimit=N 主发送给从 的请求应答时间长度（心跳）表示是tickTime的N倍 dataDir=/usr/zookeeper/dataDirdataLogDir=/usr/zooKeeper/dataLogDir并创建dataDir和dataLogDir 回到/bin 启动服务器./zkServer.sh start 启动客户端./zkCli.sh 链接成功后 help显示命令 ls2 /和stat /一样ctime创建时间pZxid 子节点idcversion子节点的变化 创建创建结点 create /iznode inode-data查看get /iznode创建临时结点create /iznode/tmp inode-dataephemeralOwner可以看出是不是临时结点 客户端关闭后，超时后，临时结点会自动删除创建顺序结点create -s /iznode/sec seq-data会自动在名字后面加序列号 set和deleteset /iznode 123 1添加乐观锁123 版本号+1 watchget /iznode watch]]></content>
  </entry>
  <entry>
    <title><![CDATA[原子性 可见性 有序性]]></title>
    <url>%2F2018%2F05%2F07%2Favo%2F</url>
    <content type="text"><![CDATA[原子性： 互斥 同一时间只有一个线程操作atomic竞争激烈能维持常态，性能比Lock还好，但每次只能同步一个值 AtomicInteger123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; Unsafe:12345678910//var1 当前对象 var2当前值 var4 add值public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123;//调用底层native方法获得var2当前值，有没有别的线程处理 var5 = this.getIntVolatile(var1, var2); //直到 主存var5和var2工作内存相等，则执行add &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; compareAndSwapInt是native方法 LongAdder与CAS中的AtomicLong比较：AtomicLong竞争激烈时，大概率修改失败，性能差JVM会将64位的long和double读写会拆成2个32位的操作123public void increment() &#123; add(1L);&#125; LongAdderextends Striped64实现热点数据分离，高并发时会将long变成一个数组Cell[] as，但是并发更新可能会有误差。 compareAndSet用于AtomicBoolean中控制代码只执行一次（只能一个线程）。执行之前是false 执行之后true。compareAndSet(false,true)12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125; AtomicBoolean1234567891011private static AtomicBoolean isHappened = new AtomicBoolean(false);//放在线程中semaphore.acquire();test();semaphore.release();private static void test() &#123; //线程执行1k次，F变T只一次 log只输出一次 if (isHappened.compareAndSet(false, true)) &#123; log.info("execute"); &#125;&#125; atomic机器级指令compareAndSet 比锁快，映射到处理器操作。123largest.updateAndGet(x-&gt;Math.max(x,observed));//或者largest.accumulateAndGet(observed,Math::max); 大量线程访问相同的原子值LongAdder,LongAccumulator线程个数增加自动提供新的加数。所有工作都完成后才需要总和的情况使用。 AtomicIntegerFieldUpdate原子性更新类的更新类中相应字段 必须volatile不能static展开代码 1234567891011121314151617public class AtomicExample5 &#123;private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, "count");public volatile int count = 100;public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if (updater.compareAndSet(example5, 100, 120)) &#123; //执行 log.info("update success 1, &#123;&#125;", example5.getCount()); &#125; if (updater.compareAndSet(example5, 100, 120)) &#123; log.info("update success 2, &#123;&#125;", example5.getCount()); &#125; else &#123;//执行 log.info("update failed, &#123;&#125;", example5.getCount()); &#125;&#125;&#125; AtomicStampReference解决CAS的ABA问题1234567891011 private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125;&#125; ABA其它线程将A改成B再改成A，本线程比较发现没有变。每次更新变量版本号+1123456789101112 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp;//比较stamp ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125; AtomicLongArray数组，可以更新索引位置的值long getAndSet(int i, long newValue)boolean compareAndSet(int i, long expect, long update) 锁synchronized 依赖JVM不可中断锁，必须等到代码执行完,竞争不激烈使用，可读性好1.修饰代码块：作用域调用的对象输出0~9，0~91234567891011121314151617181920public class SynchronizedExample1 &#123; // 修饰一个代码块 public void test1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", i); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); &#125;&#125; 2.修饰方法：作用于调用的对象，子类的继承该方法不会带synchronized，需要再声明。因为synchronized不是方法声明的一部分同上输出0~9，0~912345public synchronized void test2() &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", i); &#125;&#125; 当声明另一个对象,两个线程会交叉执行，不同对象之间不影响123SynchronizedExample1 example2 = new SynchronizedExample1();example1.test2();example2.test2(); 3.修饰静态方法：作用于所有对象同一时间只有一个线程可以执行，两个对象也是输出0~9，0~912345public static synchronized void test2(int j) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", j, i); &#125;&#125; 4.修饰类：作用于所有对象1234567public static void test1(int j) &#123; synchronized (SynchronizedExample2.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", j, i); &#125; &#125;&#125; Lock:依赖特殊的CPU指令 可中断unLock竞争激烈维持常态 ReentrantLock123private Lock bankLock = new ReentrantLock();try&#123;bankLock.lock();&#125;finally&#123;bankLock.unlock();&#125; 可见性：每个cpu都有cacheCPU2修改了内存中的a，CPU1读取a只读取cache中的值，不可见虚拟机有两种模式 客户端模式不会优化 -server优化（64位虚拟机一般是server模式） 线程交叉执行 重排序+线程交叉执行 共享变量更新再工作内存和主存没同步 java内存模型线程如何何时看到其它线程修改过的共享变量的值，如何同步地访问共享变量堆 运行时动态分配内存大小。调用栈和本地变量存放在线程栈。 java内存模型JMM对synchronized的两条规定： 线程解锁必须刷新共享变量到主存 线程加锁要清空工作内存中共享变量的值，使用共享变量时从主存读新值（同一个范围的锁） volatile内存屏障，禁止重排序volatile写：会在写操作后加入一条store屏障指令它的修改会立刻刷新到主存，图有问题？？？读：读之前加入load屏障指令，c去内存中读取新值。 使用volatile run(){count++}还是会出错volatile不具有原子性。因为：1. 取值2. +1 3.写回主存，两个线程同时拿到值并+1，同时写回主存，丢1. 使用场景：对变量的写操作不依赖当前值适合当状态标记量：用volatile的值作为线程1的状态加载完毕。线程2 while(!)判断 有序性volatile、synchronized、Lock 不满足happends-beforey原则 JVM就可以重排序volatile 写操作先于读操作终止检测Thread.isAlive()]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io-file]]></title>
    <url>%2F2018%2F05%2F04%2Fjava-io-file%2F</url>
    <content type="text"><![CDATA[JNI java native interface 本地接口堆外内存：ByteBuffer1.wrap可以包装一个数组，保证不被直接修改2.ByteBuffer.allocateDirect() 堆外内存。123public static ByteBuffer allocateDirect(int capacity) &#123; return new DirectByteBuffer(capacity);&#125; DirectByteBuffer继承MappedByteBuffer,map..继承ByteBuffer继承BufferBuffer.java中 实现零拷贝1234// Used only by direct buffers// NOTE: 升级为了JNI方法调用的速度hoisted here for speed in JNI GetDirectBufferAddress//堆外内存数据地址用c申请的long address; Reactor模式IO分为广义File I/O和Stream I/O两类common-ioxml解析SAX 事件驱动，顺序。，读取(内存占用小) 解析器工厂 1SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); 创建SAX解析器 1SAXParser saxParser = saxParserFactory.newSAXParser(); 数据处理器 1PersonHandler personHandler = new PersonHandler(); 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class PersonHandler extends DefaultHandler&#123; public List&lt;Person&gt; getPersons() &#123; return persons; &#125; private List&lt;Person&gt; persons = null; private Person p= null; //用于记录当前正在解析的标签 private String tag; @Override public void startDocument() throws SAXException &#123; super.startDocument(); //开始解析文档 persons = new ArrayList&lt;&gt;(); System.out.println("开始解析标签"); &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); System.out.println("结束解析"); &#125; /* * @param uri 命名空间 * @param localName 不带前缀的标签 * @param qName 带前缀的标签&lt;aa: * @param attributes 标签里的属性集合 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; super.startElement(uri, localName, qName, attributes); if("Person".equals(qName))&#123; p=new Person(); int id = Integer.parseInt(attributes.getValue("id")); p.setId(id); &#125; //开始解析标签时记录名字 tag = qName; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; super.endElement(uri, localName, qName); //每次结束标记就把tag置空 if ("Person".equals(qName)) &#123; persons.add(p); &#125; tag = null; &#125; @Override //解析文本内容时 public void characters(char[] ch, int start, int length) throws SAXException &#123; super.characters(ch, start, length); //ch是整个xml文件的内容 if (tag != null) &#123; if("name".equals(tag))&#123; p.setName(new String(ch,start,length)); &#125; &#125; &#125;&#125; 开始解析12InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("person.xml");saxParser.parse(is,personHandler); 据说jdom和dom文档超过10M会内存溢出 Dom解析 解析器工厂 1DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); 解析器对象 1DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); 解析（把所有文件读取到内存） 12//树状结构Document parse = documentBuilder.parse(is); 从内存中读取 123456789101112131415161718192021NodeList people = parse.getElementsByTagName("Person");ArrayList&lt;Person&gt; pp = new ArrayList&lt;&gt;();Person p =null;for (int i = 0; i &lt;people.getLength() ; i++) &#123;Node person = people.item(i);p = new Person();//获取person元素的属性idp.setId(Integer.parseInt(person.getAttributes().getNamedItem("id").getNodeValue()));//获取子节点NodeList childNodes = person.getChildNodes();for (int j = 0; j &lt;childNodes.getLength() ; j++) &#123; Node child = childNodes.item(j); if ("name".equals(child.getNodeName())) &#123; p.setName(child.getTextContent()); System.out.println(child.getFirstChild()); System.out.println(child.getFirstChild().getNodeValue()); &#125;&#125;pp.add(p);System.out.println(p);&#125; JDOM 三方 不用NodeList 返回原生的Collection123456789101112131415161718SAXBuilder builder = new SAXBuilder();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document build = builder.build(is);Element root = build.getRootElement();List&lt;Person&gt; list = new ArrayList&lt;&gt;();Person p = null;List&lt;Element&gt; children = root.getChildren();for(Element e :children)&#123; p = new Person(); p.setId(Integer.parseInt(e.getAttributeValue("id"))); List&lt;Element&gt; child = e.getChildren(); for(Element ce:child)&#123; if ("name".equals(ce.getName())) &#123; p.setName(ce.getText()); &#125; &#125; list.add(p);&#125; DOM4JJAXM 和hibernate读写配置文件 都使用1234567891011121314151617181920SAXReader reader = new SAXReader();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document doc = reader.read(is);Element root = doc.getRootElement();Iterator&lt;Element&gt; iter = root.elementIterator();ArrayList&lt;Person&gt; people = new ArrayList&lt;&gt;();Person p = null;while(iter.hasNext())&#123; p = new Person(); Element next = iter.next(); p.setId(Integer.parseInt(next.attributeValue("id"))); Iterator&lt;Element&gt; childiter = next.elementIterator(); while(childiter.hasNext())&#123; Element next1 = childiter.next(); if ("name".equals(next1.getName())) &#123; p.setName(next1.getText()); &#125; &#125; people.add(p);&#125; 对象写入生成xml1.XMLEncoder 用decoder直接解析12345BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("outxml.xml"));XMLEncoder xmlEncoder = new XMLEncoder(bos);//forxmlEncoder.writeObject(p);xmlEncoder.close(); 生成1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;java version="1.8.0_144" class="java.beans.XMLDecoder"&gt; &lt;object class="javacoretest.xmljson.Person"&gt; &lt;void property="id"&gt; &lt;int&gt;3&lt;/int&gt; &lt;/void&gt; &lt;void property="name"&gt; &lt;string&gt;第三个&lt;/string&gt; &lt;/void&gt; &lt;/object&gt;&lt;/java&gt; 2.xstream 依赖包xpp312XStream xStream = new XStream(new Xpp3Driver());String xml = xStream.toXML(p); 输出：1234&lt;javacoretest.xmljson.Person&gt; &lt;name&gt;第三个&lt;/name&gt; &lt;id&gt;3&lt;/id&gt;&lt;/javacoretest.xmljson.Person&gt; 修改成Person包名，id为属性:在toXML之前加12xStream.alias("Person",Person.class);xStream.useAttributeFor(Person.class,"id"); 解析:xml是字符串xml(Person)xStream.fromXML(xml); JSON：GSON12[&#123;"id":"1","name":"小明"&#125;, &#123;"id":"2","name":"小红"&#125;] 1解析list123456789InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/people.json");InputStreamReader in = new InputStreamReader(is);JsonReader reader = new JsonReader(in);List&lt;Person&gt; list = new ArrayList&lt;&gt;();reader.beginArray();while(reader.hasNext())&#123; list.add(addobj(reader));&#125;reader.endArray(); 2解析obj123456789101112131415161718private static Person addobj(JsonReader reader) throws IOException &#123; Person p = null; //读大括号 reader.beginObject(); p = new Person(); while(reader.hasNext())&#123; String s = reader.nextName(); if ("name".equals(s)) &#123; p.setName(reader.nextString()); &#125; else if("id".equals(s))&#123; int i = reader.nextInt(); p.setId(i); &#125; &#125; reader.endObject(); return p;&#125; 直接用Gson将字符串{:}转化成类 “age”:”4”会自动映射成int12Gson gson = new Gson();list.add(gson.fromJson(reader,Person.class)); 3 生成json12345678910private static String createJson(List&lt;Person&gt; people)&#123; JsonArray array = new JsonArray(); for(Person p: people) &#123; JsonObject obj = new JsonObject(); obj.addProperty("name",p.getName()); obj.addProperty("id",p.getId()); array.add(obj); &#125; return array.toString();&#125; 直接用gson将对象转成json字符串1String s = gson.toJson(pp); 制定生成json list12345//相当于 允许运行时创建一个子列获取typeclass mytype extends TypeToken&lt;List&lt;People&gt;&gt;&#123;&#125;//new一个子类，里面什么都不写TypeToken&lt;List&lt;Person&gt;&gt; typeToken = new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;;List&lt;Person&gt; people = gson.fromJson(reader,typeToken.getType()); 用List生成list json1String pjson = gson.toJson(people,typeToken.getType()); IO文件File File.separator:winsows:”\”,linux”/“ windows换行符：System.lineSeparator().equals(&quot;\r\n&quot;) trueLinux：equals(&quot;\n&quot;) .list()列出目录下所有文件名.listFiles()返回File[].length()返回文件字节数 123Date last = new Date(f.lastModified());DateFormat df = new SimpleDateFormat();System.out.println(f.getName()+f.length()+df.format(last)); 过滤： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(".java")); 递归找文件： 展开代码 123456789101112131415 private static void findFile(File start,String file)&#123; if(start==null)return; if(start.isDirectory()) &#123; File[] list = start.listFiles(); if (list != null) &#123; for (File f : list) &#123; findFile(f,file); &#125; &#125; &#125;else&#123; if (start.getName().equals(file)) &#123; System.out.println(start.getAbsolutePath()); &#125; &#125;&#125; 字节流123456789InputStream inputStream = new FileInputStream(a);//汉字两个字节大小过小会出错byte[] bt = new byte[3];int len=-1;StringBuffer sb = new StringBuffer();while ((len=inputStream.read(bt))!=-1)&#123; //如果最后一次只读1个字节，bt[0]是新值，[1-2]是旧值，重复 sb.append(new String(bt,0,len));&#125;System.out.println(sb); InputStream 字节 ：mark() reset() 字符流顶层父类：Writer、Reader 解决不同文字编码占的字节数不同1.Reader用char[]接收1234567Reader rd = new FileReader(a);char[] buff = new char[1];StringBuffer sb = new StringBuffer();int len =-1;while((len = rd.read(buff))!=-1) &#123; sb.append(new String(buff,0,len));&#125;rd.close(); 实现： FileReader extends InputStreamReader private final StreamDecoder sd;sd.read()是一个.class LineNumberReader2.Writer append调用writeprivate char[] writeBuffer;,WRITE_BUFFER_SIZE = 1024;1.关闭流.close()、2.手动刷新、3.缓存满 之后才会把缓冲区写入文件字节流的.write()直接写3.文件复制(用字节流)12byte[] bytes = new byte[1024];int len =-1;while((len=in.read(bytes))!=-1)&#123;out.write(bytes,0,len);&#125; OutputStreamWriter Writer = InputStreamReader Reader= 4个缓冲流1.BufferedOutputStream(OutputStream)的关闭1234@SuppressWarnings("try") public void close() throws IOException &#123; try (OutputStream ostream = out) &#123; flush(); &#125; &#125; 只需要关闭外层bos的close 默认缓存大小8192 8K 使用try语法的类要实现Closeable，作用域在后面的大括号中2.BufferedReader可以readLine() 打印流PrintStream字节,PrintWriter字符添加了更多的print，只是为了遍历输出 对象流 存储到物理介质/网络传输12345678910Student st = new Student("小明",33);File store = new File("src/javacoretest/File/tryst.obj");//写try (ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(store)))&#123;oos.writeObject(st);&#125;//读try(ObjectInputStream ois = new ObjectInputStream( new FileInputStream("src/javacoretest/File/tryst.obj")))&#123; Student xiaoming = (Student) ois.readObject(); System.out.println(xiaoming);&#125; 加上serialVersionUID=1L 版本号用数组实现一组对象的存储trasient在序列化中被忽略,还原时变成默认值 字节数组流ByteArrayInputStream ByteArrayOutputStream内存操作与文件无关，每次读取一个字节，处理字符串，无需关闭从String中得到过滤出全部字母展开代码 12345678910String s = "12345dadfa(*dafAAAdaf@$#234";ByteArrayInputStream bais = new ByteArrayInputStream(s.getBytes());ByteArrayOutputStream baos = new ByteArrayOutputStream();int curr =-1;while((curr=bais.read())!=-1)&#123; if((curr&gt;=65&amp;&amp;curr&lt;=90)||curr&gt;=97&amp;&amp;curr&lt;=122)&#123; baos.write(curr); &#125;&#125;System.out.println(baos.toString()); 数据流DataInputStream DataOutputStream按java基本数据类型,与机器底层无关.writeInt(10) 对应.readXXX.wirteByte(1).writeUTF(&quot;中文&quot;) 分割文件void divide(File target,long cutSize) 123456789for (int i = 0; i &lt;n ; i++) &#123; out = new BufferedOutputStream(new FileOutputStream("src/javacoretest/File/"+(i+1)+".txt")); ... if((len = in.read(bytes))!=-1)&#123; out.write(bytes, 0, len); out.flush(); &#125; out.close();&#125; 合并文件 合并流SequenceInputStream 123456Vector&lt;InputStream&gt; v = new Vector&lt;&gt;();Eumeration es = v.elements();SequenceInputStream sis = new SequenceInputStream(es);sis.read(bytes);bos.write(bytes,0,len);bos.flash(); 字符串流StringReader StringWriterStringTokenizer流标记器1if(st.nextToken()==StreamTokenizer.TT_WORD)cnt++; 管道流 PipedInputStream.. 线程之间的数据通信pin.connect(pout); RandomAccessFile在jdk1.4中nio 被内存映射文件 替代复制文件12RandomAccessFile r = new RandomAccessFile("a.txt","r");RandomAccessFile w = new RandomAccessFile("c.txt","rw"); seek 实现文件续传 Properties 工具类 extends HashtableResourceBundle只能读取12345678InputStream cfg = new FileInputStream...p.load(cfg);String name = p.getProperty("username");p.put("passwd","dafdafa");String pw = p.getProperty("passwd");//写OutputStream out = new FileOutputStream...p.store(out,"updatatatata"); 可以通过类加载器加载1InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("src/a.p"); 清除所有的键值对p.clear(); 压缩ZipOutputStream压缩 z.putNextEntry(new ZipEntry(name));ZipEntry(String name) 创建条目解压 zIn.getNextEntry() NIO原来IO流一个字节一个字节处理。NIO块。每一种java数据类型都有缓冲区1.ByteBuffer bf = ByteBuffer.allocate(8);2.添加 bf.put((byte)10); 获取.get(index)3.偏移量：bf.position()4.缓冲区反转：bf.flip()取值的数据变成position-limit 123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 5.bf.hasRemaining()positon和limit之间有值, bf.remaining()有多少个：return limit - position;123456bf.flip()if(bf.hasRemaining())&#123; for(int i =0;i&lt;bf.remaining();i++)&#123; byte b= bf.get(i); &#125;&#125; 6.campact丢弃position及以前的数据，将position到limit的数据复制到之前，并将pisiton移到复制完的数据之后，用于写入新数据覆盖没被覆盖掉但是已经移到前面去的值，limit放到capacity上。 Channel 文件只能通过RandomAccessFile,FileInput/OutputStream的.getChannel()打开只读/只写 socket有Socket,Server,Datagram三种Channel selector是系统(native)调用select() poll()的封装注册:通道设置成非阻塞，File通道不能是非阻塞123Selector sl = Selector.open();channel.configureBolcking(false);SelectionKey = channel.register(selector,Selection.OP_READ); rigister的第二个参数监听四种不同类型：Connect，Accept，R/W可以用|位运算连接多个监听的值 返回的SelectionKey对象有4个boolean方法表示通道的就绪状态从键可以访问对应的通道和选择器： 12selectionKey.channel();selectionKey.selector(); Selecotr对象维护3个键的Set：每个键关联一个通道 12345public abstract SelectorProvider provider();//已注册的键的集合public abstract Set&lt;SelectionKey&gt; keys();//已注册中的已经准备好的集合public abstract Set&lt;SelectionKey&gt; selectedKeys(); select方法返回上次select之后就绪的通道数(增量)通过就绪key访问通道1234567891011Set selectedKeys = selector.selectedKeys();Iterator KeyIterator = selectedKeys.iterator();while(KeyIterator.hasNext)&#123; SelectionKey key = KeyIterator.next(); //四种就绪状态 if(key.isAcceptable())&#123; ... &#125; //从就绪集中移除，下次通道再就绪时再放入选择集 KeyIterator.remove();&#125; 内存缓存区1outBuf.put(inBuf.get()); Path get file.toPath() FileSystem.getDefault().getPath(“”,); Files工具类 copy move delete deleteifExists]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-Collection]]></title>
    <url>%2F2018%2F04%2F28%2Fjava-Collection%2F</url>
    <content type="text"><![CDATA[集合框架 三大接口：Iterator,Collection,Map 工具类：Collections Arrays guava组件 ImmutableList&lt;String&gt; ilist = ImmutableList.of(&quot;a&quot;,&quot;b&quot;);不可变List 过滤器 工具类Lists 1List&lt;String&gt; lit = Lists.newArrayList("aaa","ddd","bbb"); 1Collection&lt;String&gt; cl =Collections2.filter(lit,(e)-&gt;e.toUpperCase().startsWith("a")); 转换 (有问题)日期 12Set&lt;Long&gt; set = Sets.newHashSet(20170801L,20980320L,19950730L);Collection&lt;String&gt; col = Collections2.transform(set,(e)-&gt;new SimpleDateFormat("yyyy-MM-dd").format(e)); 组合函数Functions.compose(f1,f2) 用google的Function 集合操作 交集SetView&lt;Integer&gt; v1 = Sets.intersection(set, set2); 差集：只是1中没有在2中的元素.difference(s1,s2) 并集：把重复的只留一份 Mutiset无序可重复12345//输出[study, dayday, up, good x 2]String[] sp = s.split(" ");HashMultiset&lt;String&gt; hms = HashMultiset.create();for(String str:sp)&#123; hms.add(str);&#125; 获取次数123 Set&lt;String&gt; ele = hms.elementSet();for(String ss:ele)&#123; System.out.println(ss+":"+hms.count(ss));&#125; Multimap Key 可以重复，一个键对应一个Collection1234567891011121314151617//输出：// 作者2 [书3]// 作者1 [书2, 书1]Multimap&lt;String,String&gt; mmap = ArrayListMultimap.create();Map&lt;String,String&gt; map = new Hashtable&lt;&gt;();map.put("书1","作者1");map.put("书2","作者1");map.put("书3","作者2");Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = map.entrySet().iterator();while(iter.hasNext())&#123; Map.Entry&lt;String,String&gt; entry = iter.next(); mmap.put(entry.getValue(),entry.getKey());&#125;for(String key:mmap.keySet())&#123; Collection&lt;String&gt; value = mmap.get(key); System.out.println(key+" "+value);&#125; BiMap 双向map 键值都不能重复BiMap&lt;String,String&gt; map = HashBiMap.create();key和val可以反转map.inverse() 双键Map 行，列，值Table&lt;String,String,Integer&gt; table = HashBasedTable.create();获取条settable.cellSet() 多对多拆分成两个一对多Student和Course生成StudentAndCourse12345class StudentAndCourse&#123; private int id; private int cid;//添加在Course private int sid;//添加在Student&#125; Collections工具类排序类：针对List（set不用排序） shuffle(list)随机打乱 reverse(list) .sort()/(,Comparator c) .swap 123public static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; ArrayList: set返回旧值 123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; rotate(list,int)i移动到(i+d)%size rotate1(list, distance); : 数组实现，并且长度小于100 if (list instanceof RandomAccess ||list.size() &lt; ROTATE_THRESHOLD) leetcode的算法3展开代码 直接放在正确的位置上理解：把0位放到正确位置（distance)后，将这个位置继续当作0位，继续移动distance步，直到i回到0位1234567891011121314151617181920212223private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; distance = distance % size; if (distance &lt; 0) distance += size; if (distance == 0) return; /****以上得的了正确的distance size和distance有一个为零就不动***/ for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123; //size = 5 T displaced = list.get(cycleStart);//1.得到[0] int i = cycleStart; do &#123; i += distance; //向前走3步 if (i &gt;= size) i -= size;//对长度取模 displaced = list.set(i, displaced);//2.赋值给[3],得到[3]的值 nMoved ++;//3.每位放一次一共执行size次同时退出for循环 &#125; while (i != cycleStart); &#125; &#125; 123reverse(list.subList(0, mid));reverse(list.subList(mid, size));reverse(list); 查找 binarySearch,max,min(遍历compare/compareTo) fill(List,o)填充 （遍历调用set） frequency(c,o)c中与o相等元素数量（遍历equals) replaceAll(list,old,new)遍历equals，set 同步重建，加上代码块的锁只有vector/hashtable比较古老是安全的 synchronizedList(list)… 设置不可变的集合emptyXXX,singletonXXX,unmodifiableXXX EmptyList防空指针 UnmodifiableCollection重写了add、remove等方法，直接抛异常 singletonMapsize=1 其它 disjoint(,)没有相同元素返回true addAll(c,T...)全部加入c reverseOrder(Comparator&lt;T&gt; cmp)返回比较器12//反转排序[5, 4, 3, 2, 1] Collections.sort(list,Collections.reverseOrder()); Optional创建： of工厂方法Optional.of(&quot;abb&quot;); ofNullable:如果为空返回empty()空的optionalOptional.ofNullable(&quot;abb&quot;); .empty() isPresent.. Iterator ListIterator Enumeration Vector使用public Enumeration&lt;E&gt; elements()1234Enumeration&lt;Integer&gt; es = v.elements();while(es.hasMoreElements())&#123; System.out.println(es.nextElement());&#125; 迭代器设计模式1.迭代器接口 2.迭代器的实现（用构造函数传入（3））3.抽象类 4.具体类（return new迭代器） forEach jdk1.8 ArrayList:public void forEach(Consumer&lt;? super E&gt; action) Consumer接口：void accept(T t); 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Map 键值setSet&lt;Map.Entry&lt;Integer,String&gt;&gt; enry = map.entrySet(); 值Collection&lt;String&gt; cl = map.values(); forEach(BiConsumer&lt;? super K, ? super V&gt; action) 权限查询.containsKey() Map接口中的新方法 getOrDefault(Object key, V defaultValue)不存在返回默认值 1return (((v = get(key)) != null) || containsKey(key))? v: defaultValue; V putIfAbsent(K key, V value)不覆盖添加 原本的put覆盖并返回旧值 12V v = get(key);if (v == null) &#123;v = put(key, value);&#125; boolean remove(Object key, Object value)保证key和val都有 1234567 Object curValue = get(key);if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false;&#125;remove(key);return true; boolean replace(K key, V oldValue, V newValue) V compute对key位置上的kv对用BiFunction最后更新并返回计算后的值put(key, newValue); 12map.compute(1,(k,v)-&gt;v+="1");map.computeIfAbsent(5,(k)-&gt;"空空空"); merge 1map.merge(1,"222",(oldv,newv)-&gt;oldv+newv); TreeMapHashMap 数组+链表+（链表长度达到8，会转化成红黑树） 计算hash值 【扰动函数】 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 65536(2^16)&gt;&gt;&gt;16 ==1 table uses power-of-two masking 为了用&amp;2^n-1取模 2^n的table长不是素数很容易冲突 *spreads the impact of higher bits downward int类型自带hashCode范围-2147483648到2147483648 i = (n - 1) &amp; hash 插入位置 n-1=15是1111低位掩码高位归零 int长32&gt;&gt;&gt;16是int的高16位，低16与高16位^,混合hash的高位低位key1=0ABC0000 &amp; (16-1) = 0（8个16进制数，共32位）key2=0DEF0000 &amp; (16-1) = 0hashcode的1位全集中在前16位。key相差很大的pair，却存放在了同一个链表把hashcode的“1位”变得“松散”，比如，经过hash函数处理后，0ABC0000变为A02188B，0DEF0000变为D2AFC70 put(K key, V value) {return putVal(hash(key), key putVal 12if ((p = tab[i = (n - 1) &amp; hash]) == null)//n=length=16 tab[i] = newNode(hash, key, value, null); putVal如果Node链表太长 12if (binCount &gt;= TREEIFY_THRESHOLD - 1) //TREEIFY_THRESHOLD==8 treeifyBin(tab, hash);//变成红黑树 TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; Hashtable 数组加链表没用二叉树数据结构一样的名字不同：hashtable:private transient Entry&lt;?,?&gt;[] table; 默认大小11hashmap: transient Node&lt;K,V&gt;[] table; LinkedHashMap 双重链表set String、Path都有很好的hash函数 顺序遍历集合TreeSet实现了SortedSet和NavigableSet接口 set的元素必须实现Comparable接口或者构造函数中有Comparator HashSet HashMap实现,用空对象占位 12345private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 保持不重复 使用HashMap的 putVal 比较hashCode相同不一定是同一个对象，再比较equals 重写放入hash的类的hashCode： LinkedHashSet 用链表记录插入的位置TreeSet 排序 需要实现Comparatable或传入Comparator，会根据compare的值覆盖，去重 NavigableSet使用元素自然顺序排序，or 用Comparator]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2018%2F04%2F23%2FJVM%2F</url>
    <content type="text"><![CDATA[堆外内存64位的JVM 寻址空间类装载器 装载：1.取得类的二进制流：装载器ClassLoader 读入java字节码装在到JVM2.转为方法区的数据结构3.在堆中生成对象 链接：1.验证2.准备 static final 在准备阶段赋值，static被赋值03.解析 符号引用转换成指针or地址偏移量（直接引用）（内存中的位置） 初始化&lt;clint&gt; lang.NoSuchFiledError jvm用软件模拟java字节码的指令集jvm规范定义了：returnAddress数据类型 指向操作码的指针;输出整数的二进制123456789public static void main(String[] args) &#123; int a = 6; //0x80000000表示最高位为1的数字 for(int i =0;i&lt;32;i++)&#123; //取出a的第一位 //无符号右移( &gt;&gt;&gt; ) int t = (a&amp;0x80000000&gt;&gt;&gt;i)&gt;&gt;&gt;(31-i); System.out.print(t); &#125; &#125; public native String intern();运行期间放入常量池]]></content>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2018%2F04%2F23%2Fcpp%2F</url>
    <content type="text"><![CDATA[STL 分配器Allocator支持容器，处理容器的内存。容器Containers数据和算法Algorithms操作分开。不是OO设计，是模板编程。迭代器是泛化指针 是容器和算法的桥梁。仿函数Functors 容器1 Sequence Containers: Array\vector\deque\list循环双端链表\forwardlist单向链表2 Associative Container:Set\Multiset,Map\Multimap3 unordered Containers: HashTable:Separate Chaning。 array12345678910array&lt;long,50000&gt; c;////0x47a20数组在内存中起始的地址c.data();int compareLongs(const void*a,const void*b)&#123; return(*(long*)a-*(long*)b);&#125;//排序qsort(c.data,50000,sizeof(long),compareLongs);//二分查找long* pItem = (long*)bsearch(&amp;target,c.data(),50000,sizeof(long),compareLongs); vecotr对象像指针*,-&gt;智能指针 包装类修改指针的行为 像一个指针-&gt;会对作用到的结果一直作用下去operator*() operator -&gt; () 写法固定 迭代器 包括智能指针，++,–对象像函数()转换函数当编译器遇到要把该类转换成double类型时，调用double explicit 用在构造函数前non-explicit-one-argument 可以把4转换成fraction用了explicit不能自动调用构造函数转型 委托：delegation,空心菱形表示有。又称Composition by reference 生命周期不同步 handle/body(impl)组合：实心菱形 生命周期同步组合是part在内，继承是base在内 cpp继承有三种 java只有public不用写继承的base class的构造函数必须是virtual不然西沟就不会先子类再base1struct ListNode:public _list_node_base&#123;&#125;; 虚函数成员函数有3种12345678class Shap&#123;//纯虚函数 所有子类必须重新定义virtual void draw() const = 0;//可以重新定义virtual void error(const std::string&amp; msg);//不让子类overrideint objId() const;&#125;; delegation+继承组合模式（文件/文件夹）原型模式，继承框架类，将自己定义的新类加入框架让框架调用 静态方法要在类外给内存 .h头文件写法conplex.h1234#ifndef __COMPLEX__#define __COMPLEX__....#endif 语法制导翻译：类型检查/中间代码生成向文法的产生式附加一些规则（或程序片段）语法分析过程时相应的程序片段会被执行。在语法分析的过程中结合语义动作。 语法指导定义 上下文无关文法和属性及规则集合。规则：语义规则 和产生式相关联。属性与文法相关联 splice emplace_front map:find找到第一个相等的元素 iterator :.cend()容器最后面 把vector中的一个元素移动到最前面 12//it-&gt;second map中的值，指向结点的指针list.splice(list.begin(),list,it-&gt;second); 查找vector中的最大最小元素*max_element(first,end) multiset和set在c++里是有序的，是红黑树，用*set.rbegin()可以获得最大值.erase()会遍历删除所有相同的元素，.equal_range()限定范围 123456multiset&lt;int&gt; s;s.insert(5);s.insert(5);s.insert(5);//只删除了第一个5s.erase(s.equal_range(5).first); c++ 的deque：用指针取头尾的连续存储 advance(it,5)将迭代器移动5次，迭代器*it指向第6个元素 dummy标记[0]元素?????? vector1.swap(v2) 与另一个vector交换数据 unordered_set 拉链法hash表 #include读 hash-include ; 读semicolon auto 类型由编译器自动推断 explicit 禁止隐式转换 成员初始化列表语法 继承关系： 共有继承：is a == is a kind of关系不可逆 香蕉是一种水果，水果不是香蕉 has a 午餐包括水果 is like a 律师像鲨鱼 is implemented as a 栈用数组实现 uses a 计算机可以使用打印机使用友元通信 多态：派生类使用基类的方法；方法行为随上下文，取决于调用该方法的对象。 在派生类中重新定义基类方法 虚方法:根据引用/指针指向的对象 的类型选择方法.派生类回重新定义的方法，在基类中应为虚的。 派生通过 作用域解析运算符 调用基类方法 虚函数原理： 每个对象由隐藏成员，是虚函数表（virtual function table） _vtbl,所有虚函数的地址表 例程 fprintf]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVVM]]></title>
    <url>%2F2018%2F04%2F19%2FMVVM%2F</url>
    <content type="text"><![CDATA[实现myvue.b=222页面刷新 1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234let myvue = new myVue(&#123; el:'#app', data:&#123;a:&#123;a:&#123;a:1&#125;&#125;,b:'aaaaaaaaaaa'&#125; &#125;); 12345678910111213141516171819function myVue(options=&#123;&#125;) &#123;//传入的对象（&#123;el:,data:&#125; //将所有属性挂载在$opthion this.$options = options var data = this._data=this.$options.data //用data别名._data observe(data)//-----------&gt;数据劫持 for(let key in data)&#123; //--&gt; this代理了this._data Object.defineProperty(this,key,&#123; enumerable:true, get()&#123; return this._data[key]//this.a=&#123;a:1&#125; &#125;, set(newVal)&#123; this._data[key]=newVal &#125; &#125;) &#125; ///-------渲染 new Compile(options.el,this)&#125; 数据劫持（观察者）对_data定义get/set属性 123456789101112131415161718192021222324252627282930function Observer(data) &#123; for(let key in data)&#123; // let dep = new Dep() let val = data[key] observe(val)//递归 Object.defineProperty(data,key,&#123; enumerable:true, get() &#123; // -- watcher里的this //只有target绑定了this(Watcher函数) 才把watcher函数放入dep队列 Dep.target&amp;&amp;dep.addSub(Dep.target) return val; &#125;, set(newVal)&#123; if(newVal===val)return val=newVal //----深度数据劫持myvue.a=&#123;a:1&#125; 里面的a也有get/set observe(newVal) // dep.notify() &#125; &#125;) &#125;&#125;//观察对象，给对象添加define...function observe(data) &#123; if(typeof data !== 'object')return //为方便递归 return new Observer(data)&#125; 渲染 123456789101112131415161718192021222324252627282930313233343536function Compile(el,vm) &#123; vm.$el=document.querySelector(el); //创建文档碎片 let fragment = document.createDocumentFragment(); // console.log(vm.$el.firstChild) //移到内存中 while(child = vm.$el.firstChild)&#123; fragment.appendChild(child) &#125; replace(fragment) function replace(fragment) &#123; //从DOM元素节点集合返回一个数组 Array.from(fragment.childNodes).forEach(function (item) &#123; let text = item.textContent let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/ //nodeType=3文本节点 if(item.nodeType===3&amp;&amp;reg.test(text))&#123; //获取匹配的第一个分组 //是标签 nodeType=1 let arr = RegExp.$1.split('.')//[a.a] let val = vm//----&gt;vm=myvue arr.forEach(function (k) &#123;//val=vm[a]-&gt;val=vm[a][a] val = val[k] &#125;) // //----------- 监听替换位置 // new Watcher(vm,RegExp.$1,function (newVal) &#123; // item.textContent = text.replace(reg,newVal) // &#125;) item.textContent = text.replace(reg,val)&#125; if(item.childNodes)&#123; replace(item) &#125; &#125;) &#125;&#125; 订阅器：接受更新重新渲染 订阅器[fn1,fn2]方法集合 1function Dep() &#123;this.subs =[]&#125; 订阅器添加方法、订阅器中方法全部执行(约定订阅”update方法”) 1234567Dep.prototype.addSub= function (sub) &#123; this.subs.push(sub)&#125;//假设每个方法里都有update方法 遍历激活Dep.prototype.notify= function () &#123; this.subs.forEach(sub=&gt;sub.update())&#125; 订阅者（Dep数组中的方法类，被激活的方法类) 在观察者Observer中注册let dep = new Dep() 订阅事件在渲染Compile中 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) 定义watcher并添加到订阅中 12345678910111213 function Watcher(vm,exp,fn) &#123; this.fn = fn this.vm= vm this.exp = exp Dep.target = this; let val = vm; let arr = exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) Dep.target=null&#125; 调用get方法更新时添加Dep.target&amp;&amp;dep.addSub(Dep.target) 在set中执行订阅器中所有watcher的方法dep.notify() 12345678910 Watcher.prototype.update=function () &#123; //取最新的值 let val = this.vm let arr = this.exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) //将新值传给回调函数 this.fn(val)&#125; this.fn(val)回调函数会回到渲染中,用新值替换 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) ====效果：1.myvue.b放入队列2.myvue.b=222先调用set，调用notify3.执行watcher的update4.回调函数fn更新页面 实现v-model 双向数据绑定1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;input type = "text" v-model="b"&gt;&lt;/div&gt; 找到带v-的元素并获得v-model绑定的属性；在渲染中添加监听器；并添加触发事件12345678910111213141516171819202122if(item.nodeType==1)&#123; //如果是元素节点 获取所有dom属性 let nodeAttrs = item.attributes; Array.from(nodeAttrs).forEach(function (attr) &#123; //获取v-model后的属性 //b if(attr.name.indexOf('v-')==0)&#123; let exp = attr.value //初始输入框填值 item.value = vm[exp] //订阅每次更改都更新 new Watcher(vm,exp,function (newVal) &#123; item.value = newVal &#125;) //定义触发事件 item.addEventListener('input',function (e) &#123; console.error(e) let newVal = e.target.value vm[exp] = newVal//调用set方法-&gt;notify-&gt;更新watcher &#125;) &#125; &#125;) &#125; 实现computed的缓存 绑数据挂到vm上1&lt;div&gt;&#123;&#123;hello&#125;&#125;&lt;div&gt; 12345computed:&#123; hello()&#123; return this.b+this.a &#125; &#125; 1234function myVue(options=&#123;&#125;) &#123; ... initComputed.call(this)&#125; 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[About-js]]></title>
    <url>%2F2018%2F04%2F17%2FAbout-js%2F</url>
    <content type="text"><![CDATA[Web Component 用法Webview loadUrl浏览器由7部分组成用户界面网络：请求静态资源发起请求js引擎渲染引擎：DOM和CSS内容排版 WebKit中Html和CSS解析可以并行UI后端：选择框、按钮、输入框js解释器持久化数据存储 查看渲染计算后的CSS规则document.defaultView.getComputedStype(document.getElementById(&quot;id&quot;,null))css计算权重：!important&gt;内联样式&gt;id选择器&gt;类选择器&gt;元素选择器 浏览器持久化 HTTP文件缓存Application-FramesEtag响应/if-Node-Match请求同时设置Expire和Cache-Control只有Cache-Control生效 localStroage在chrome限制为2.6M 同域名一般共享只有4个api：set/get/removeItem/clear sessionStorage 浏览器关闭时会自动清空 cookie单个域名持支的cookie个数。chrome50个，长度4k与localStorage类似 不同域名独立。可以设置cookie的path和domain相同父域共享 HTTPhttp/1.1 字符串传输持久链接：一个tcp链接里可以发送很多http请求。减少三次握手次数。pipeline:添加了host： http2：分帧传输二进制传输（不用连续）信道复用 同一个链接多个请求一个tcp链接并发http请求，不用等前一个请求接收到之后再发送。server push推送。以前要先解析html再发送请求css/js。现在请求html就获取。 nginx开启http2 开启https才能http2ALPN转称http1.1传给服务器123456server&#123; listen 443 http2; server_name test.com; http2_push_preload on;&#125;` nodejs12345678if(request.url === '/')&#123; response.writeHead(200,&#123; 'Content-Type':'text/html', 'Connection':'close', //http2的push 'Link':'&lt;/test.jpg&gt;;as=image;rel=preload' &#125;)&#125; 协议变成h2chrome://net-internals/#http2 看pushed和 claimed 使用1个push到30个push的区别https的握手过程 http2性能测试 nodejs跨域测试 被请求的添加html里type:xhr12345&lt;script&gt;var xhr = new XMLHttpRequest()xhr.open('GET','http://127.0.0.1:8897')xhr.send()&lt;script&gt; 8897:任何服务都能访问这个服务1response.writeHead(200,&#123;'Access-Control-Allow-Origin':'*'&#125;) 或者特定域名12response.writeHead(200, &#123;'Access-Control-Allow-Origin':'http://localhost:8898'&#125;) jsonp标签里允许跨域不用添加allow-origintype:script1&lt;script src="http://127.0.0.1:8897"&gt;&lt;script&gt; CORS预请求 option跨域只允许get/head/postcontent-type只允许 form表单三种数据类型text/plain multipart/form-data application/x-www.form-urlencodedhtml：报错not allowed by Access-Control-Allow-Headers123456fetch('http://localhost:8897/',&#123; method:'POST', headers:&#123; 'X-cors':'123' &#125;&#125;) fetch允许跨域的header允许的header 其它的都需要服务器端验证先发送option类型再发送post123response.writeHead(200,&#123; 'Access-Control-Allow-Header':'X-Test-Cors'&#125;) 同理可以添加Allow-Methods等设置允许跨域的最长时间不需要再发送option预请求&#39;Access-Control-Max-Age&#39;:&#39;1000&#39; 缓存Cache-Control 可缓存性public：http经过的代理服务器、客户端都能缓存private：只有发起请求的浏览器可以缓存(百度设置了privae) 过期max-age：客户端过期时间s-maxage=代理服务器的过期时间max-stale=使用过期缓存 重新验证must-revalidate 其它对代理服务器nginxno-cache 可以本地缓存。向服务器发起验证是否可以使用本地缓存no-store 不能本地缓存。no-transform 不压缩 在请求服务器设置123response.writeHead(200,&#123;'Cache-Control':'max-age=200,public'&#125;) 服务端12345678const etag = request.headers['if-none-match']if(etag === '777')&#123; response.writeHead(304,&#123; 'Content-Type':'text/javascript', 'Etag':'777' &#125;) response.end('并不会显示，浏览器直接读了缓存')&#125; 设置Cookie禁止javascript修改cookie1234response.writeHead(200,&#123; 'Set-Cookie:['id=123;max-age=2','abc=456;HttpOnly']&#125;)response.end(html) &#39;adc=456;domain=test.com&#39; 不能跨域设置给a.test.com 长链接Network-Connection ID（TCP链接的id）http1.1发送请求有先后顺序。不能并发请求chrome允许并发限制创建6个保持长链接Connect:Keep-Alive 默认都是keep-alive本地开发 把网速调慢：online-&gt;Fast 3G可以设置&#39;Connection&#39;:&#39;close&#39; google 使用h2 都是一个connectID 数据协商AcceptAccept-EncodingAccept-Languagemimetype &#39;X-Content-Type-Options&#39;:&#39;nosniff&#39; 禁止浏览器自动猜测返回类型 使用gzip压缩1234567const fs = require('fs')const zlib = require('zlib')const html = fs.readFileSync('test.html')response.writeHead(200,&#123; 'Content-Encoding':'gzip',&#125;)response.end(zlib.gzipSync(html)) 表单如果用ajax使用application/json或者application/xml123456&lt;form action ='/from' id = "form" method = "POST" enctype="multipart/form-data"&gt;&lt;input type = "text" name = "name"&gt;&lt;input type = "password" name = "password"&gt;&lt;input type="file" name="file"&gt;&lt;input type ="submit" name = "submit"&gt;&lt;/form&gt; ajax发送123456789var form = document.getElementById("form")form.addEventListener('submit',fumction(e)&#123; e.preventDefault()//页面不会跳转 var formData = new FormData(form) fetch('/form',&#123; method:'post', body:formData &#125;)&#125;) 会自动带上Content-Type redirect只有302的头才表示跳转123response.writeHead(302,&#123; 'Location':'/new'&#125;) 改成301永久变更 浏览器会自动只发送/new的请求 /new的路由放到了缓存里。接下来改成200也读不到了。 CSP content-security-policy 内容安全策略1'Content-Security-Policy':'default-src http:https' 考虑同一域名的浏览器请求上限将html放在admin.domain.com下,js+css放在s.下，将image放在image.下前端访问后端api.发生跨域需要使用代理服务器 304是协商缓存 还会和服务器通信一次本地缓存(cache-control/expires) 通过html中引用css地址更新v1放弃缓存 用摘要算法当文件更新时更新css文件名静态资源部署在cdn，动态网页部署在另一个节点。1 先更新页面：加载旧缓存，页面样式错乱2 先静态资源后页面：有缓存则不更新，第一次访问的没缓存用户 页面执行错误。访问量小的网站可以先静态资源后页面非覆盖式发布：新旧css同时存在cdn上，再更新html页面 全局微软雅黑document.getElementByTagName(&quot;body&quot;).sytle.fontFamily=&quot;微软雅黑&quot;Array.from(document.getElementByTagName(&quot;p&quot;).forEach((item)=&gt;item.style.fontFamily=&quot;微软雅黑&quot;)) import有无default ，default导出的只能一个，所以不用大括号 webpack-dev-server 开发模式wepack.config.js:123456789101112131415const isDev = process.env.NODE_ENV==='development'const config=&#123; target: 'web'&#125;if(isDev)&#123; config.devSever =&#123; port:8888 host:0.0.0.0,//可以在内网中用内网ip用手机访问测试 overlay:&#123; errors:true, &#125;, historyFallback:"index.html", hot:ture//只渲染当前组件&#125;&#125; 安装corss-env在windows平台下设置NODE_ENV要用set和linux不同package.json1234"script":&#123; "build":"cross-env NODE_ENV=production webpack --config webpack.config.js", "dev": "cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js"&#125; html-webpack-pluginautoprefixerpostcss.config.js优化css代码 自动加webkit等前缀 mixin模式typeof一共有五种返回值按存储方式只有值类型和引用类型（共用内存块）只能区分值类型。无法区分引用类型：数组、对象、方法 强制类型转换==123100=='100'//true0=='' //true 都会转换成falsenull==undefine//true 都会转换成false if和逻辑运算符判断变量被当成true还是false12var a = 100console.log(!!a)//true 何时使用===和==除了1234obj.a==null//相当于obj.a===null||obj.a===undefined//来自jquery 其它都用=== 12个js内置函数 （数据封装类对象）JSON和Math也是内置对象12JSON.stringify(&#123;a:10,b:20&#125;)JSON.parse('&#123;"a":10,"b":20&#125;') 原型js构造函数12345678910//构造函数function MathHandle(x,y)&#123; this.x=x; this.y=y;&#125;MathHandle.prototype.add=function()&#123; return this.x+this.y&#125;var m = new MathHandle(1,2)console.log(m.add()) Class语法1234567891011class MathHandle&#123; construct(x,y)&#123; this.x=x; this.y=y; &#125; add()&#123; return x+y &#125;&#125;const m = new MathHandle(1,2);console.log(m.add()) 语法糖实现MathHandle===MathHandle.prototype.constructor true 继承123456789function Animal()&#123; this.eat = function()&#123; console.log("animal")&#125;&#125;function Dog()&#123; this.bark = function()&#123; console.log("bark")&#125;&#125;Dog.prototype = new Animal()var hs = new Dog()//hs有了eat方法 window.onload和DOMContentLoaded区别zeptorollup.js 比webpack小 babel src/index.js zepto小型jquery专门移动端开发Rivets.js数据绑定js预处理器 pug webpack 模版处理器（jade） 数组 arr.includes(4) true/false .find 123let result = arr3.find(function (item,index) &#123; return item.toString().indexOf(5)&gt;-1&#125;) .some找到true后停止返回true .every找到false后停止返回false .reduce变成undefined是因为没有写返回值 对象求和：12//不报错，返回NaN 因为pre从对象变成了数 [&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev.price*prev.count+next.price*next.count) 正确写法：123[0,&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count)//或者添加默认参数[&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count,0) 数组扁平化：二维数组变成一维1[[1,2,3],[4,5,6],[4,5,6]].reduce((prev,next)=&gt;prev.concat(next)) 箭头函数let a = b =&gt; c =&gt; b+ca(1)(2)=3(return function(c){b+c})闭包：返回的是引用数据类型，赋值给外界变量，不会被销毁。 更改this指向 call和apply和bindapply\call详解绑定this上下文，call和apply使函数立即执行 bind返回函数自己实现bind12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125; &#125; 文档碎片在赋值操作中 A||B :A真返回A，A假返回B A&amp;&amp;B :A假返回A，A真返回B &amp;&amp;优先于||应用场景：1234function fn(num,callBack)&#123; num=num||0//undefined会转换成false callBack&amp;&amp;callBack();//只要传了函数进来callBack为真&#125; 闭包里边的作用域被赋值给外面的变量占用了，不能释放。1234567891011var a = 9;function fn()&#123; a=0; return function(b)&#123; return b+a++; &#125;&#125;var f=fn()//占用 function(b)console.log(f(5))//输出5.f(5)执行后会销毁 全局a=1console.log(f()(5))//修改全局a=0 输出5 执行完后a++ 全局a=1console.log(f(5))//输出6 从fn到return之间的被保留 类数组 （arguments形参集合） 以0~n数字作索引 length arguments.callee是函数本身 严格模式不使用 arguments.caller 是fn 严格模式不使用 Array.from()将类数组转换成数组12function sum()&#123;console.log(arguments.callee.caller)&#125;function fn()&#123;sum(1,2,3,4)&#125; 立即执行函数IIFEfunction t (num){console.log(num)}(3) 浏览器的【全局作用域】是window,nodejs的全局作用域是globalvar a=1 给window加了属性 对象数据类型： 浏览器开辟内存空间分配一个16进制的地址， 内存空间存对象键值对 给对象变量存地址 任意数求和123456function fn()&#123; //类数组转化成数组 var ary = Array.prototype.slice.call(arguments); return eval(ary.join('+'))&#125;fn(12,23,34) 函数与对象的创建相同也是地址，函数把js代码当作字符串存到空间中 js中栈内存是作用域，用于执行代码，存放基本数据类型。堆内存用于存储键值对or函数字符串调用栈是连续空间。后进先释放，要节约栈空间。堆是链表。 变量提升：在当前作用域，浏览器把所有 带var的声明， 带function的声明并定义（defined赋值(代码字符串的地址)） 全局作用域var相当于给window加了属性 单例模式：团队合作防止全局变量污染：封装到对象内置类 htmlCollection元素集合类 123getElementByTagNamegetElementByClassNamequerySelectorAll NodeList 节点集合类 12getElementByTagNamechildNodes proto:HTML[Div]Element元素对象-&gt;HTMLElement-&gt;ELement-&gt;Node-&gt;EventTarget-&gt;Object 构造函数构造函数执行方式new fn() 普通函数 fn() this是window 123function fn(num)&#123; console.log(this)&#125; 调用构造函数时 this指向函数本身 输出：nfn的属性nnn:10构造函数过程：创建this实例，对this赋值并返回this并且每次new都是不同实例 12345function nfn(nnn)&#123; console.log(this) this.nnn=nnn;&#125;var ff = new nfn(10) 判断JS数据类型的4种方法js数据类型 typeof 无法区分正则和array 都返回object instanceof 检测当前实例是否属于这个类 .constructor（对象实例的constructor是类） Object.prototype.toString.call in/hasOwnPropertyhsOwnProperty是通过原型链检测是否是Constuctor的实例区别：Object.hasOwnProperty(&#39;hasOwnProperty&#39;) false&#39;hasOwnProperty&#39; in Object truehasOwnProperty用于检测私有属性in 私有共有都返回true共有：类提供，所有实例都能用 （静态方法） 原型和原型链类是函数，实例是对象。 函数的prototype属性是对象 实例的__proto__属性是对象 typeof Object “function” 所有的类都是函数类型Function instanceof Object -&gt;true 所有内置类String/Number 也是”function”类型 原型 三个自带的属性原型链：实例的__proto__是类的prototype prototype对象（原型对象）是所有函数的属性。存储了当前类给实例提供的公共属性和方法通过prototype定义类：使用new Person获得实例 1234567var Person = function()&#123;&#125;;//function Person()&#123;&#125;Person.prototype = &#123; name : 'ecmadao', sayName : function()&#123; console.log(this.name); &#125;&#125;; prototype对象，带constructor属性存的值就是函数本身（类） 每个对象都带__proto__属性，值是当前对象所属类的原型(prototype)1234function fun(num)&#123; this.num = num&#125;var f1 = new fun(10)fun.prototype=== f1.__proto__ //true 对fun.prototype添加的方法1fun.prototype.say = function()&#123;console.log("prototypesay")&#125; 对f1来说f1.hasOwnProperty(&#39;say&#39;) false . 是公共方法 fun.prototype.__proto__是Object.prototype Object.prototype没有__proto__ 有也指向自己 构造原型Fn.prototype = {} 会没有constructor,使用constructor:Fn 会导致原来使用Fn.prototype.c=function的属性被替换（可以遍历原有的克隆） 12var jQuery = function(selector,context)&#123;return new jQuery.fn.init(,)&#125;jQuery.fn = jQuery.prototype=&#123;constructor:jQuery,init:function(,)&#123;&#125;&#125; BOM document.querySelector(&quot;body&quot;).setAttribute(&quot;style&quot;,&quot;background-color:black&quot;);document.querySelector(&quot;body&quot;).style.cssText=&quot;background-color:black&quot;; https://chromium.googlesource.com/chromium/src/+/master/docs/es6_chromium.md 前端模块化 CommonJS CommonJS是不适用于浏览器端,因为文件是从服务器请求过来，不能同步加载模块。 浏览器模块化AMD规范：require.js非同步，指定回调函数浏览器中异步加载。可以并行加载多个模块。???如何并行？ CMD规范：按需加载sea.js ES6模块化 通过babel将不被支持的import编译为当前受到广泛支持的 require 加载过程defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后 虚拟DOM Virtual Node 用json构建，type\props\children{type:”div”,props:{“style:”},children:[]}vnodes-&gt;vdom 柯里化currying：函数式编程风格，组合函数123456789101112131415//两数相乘var multiple = function(a)&#123; return function(b)&#123; return +b*a+"" &#125;&#125;//拼接var concatArray = function(list,fct)&#123; return list.map(fct) .reduce(function(a,b)&#123; return a.concat(b) &#125;) &#125;//运行24concatArray(["1","2"],multiple(2)) Object.defineProperty 为对象定义属性 js对象or DOM对象 属性名 描述符： {value: “covergou”, writable: false, enumerable: true, configurable: false} 12let obj =&#123;&#125;Object.defineProperty(obj,"school",&#123;get:,set:&#125;) value:”name” writable:true/false 是否可写 configurable:false 删除属性、修改属性（writable, configurable, enumerable）的行为将被无效化 enumerable: true 是否能在for-in循环中遍历出来或在Object.keys中列举出来 get/set:function(){}使用get/set不能有writable和value属性 实现数据双向绑定数据劫持12345678Object.defineProperty(dom, 'translateX', &#123;set: function(value) &#123; var transformText = 'translateX(' + value + 'px)'; dom.style.webkitTransform = transformText; dom.style.transform = transformText;&#125;&#125;)dom.scale = 1.5; ES6数组类方法： Array.form(1,2,3,4)转成数组.from(3)生成空位 Array.of(3)与from用法相同，解决了单个值数组 toArray(1,2,3,4)转数组 原型方法（用于实例） .copyWithin(target,start,end) cool()函数丢失了同this之间的绑定var self = this 123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log( this.id ); &#125; &#125;; var id = "not awesome" obj.cool(); // 酷 setTimeout( obj.cool, 100 ); // 不酷 setTimeout中的this指向的是全局对象 var self = this function(){}.bind(this),1000 模板字符串 显示所有全局变量12for(name in this)&#123; vars+=name+"\n"&#125; 对象保护 对象代理 ES3,ES5 123456789//声明类var Person= fuction()&#123; var data=&#123; name='es3', sex:'male', age:15 &#125; this.get,this.set = function()&#123;&#125;&#125; es5:对象的只读属性Object.defineProperty(&quot;Person&quot;,&#39;sex&#39;,{ writable:false,value:&#39;male&#39; })只能读不能写 ES6用代理访问对象1234567let Person=&#123;:,:,:&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; target[key] &#125;, set(target,key,value) &#125;) 箭头函数import {}块状作用域 .map(function(v){return v+1}).map(v=&gt;v+1) 箭头函数内的this指向是定义时this的指向function中this指向是该函数被调用的对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[concurrent并发多线程]]></title>
    <url>%2F2018%2F04%2F13%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[dxdiag TreeMap是非线程安全的。跳表：数据大时性能高于红黑树123456789101112131415161718private transient volatile HeadIndex&lt;K,V&gt; head;static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125;static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile Node&lt;K,V&gt; next;&#125;static class Index&lt;K,V&gt; &#123; final Node&lt;K,V&gt; node; final Index&lt;K,V&gt; down; volatile Index&lt;K,V&gt; right;&#125; ConcurrentMap的实现类ConcurrentSkipListMap跳表 redis的实现方法1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); 线程池ThreadPoolExecutor1private final BlockingQueue&lt;Runnable&gt; workQueue; 工作队列（阻塞队列） 保护性暂时挂起模式不可变对象模式不可变对象如果对象作为key放入HashMap，对象状态变化导致HashCode变化，会导致同样的对象作为Key，get不到相关联的值。 所以不可变对象适合作为Key。电信服务商的路由表 模式应用：CopyOnWriteArrayList对集合加锁：不适合插入删除操作比遍历多的集合。CopyOnWriteArrayList 应用了不可变对象模式。不用锁的遍历安全。适用于遍历操作比添加删除频繁的场景。源码：加添元素时会复制123Object[] newElements = Arrays.copyOf(elements,len+1);newElements[len] = e;setArray(newElements); 线程池中线程数量过多，会竞争浪费事件再上下文切换。线程池大小与处理器利用率之比：$N_{threads}=N_{CPU}处理器核数*U_{CPU}期望的cpu利用率（0-1）*(1+W/C等待时间与计算时间的比率)$ Stream在背后引入Fork/join框架Future接口目标：实现并发，充分利用cpu的核，最大化程序吞吐量，避免因为等待远程服务返回/数据库查询。阻塞线程。对计算结果的建模，返回一个运算结果的引用给调用方。12345678910ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;Double&gt; future = executor.submit(new Callable&lt;Double&gt;() &#123; @Override public Double call() throws Exception &#123; //异步操作 return doSomeLongComputation(); &#125; &#125;); //异步操作运行同时也能执行 doSomeThingElse(); Fork/Join工作窃取算法 发布对象：可以得到成员变量引用对象溢出：内部类 AQS 两个node的队列MESI缓存一致性！！！M（Modified)被修改：只缓存在该CPU的缓存中，被修改，与主存不一致。写回主存Exlusive独享：缓存行只在该CPU的缓存中，未被修改，与主存一致。其它CPU读取内存时变成S状态。被修改则变成M。Share共享：该缓存行被多个CPU缓存，且与主存相同。当一个CPU修改时其它CPU的变成I。Invaild无效。 local read读本地缓存中数据local write写本地缓存remote read读取内存数据 remote write写回主存 Cache伪共享X86 cpu的cache line长64字节如果有一对象有成员变量long a,b,c(共24字节）则可能加载在一个cache line中。当 CPU1：线程1和cpu2：线程2 都从内存中读取这个对象放入自己的cache line1和2。当线程1写a则2上的cache line变成Invalid，当2要读b需要重新从内存中读。本来无关的两个线程，并行变成串行。 解决方法：将a,b分到不同的cache line 采用@Contended NUMA架构：内存分割，被CPU私有化：一致性协议MESIF：目录表message packmsgpack 并发模拟 PostMan-runner选中测试的接口iteration(并发多少次)delay(每次延迟多少) 安装apahce服务器bin下的ab -n 1000 -c 50 http://localhost:8080/test本次测试请求总数1000次，同时并发数50 1234567891011121314151617181920 并发量Concurrency Level: 50 整个测试所用的时间Time taken for tests: 0.667 seconds 完成的请求数Complete requests: 1000 失败请求数Failed requests: 0 所有响应数据长度总和，包括http头信息和正文数据长度，不包括http请求信息的长度Total transferred: 136000 bytes 所有正文数据长度HTML transferred: 4000 bytes 吞吐率（与并发数相关）=Complete requests:/Time taken for testsRequests per second: 1498.52 [#/sec] (mean) 用户平均请求等待时间Time per request: 33.366 [ms] (mean) 服务器平均请求等待时间Time per request: 0.667 [ms] (mean, across all concurrent requests) 单位时间从服务器获取的数据长度=Total transferred/Time taken for testsTransfer rate: 199.02 [Kbytes/sec] received JMeter 添加线程组File-Test Plan-Add-Threads- Thread Group用户数：50虚拟用户增长时长(Ramp-Up Period): 1Loop Count循环次数：一个虚拟用户做多少次测试 20（共1000次） 添加实例请求 add Sanper HttpRequest 添加监听器 图形结果、查看结果树 Option 打开Logviewer展开代码 Throughput吞吐量 用代码并发模拟123456789101112131415161718192021ExecutorService executorService = Executors.newCachedThreadPool();//同时的并发数final Semaphore semaphore = new Semaphore(threadTotal);//请求完之后统计结果 传入请求总数final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123;//超过了并发数add会被阻塞 semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error("exception", e); &#125;//闭锁 每执行完一次-1 countDownLatch.countDown(); &#125;); &#125;//保证闭锁到0再执行 countDownLatch.await(); executorService.shutdown(); log.info("count:&#123;&#125;", count);&#125; 通常与线程池一起使用 同步器Semaphore信号量 阻塞线程 控制同一时间请求并发量 适合控制并发数 Semaphore(int count)创建count个许可的信号量 每个线程：123//public void runsemaphore.acquire();//获取1/num个许可证semaphore.release();//释放许可 Semphore（2）则A,B,C三个线程，A执行完后C才能开始执行。 CountDownLatch()计数栓:必须发生指定数量的事件后才可以继续使用阻塞线程，直到满足某种条件线程再继续执行,计数值（count）实际上就是闭锁需要等待的线程数量 适合保证线程执行完再做其它处理 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 123void run()&#123;&#125;//主线程必须在启动其他线程后立即调用CountDownLatch.await()方法CountDownLatch.await();&#125;//等待锁存器 线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。 12345//倒计时为0执行main&#123; new CountDownLatch(3); CountDownLatch.countDown();//触发事件&#125; 面试题解释一下CountDownLatch概念?CountDownLatch 和CyclicBarrier的不同之处?给出一些CountDownLatch使用的例子?CountDownLatch 类中主要的方法? 汇编 jne有条件跳转 jmp无条件跳转进程-详细-设置相关性：分配到指定cpu执行，开的线程只在指定的执行java会把线程直接映射到操作系统 javac xxx.java-&gt;.classjavap -c -v xxx 查看虚拟机字节码 Condition1234567private Condition sufficientFunds;if (accounts[from] &lt; amount) //将该线程放到等待集 sufficientFunds.await();try&#123;////最后。账户发生变化，重新检查余额 sufficientFunds.signalAll();&#125; synchronizedjava每个对象有内部锁。并且该锁有一个内部条件12while (accounts[from] &lt; amount)wait();notifyAll(); final 匿名内部类中只能使用final？ 阻塞队列CAS(compareAndSwap)AtomicReference&lt;V&gt;模板，可以封装任何对数据加上时间戳解决ABA过程状态敏感问题（充值10，20，花费10if (money.compareAndSet(m, m + 20, timestap, timestap + 1))Pair&lt;V&gt; current = pair;第i个元素在数组中的偏移量123private static long byteOffset(int i) &#123; return ((long) i &lt;&lt; shift) + base;//左移2，00乘4 &#125; shift = 31 - Integer.numberOfLeadingZeros(scale); 29个前导0-&gt;shift=2 前导零：数字转换成二进制数后前面0的个数 数组当中每个元素有多宽：int scale = unsafe.arrayIndexScale(int[].class); 4 private static final int base = unsafe.arrayBaseOffset(int[].class); int的话4个byte 静态工厂方法 casPair使用cas的方式更新 1. .start开启新线程调用run .run不开启新线程两种创建方法1.传入一个runnable对象 2.覆盖runThread:123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 2. stop不建议使用，会释放所有的锁（monitor） 实例方法.interrupt()在run()中处理 123456public void run()&#123; while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125; Thread.yeild();&#125; 用Thread.sleep(2000)异常处理 sleep会释放cpu时间片，不释放监视器所有权。让给其它线程在外部对这个sleep的线程中断会抛出异常.isInterrupted方法可以清除中断状态 1234567891011 while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125;try&#123; Thread.sleep(2000);&#125;catch(InterruptedException e)&#123; //设置中断状态，抛出异常后会清除中断标记位 Thread.currentTread.interrupt();&#125; Thread.yeild(); &#125; 用自定义标记抛出异常 3. suspend &amp; resume 已弃用 If the target thread holds a lock on the monitor protecting a critical system resource when it is suspended, no thread can access this resource until the target thread is resumed.If the thread that would [resume] the target thread attempts to lock thismonitor prior to calling resume, deadlock results. Such deadlocks typically manifest themselves as “frozen” processes. 线程2resume线程1发生在线程1suspend之前，当线程1suspend之后没办法resume，导致线程1资源冻结。测试代码点击显/隐内容 1234567891011121314151617181920212223242526272829package learnThr;public class learnThread &#123; public static Object u = new Object(); static ChangeObjectThread t1 = new ChangeObjectThread("t1"); static ChangeObjectThread t2 = new ChangeObjectThread("t2"); public static class ChangeObjectThread extends Thread&#123; public ChangeObjectThread(String name)&#123; super.setName(name); &#125; @Override public void run()&#123; //加锁 synchronized (u)&#123; Thread.currentThread().suspend(); &#125; &#125; &#125; public static void main(String[] args)throws InterruptedException&#123; t1.start(); Thread.sleep(100); t2.start(); t1.resume(); t2.resume(); t1.join(); t2.join(); &#125;&#125; yield &amp; joinA.join(0)等待A结束后执行 用wait实现join实现 As a thread terminates the this.notifyAll method is invoked.It is recommended that applications not use wait, notify, ornotifyAllon Thread instances.不要在Thread实例上使用，会影响系统API wait该线程释放监视器所有权。 在同步方法中使用虚拟机实现notifyAll，在Object上。结束时会唤醒所有等待线程。12345if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; 守护线程t.setDaemon(true);虚拟机不会管守护线程是否存在，直接退出。 优先级12high.setPriority(Thread.MAX_PRIORITY);low.setPriority(Thread.MIN_PRIORITY); wait &amp; notify-Object.wait() 线程等待在当前对象上 The current thread must own this object’s monitor.releases ownership of this monitor and waits until another thread notifies -Object.notify()通知等待在这个线程上的对象 随机唤醒一个 Wakes up a single threadthat is waiting on this object’s monitor. 12synchronized (object) &#123; object.wait();&#125;synchronized (object) &#123; object.notify();&#125; 同步 synchronized独占加锁 java.util.concurrent 并发工具包 CyclicBarrier(int num)等待多个线程到达预定点 执行器 并发集合 Frok/Join框架：并行 atomic包：不需要锁即可完成并发环境变量使用的原子性操作 locks包]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F04%2F12%2Fperformance%2F</url>
    <content type="text"><![CDATA[浏览器解析 Firefox 规则树 CSS图像精灵 减少http请求次数服务端对静态文件gzip压缩使用css/js（内容不是很多）内嵌式减少http请求 JS和DOM的映射机制是浏览器的监听机制是，DOM操作会触发浏览器回流和重绘。减少css选择器前缀，使用组合名表示层级。避免使用css表达式 服务器多处理304缓存，客户端利用localStoreage将css/js存储在本地。少使用闭包，会产生不销毁的栈内存。内存泄漏。eval性能消耗大，压缩后会错乱。DOM事件绑定使用事件委托（代理），把事件绑定给外层容器，里面元素触发外层也触发（冒泡）。通过事件源判断做不同的操作。 用CSS3替代js动画，css3有硬件加速。减少css滤镜使用和页面flash。 CDN 效果最佳 数据懒加载 分页(后台) html渲染 外部资源在浏览器加载是并发加载，对于单个域名浏览器的并发度有限，设3-4个CDN域名，防止浏览器达到外部资源并发请求数目上限，导致资源不能并发请求。 css阻塞用link在head导入css会阻塞页面渲染，阻塞js执行，但是不阻塞外部脚本加载 js阻塞不用defer和async直接用&lt;script src&gt;会阻塞页面渲染，不阻塞资源加载，阻塞执行async 不会阻塞页面加载，放弃了js依赖关系 懒加载 zepto.js 图片 进入可视区域再加载，浏览器并发上限如果图片和静态资源在的cdn是同一个，图片加载会阻塞js加载 img的src并不是图片的url是只有1px的占位符，图片标签被放在data-url属性上，js监听scroll事件。 lazyload=true。触发时链接放到background-image中 dom上底边(clientHeight) 到页面顶部的距离小于 手机屏高 则可视 addEventListener(&#39;scroll&#39;,lazyload) 遍历所有懒加载标签document.querySelectorAll(&#39;div[lazyload]&#39;) 获取距离顶部的位置 12345element.getBoundingclientRect()&gt;document.querySelectorAll('img[src]')[0].getBoundingClientRect()//输出 DOMRect &#123;x: 0, y: 0, width: 0, height: 0, top: 0, …&#125;&gt;document.querySelectorAll('img[src]')[99].getBoundingClientRect()//输出 DOMRect &#123;x: 835, y: -1604, width: 22, height: 22, top: -1604, …&#125; NodeList，它里面没有.forEach方法 123456789Array.prototype.forEach.call(nodes,function(item,index))&#123;var image = new Image()//请求图片资源image.src=dataurl//赋值到item上image.onload = function()&#123;item.src = img.src&#125;item.removeAttribute('data-original')item.removeAttribute('lazyload')&#125; 预加载preloadjs 九宫格抽奖 style=&quot;display:none&quot; 使用new Image() XMLhttpRequest2加了对请求过程的监控xmlhttprequest.onprogress 会有跨域问题123456789var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callback;xmlhttprequest.open("GET",".jpg",true)xmlhttprequest.send() //请求返回时会 onreadystatechangefunction callback()&#123; if(xmlhttprequest.readyState==4&amp;&amp;xmlhttprequest.status==200)&#123; var responseText = xmlhttprequest.responseText; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F04%2F11%2Fwebpack%2F</url>
    <content type="text"><![CDATA[npm init 生成package.json文件 npm i webpack 新建build文件夹 放配置文件 webpack.config.js: 仍出一个webpack配置对象module.exports = { } entry 入口文件 防止系统差异引用const path= require(&#39;path&#39;) app:path.join(__dirname,&#39;../app.js&#39;):__dirname 当前文件夹 output:{filename:&#39;[name].[hash].js} 中括号表示变量,[name]表示entry下对应的名字,加上打包后的hash值，有任何文件改动hash变化，浏览器刷新缓存 publicPath:”” (js,css404:”/“绝对路径，”./“相对路径)静态资源引用时的路径，区分静态资源还是api请求，如果部署到CDN，写CDN前缀 配置moudle识别jsxtest后面跟正则表达式（以jsx的）表示文件类型loader是编译工具，编译成ES5 安装babel-core 1234moudle:&#123;rule:[ test:'/.jsx$/'， loader：'babel-loader' ]&#125; 配置babel（默认编译ES6）的配置文件.babelrc presets 支持的语法 123456&#123; "presets":[ ["es2015",&#123;"loose":true&#125;], "react" ]&#125; 用松散模式编译ES6,用react语法 安装babel的3个包 安装html-webpack-plugin -D并 require 能生成一个html页面把entry里的都注入，路径根据output 123plugins:[new HTMLplugin()] 没有启动服务器没有做路径映射所以访问不到js文件将publicPath设置为’’变成相对路径react的js文件也需要babel但是nodemodules里面都是js 1234567&#123; test:/.js$/, loader:'babel-loader', exclude:[ path.join(_direname,'../node_modules') ]&#125; 服务端渲染：单页js写的应用SEO不友好、请求时间长webpack.config中的内容复制到webpack.config.servertarget:&#39;node打包完在哪执行可以是node/web（浏览器 entry:app： export default的js libraryTarget：’AMD’ 模块加载方案 nodejs：commonjs2 服务端渲染不需要htmlplugin rimraf dist 是nodejs的包 专门用来删除文件夹 moudle.exports nodejs的导出方式 commonjs2 的写法 export default。 require的时候加.default 将node启动后渲染出server.js的插入html 新建html文件new HTMLPlugin({template:path.join(__dirname,&#39;../client/template.html&#39;)})生成的html以template为模板 server端读template文件 同步读12const template = fs.readFileSync(path.join(,index.html),'utf8')res.send(template.replace('&lt;app&gt;&lt;/app&gt;'),appString) Webpack-dev-server安装 contentBase:静态文件地址 hot启动 hot-module-replacement 数据请求也刷新？ 黑色弹窗报错overlay:{ errors:true } cross-env不同系统环境变量配置 mac上可执行的在windows上可能不行 historyApiFailback:{index:’/index.html’404路径返回index webpack.bace放client和server相同的js代码 hot-module-replacement 在babel配置文件中配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[mySQL]]></title>
    <url>%2F2018%2F04%2F08%2Fmysql%2F</url>
    <content type="text"><![CDATA[timestamp有时区datetime表示的时间范围更广，一般应用不会跨时区。 压力测试1mysqlslap -hlocalhost -uroot -proot -P3306 --concurrency=5000 --iterations=1 --auto-generate-sql --auto-generate-sql-load-type=mixed --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=5000 --debug-info 5000并发，6秒10000并发每次10000查询 会提示 1w并发单集群的mysql不行，需要集群2003 Can’t connect1040Too many connectionsmysql单表数据量小于2千万 mycat可以集群分片 mybatis逆向工程generatorConfig.xmlexplain执行计划 ：select,update,insert,replace,delete 分区show plugins;可以看到partition 则可以分区。逻辑上一个表，物理上多个文件中。在create table的最后加上partition by hash(id) partitions 4.frm存储表数据.ibdinndb数据文件分区之后.ibd会有好几个 hash分区 利用表中的int列或者by hash(UNIX_TIMESTAMP(login_time))将timestamp转成intrange分区 log推荐使用 日期/时间 查询的时候包含分区键 适合定期清理历史数据1234partition by range(id)( partition p0 values less than(10000), partition p1 values less than(20000), partition p3 values less than maxvalue); list分区 按枚举123partition by list(type)( partition p0 values in (1,3,5,7,9), partition p1 values in (2,4,6,8)); 到了新的一年添加分区1alter table t1 add partition (partition p4 values less than(2018)); 删除分区1alter table t1 drop partition p0; 归档新建一个和t1结构相同的 非分区表t2 .一般迁移后删除分区，切换归档表的存储引擎分区表只能查询不能写 分区表梗适合用mysam引擎123alter table t1 exchange partition p0 with table t2;#--drop之后切换引擎alter table t2 ENGINE=ARCHIVE; password用char(32)timestamp on update CURRENT_TIMESTAMP字段会在表被修改时自动更新 Mybatis mybatis-3-config.dtd: 可以用&lt;properties&gt;导入配置文件在&lt;mappers&gt;里可以用&lt;package&gt;导入整个有mapper.xml的文件夹 mybatis-3-mapper.dtd&lt;typeAliases&gt;中添加&lt;package&gt;自动扫描包，将类名作为别名 PageHelper.orderBy(&quot;price desc&quot;)按价格降序（sql中的order by 之后的格式） mysql like通配符% 任意多个字符 ER图矩形：实体特化：自顶向下继承设计概化：底向上菱形：联系集：把多对多变成1对多 用虚线连接联系集的属性 双线：全参与：表示在联系集中的参与度&lt;advisor&gt;=student表示每个学生都要有导师，双边菱形：表示弱实体集和它依附的实体集。当弱实体集里放入依赖的实体集的id，则不需要联系集 椭圆：属性角色：&lt;先修课联系集&gt;和[课程]的联系通过course_id和prereq_id角色标识区分派生属性：可以通过其它属性计算得到复合型属性应该拆分成2个属性多值型（一个老师对应多个电话）应该用另一个(id,phone)(1,phone1)(1,phone2)每个属性映射到单行映射基数：1：1，1：n,n:1,n:n基数约束：导师&lt;-&lt;advisor&gt;-学生 一对一：箭头从关系指向实体：导师&lt;-&lt;advisor&gt; 一名学生只有一名导师 一对多：没有箭头表示多端，有箭头表示“一”端 &lt;advisor&gt;-学生 一名老师可以有多名学生。导师 0..* &lt;advisor&gt; 1..1 学生 参与的上限..下限，0表示老师参与的下线是0，不是全参与，是半参与。 天然的三元关系 导师 项目 学生 通过一个联系集不能拆分成2个二元关系。 什么时候作为实体:instructor/ins-phone/phone三张表什么时候作为属性instructor(phone) 只对名字和单值（不是多值（对应多个电话））感兴趣则为属性：性别。 一个对象除了名字意外，还有其它属性要描述则定义成实体：电话、住址、部门。 是实体集还是用联系集（对象之间的动作）：考虑映射的基数customer-&lt;loan&gt;-branch 但是当要表示一个客户在一个银行里多笔贷款customer-&lt;borrow&gt;-loan(实体)-&lt;Loan-bra&gt;-branch客户与贷款多对多，贷款对支行一对多。 用属性student(supervisior-id,supervisior-name)还是用联系集&lt;stu-sub&gt;,&lt;stu-class&gt; innodb有索引组织表 IP地址字符串转intINET_ATON(&#39;255,255,255,255&#39;)=4292967295(无符号int最大值)INET_NTOA(&#39;4292967295&#39;)=’255,255,255,255’Varchar(255)utf-8汉字3个字节 总共765字节避免使用TEXT64k,BLOB 可以用varchar mysql内存映射表不持支，所以排序只能用磁盘映射表 timestamp只能存到2038年01-19 decimal精确浮点类型 预编译语句 每次执行只需要传递参数 节省带宽12345prepare stmt1 from 'select sqrt(pow(?,2)+pow(?,2)) as hypotenuse';set @a=3;set @b=4;execute stmt1 using @a,@b;deallocate prepare stmt1 将where date(ctime)=&quot;20160901&quot;改成where ctime&gt;=&#39;20160901 and ctime&lt;&#39;20160902可以使用索引 第三范式 不存在 传递函数依赖关系 名字可以决定分类；分类可以决定分类描述 则存在非关键字段 分类描述 对名称的依赖 范围查询会使联合索引失效 要把范围查询的表放到索引右侧使用leftjoin/not exists代替 not in（会使索引失效 索引列的循序 区分度(列中唯一值数量/总行数)高的放在联合索引左边不使用外键 外键用于数据参照完整性（数据一致性）但是降低写性能，可以用其它方式保证一致性 但是要在表之间的关联键上建立索引 慢查询开启慢查询日志 SQL监控1show variables like 'slow_query_log'; 记录没有使用索引的sqllog_queries_not_using_indexes 变量123show variables like '%log%';set global log_queries_not_using_indexe=on;set long_query_time = 1; long_query_time超过多少秒之后的查询记录在日志中查看慢查询日志的位置1show variables like 'slow%'; 慢查询分析工具mysqldumpslowcount(1)和count(*)和count(*)count(1)比count（*）效率高一些123create table t(id int);insert into t value(1),value(2),(null);select count(*),count(id),count(1) from t; count(*) count(id) count(1) 3 2 3 内置类型now() 数据类型 int(11)和int(21)都占4个字节，区别在于补零位数 123create table t(a int(11) zerofill, b int(21) zerofill);insert into t values (1, 1);select * from t; char和varchar存储字符数。 char 存储255个字符，varchar根据类型计算字符数，上限是65535个字节 char会自动补空，varchar&lt;=255用一个字节&gt;255用两个字节存储长度length desc 查看表结构 mysql join inner join内连接，两张表的公共部分 数据库会先在每个表里先查条件再生成笛卡儿积select a.name from a A inner join b B on A.name =B.name; left outer join左外连接，以左表为基础 内链接当左表中查询条件是null的时候被忽略，外连接则有用左外连接查询只存在A中不存在B中的where B.Key is NULL (优化not in不会使用索引)select * from b left outer join a on a.name =b.name where a.Id is null; right outer joinselect * from a right outer join b on a.name =b.name where a.Id is null; full join count(*),min(p.&#39;price&#39;) group by p.&quot;id&quot;,&quot;name&quot;数据库Myisam表锁 -&gt; Innodb 行锁 从大锁到小锁提升并行度MyISAM引擎不持支事务，优点是读写快,列存储5.5之前的默认Innodb支持事务ACID 行级锁，高并发场景好 JDBCstatic final String JDBC_DRIVER=&quot;com.mysql.jdbc.Driver&quot;; close放在finally里，保证执行 防止空指针异常 12345finally&#123; if(conn!=null)conn.close(); if(stmt!=null)stmt.close(); if(rs!=null) rs.close(); &#125; 游标：读取记录太多，内存放不下。DB_URL:useCursorFetch=true 1static final String DB_URL ="jdbc:mysql://localhost/scraping?characterEncoding=utf8&amp;useCursorFetch=true&amp;useSSL=true"; ptmt=conn.prepareStatement(sql); 每次从服务器端取回记录的数量ptmt.setFetchSize(1); rs = ptmt.executeQuery(); 流方式:记录中存在大字段内容：博文。读一条记录内存可能放不下。 变成二进制流读取小区间 InputStream in = ResultSet.getBinaryStream(&quot;blog&quot;) 在外部生成一个文件，每次读取一行输出到外部文件1234567File f = new File(FILE_URL);OutputStream out = null;out = new FileOutputStream(f);int tmp = 0;while((tmp= in.read)!==-1)out.write(tmp);in.close();out.close(); 连接池 DriverManager.getConnection流程客户端利用密码种子和自己保存的数据库密码按加密算法得到加密密码 每个线程使用数据库连接后不销毁，每个请求从连接池中【租借】连接 数据库服务器端处理请求时要分配资源，请求结束后被释放。服务器设置最大并发连接数。抛toomanyConnection异常。应在客户端中实现业务线程排队获取数据库连接。 DBCP是一组jar包：commons-dbcp,jar,commons-pool.jar,commons-logging.jar dbcp重写了Connection的close方法，把销毁数据库连接改成了归还给连接池 12345678public static void dbpoolInit()&#123; db = new BasicDataSource(); db.setUrl(DB_URL); db.setDriverClassName(JDBC_DRIVER); db.setUsername(USER); db.setPassword(PASSWORD); db.setMaxTotal(2);&#125; 优化连接池 提高第一次访问数据库的速度，在连接池中预制一定数量的连接.setInitialSize(1) .setMaxTotal()设置客户端的最大连接数，超过的不创建新连接，而是进入等待队列 .setMaxWaitMillis()设置最大等待时间 .setMaxIdel()空闲连接数的最大值，超过则销毁 setMinIdel()空闲数低于则创建，建议于MaxIdel相同 DBCP定期检查，服务端会自动关闭空闲连接，连接池可能租借失效的连接 定期检查连接池中连接的空闲时间 开启.setTestWhileIdel(True) 应该销毁的最小空闲时间.setMinEvictableIdleTimeMillis() 检查的时间间隔,应小于服务器自动关闭连接的时间（Mysql 8小时).setTimeBetweenEvictionRunsMillis() Mysql show processlist;查看连接数 防范SQL注入&#39;-- 参数化sql conn.prepareStatement(sql)传入格式化sql,需要传入的参数用？占位 1Select * from user where userName = ? And password=? 传入参数ptmt.setString(1,username) 参数位置从左往右1开始 数据库权限、封装数据库异常 mysql AES_ENCRYPT/AES_DECRYPTstring加密/解密 事务：单个逻辑工作单元执行的一系列操作，逻辑工作单元满足ACID(原子、一致、隔离、持久) ，并发控制的基本单位。1234567try&#123;Connection.setAutoCommit(false)//开启事务Connection.commit()//提交事务Connection.rollback()//事务回滚&#125;catch(SQLException e)&#123; if(Connection!=null)Connection.rollback()&#125; 检查点12Savepoint sp = Connection.setSavepoint();Connection.rollback(sp); 事务的隔离级别 脏读：一个事务读取了一个事务未提交的更新 不可重复读：同一个事务，两次读取值不一样。 幻读：同一个事务，两次读取行记录数目不一样。插入了新记录 隔离级别 脏读 可重复读 幻读 读未提交 √ X √ 读提交 X X √ 可重复读 X √ √ 串行化 X √ X 读未提交：允许脏读 读提交：不允许脏读，可以不可重复读 重复读：可能出现幻读。 MySQL的事务隔离级别。 1set 串行化：最高隔离级别，所有事务串行执行，不能幻读。 设置和获取事务隔离级别12Connection.getTransactionIsolation()Connection.setTransactionIsolation() MySQL的锁 排他锁X：与任何锁都冲突，等待。（写锁） 共享锁S：多个事务共享一把锁。其它事务不会被阻塞。（读锁）加锁方式 外部加锁：SQL语句 共享 select * from table lock in share mode 排他 select * from table for update 内部自动加锁 加锁粒度和策略：表锁table lock：开销少；行锁（row lock): innoDB MySQL所有的select读都是快照读。存储引擎Innodb实现了多版本控制（MVCC)，不加锁快照读。所以一个事务内部保证select数据一致要外部加锁 MVCC 在每行记录后面保存两个隐藏的列：行创建时间，过期时间。通过版本号记录时间，每开始新的事务，系统版本递增。 Update 对行加排他锁X 分析MySQL处理死锁：show engine innodb status Mybatis 底层基于JDBC SqlSessionFactory实例能将对象操作转换成数据库操作事务管理器transactionManager type = &quot;jdbcdataSource驱动、url、用户名、密码 对象类、操作接口 映射文件&lt;mapper namespace = &quot;操作接口&quot;&gt; 将映射文件加载到配置文件&lt;mappers&gt;&lt;mapper resource=&quot;&quot;&gt; 测试123456789101112131415161718192021public static void main(String[] args) &#123; // 1. 声明配置⽂文件的⺫⽬目录渎职 String resource = "confAnnotation.xml"; // 2. 加载应⽤用配置⽂文件 InputStream is = HelloMyBatisAnnotation.class.getClassLoader().getResourceAsStream(resource); // 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder() .build(is); // 4. 获取Session SqlSession session = sessionFactory.openSession(); try &#123; // 5. 获取操作类（接口） GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class); // 6. 完成查询操作 User user = getUserInfo.getUser(11); System.out.println(user.getId() + " " + user.getUserName() + " " + user.getCorp()); &#125; finally &#123; // 7.关闭Session session.close(); &#125; &#125; 在操作接口上用注解@select ResultMap 构造方法 mapper.xml1234567891011&lt;resultMap id="UserMap" type="com.micro.profession.mybatis.resultMapTest.User"&gt; &lt;constructor&gt; &lt;idArg column="userId" javaType="int" /&gt; &lt;arg column="userName" javaType="String" /&gt; &lt;arg column="corp" javaType="String" /&gt; &lt;/constructor&gt; &lt;collection&gt; &lt;association&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F04%2F04%2Fcanvas%2F</url>
    <content type="text"><![CDATA[创建1. canvas正确绘制时，标签内容会被忽略 不能在css中定大小123&lt;canvas id="canvas" width="800" height="600" style="border: 1px solid red;"&gt; 当前浏览器不持支Canvas&lt;/canvas&gt; 2. 判断当前浏览器12345678window.onload= function()&#123; var canvas = document.getElementById('canvas') if(canvas.getContext("2d")) &#123; var context = canvas.getContext('2d') &#125;else&#123; alert("当前浏览器不支持canvas") &#125; &#125; 3. 设置画布大小不需要px12canvas.width=1024canvas.height=768 4. 画路径:.colsePath不是封闭路径时 会自动封闭1.begin 重新规划2.close 自动封闭3..arc(圆心坐标x,y,半径r,开始弧度起始点,结束弧度起始点,是否逆时针false)12345678for(var i = 0;i&lt;10;i++)&#123; context.beginPath() context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10) //只使用beginPath不使用closePath就不会有封闭线段 context.closePath() context.stroke() //下一次.bgeinPath会重新规划路径&#125; 5. context.fill()会把边框内测一半像素覆盖，fill写在路径和stroke中间1234context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10)context.fillStyle= "yellow"context.fill()context.stroke() 6. 矩形 路径：.rect(左上角坐标x,y,width,height) 直接绘制： 填充、边框.fillRect(x,y,width,height).strokeRect(x,y,width,height) 7. 线条两端属性lineCapcontext.lineCap=&quot;round&quot; 超出原来的长度的部分是圆形context.lineCap=&quot;squre&quot; 8. 画星 5个角，一个角隔72° 大圆半径300，小圆半径150123456789context.beginPath()for(var i =0;i&lt;5;i++)&#123; context.lineTo(x=Math.cos((18+i*72)/180*Math.PI)*300+400, y=-Math.sin((18+i*72)/180*Math.PI)*300+400) context.lineTo(x=Math.cos((54+i*72)/180*Math.PI)*150+400, y=-Math.sin((54+i*72)/180*Math.PI)*150+400)&#125;context.stroke()context.closePath() 9. lineJoin 线段连接处bevel线条顶端不会衍生自然形成尖角，形成纸带折叠效果context.lineJoin=&quot;miter&quot; context.miterLimit=0.01内角和外角的最大值。超过则使用bevel显示 10. 保存绘图状态,图形变换时123context.save() context.translate(100,100)context.restore() 11. 与鼠标事件交互 down up out move1234567891011121314151617181920var isMouseDown = falsecanvas.onmousedown=function (e) &#123; e.preventDefault() isMouseDown= true&#125;canvas.onmouseup=function (e) &#123; e.preventDefault() isMouseDown= false&#125;//按着画布出画布也是不想画canvas.onmouseout=function (e) &#123; e.preventDefault() isMouseDown= false&#125;canvas.onmousemove=function (e) &#123; e.preventDefault() if(isMouseDown== true)&#123; 画图() &#125;&#125; preventDefault在pc端作用不大，移动端和键盘操作例如：小游戏中的角色运动：上下，同时是浏览器上下移动翻页操作 1. 转换鼠标位置为相对canvas内的位置1234 function window2canvas(x,y)&#123; var canvasbox = canvas.getBoundingClientRect() return &#123;x:Math.round(x-canvasbox.left),y:Math.round(y-canvasbox.top)&#125;&#125; 2. 鼠标移动在canvas上画 onmousemove执行频繁只要绘制直线就能达到曲线 设置变量记录上一个位置var lastLoc = {x:0,y:0} down时记录lastloc,move记录currentloc 123context.moveTo(lastLoc.x,lastLoc.y)context.lineTo(curloc.x,curloc.y) //context.stroke()lastLoc = curloc 平滑移动 12context.lineCap = "round"context.lineJoin = "round" 笔压:速度 = 距离/时间 距离 12function calculateDistance(loc1,loc2) &#123; return Math.sqrt((loc1.x-loc2.x)*(loc1.x-loc2.x)+(loc1.y-loc2.y)*(loc1.y-loc2.y))&#125; 时间var lastTimestamp =0 mouseover:var curstamp = new Date().getTime()var timedif = curstamp-lastTimestamp 宽度1234567891011121314151617function calLineWidth(t,s) &#123; var width var speed = s/t //1. 速度最小，宽度最大 if(speed&lt;=0.1) width= MAXWIDTH //2. 速度很大，宽度最小 else if (speed&gt;10) width = 1 //3. 中间宽度：（当前速度-最小速度）/（最大速度-最小速度）*宽度取值范围 else width = MAXWIDTH- (speed-0.1)/(10-0.1)*(MAXWIDTH-1) console.log(width) if (lastWidth==-1) return width else width = lastWidth*4/5+width*1/5 lastWidth = width return width &#125; 清除画布 context.clearRect(0,0,canvasWidth,canvasHeight) 12. 移动端自适应1234567&lt;meta name="viewport" content = "height = device-height, width = device-width, initial-scale = 1.0, minimum-scale = 1.0, maximum-scale = 1.0, user-scalable=no"/&gt; 13. 触控touch时间 start move end touch = e.touchs[0]从多点触控TouchList中获取touch clientX/Y -&gt;Y:568 pageX/Y -&gt;Y:650 将 e.x/y封装到point.x/y 1234567 canvas.addEventListener("touchmove",function(e)&#123; e.preventDefault() if(isMouseDown) touch = e.touches[0] moveStroke(&#123;x:touch.pageX,y:touch.pageY&#125;)&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2018%2F04%2F02%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx1. 环境 基本库yum -y install gcc gcc-c++ autoconf pcr^Cpcre-devel make automake 工具yum -y install wget httpd-tools vim 确认yum源可用yum list|grep gcc 关闭iptables规则iptables -L iptables -F 停用selinuxgetenforce setenforce 0 cd /opt mkdir 重启 nginx -s reload IO多路复用 使用epoll模型Linux文件描述符 文件描述符（file descriptor 是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。sysctl -a|grep fs.file-max系统级别的最大打开文件数ulimit -n 单个进程最大打开文件数 每一个文件描述符会与一个打开文件相对应，不同的文件描述符也会指向同一个文件。 rpm -ql nginx rpm包有哪些配置文件/usr/share/nginx/html HSTS（HTTP Strict-Transport-Security） 是Web安全策略机制（web security policy mechanism）HSTS： 建立起HTTPS连接之前存在一次明文的HTTP请求和重定向（上图中的第1、2步），使得攻击者可以以中间人的方式劫持这次请求，从而进行后续的攻击，例如窃听数据，篡改请求和响应，跳转到钓鱼网站等。 攻击者直接劫持了HTTP请求，并返回了内容给浏览器，根本不给浏览器同真实网站建立HTTPS连接的机会 当用户让浏览器发起HTTP请求时，浏览器将其转换为HTTPS请求，直接略过上述的HTTP请求和重定向，从而使得中间人攻击失效，规避风险。 HSTS 响应 Header：让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload] max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。 ncludeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。 preload是可选参数，只有当申请将自己的域名加入到浏览器内置列表的时候才需要使用到它 对于启用了浏览器HSTS保护的网站，如果浏览器发现当前连接不安全，它将仅仅警告用户，而不再给用户提供是否继续访问的选择 第一次访问：Preload List： 在浏览器里内置一个列表，只要是在这个列表里的域名，无论何时、何种情况，浏览器都只使用HTTPS发起连接。这个列表由Google Chromium维护，FireFox、Safari、IE等主流浏览器均在使用。 nginx: hstsadd_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always; 一旦浏览器接收到HSTS Header（假如有效期是1年），但是网站的证书又恰好出了问题，那么用户将在接下来的1年时间内都无法访问到你的网站，直到证书错误被修复，或者用户主动清除浏览器缓存。先将max-age的值设置小一些]]></content>
  </entry>
  <entry>
    <title><![CDATA[cryption]]></title>
    <url>%2F2018%2F03%2F27%2Fcryption%2F</url>
    <content type="text"><![CDATA[安全报文摘要：固定长度的摘要 类似消息验证码MAC关键：找到两段内容不同而摘要相同的数据在计算上是不可能的 消息验证码MAC：计算过程用了密钥javax.crypto.Mac 数据用散列函数计算出消息验证码HMAC 消息验证码加载原始数据后 用密钥对整个数据加密后传输 数字签名security.Signature 用于验证身份A要验证B的身份： B用私钥对消息加密发送给A A用公钥解密 SSL协议 身份验证（钓鱼网站）数字签名证书 数据窃取：数据传输加密 数据串改：数据+消息验证码，接收者完整性验证流程 客户端向服务器确认SSL协议和加密算法。（可请求验证服务器身份） 服务器 发送数字签名给客户端 也可以向客户端验证身份 客户端用私钥对自己的数字证书加密发送给服务器。生成[数据传输]用的密钥，用服务器的公钥加密发送给服务器。（数据传输是对称加密，客服端和服务器使用相同密钥） 服务端验证完客户端身份，切换到数据传输直到关闭。 数字证书=身份信息+公钥。被信任机构的私钥加密，浏览器公钥验证证书合法。HTTPSRSA 非对称加密算法： 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 n = a*b(a，b质数) n-&gt;二进制位数为密钥长度（1024） 计算n的欧拉函数φ(n) 选择65537 or 其它小于φ(n)并与φ(n)互质的整数e 计算e对φ(n)的【模反元素】dex + φ(n)y = 1求解数对x,y中的x扩展欧几里得 (n,e)为公钥(n,d)为私钥 当n被因式分解，d可以算出 被破解 AES安全漏洞Network-Doc http请求 Referer 防止CSRF漏洞 http响应 302 跳转 Location:跳转地址 Set-Cookie:颁发凭证 Application 查看Cookie BOM document.cookie 添加cookie document.cookie=”aaaa” window.location.href获取页面URL window.navigator.userAgent 获取浏览器信息 window.open(“http://baidu.com&quot;) 打开页面 XSS漏洞测试prompt(,)提示弹窗 WEB服务架构 SQL union 连接两个select 不显示重复的；union all socket路径：show global variables like ‘socket’; 客户端：XSS(跨站脚本注入):CSRF(跨站请求伪造) 点击劫持，URL跳转服务端：SQL注入 命令注入 文件类操作 XSS漏洞：Cross Site Script存储型 反射型 DOM型 存储型 &lt;img src=&quot;#&quot; onerror=&quot;alert()&quot;&gt;写在评论框，发送给后台 图片加载失败触发onerror事件 XSS 脚本存储在数据库中 反射型 后端写入url的参数中 ?name = &lt;image src = @ onerror= alert()&gt; DOM型window.location.hashurl的hash中#后面的值填到innerHTML CSRF（XSRF）用已登录身份以用户名义非法操作&lt;body onload = &quot;sbm()&quot;页面加载自动提交表单smt(){ .getbyID(&quot;id&quot;).submit()调用表单提交form表单提交有明显页面跳转，将恶意页面用iframe嵌入 width,height=0防止触发查看源代码： view-source:url 点击劫持 UI覆盖攻击用iframe设置height,width:100%,opaocity:0;z-index=2;将iframe上的提交按钮隐藏在页面按钮之下 url页面跳转META跳转 等待5秒后跳转?url = 短链接1&lt;meta http-equiv = "Refresh" content = "5;url&lt;?php echo $url?&gt;" SQL注入mysql注释--闭合、注释 where name = ‘admin&#39;-- and passwd = ‘’数据和代码未分离 union 查看mysql版本 2. 用户名和密码 DOS命令 net user用户名]]></content>
      <tags>
        <tag>cryption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apriori_FP]]></title>
    <url>%2F2018%2F03%2F24%2FApriori-FP%2F</url>
    <content type="text"><![CDATA[Apriori 算法 频繁项集：经常出现在一块的物品的集合； 关联规则（association rules）暗示两种物品之间可能存在很强的关系。 频繁的定义：支持度、可信度 支持度：项集{豆奶，尿布}在记录中的出现频率有多少比例的交易记录包含该集合 confidentce： 关联规则{尿布}-&gt;{葡萄酒}的可信度为：“支持度({尿布, 葡萄酒})/支持度({尿布})”。 表示对于包含”尿布”的规则，规则对其中（可信度）%的记录适用。 原理 假设想找到支持度大于0.8的所有项集；4种物品的集合要遍历数据15次 对于包含N种物品的数据集共有2N-1种项集组合。 连线表明两个或者更多集合可以组合成一个更大集合 某个项集是频繁的，那么它的所有子集也是频繁的 算法 发现频繁项集：输入：最小支持度，数据集 生成候选集 从{1个元素集合}计数数据集中出现次数 算每个元素出现频次，超出阈值的保留 按计算k=2;k-2求k-2个项相同的并集 12a[:k-2]==b[:k-2].append(a|b)#|set的并，出现在a或b中的元素#a.union(b) 计算{2个元素的集合}的频率(1、2) //+1个元素的集合 当3.的并集为空 得到 #L[0] 1项的频繁集[1]两项 [2]3项的 [3]4 [4]空集#都是支持度超过support的子集 关联规则： 有一个频繁项集{豆奶, 莴苣}，那么就可能有一条关联规则“豆奶 ➞ 莴苣”。P ➞ H的可信度定义为support(P | H)/support(P)。 生成一个可能的规则列表，然后测试每条规则的可信度。如果可信度不满足最小要求，则去掉该规则。 从一个频繁项集开始，接着创建一个规则列表，其中规则右部只包含一个元素，然后对这些规则进行测试。接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。这种方法也被称作分级法。 FP-growth FP树-频繁集-自动补全 FP只需要对数据库进行两次扫描，Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁， FP树（频繁模式（Frequent Pattern））编码数据集 一个元素项可以在一棵FP树中出现多次。 FP树会存储项集的出现频率，而每个项集会以路径的方式存储在树中。 存在相似元素的集合会共享树的一部分。 算法 对原始数据集扫描两遍。第一遍对所有元素项的出现次数进行计数。 只考虑频繁元素]]></content>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alg]]></title>
    <url>%2F2018%2F03%2F24%2Falg%2F</url>
    <content type="text"><![CDATA[伪多项式时间一个整数是否是素数123def isPrime(n): for i in range(2,n): if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ 97 s1和s2是否交错组成s3Solution状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中任意位置s3[i]一定是由s1[m],s2[n]组成的s1=”aa bc c”s2=” db bca”s3=”aadbbcbcac”dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况遍历s3的位置： 遍历s1的长度，s3+1-s1为s2的长度 如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了 ||s3当前与s1当前匹配并且dp[s1-1][s2]: dp[s1][s2] = true可以用滚动数组降成1维 ？？？按背包问题递减更新 99%ct的意义动态规划中的ct123456789101112131415161718public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1.length() + s2.length() != s3.length()) return false; boolean[] dp = new boolean[s1.length() + 1]; dp[0] = true; for (int i = 0; i &lt; s3.length(); i++) &#123; boolean ct = true; for (int j = Math.min(s1.length(), i + 1); j &gt; 0; j--) &#123; if (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = false; else if (dp[j - 1] &amp;&amp; s1.charAt(j- 1) == s3.charAt(i))&#123; dp[j] = true; ct = false; &#125;else dp[j] = false; &#125; if(dp[0]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = false; if(ct)return false; &#125; return true;&#125; 62 从左上角走到右下角总共有多少种不同方式f[m][n] = f[m-1][n]+f[m][n-1]简化成一维dp1234567891011public int uniPath(int m,int n)&#123; int[] res = new int[n]; for(int i =0;i&lt;m;i++)&#123; //一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法 for(int j =1;j&lt;n;j++)&#123; //加上左边走过来的走法 res[j]+=res[j-1]; &#125; &#125; return res[n-1];&#125; !数学公式m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。$C_{m+n-2}^{m-1}$12345long rst=1;for(int i =0;i&lt;Math.min(m-1,n-1);i++)&#123; rst=rst*(m+n-2-i)/(i+1);&#125;return (int)rst; 63 有障碍物的左上到右下dp[i][j]定义为走到i,j的方法数，障碍物则为01if(obs[i][j]==1)continue;//dp[i][j]=0//res[j]=0; 64 从左上角走到右下角的最少sumgrid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]); 32 括号字符串中合法的括号对1.stack:栈底放-1，当栈空&amp;&amp;读到是’)’将’)’的index当栈底。每次读到’)’弹栈，并更新i-peek()，因为peek为没消掉的’(‘的前一个位置2.从左向右扫描，当左括号数==右括号数更新max，当右括号&gt;左括号置0. 从右向左扫描，同理更新max，当左括号&gt;右括号重置0. ？96 不同的BST数量(为什么是乘)1个节点只有1种，2个节点1 2 一共两种 \ / 2 13个节点1 2 3 / \ / \ / \ （0）(2) (1)(1) (2)(0) 1x2 + 1x1 + 2x1左子树有j个节点，右子树有n-j-1个节点1234567891011int[] dp = new int[n+1];dp[0] = 1;dp[1] = 1;//节点个数for(int i =2;i&lt;=n;i++)&#123; //左边j个 for(int j =0;j&lt;i;j++)&#123; dp[i]+=dp[j]*dp[i-j-1]; &#125;&#125;return dp[n]; ！95 输出全部不同的BST[1~n]组成的BST1…….k…n / \[1~k-1] [k+1,n] 与上一层的构建过程是一样的 背包9讲:01背包N个物品，背包容量VF[i,v]前i件物品放入容量v的背包可获得的最大价值。如果放第i件，转化为前i-i件放入容量为v-Ci的背包中，最大价值是F[i-1,v-Ci]+Wi$F[i,v]=max{F[i-1,v],F[i-1,v-C_i]+W_i}$123for i&lt;- 1 to N for v&lt;- Ci to V F[i,v]&lt;-max&#123;F[i-1,v],F[i-1,v-Ci]+Wi&#125; 时间/空间复杂度O（VN)1.简化空间-&gt;O(V) 递减顺序计算F[v]，保证计算F[v]时F[v-Ci] 保存的是F[i-1,v-Ci]123for i&lt;- 1 to N for v &lt;- V to Ci F[v] &lt;- max(F[v],F[v-Ci]+Wi) 第二个for可以优化for v&lt;- V to max(V-$\sum_{i}^{N}W_i$,Ci) taotao要吃鸡1.m+h容量背包，在m+h没装满时可以任意取一个超过重量的最外层遍历：最后一个超额的物品i. 计算m+h-1背包容量的最大val123456789101112int ans = -1;for(int i =0;i&lt;n;i++)&#123; ans = max(ans,v[i]+slove(m+h-1),i);&#125;int slove(int W,int index)&#123; for(int i =0;i&lt;n;i++)&#123; if(i==index)continue; for(int j = W;j&gt;=w[i];j--)&#123; dp[j] = max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125;&#125; 2.1.按重量排序123456789101112for(int i =0;i&lt;n;i++)&#123; for(int j = m+h;j&gt;=goods[i].w;j--)&#123; dp[j] = Math.max(dp[j],dp[j-goods[i].w]+goods[i].v); &#125; if(h&gt;0)&#123; //强行装的位置,不能填dp[0]，0表示装满了 for(int j = Math.min(m+h,goods[i].w-1)j&gt;0;j--)&#123; dp[j] = Math.max(dp[j],goods[i].v); &#125; &#125; out.println(dp[m+h]);&#125; 2.初始化F 恰好装满背包，F[0]=0 其余-∞没有装任务物品时，只有容量为0的背包表示装满，其它容量为非法解。 不用装满，F全部为0任何容量的背包，什么都不装，价值F都为0也是合法解。 完全背包 每个物品可用无限次简化1.如果Ci&lt;=Cj,Wi&gt;=Wj 则j可以不考虑。简化2.重量大于V的去掉。用计数排序算出v相同的物品中价值最高的那个O(V+N)转化成01背包：将第i种物品拆成重量$C_i2^k$价值为$W_i2^k$ 件数可写成若干个$2^k$件的组合用递增的循环O(VN)： 01背包V&lt;-V to Ci 因为保证选i件物品时F[i-1,v-Ci]是绝对没有选第i件物品的情况 而完全背包的子结果F[i,v-Ci]是加选一件第i种物品123for i&lt;- 1 to N for v&lt;- Ci to V F[v]&lt;- max(F[v],F[v-Ci]+Wi) 两个状态转移方程$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=kC_i&lt;=v}$$F[i,v] = max(F[i-1,v],F[i,v-C_i]+W_i) ！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。12345678910111213141516public boolean canPartition(int[] nums)&#123; int sum = 0; for(int n : nums)&#123; sum+=n; &#125; if(sum%2!=0)return false; int[] dp = new int[sum+1]; dp[0] = 1; for(int n : nums)&#123; for(int v = sum;v&gt;=0;v--)&#123; if(dp[v]==1)dp[v+n]=1; &#125; if(dp[sum/2]==1)return true; &#125; return false;&#125; 多重背包 第i种物品最多Mi件可用$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=k&lt;=Mi} 本福特定律以1为首位的数组数显的概率为30% 正确二分查找的写法1.查找范围是 [0,len-1]123456789101112131415int l = 0,r=n-1;while(l&lt;=r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)&#123; return mid; &#125; else if(arr[mid]&lt;target)&#123; l=mid+1;// &#125; else&#123; r=mid-1; &#125;&#125;//如果l&gt;rreturn -1; 2.[0,len) 保持len取不到好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的1234567891011121314int l = 0,r = n;while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)return mid; if(arr[mid]&gt;target)&#123; //在左边，边界为取不到的数 r=mid;//[l,mid) &#125;else&#123; //左闭又开 l = mid+1;//[mid+1,r) &#125;&#125;//如果l==r [1,1)表示空的return -1; 307Binary Index Tree与dp不同，dp[i]存储了前i个的总和 e只存部分visualgo可视化1.update树每个叶子节点的父节点的计算方法i+lowbit(i)1的父节点=001+001=0102的父节点=010+010=100==44的父节点=100+100 = 1000==8 最低位：lowbit(5) = 101&amp;((010+1)==011)=0015的父节点=101+001=110==6沿着path向上更新，最多只会更新logn(树高个节点)12345678void update(int i,int val)&#123; int dif = val-nums[i]; nums[i++]=val; while(i&lt;e.length)&#123; e[i]+=dif; i+=(i&amp;-i); &#125;&#125; 2.sum树 前7个元素的和=7+11+101234567891011int query(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum+=e[i]; i-=(i&amp;-i); &#125; return sum;&#125;int rangeSum(int i,int j)&#123; return query(j+1)-query(i);&#125; k=末尾零个数 二进制末尾有k个0则e[i] 是2^k个元素的和 1 -&gt; 1 e[1]=a[1] 2 -&gt; 10 e[2]=a[1]+a[2] 3 -&gt; 11 e[3]=a[3] 4 -&gt; 100 e[4]=a[1]+a[2]+a[3]+a[4] = e[2]+e[3]+a[4] 5 -&gt; 101 e[5]=a[5] 6 -&gt; 110 e[6] = e[5]+e[6] 7 -&gt; 111 e[7] = a[7] 8 -&gt; 1000 e[8] = e[4]+e[6]+e[7]+a[8] 315 输出数组每个位置后有多少个数字比它小80 数组每个元素只保留&lt;=2次cnt表示插入位置，i用于遍历123456int cnt=2;for(int i =2;i&lt;nums.length;i++)&#123; if(nums[i]!=nums[cnt-2])&#123; nums[cnt++] = nums[i]; &#125;&#125; 节点是随机变量的有向无环图=贝叶斯网络BN求联合概率会用到最小生成树 如果84*148=B6A8成立，则公式采用的是__进制表示的(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8=&gt;(3x^2+6x+2)(x-12)=0=&gt;x=12 快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数24表示在这种进制下个位应该为0 逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A 树的前/中/后序遍历本质都是DFS 无向图的连通分量可以用并查集（集合）来做并查集：[12,3,4,5]-&gt;[6,2,3,4,5]位置存放的是根节点 452 重叠线段12345678910111213int cnt =0;//按结束顺序排序不会出现// |__| 只有： |___| 和 |____|//|______|的情况 |____| |_|Arrays.sort(points,(a,b)-&gt;a[1]&gt;b[1])for(int i =0;i&lt;points.length;i++)&#123; int cur = points[i][1]; cnt++; while(i+1&lt;points.length&amp;&amp;points[i+1][0]&lt;=cur&amp;&amp;cur&lt;=points[i+1][1])&#123; i++; &#125;&#125;return cnt; 前一个的end在i+1的线段中，则跳过。问题：1234567891011121314151617181920### 402 去掉数字串中k个数字留下最小的数字Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;找最小数字：从高位，越高位越小的数。算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉用栈，下一个位置比栈顶小，则把栈顶换掉。注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。```javanum=&quot;1234567890&quot;;k=9;for(int i =0;i&lt;len;i++)&#123; // len=10,k=9 但是0比所有前9个都小，则while(top!=0&amp;&amp;num.charAt(i)&lt;stack[top-1]&amp;&amp;k&gt;0)&#123; top--; k--; &#125; //0覆盖掉1 之后截取stack中len-k=1长度并且去掉0 stack[top++]=num.charAt(i);&#125; 欧拉图：一笔画经过所有顶点、所有边的闭路径（边不重复，允许顶点重复） 欧拉路径：经过所有顶点，所有边的路径（边不重复，顶点重复） 不是闭路径（不需要回到原地）。 欧拉图判定条件：无向图：G是连通的，所有顶点的度都是偶数。有向图：G弱连通，每个顶点的出度和入度相等 欧拉路径判定条件：无向图：G连通，恰有两个顶点的度是奇数。从一个奇数顶点出发，到另一个奇数度顶点结束。有向图：G连通，恰两个顶点出度入度不相等，其实于出度多1的终结与入度多1的。 哈密顿图一条经过所有顶点的回路（不要求经过所有边） 哈密顿通路：经过所有顶点的通路，不要求回路 充分条件：满足： 是哈密顿图 236 最低的二叉树公共祖先终止条件root==null|root==q||root=p 在左/右子树找p|q，两边都能找到一个值（因为值不重复） 则返回当前root 如果左边没找到p|q，右边找到了p|q，最低的祖先就是找到的p|q，(因为保证p|q一定在树中) 222 完全二叉树的节点数83% DLS可以达到BFS一样空间的DFS139 word break1.状态：boolean[n+1]长度为i的前缀能否由字典组成2.初始值：[0]=true 空字符串3.转移方程if(dp[i]==true&amp;&amp;dic.contains(sub(i,i+j)))dp[i+j]=true4.结果 12345678910f[0]=true;for(int i =1;i&lt;s.length();i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(f[j]&amp;&amp;dic.contains(s.substring(j,i)))&#123; f[i]=true; break; &#125; &#125;&#125;return f[s.length()]; 55jump gamejump gamei+nums[i]大于lastp表示i位置可以跳到lastp位置。将lastp更新成现在的i。再向前直到lastp变成0，表示0位置可以到下一个lastp一直到len-1。1234lastp = len-1;for(int i =len-1;i&gt;=0;i--)if(i+nums[i]&gt;=lastp)lastp==i;return lastp==0; 45 jump game最少跳跃次数1.在本次可跳跃的长度范围内如果不能达到len-1则表示一定要跳跃2.BFS 322找钱最少硬币数贪心算法一般考举反例。不能用贪心的原因：如果coin={1,2,5,7,10}则使用2个7组成14是最少的，贪心不成立。满足贪心则需要coin满足倍数关系{1,5,10,20,100,200} 输入：coins = [1, 2, 5], amount = 11输出：3 (11 = 5 + 5 + 1)1.递归mincoins(coins,11)=mincoins(coins,11-1)+1=(mincoins,10-1)+1+1..=(mincoins,0)+n 2.dp: 1初始化table[amount+1]={0,max,max…} 2table[5]=table[0]对每个coin重填整行表格 3if(amount&gt;=coin)dp[amoun]+=dp[amount-coin]3.dfs分支限界 1.逆序coins数组 贪心从大硬币开始试 定义dp[i][j]用前i种硬币达到amount[j]最少的硬币数量用1，2，5组成11的数量=只用1,2组成11的数量+1，2，5组成[11-5]1.dp[i][j]=min(dp[i][j],dp[i-1][j-kcoin[i]]+k)：[i-1]不用这枚硬币之前能够到加上k枚i硬币达到amount[J]。需要遍历n.复杂度n\amount^22.不需要遍历几枚硬币dp[i][j]=min(dp[i][j],dp[i][j-coin[i]]+1).复杂度n*amount 降成了一维。dp[i]=dp[i-coin[i]]+1基础：dp[amount] 当amount=0时，dp=0;当coin有1时dp[i]=i 网络流 最小割 st-cut 去掉这几条边，源点S和终点T就会被分为两个不相交的set，S到不了T。这种边集的最小值断掉两点间的通信的最小代价。 最大流max-flow 边的流量小于capacity。每个点的入流和出流相等。除了源点S和终点T。求源点/终点能发出/接收的最大值。 其实可以是一个问题。 Ford-fulkerson算法1 先假设每条边的当前流量是0/capacity2 找到S到T的路径，并最大化这条路径上的空的边的当前流量3 继续找路径，如果可以通过一条边的反向到达T，经过的是一条边的反向流，则减少这条边逆向流过去。4 每条边到达正向包和或者负向为0 不能remove from backward edge flow value lemma :最小cut上的流量 == 最大网络流flow &lt;= capacity of cutmax flw == min cut 已知最大流(cur/capacity) 求cut从S点 正向走最不满的正向流。走最满的逆向流，满正向流和空逆向流当作不存在。 如何找augmenting path BFS如果容量都是integernumber of augemntation &lt;= maxflow value 每次增加至少1 TrieNode字典树 find/insert复杂度为字符串商都结点保存子节点（指针）的目录[26]下一个字符和结点是否终止boolean1234struct TrieNode&#123; TrieNode* children[26]; boolean terminal;&#125; 可以把terminal变成int用map&lt;String,int&gt;表示字典树 后缀树字典树 每层多一个字符的字典树后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)后缀数组 A[]后缀的起始位置“alohomora”1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀 [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra A[i]的i是字典序的i，值是真实位置 例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8); 生成后缀数组Manber-Myers O(n)但是太复杂 排序后缀目录：桶排序 Aho-Corasick1添加失败链接2缝衣针字符串序号数组 A,B两人选k种可乐达到期望最大A选m个，B选(n-m)个每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大输出 买k种可乐的数量期望和：$m/na+(m-n)/nb$的最大值 全部买期望最大那种输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1m/n=.50.5x1+0.5x2=0.5+1=1.50.5x3+0.5x1 = 2 全部买第二种可乐输出:0 2 火车换乘保证每个车错过能在30分钟以后换车输入：城市n 火车数mfrom1 to3 cost800 18:00 21:00…输出从1到n的最小花费 16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)(P(C进入1/8)P(A赢了C)+P(D进入1/8)*P(A赢了D))A进入1/2需要赢没比过的另外4个队A变成冠军需要赢没比过的另外8个队分组问题：如果1/4赛 1234 5678是一组4个是一组如果1/2赛 8个是一组展开代码 1234567891011for(int i =1;i&lt;4;i++)&#123; int inergroup = 1&lt;&lt;i; int group= 1&lt;&lt;i+1; for (int j = 0; j &lt;16 ; j++) &#123; for(int k=0;k&lt;16;k++) &#123; //在同一个大组 if(j/group==k/group) &#123; //不在同一个小组 if (j / inergroup != k / inergroup) &#123; dp[i][j] += dp[i - 1][j] * dp[i - 1][k] * p[j][k];&#125;&#125;&#125;&#125;&#125; 第一轮：1进入1/8赢的概率是[1][2] 1打败2的概率=0.133第二轮：1赢了1/8进入1/4赢的概率是12341在第2轮的获胜概率是0加上1在上一轮胜利的概率0.133 ×3在上一轮获胜的概率0.335×1赢3的概率0.211 2 0.009356551在第2轮的获胜概率是0.00935655加上1在上一轮胜利的概率0.133 ×4在上一轮获胜的概率0.665×1赢4的概率0.2921 2 0.0351825 第三轮：1赢了1/4在1/2半决赛赢的概率是123456781在第3轮的获胜概率是0加上1在上一轮胜利的概率0.0351825 ×5在上一轮获胜的概率0.336947×1赢5的概率0.671 3 0.007942611在第3轮的获胜概率是0.00794261加上1在上一轮胜利的概率0.0351825 ×6在上一轮获胜的概率0.198831×1赢6的概率0.271 3 0.009831361在第3轮的获胜概率是0.00983136加上1在上一轮胜利的概率0.0351825 ×7在上一轮获胜的概率0.0229419×1赢7的概率0.9531 3 0.01060061在第3轮的获胜概率是0.0106006加上1在上一轮胜利的概率0.0351825 ×8在上一轮获胜的概率0.44128×1赢8的概率0.3531 3 0.016081 第四轮：1赢了1/2变成冠军的概率123456789101112131415161在第4轮的获胜概率是0加上1在上一轮胜利的概率0.016081 ×9在上一轮获胜的概率0.0606261×1赢9的概率0.3281 4 0.0003197771在第4轮的获胜概率是0.000319777加上1在上一轮胜利的概率0.016081 ×10在上一轮获胜的概率0.0113548×1赢10的概率0.1281 4 0.0003431491在第4轮的获胜概率是0.000343149加上1在上一轮胜利的概率0.016081 ×11在上一轮获胜的概率0.203126×1赢11的概率0.8731 4 0.003194781在第4轮的获胜概率是0.00319478加上1在上一轮胜利的概率0.016081 ×12在上一轮获胜的概率0.147508×1赢12的概率0.0821 4 0.003389291在第4轮的获胜概率是0.00338929加上1在上一轮胜利的概率0.016081 ×13在上一轮获胜的概率0.160952×1赢13的概率0.7711 4 0.005384851在第4轮的获胜概率是0.00538485加上1在上一轮胜利的概率0.016081 ×14在上一轮获胜的概率0.0877648×1赢14的概率0.31 4 0.005808261在第4轮的获胜概率是0.00580826加上1在上一轮胜利的概率0.016081 ×15在上一轮获胜的概率0.240971×1赢15的概率0.4051 4 0.007377661在第4轮的获胜概率是0.00737766加上1在上一轮胜利的概率0.016081 ×16在上一轮获胜的概率0.0876971×1赢16的概率0.4551 4 0.00801932 KMP文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。1 子序列 不连续 2 字串 连续KMP:getIndexOfd之前【最长前缀】和【最长后缀】的匹配长度(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)所以最长匹配是3：abc,记录在d位置上int[]next = f(“abcabcd”)={-1,0,0,1，2，3}关键加速求解匹配 90 有重复的subset[1,2,2,2] 选不同的2得到{1,2}是重复的 次序不同得到{1,2},{2,1}是重复的先排序，再去重。 78 subset[1,2,3]-&gt;[1][1,2][1,2,3][2,3][2][3]回溯法：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); back(rst,new ArrayList&lt;&gt;(),nums,0); return rst; &#125;private void back(List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; item,int[] nums,int index)&#123; rst.add(new ArrayList&lt;&gt;(item)); for(int i =index;i&lt;nums.length;i++)&#123; item.add(nums[i]); //1.当i=2+1==nums.length 则回到上一层i=2,remove back(rst,item,nums,i+1); //2.结束了back(,,2)并去掉了&#123;3&#125; //3回到back(,,index=1)并去掉了[2] item里只有1， // i++ 添加[3]-&gt;rst.add(&#123;1,3&#125;) //4.结束back(,,index=1)回到index=0 remove 0 index=1 add&#123;2&#125; back item.remove(item.size()-1); &#125;&#125; 位运算法 集合每一项可以用0，1表示取不取输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 从000到111的过程{A,B,C}=111=7{A,B}=110=6{A}=100=5…一共有2^3种A用100表示B用010表示C用001表示如果i=011=3,添加j=0,001,j=1,010到item；i=100=4,添加j==2,1&lt;&lt;2=4123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; int setnum = 1&lt;&lt;nums.length; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); for(int i =0;i&lt;setnum;i++)&#123; List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); for(int j=0;j&lt;nums.length;j++)&#123; if((i&amp;(1&lt;&lt;j))!=0) &#123; item.add(nums[j]); &#125; &#125; rst.add(item); &#125; return rst;&#125; 815 换公交routes = [[1, 2, 7], [3, 6, 7]]把车routes[0]的路线当成一个连通分量，并分配一个颜色标记BFS相同连通分量标记的点跳过。 数据结构： {站点：list&lt;经过的公交车id&gt;} list&lt;公交车id&gt; 标记已经乘过的公交 BFS连通分量while(!que.empty)， 遍历一辆车的连通分量while(que.size()&gt;0) 遍历当前节点相邻的busid是否乘过for(int car:list)， 并标记这个车的连通分量已乘过，遍历这个连通分量for(int t:routes[car])中有没有T，有则结束，没有则将整个连通分量入队。 fib123456int fib(int n)&#123; num++;//计数 if(n==0||n==1)return n; if(memo[n] == -1)memo[n] = fib(n-1)+fib(n-2); return memo[n];&#125; 11 数组index当底边，值当杯子两侧，最大面积！30 字典中单词连续出现在字符串中的位置 AC自动机（？加入字典的常用写法dict.put(word,dict.getOrDefault(word,0)+1)展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Solution &#123;public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res;&#125;public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start;&#125;public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1);&#125;&#125; 3 连续最长不重复子序列两指针i从左向右遍历到最后j指示i之前不重复的最高位置。i-j+1为当前最长结果 409 string中字符组成回文串的最大长度1.开int[128]，直接用int[char]++计数2.奇数-1变偶数&amp;(~1)3.判断奇数(&amp;1)&gt;0 ！5 最长回文串bealen[i][j]表示[i]-[j]是回文串反转做法不行:abcxyzcba -&gt; abczyxcba -&gt;相同的abc并不是回文“cba”是“abc”的 reversed copy中心扩展法：回文的中心有奇数：n个，偶数：n-1个位置会输出靠后的abab-&gt;输出bab12345678910111213141516171819202122232425262728int len;public String longestPalindrome(String s) &#123; if(s==null||s.length()&lt;2)return s; len = s.length(); int start = 0;int end = 0; // int max = 0; for(int i =0;i&lt;len;i++)&#123; //"babad" -&gt;"bab" -&gt;i =1 len = 3 //"cbbd" -&gt; "bb" -&gt;i=1 len = 2 int len1 = help(s,i,i);//奇数扩展 int len2 = help(s,i,i+1);//偶数扩展 int max = Math.max(len1,len2); if(max&gt;end-start)&#123; start = i - (max-1)/2;//去掉中间那个左边长度的一半 end = i+max/2;//右边长度的一半 &#125;//end-start= i+max/2-i+(max-1)/2 = max-1/2 &#125; return s.substring(start,end+1); &#125;private int help(String s,int left,int right)&#123; while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; return right-left-1;&#125; Manacher’s 算法 O(n)前缀/ 回文树next[i][c] 编号为i的节点表示的回文串两边添加c后变成的回文串编号。fail[i]节点i失配后cnt[i] 347桶排序 int数组中最常出现的n个桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。 242 Anagram 相同字母的单词22 卡特兰数括号left括号数量小于n，right括号数量必须小于left不然(()))肯定不合理1234if(left&gt;right)return;if(left==0&amp;&amp;right==0)&#123;rst.add(s);return;&#125;if(left&gt;0)help(rst,s+"(",left-1,right);if(right&lt;0)help(rst,s+")",left,right+1); 树遍历 递归的每一帧不够小，尾递归-&gt;栈 先序迭代1：先放入栈右子树再入栈左子树。不能推广到中序、后序遍历qia12345while(!s.empty())&#123; x=s.pop();visit(x); if(root.right!=null)stack.push(root.right); if(root.left!=null) stack.push(root.left);&#125; 344 reverse String转成char数组/位运算做法77%比stringbuilder好 238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法left数组：自己左边数的乘积[1,1,2,6]right数组:自己右边的乘积（包括自己）[24,12,4,1]left和right对应位置相乘不用extra space12345678910res[0]=1;for(1 to n-1)&#123; res[i]=res[i-1]*nums[i-1];&#125;int right=1;for(n-1 to 0)&#123; res[i]*right; right*=nums[i];&#125;return res; 371 不用’+’用位运算完成求和123456public int getSum(int a, int b) &#123; int rst = a^b;//0^0=0,0^1=1,1^1=0 int carry = (a&amp;b)&lt;&lt;1;//当ab相等的时候需要进位 //a+b=（a xor b）+ （(a and b) &lt;&lt; 1） if(carry!=0)return getSum(rst,carry); return rst;&#125; 412 遇到3||5和3&amp;5的倍数变成特定字符不用%最快方法!对于CPU取余数的运算相对来说效率很低1234567891011121314151617for(int i=1,fizz=0,buzz=0;i&lt;=n ;i++)&#123; fizz++; buzz++; if(fizz==3 &amp;&amp; buzz==5)&#123; ret.add("FizzBuzz"); fizz=0; buzz=0; &#125;else if(fizz==3)&#123; ret.add("Fizz"); fizz=0; &#125;else if(buzz==5)&#123; ret.add("Buzz"); buzz=0; &#125;else&#123; ret.add(String.valueOf(i)); &#125; &#125; 15 3sum=0 荷兰国旗写法3指针1p：从0~len-2，3个数的和 右边至少留两个数 sum=0-nums[i]转化成2sum问题去重：当num[i]=num[i-1]:continue另外两个指针从1p往后从len-1往前。去重：预判：nums[low]=nums[low+1]:low++;nums[high]=nums[high-1]:high–; 152 最大子列乘积 保留当前值之前的最大积和最小积负数的最小积有潜力变成最大积1234567for(int i =1;i&lt;nums.length;i++)&#123; int nextmax = nums[i]*curmax; int nextmin = nums[i]*curmin; curmax=Math.max(Math.max(nextmax,nextmin),nums[i]); curmin=Math.min(Math.min(nextmax,nextmin),nums[i]); sum = Math.max(curmax,sum);&#125; 818 A加速，R掉头并减速，到指定位置最少需要多少条指令551 出现两个以上A或者3个以上L为false1return s.indexOf("A")==s.lastIndexOf("A") &amp;&amp; s.indexOf("LLL") == -1; 34二分查找获取最左/右边相等的1234567//获取最右while(i&lt;j)&#123; int mid = (i+j)/2+1; if(nums[mid]&gt;target)j = mid-1; //找到了继续向右找 else i =mid;&#125;rst[1]=j; ？698 减枝？DP方法239Monotonic queue 前后可以修改o(1)，并且可以随机访问维护一个单调递减的序列，读一个窗口输出单调队列的first 476前导012345678910//找到左边第一个1，然后后面全置0public static int highestOneBit(int i) &#123; // HD, Figure 3-1 i |= (i &gt;&gt; 1);//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx i |= (i &gt;&gt; 2);//连续4个1 但是如果位数不够就只有3个1或者更少 i |= (i &gt;&gt; 4); i |= (i &gt;&gt; 8); i |= (i &gt;&gt; 16); return i - (i &gt;&gt;&gt; 1);//让全1的无符号右移1格1111-0111得到1000&#125; 464 博弈A,B玩家轮流从1-10中选数组加到同一个total，让total先大于11的赢.B肯定赢。1.计算1-n个数的permutation，并判断每个赢的可能性复杂度(n!)2.因为1,2…和2,1…是一样的，所以可以降为$2^n$ 486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高{3，9，1，2} 二维数组dp：[i][j]只用右上三角表示两个人都从list取1个数，2个数，3个数到list长能获得的最大差值 填对角线，如果两个人只身下一个数为3：{A取3，B取0}，剩下9：{A取9，B取0}… 如果剩下2个数，剩下{3,9}[1][2]：{A取9，B剩下{3}回到1的情况}… 如果剩下3个数，剩下{3,9,1}[1][3]:{A取3,B剩下{9,1}即表格[2][3]的情况} 剩下4个数，填[1][4]即为答案 递归：但是会有很多重复计算复杂度$2^n$比如让对手选[3,9,1]后，自己选[9,1]和[3,9]/让对手选[9,1,2]后，自己选[9,1]和[1,2][9,1]被计算了两次。可以进行存储1234567//最大的分数差int dif(int[] nums,int left,int right)&#123; //如果长度为1，获得的差值就是这个数 if(left==right)return nums[left]; //选一个数之后 交给对手用相同策略选 return max(nums[left]-dif(nums,left+1,right),nums[right]-dif(nums,left,right+1));&#125; 用一个数组存储key是left*len+right展开代码 123456789101112131415int[] m;int len =0;public boolean PredictTheWinner(int[] nums) &#123; this.len = nums.length; if(len==1)return true; this.m= new int[len*len]; return help(nums,0,len-1)&gt;=0;&#125;private int help(int[] nums,int l,int r)&#123; if(l==r)return nums[l]; int index = l*len+r; if(m[index]&gt;0)return m[index]; m[index]=Math.max(nums[l]-help(nums,l+1,r),nums[r]-help(nums,l,r-1)); return m[index];&#125; 292lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree TraversalMorris Inorder(中序) Tree Traversal先把每个中缀的前缀（左子树最右）指向中缀，遍历完后把这些链接都删除还原为 null 找root的前趋：root 的中序前趋是左子树(第一个左结点)cur的最右标记为pre， pre.right = root12345678//找前趋Node cur = root;if(cur.left!=null)&#123; Node pre = current.left; while(pre.right!=null&amp;&amp;pre.right!=cur)&#123; pre=pre.right; &#125;&#125; 12345//创建链接：第一次到达这个最右的结点，cur的左边其实还有结点if(pre.right==null)&#123; pre.right = cur; cur=cur.left;&#125; 找root.left的前趋：cur向左（相当于新的root（1）的状态），找到cur的最右，标识成pre.right = cur 当cur向左是null则找到中序遍历的第一个输出，cur向右 123if(cur.left==null)&#123; sout(current.val); current=current.right;&#125; 当cur的left==null并且右链接已经建立到上一层。cur移动到上一层，找到前趋pre就是右链接的cur.left。 把这个右链接(pre.right)删除，输出（中），然后继续向右（上）并删除这种从前趋right过来的线。 123456//pre.right=curelse if(pre.right!=null)&#123; pre.right = null; sout(cur.val); cur=cur.right;&#125; Convert BST to Greater Tree17ms 66% Reverse Morris In-order Traversal展开代码 12345678910111213141516171819202122232425262728293031323334public TreeNode convertBST(TreeNode root) &#123; int sum = 0; TreeNode cur = root; while(cur!=null)&#123; //最右 if(cur.right==null)&#123; sum+=cur.val; cur.val=sum; cur=cur.left; &#125;else&#123; //找前继，键link TreeNode pre = cur.right; //一直向左 while(pre.left!=null&amp;&amp;pre.left!=cur)&#123; pre=pre.left; &#125; //找到了pre 联立链接 if(pre.left== null)&#123; pre.left = cur; cur=cur.right; &#125; //右边没了，并且左连接向上 else&#123; pre.left=null; sum+=cur.val; cur.val= sum; cur=cur.left; &#125; &#125; &#125; return root; &#125; 正常做法递归中序 15ms 99%12345678public TreeNode convertBST(TreeNode root) &#123;if(root==null)return root;convertBST(root.right);sum+=root.val;root.val=sum;convertBST(root.left);return root;&#125; 110 判断树平衡 在计算高度时同时判断平衡只需要O(n)123456789101112private boolean balance =true;public boolean isbalance(TreeNode root)&#123; height(root); return balance;&#125;private int height(TreeNode root)&#123; if(root==null) return 0; int left = height(root.left); int right = height(root.right); if(Math.abs(left-right)&gt;1)balance = false; return Math.max(left,right)+1;&#125; 2-3树10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间 红黑树：将3-结点变成左二叉树，将2-3变成二叉树有二叉树高效查找和2-3树高效平衡插入红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$ 插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转） 581 需要排序的最小子串，整个串都被排序了 递增40大于35，只排序到右边遍历过来第一个n&lt;n-1是不够的要找到[30~31]中的min和max1234567891011public static int fid(int[]A)&#123; //1,3,2,2,2 int n = A.length, beg = -1, end = -2, min = A[n-1], max = A[0]; for (int i=1;i&lt;n;i++) &#123; max = Math.max(max, A[i]);//从前往后，找到最大值max=3 min = Math.min(min, A[n-1-i]);//从后往前找到最小值min=2 if (A[i] &lt; max) end = i; //a=2&lt;3 end = 2-&gt;3-&gt;4 直到找到a[i]&gt;max if (A[n-1-i] &gt; min) beg = n-1-i;//begin =1 直到找到a[i]&lt;min &#125; return end - beg + 1; &#125; 136 Single Number异或 0^12=12,12^12=0single number$$2(a+b+c)-(a+a+b+b+c)$$ 2*sum(set(list))-sum(list) 438 Anagrams in a String 滑动窗口Sliding Window algorithm两个数组一样，则找到index，不一样，则窗口向前滑动一哥输出0，1，4s: “cbaebabacd” p: “abc” 顺序无关，连续出现在s中Output:[0, 6] Anagram result of [rearranging the letter of a word to produce a new word using all the orginal letters exactly once]1) The first count array store frequencies of characters in pattern.2) The second count array stores frequencies of characters in current window of text. 141链表环检测空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针最坏情况，快指针和慢指针相差环长q -1步cpp练习 1234567891011121314class Solution&#123; public: bool hasCycle(ListNode *head) &#123; auto slow = head; auto fast = head; while(fast)&#123; if(!fast-&gt;next)return false; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 142 环起始于哪个node1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;3 meet:6a: 从head到环b：快指针走了两次的环内距离(慢指针到环起点的距离)c: 慢指针没走完的环内距离已知快指针走的距离是slow的两倍慢=a+b 快=a+2b+c则a=c从len(head - 环起点) == 慢指针没走完的环距离head与慢指针能在环起点相遇。1234567if(slow==fast)&#123; while(head!=slow)&#123; head=head.next; slow=slow.next; &#125; return slow;&#125; 160 链表相交于哪一点A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val思路2：将a,b连成m+n长的链表遍历两遍 a1 → a2 c1 → c2 → c3 -null- b1 → b2 → b3 c1 → c2 → c3 // ↘ // c1 → c2 → c3 // ↗ b1 → b2 → b3 c1 → c2 → c3 -null- a1 → a2 c1 → c2 → c3展开代码 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null)return null; ListNode a = headA; ListNode b = headB; while(a!=b)&#123; if(a==null)&#123;a=headB;&#125;else&#123;a=a.next;&#125; if(b==null)&#123;b=headA;&#125;else&#123;b=b.next;&#125; &#125; return a; &#125;&#125; 1681 -&gt; A2 -&gt; B3 -&gt; C…26 -&gt; Z27 -&gt; AA28 -&gt; AB递归26进制123 public String convertToTitle(int n) &#123; return n == 0 ? "" : convertToTitle(--n / 26) + (char)('A' + (n % 26));&#125; 169 众数 Boyer-Moore Voting Algorithm每次取两个不同的数删除，最后剩下的返回展开代码 1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums==null)return -1; int res=0; int count=0; for(int e : nums)&#123; if(count==0)&#123; res=e; &#125; if(res!=e)&#123; count--;//删除这个数 &#125; else count++; &#125; return res; &#125;&#125; 搜索算法的优化问题 8数码（9宫格拼图) 移动序列，树搜索：每个移动状态为节点，边为状态转移。 哈密顿环：从一个点出发经过所有的点1次回到原点。 子集的合 S={} 求sum(S’)=num ：树搜索，栈，深度优先 搜索速度：广度优先 最优解 ；深度优先:存在问题，可行解。（得遍历完整个空间得到最优） ？？？空间：深度栈：多项式； 广度优先队列：最坏指数 1. 爬山：局部贪心，快速找到可行解，局部最优 8数码:启发函数：当前状态和目标状态的距离：错位方块个数。 深度优先 每次将当前节点S的子节点按启发式函数由大到小压入栈 Best-First搜索：全局最优贪心 当前所有可扩展节点中启发函数最优点 用堆 分支界限：组合优化 多阶段图搜索：最短路径 爬山与BF算法得到最优解都需要遍历整个空间 用爬山生成界限(可行解or最优解的上限) 字符串搜索Rabin-KarpO(MN) Review1. 枚举： 小于N的完美立方 $a^3=b^3+c^3+d^3$ 按a的值从小到大输出a&gt;b&gt;c&gt;d a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1] 生理周期 A周期23天，B周期28天，C周期31天给定三个高峰p,e,i;求给定日子d后下一次三次高峰同一天还有多少天。 输出天数小于21252.输入：0 0 0 0 k=[d+1,21252] ;(k-p)%23,(k-e)%28,(k-i)%31==01234for(k=d+1;(k-p)%23;++k); //找到第一个高峰for(;(k-e)%28;k+=23); //找双高峰for(;(k-i)%33;k+=23*28); //找三高峰//输出k-d 称硬币:已经分组称了3次12枚硬币，找出假币 ABCD EFGH evenABI EFJK upABIJ EFGH even输出假的硬币 数据结构 char Left[3][7]`char Right[3][7]char result[3][7]` 一共称3次，每边最多放6个硬币，result（天平右边的情况） isFake(char c,bool light )假设函数：c是轻的 for(char c= &#39;A&#39; to &#39;L&#39;)枚举假硬币 for(3)三次称重情况都匹配 如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换 switch result[i][0] 选择三种u,e,d的情况 如果 第一次实验为up,右边高，则c应该出现在right,当right.indexOf(c)==null//没出现 return false 如果even 判断出现在left||right d 判断出现在left 熄灯问题(deng.java) 按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4给定每盏灯的初始状态，求按钮方案，使灯全熄灭输入 01矩阵 输出 01矩阵一个按钮按两次及以上是无意义的，按钮次序无关{0,1,1,0,1,0},{1,0,0,1,1,1},{0,0,1,0,0,1},{1,0,0,1,0,1},{0,1,1,1,0,0} 枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数） 只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按 一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1] 一个bit异或1 反转1^1-&gt;0反转0^1-&gt;1反转； j位 置1 |=(1&lt;&lt;j) j位 置0 &amp;=~(1&lt;&lt;j) 取第j 位的值 &gt;&gt;j&amp;1 主循环：1.遍历第一行开关状态 2.每次换第一行重置原来灯状态lighting[]=输入 3.对每一行，每一个灯，按switch更新lighting 123456for (int j = 0;j&lt;6;j++)&#123; if(getBit(result,i,j)==1)&#123;if(j&gt;0)FlipBit(lights,i,j-1);FlipBit(lights,i,j);if(j&lt;5)FlipBit(lights,i,j+1);&#125;&#125;if(i&lt;4)&#123;lights[i+1]^= switchs;&#125; &gt; 4.更新开关，下一行开关为上一行还亮着灯的位置回3 &gt; 5.当lighting最后一行为0，结束 递归 汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2) A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c) 再将B上n-1个移动到C，用A中转 回到0 A上n-2个移动到C，用B中转 n皇后 递归代替多重循环 链表DELETE_IF12 创建链表list-&gt;nodelist 会stackOverflow123456Node create(List&lt;Integer&gt; data)&#123; Node first = new Node(data.get(0)); Node sub = create(data.subList(1,data.size())); first.next=sub; return first;&#125; 迭代：123456789101112Node pre = null;Node head =null;for(1 to size)&#123; Node node = new Node(i); if(pre!=null)&#123; pre.next =node; &#125;else&#123; head = node; &#125; pre = node;&#125;return head; 反转链表12345678Node reverse(Nodde head)&#123; if(head==null)return null; if(head.next == null)return head; Node second = reverse(head.next); second.next = head; head.next = null; return second;&#125; 迭代：中间状态null&lt;-1&lt;-25-&gt;null3是newhead 反转成功的链表 | 4curhead是还没反转的链表newhead=null开始，curhead从第一个node开始，两个同时向右每次移一格，直到curhead=null123456789Node newhead = null;Node curhead = head;while(head!=null)&#123; Node tmp = curhead.next; curhead.next = newhead; curhead=tmp; newhead = curhead;&#125;return newhead; 转成栈浪费空间并且代码复杂 combinations 从list中选n个的组合递归框架：1选择第0号元素，递归去除第一个元素中选n-1个com(data.subList(1,data.size()),n-1)2不选，去除第一个元素后选n个元素 递归基准：1.当data为空，并且选择0个则合理2.当n=0 选完了 12345678void com(List&lt;Integer&gt; selected,List&lt;Integer&gt; data,int n)&#123; if(n==0)printList(selected); if(data.isEmpty())return; selected.add(data.get(0)); com(selected,data.subList(1,data.size()),n-1); selected.remove(selected.size()-1,n); com(selected,data.subList(1,data.size()),n);&#125; 最长上升子序列无后效性：可写出递推式。之与子问题函数的状态函数值有关，与到达值的路径无关子问题：求以$a_k(k=1,2,3…N)$为终点的最长上升子序列长度max(n个子问题) 如果ak比已得最长子序列的最后ai大，则长度+1maxLen(k)=max(maxLen(i):i in range(1,k)且ai&lt;ak且k!=1)+112345678for i in range(1,n) maxlen[i]=1for i in range(2,n) ##求以ai 为终点的最长 for j in range(0,i)# ai左边所有的数 if a[i]&gt;a[j]: # ai为终点的更长 #？？ maxlen[i]也更新了，可能比manlen[j]+1大 maxlen[i]=max(maxlen[j]+1,maxlen[i])]]></content>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busyman Notes]]></title>
    <url>%2F2018%2F03%2F21%2Fbusyman%2F</url>
    <content type="text"><![CDATA[signature???方法签名就由方法名+形参列表构成 并行 计算很长数组的总和1long sum = IntStream.of(a).parallel().sum(); Stream 统计一本书中的长单词 \PL 拆分单词 12String contents = new String(Files.readAllBytes(Paths.get(""),StandardCharsets.UTF_8));List&lt;String&gt; words = Arrays.asList(contents.split("\PL+")); stream代替迭代 12long count = aaa.stream().filter(w-&gt;w.length()&gt;12).count();System.out.println(count); 所有单词转换成小写 1Stream&lt;String&gt; lower = words.stream().map(String::toLowerCase); 每个单词的第一个字母 1Stream&lt;String&gt; first = words.stream().map(s-&gt;s.substring(0,1)); 创建流 集合-&gt;流：Collection.stream() 数组-&gt;流：Stream.of Arrays.stream(array,from,to) 方法 Stream&lt;Stream&lt;String&gt;&gt;用.flatMap(lambda) .limit(int)前int N个元素；.skip(n)丢弃前n个元素；.concat(stream,stream)拼接流 .distinct()删除重复元素 Optional防止空指针引用，对null封装默认值 收集 toArray stream.collect(Collectors.toList/toSet/toCollection(TreeSet::new)) 收集一个国家的语言Map&lt;String,List&lt;Local&gt;&gt;&#39;处理相同键 分类函数：.collect(Collectors.groupingBy(Local::getCountry)) 当分类函数是布尔值.partitioningBy(l-&gt;l.getLanguage().equal(&quot;en&quot;)); groupingBy可以针对List&lt;Local&gt;加下游收集器参数toSet()等 求一个流所有字符串总长度,reduce要求(T,T)-&gt;T返回值和参数 类型一样累加器函数：(total,word)-&gt;total+word reduce并行所以最后total要汇总（注意线程安全）12int result = aaa.stream().reduce(0,(total,word)-&gt;total+word.length(), (total1,total2)-&gt;total1+total2); 映射到一个数字流1int m2i=aaa.stream().mapToInt(String::length).sum(); 避免装箱，基本类型流 byte\short\char\boolean使用IntStream.of(1,2,3,4)和Arrays.stream 并行流 不能使用paralineStream.forEach forEach中的函数会在多个线程中并发执行，更新共享的数组 按长度将字符串进行分组并计数123Map&lt;Integer,Long&gt; shortWordCount = aaa.parallelStream() .filter(s-&gt;s.length()&lt;10) .collect(groupingBy(String::length,counting())); 并发收集123Map&lt;Integer,List&lt;String&gt;&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length)); 值是次数123Map&lt;Integer,Long&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length,counting())); Properities12345Properties st = new Properties();st.put("",);try(OutputStream out = Files.newOutputStream(path))&#123; st.store(out,"name");&#125; EnumSetEnumSet没有公共构造函数，使用静态工厂方法构造EnumSet：12enum Weekday&#123;MONDAY&#125;;Set&lt;Weekday&gt; alwarys = EnumSet.allof(Weekday.class); EnumMap指定[键]类型1EnumMap&lt;Weekday,String&gt; personInChange = new EnumMap&lt;&gt;(Weekday.class); BitSet用户标识位序列 第i个位置位1表示i在集合内栈、队列等 栈没有Stack接口，有Stack类，避免使用。使用ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); 优先队列和作业调度PriorityQueue&lt;Job&gt; jobs = new PriorityQueue&lt;&gt;();容纳实现了Comparable的类 WeakHashMap:当键的唯一引用来自哈希表条目，删除键/值 视图 KeySet、values、asList方法生成视图 范围range 任何子列表的添加删除都会影响原先列表 12List&lt;String&gt; st = ;List&lt;String&gt; nextfive = st.subList(5,10); 有序集合通过上下界 输出[1,2] 1234 TreeSet&lt;String&gt; words = new TreeSet&lt;&gt;();words.addAll(Arrays.asList(new String[]&#123;"1","2","3","4","5","6"&#125;));SortedSet&lt;String&gt; asOnly = words.subSet("1","3");System.out.println(asOnly); 轻量级创建map类型的属性12Collections.emptyMap()System.out.println(Collections.singletonMap("id","222")); 检查视图，检查错误类型（堆污染）,监视ArrayList 1List&lt;String&gt; strings = Collections.checkedList(new ArrayList&lt;&gt;(),String.class); 不要使用Collections的同步视图，并发使用util.concurrent的数据结构 迭代器Iterator&lt;String&gt; iter= coll.iterator() coll.removeIf(e-&gt;e fulfill the condition iter.remove()移除最后一个访问的元素，不是指向元素，不能两次连用remove 泛型泛型方法： 类型参数放在修饰符public static后，返回类型之前 元素限定&lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems)确保Array的元素类型是AutoCloseable的子类；extends表示子类型、类型限定 多个限定T extends Runnable &amp; AutoCloseable,只能有一个限定类，放在第一个，其它都是接口 Manager是Employee子类但ArrayList&lt;Manger&gt;不是ArrayList&lt;Employee&gt;子类因为123ArrayList&lt;Manger&gt; bosses = new ArrayList&lt;&gt;();ArrayList&lt;Employee&gt; empls = bosses; //非法empls.add(new Employee(...)); //可以在管理员列里添加普通成员 如果使用数组Manger[]和Employee[] 转型是合法的，但赋值会爆ArrayStoreException 如果不对ArrayList写操作，转换是安全的。可以用子类通配符 &lt;? extends Employee&gt; staff可以传Arraylist staff.get(i)可以 可以将&lt;? extends Employee&gt;转成Employee staff.add(i)不行 不能将任何对象转成&lt;? extends Employee&gt; 父类通配符&lt;? super Employee&gt;常用于函数式对象参数（用lambda调用） 类型擦除变成object/第一个限定 泛型约束 类型变量不能实例化 T[] result = new T[n];错误 以【方法引用】方式提供数组的构造函数Sting[]::newIntFunction&lt;T[]&gt; constr T[] result = constr.apply(n) 反射 1234567public static &lt;T&gt; T[] repeat(int n,T obj,Class&lt;T&gt; c1)&#123;//编译器不知道类型，必须转换@SuppressWarnings("unchecked") T[] result = (T[])java.lang.reflect.Array.newInstance(c1,n);for(int i=0;i&lt;n;i++)result[i]=obj;return result;&#125; 调用String[] greetings = repeat(10,&quot;Hi&quot;,String.class); 最简单的方法12345 public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n,T obj)&#123; ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;(); for(int i =0;i&lt;n;i++) result.add(obj); return result;&#125; 泛型类数组Entry&lt;String,Integer&gt;[]是合法的，但是初始化要@SuppressWarnings(“unchecked”)正确方法：ArrayList&lt;Entry&lt;String,Integer&gt;&gt; 异常 已检查错误：可提前预知 IOException。Integer.parseInt(str)检查str是否是整数是可能的 覆盖方法时，不能抛出比父类方法中声明更多的已检查异常 @throws异常注释文档化 实现了AutoCloseable/Closeable的类 try(PrintWriter out = new PrintWriter(&quot;out.txt&quot;){}保证了out.close()必会调用，替换finally{in.close()}因为close可能异常 ·ex.getSuppressed()捕获了主要异常时检测得到第二个异常 可以catch到已检查异常后连接到未检查异常 检测非空值123public void process(String directions)&#123; this.directions = Object.requireNonNull(directions,"空指针");&#125; 会抛出空指针异常 Logger代替print：7种级别默认会记录INFO及更高级别。CONFIG/FINE/FINER.FINEST对用户无意义12Logger.getGlobal().info(()-&gt;ex.getMessage());Logger logger = Logger.getLogger("com.Logger"); log输出到文件用户文件夹下javan.log12FileHandler handler = new FileHandler();logger.addHandler(handler); 未检查：逻辑错误：NullPointerExcepterClass.forName(str)不可能知道类能否成功加载。 接口 要使用子类的方法，强制cast，先检查类型 123if (a instanceof B)&#123; B b = (B)a;&#125; Collection/AbstractCollection/Collections,Path/Paths default Stream stream() 接口中添加了，为了保持兼容以前版本，写了默认方法 Comparable 接口 返回不一定是1,-1,0； 当两个大负数相减可能变正，用Integer.compare() 浮点数 Double.compare() Arrays.sort()可以对Comparable对象数组进行排序 Comparator 接口不能更改String的compareTO,创建一个Comparator实现类。 创建Comparator comp 对象=new 实现了接口的对象(); 在Comparator对象上调用.compare(,) compare方法不是静态方法！ （？？？） Arrays.sort(obj,new Comparatorobj) Runable 接口 A implements Runnable{run(){}} new Thread(A).start UI回调 EventHandler lambda表达式 带有自由变量值的代码块是闭包。捕获闭合作用域中变量值 lambda中只能引用值不变的量，不能捕获变量，也不能改变 123for(int i =0;i&lt;n;i++)&#123; new Thread( ()-&gt; sout(i) ).start(); //报错&#125; for(Sting arg:args)中的变量是final的，作用域是单个迭代 可以捕获；每个底碟会创建新的arg变量；for(i)的作用域是整个循环。 只有一个抽象方法的接口对象，函数式接口 将lambda表达式放入类型为函数式接口的变量中，转化成接口的实例 ArrayList removeIf(Predictae) //e-&gt;e==nullremoveIf(Object::isNull)123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; 函数式接口@FunctionalInterface 单个方法的接口 高阶函数：返回函数的函数1. Comparator `public static &lt;T, U&gt; Comparator comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)` key提取器将类型T映射到可比较的类型 comparingDouble避免装箱 nullsLast`nullsFirst`避免null抛出异常 naturalOrder()适合实现了Comparable的类 thenComparing 局部内部类，实现接口的类。 方法中的类，可以接受方法中的值，不需要构造函数和存储在实例变量中。 匿名 继承和反射 代理对象实现接口，将所有方法路由到一个handler super() 因为子类不能访问父类的私有变量，所有要通过父类的构造函数初始化。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDB]]></title>
    <url>%2F2018%2F03%2F16%2FDDB%2F</url>
    <content type="text"><![CDATA[隔离级别是对一致性的破坏。事务之间的Happen-before关系：4种 【读写，写读，读读】，写写 排他锁 排队：序列化读写 不需要冲突控制，无死锁 排他锁：用n个队列，发生共享数据冲突就并行，不然就串行。对数据加锁，只允许一个线程访问。 读写锁：读写分离。读可以并行（可重复读），写写、写读、读写依然串行。对于读多写少的应用性能提升并行度。针对读读、读写优化。 读写锁的第二种（读已提交，不可重复读）：实现读后写并行。读锁可以被写锁升级。读锁-&gt;写锁。 写读还不能并行。死锁：读写：事务1申请A的读锁，事务2也加读锁并行读A。当事务1想把A升级成写锁需要等2释放读锁。反过来2要等1释放读锁。Update set A=A-1 where id=100先读查where再写会死锁U锁：先判断事务中的写操作，申请锁时把原来的读锁改写锁。事务2想要先read再update写A的时候就等待。 读写锁第三种（读未提交）：把读锁去掉，读不加锁。写后读并行，写后的读可提前。但是可能会读到读的中间状态。 mvcc多版本并发控制 本质：copy on write。每次写都是写一个新的数据，写在log里，不是原地更新。针对写读场景优化，例如：当前数据版本号v10,读版本号v5则去log里找v5的数据。在写操作加锁时，依然可以并发读。现在主流做法：实现写读、读读、读写不冲突。当写&gt;读 记录的日志很多 会增加延迟。 减小锁的覆盖范围：原地锁-&gt;MVCC多版本锁增加锁上可并行的线程数：读写分离 有的数据库不能支持大事务原因在于写读冲突，读在外面等待。 隔离性的扩展：SNAPSHOT 快照隔离级别：就是mvcc copy on write 无锁编程。 快照读：读事务开始之前的版本。达到读未提交的并行度。保证读到一致性的数据。 悲观锁：数据加锁使线程bloking状态，等到等待的锁ok回到runnable状态。把寄存器的数据换成另一个线程，把缓存清空，cpu的cache清空，增加系统开销。适合并发争抢严重的场景。乐观锁： 持久性延迟：RAID Controller 保证一个操作写两个以上磁盘group commit 组提交 mvcc：读应该读哪一个写之后的数据：逻辑时间戳(保证顺序) 说明事务内单元的先后SCN(Oracle)Trx_id（Innodb) 原子性：记录了undo操作，可以全部成功/失败 故障恢复： 业务属性不匹配：记录事务前的数据锁定bob、smith的账户-&gt;检查bob账户是否有100元-X不满足-&gt;回滚 死锁检测：碰撞检测/等锁超时https://www.cloudera.com/developers/get-started-with-hadoop-tutorial.htmlFragmentation: process of partitioning the database into disjoint fragments, Data allocation, degree of replication 事务(transaction)：对数据库进行读或写的一个操作序列.mysql 中 myisam innodb LVM（逻辑卷） Hash 分片 round robin ：每次新+物理机$hash(key)mod(K+1)$都要重新分配，在线系统缺乏灵活性 将物理机映射和数据分片映射由一个hash函数承担，机器个数K出现在映射函数中，紧耦合。 虚拟桶 virtual buckets:虚拟桶作为数据分片，用hash映射；物理机映射采用表格 3. 一致性哈希：和弦（chord）系统中提出。 哈希长度为5，哈希空间为32，节点映射到环的位置随机 每个机器节点负责存储一段哈希空间的数据，N14存储6-14的数据；N5存储0-5， 查询 N14接收到查询请求，Hash(key)=27,不在下一个节点20 查找每个机器节点都有的路由表，找到小于27的最大节点N25（前趋） 路由表存储距离$2^k$距离的节点($14+2^3&lt;25&lt;14+2^4$),路由表存储哈希空间长度条路由信息 回1，29返回数据给14 新节点 查找后继 更新前趋，新节点，后继的前趋后继信息 将后继节点s上存储的数据分片迁移到新节点 稳定性检测当有多个新节点插入，新节点的前趋节点置空 加入N8，将N8后继置N14，前趋置空开始稳定性检测 询问后继的前趋指向是N5 不是自己 N5不在N8和N14中间，通知后继修改前趋指向N8 N14中hash6-8的值迁移到N8完成稳定性检测 对前趋N5稳定性检测 N5询问后继的前趋不是自己 ，N8介于自己和N14之间，N5修改后继 完成检测 定期更新路由表 CAP 一致性(多副本对外单副本) 可用性（延迟） 分区容忍性（网络分区现象仍工作）改进：先识别网络分区，网络分区发生时记录每个分区的状态，执行各自操作，当分区恢复，融合产生新状态。P出现时每个分区经可能执行ACID 数据无副本，发生网络分区现象or宕机数据不可访问，不满足P 副本存储在不同机器上： 选择强一致性。数据同步前拒绝读，不能满足A可用信 选择可用性并不是最新数据，不满足C 幂等性：反复执行多次和一次的效果相同。$f(f(x))=f(x)$(取绝对值)$f(x,x) = x$ max(x,x) =x ; a AND a = a 最终一致性:不一致窗口 一致性协议脏读对象存储？？？ 大数据日知录]]></content>
  </entry>
  <entry>
    <title><![CDATA[flowRecommend图计算]]></title>
    <url>%2F2018%2F03%2F15%2FflowRecommend%2F</url>
    <content type="text"><![CDATA[识别实体连接到知识库wikipediaminerDBpediaSpotilight:Lucene等语义搜索OpenCalais Bootstrapping通过实体对识别关系pattern-&gt;识别pattern中的实体再识别pattern 迭代 共指消解Co-reference ResolutionTAC KBP(Knowledge Base Population)偏态系数 和 峰态系数中位数和均值的偏差，均值大叫正偏分布集中强度，正太分布的峰态是3，如果有一个分布的峰态5则可以拒绝正太分布假设 三大分布1.卡方分布：几个标准正太分布的平方和的分布2.t分布：正太分布的随机变量/卡方分布的变量 用于小样本估计成正太分布方差未知的总体的均值3.f分布：两个卡方分布的商 抽样误差数据分类定距（间隔）可以测量差值，但无绝对零点（温度）乘法，除法，比例是无意义的 判断正太分布84.5%的样本比 均值-标准差 大正太分布+-1倍标准差之间的累计值占69%，其它两边各占15.5%如果偏态系数绝对值大(0.x)， 极大似然 TUX GraphChi Preference 偏好 Goal model系统：自然语言偏好表达-&gt;用目标模型解释的正式的偏好说明。组成： 正则、统计语义相似性，基于语料库的偏好强度分级。目标：基于优先级的软件个性化定制接口。 流程推荐 流程结构相似度 相似度-&gt; 目的：检索、合并、重组计算流程相似度 计算优化分解策略 聚合策略 mapreduce 建模【流程模型】： 用图 邻接矩阵、流程模型： PTN:probabilistic time Petri net 流程信息 控制流、数据流、资源 流程文本、流程结构、流程语义 相似度方法结构相似度 MDS：matrix distance similarity MWT最小加权时间 方法-&gt;时间效率最高 图的编辑距离： greedyalgorithm､exhaustivealgorithm withpruning､processheuristicalgorithm､Astaralgorithm,其中平均性能最好的是 greedyalgorithm｡ 图挖掘算法：gSpan 频繁子图 流程相似度 执行轨迹 可达状态 因果关系 原则路径：根据流程结构可能发生的路径表示成一个集合 变迁系统（节点空间爆炸） 流程中的数据走向: 活动发生的概率。矩阵间距离 绝对值距离：非负、同一、对称、三角不等式-&gt;只比较部分对象 差异矩阵的所有元素 树的编辑距离现状：基于图的相似度检测复杂流程：计算路径的相似度 匹配搜索的效率并行！分解和合并得到拟合出来的相似度与串行计算的准确度计算 编辑距离(geeksforgeeks)[https://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/] 123456789i=len(a);j=len(b); d[i][j] 表示a转换成b的编辑距离 for (i = 0; i &lt;= lena; i++) &#123; d[i][0] = i; &#125; 长度为j的字符串转换成长度为0的字符串最小步数。 for (j = 0; j &lt;= lenb; j++) &#123; d[0][j] = j; &#125; 表示a[0]-a[j] -&gt;"" 123456（1）当a[i]==b[i],d[i][j]=d[i-1][j-1] // fxy -&gt; fay 的编辑距离等于 fx -&gt; fa (2) 当≠，min（ &lt;1&gt; fxy -&gt; fab 删除a[i] d[i-1][j]+1 fx-&gt;fab &lt;2&gt; fxy -&gt; fab 插入b[j] d[i][j-1]+1 fxyb-&gt;fab-&gt;(1)-&gt;fxy-&gt;fa &lt;3&gt; fxy-&gt;fab 替换a[i]为b[j] d[i-1][j-1]-&gt;fxb-&gt;fab) (3) 边界：a[i][0]=i CART -&gt; MARCH c-&gt;m t-&gt;c +H [] a只需要d[i]一行 MPI]]></content>
      <tags>
        <tag>grap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQueryCode]]></title>
    <url>%2F2018%2F03%2F15%2FjQueryCodee%2F</url>
    <content type="text"><![CDATA[browser sync自动刷新 npm install -g browser-sync 进入监听文件夹// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 腻子？ JavaScript代码，能够赋予浏览器未曾有过的功能 HTML5shiv 原理？ jq 目录 代码风格：.editorconfig 不同程序员和IDE协作文件 代码规范：eslintrc- node(后端) -brower(前端);.eslintrc.json继承，便于替换 项目版本：git 基于nodejs开发 使用grunt进行工程化管理 package.json devDependencies开发阶段依赖的包 转换规则babel-plugin-transform-es2015-for-of&quot;: &quot;7.0.0-beta.0&quot; 转换命令grunt-babel自动化任务 husky阻止git中不好的操作 .git/hooks commitplease保证git提交注释的格式规则 core-jses5\6\7的腻子 eslint-config-jquery 代码规范的配置 grunt-eslint grunt- grunt-cli(一般全局安装）控制台命令接口，安装对应的自动化插件 测试相关 require.js AMD规范 sizzle 纯js选择器 scripts可以运行的脚本npm commitplease 插件配置 npm install -g全局安装，操作系统任意路径都能找到 –save 本地安装 项目目录里 –save-dev 只在开发环境依赖 运行环境不依赖 npm install grunt --save-dev 加到devdependenceis grunt Gruntfile.js初始化grunt ，加载grunt插件的脚本文件，创建自动化任务 测试环境nodejs测试环境 chrome://inspect 控制台 node --inspect-brk .\app.js 第一行里加断点浏览器测试环境 &lt;script&gt;插入require.js;并设置入口文件data-main=&quot;index.js&quot; 123456789index.js 1. 默认路径配置require.config(&#123; baseUrl:"../src"&#125;)2. 声明依赖模块 路径是src/css.js(返回jqrery)require(['css'],function($)&#123; $('div')&#125;) jquery.js core.js define(依赖的模块,function(依赖模块返回的对象)) toArray: return slice.call( this ); 关联的对象转成数组return [].slice .call(this) 绑定上下文 [].slice.call(this)返回[window]类数组 get: return num &lt; 0 ? this[ num + this.length ] : this[ num ];从后往前数数组 pushStack:jQuery.merge(构建新的jQ对象 ES5普通的创建对象 每个构造函数都有一个原型对象 constructor属性指向构造函数123456789101112131415//1.创建构造函数function Student(name,sex)&#123; this.name = name ...&#125;//2. 创建构造函数原型对象Student.prototype=&#123; constructor:Student, //添加实例共享的方法 study:function()&#123; &#125;&#125;//3. 使用构造函数必须要用new 可以返回thisvar stu = new Student(a,b);stu.study(); jquery 构造函数 core.js:return new init(,) 避免使用new 但return的是init类型，prototype的方法不能用 init.js:init = jQuery.fn.init = function放到了jq的原型里； init.prototype = jQuery.fn;两个原型相等，解决原型方法 让两个构造函数引用同一个原型对象 jQuery.fn = jQuery.prototype添加fn属性，其实是prototype的简写 init.js创建DOM对象 if ( selector.nodeType )DOM元素有nodetype属性 slector不是string/DOM/functionreturn jQuery.makeArray( selector, this );是js对象 如果是string:判断是html标签 123if ( selector[ 0 ] === "&lt;" &amp;&amp; selector[ selector.length - 1 ] === "&gt;" &amp;&amp; selector.length &gt;= 3 ) parseHTML.js 1/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i ^&lt; 第一个符号是&lt; [^\/\0&gt;:\x20\t\r\n\f]*不是/,\0匹配NULL (U+0000) 字符,&gt;，:，\x20空格… [\x20\t\r\n\f]*很多空格 \/?可以有一个/ (?:)非捕获组。 捕获组：([a-zA-Z])\1:\1捕获组 $1捕获组的引用 &lt;\/\1&gt;:\1捕获前面([a-z][^\/\0&gt;:\x20\t\r\n\f]*)小括号中的内容 /i (忽略大小写)添加属性 $(html, props) 添加属性props是js对象this.attr( match, context[ match ] ); 是string但不是&lt;&gt;开头结尾： 正则html标签rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/, 非捕获+很多空白+&lt;任意一个字母或数字或下划线\和所有字母、数字、下划线以外的字符&gt;[^&gt;]* 除了&gt;之外的符号可以有很多个 或者 是id 是string 是css选择器 .class: findFilter.js document.find(selector)-&gt;jQuery.fn.extend( { find: function( selector ) 使用了第三方的Filter库 ？？？？使用sizzle $(“.face”,”#box”)在box找.facereturn this.constructor( context ).find( selector ); 重新返回构造#box的jquery中查找.face 是string 是function 传给jQuery.Deferred(); DOM加载完毕后执行 window.onload = function(){} 所有资源加载完毕后执行,只能绑定一次事件处理函数，绑定多次会覆盖 $(function(){});只要dom加载好，图片,css,js等不需要，可以绑定多次 callbacks 等待耗时操作执行完后自动执行的函数 字符串转对象 option可选参数12 sizzlesizzle $().ready(function(){ }) Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。 门面接口底层接口快捷方法ready和load事件ready先执行，load后执行 DOM文档加载的步骤： (1) 解析HTML结构。(2) 加载外部脚本和样式表文件。(3) 解析并执行脚本代码。(4) 构造HTML DOM模型。//ready(5) 加载图片等外部文件。(6) 页面加载完毕。//load promise1document.addEventListener( "DOMContentLoaded", completed, false ); 类数组对象 jquery实现了9种方法的重载 123456789101112131415var aQuery = function(selector) &#123; //强制为对象 if (!(this instanceof aQuery)) &#123; return new aQuery(selector); &#125; var elem = document.getElementById(/[^#].*/.exec(selector)[0]); this.length = 1; this[0] = elem; this.context = document; this.selector = selector; this.get = function(num) &#123; return this[num]; &#125; return this;&#125; 属性与方法作为对象的key与value的方式给映射到this上 立即调用表达式12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery; &#125;)(window); 减少变量查找所经过的scope作用域:当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量 挂在到window下执行 在外面就可以用$()执行函数 自执行 匿名函数，不存在外部引用.防止全局变量污染。 jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）小括号把表达式组合分块，每个小伙好把匿名函数括起来返回一个匿名函数Function对象。（function（）{})()目的：使匿名函数像有名字一样，可以取得它的引用位置。（单利模式）在这个引用位置后面加参数列表，实现普通函数调用。 1234(function(window)&#123; var jQuery=function()&#123;console.log("jqqqqqqq");&#125; window.aaa=jQuery//保留jquery定义的变量，只暴露为aaa() &#125;)(window); zepto的方式 12345var Zepto=(function() &#123; var Zepto= function()&#123;&#125;; return Zepto&#125;)();Zepto()]]></content>
  </entry>
  <entry>
    <title><![CDATA[javanet]]></title>
    <url>%2F2018%2F03%2F11%2Fjavanet%2F</url>
    <content type="text"><![CDATA[GradleTasks-build-jar/build apply plugin: &#39;java 打包成jar包 ‘war’打包成war包-&gt;build-&gt;war 可以放到tomcat下的webapp-子项目依赖在dependencies添加compile project(&quot;:model&quot;)冒号加项目名在settings.gradle中include 日志级别service debugcontroll info JPA实体对应表，实例对应行，类用javax.presistence.Entity注解 EntityManager接口 定义与持久性上下文进行交互的方法创建/删除实体，查找实体 Spring Data JPA自定义接口一定要实现Repository&lt;T,ID&gt;接口 T是操作的对象，ID是主键的类型，或者加上@RepositoryDefinition注解可以添加domainClass和idClass三个子接口curdRepository CURD的接口PagingAndSortingRepository 分页和排序接口JpaRepository 命名方式,索引参数1234@Query(select o from Employee o where o.name like %:name%)public List&lt;Employee&gt;query(@Param("name") String name);@Query(select o from Employee o where o.name like %?1%)public List&lt;Employee&gt;query(String name); 使用原生sql语句12@Query(nativeQuery = true,value = "select count(1) from employee")public long getCount(); 更新和删除必须和事务一起使用事务@Transactional放在service里 JWT 单点登陆 登陆信息不是在session而是在浏览器变量表达式：${}消息表达式：#{} 文本外部化、国际化、i18n选择表达式：*{} 一定要在${}的上下文中执行链接表达式：@{}分段表达式 spring中自建exception类要继承RuntimeException只有RuntimeException才会事务回滚，继承Exception不会。 使用PUT方式body要设置成x-www-from-urlencoded 过滤器：登陆、加密、解密、会话检查、图片转换。 spring通知、事务传播行为 maven依赖子类不用版本号 抓包记得开隐身窗口注意dp[one++][two++]=dp[one-1][two-1];的执行顺序 1,1不会等于0,0 分页 List.subList(,) SQL的limit或者Oraclerownumselect * from t_student limit 0,10从0取10条PostgerSQL：select * from t_student limit 10 offset 0 hibernate:123456String hql = "from Student";//创建Query或者Criteria对象Query q = session.createQuery(hql);q.setFirstResult(0);q.setMaxResults(10);List l = q.list(); 对象123456789public class Pager&lt;T&gt; implements Serializable&#123; //每页显示几条记录 private int pageSize; //当前页 private int currentPage; private int totalPage; private int totalRecord; private List&lt;T&gt; dataList;&#125; InternalResourceViewResolverbean配置页面的jsp路径和后缀名JstlView处理?clouseID=123用12(@RequestParam("courseId") Integer courseId,Model model)model.addAttribute(course); 处理rest风格的/{courseId}123@RequestMapping(value="/view2/&#123;courseId&#125;")(@PathVariable("courseId") Integer courseId,Map&lt;String,Object&gt;model)model.put("course",course); 在SpringMVC中使用HttpServletRequest等对象引入12&lt;groupId&gt;javax.servlet&lt;/groupId&gt;&lt;artifactId&gt;servlet-api&lt;/artifactId&gt; 12request.getParameter("courseId");request.setAttribute("course",course); @ModelAttribute模型自动绑定12//请求重定向return "redirect:view/"+course.getCourseId(); 文件上传表单属性enctype=&quot;multipart/from-dataaction页面拦截12//自动转型(@RequestParam("file") MultipartFile file) common-io中的文件流操作1FileUtils.copyInputStreamToFile(file.getInputStream,new File("")); Json 添加依赖1234@ResponseBody Course getCourseInJson(@PathVariable Integer courseId)ResponseEntity&lt;Course&gt; getCourseInJson(@PathVariable Integer courseId)&#123; return new ResponseEntity&lt;Course&gt;(course,HttpStatus.OK);&#125; 数据绑定 基本类型int当参数不能为空，包装类型可以为null 传数组?name=tom&amp;name=jack&amp;name=lucy用String[] name接收 横向越权不同用户相同权限的数据，A可以查看B的订单 纵向：变成管理员 封装响应对象status,msg,T dataJSP 指令&lt;%@ page属性=&quot;&quot; %&gt;属性 language，import，contentTypeinclude，taglib 脚本元素&lt;% out.println(&quot;&quot;) %&gt; 声明 12&lt;%! String s = " ";int add(int x,int y)&#123;return x+y;&#125;%&gt; 表达式&lt;% =s %&gt;不以分号结束 JSP声明周期 第一次用户请求.jsp，JSP引擎转为Servelet类（.java)，生成字节码文件，执行jspInit()初始化 解析执行字节码文件的jspService() jspService()处理客户端请求每个客户端一个线程。Servlet常驻内存。 JSP9大内置对象 out对象是JspWriter类实例。8k缓冲区 表单get提交数据小于2k action=&quot;.jsp&quot; request是HttpServletRequest的实例，接收action的js：12//修改接收的字符集 与表单页面的编码一致&lt;% request.setCharaterEncoding("utf-8")%&gt; URL传参，但这种方法设置request的字符集无效，要修改tomcat的server.xml的Connetor标签1&lt;a href="接收请求的.jsp?username=a"&gt;接收参数并跳转&lt;/a&gt; response.sendRedirect(&quot;.jsp&quot;)重定向 response中的.getWriter得到的PrintWriter总是先于out对象输出，可以使用out.flush强制刷新输出 session对象是HttpSession类的实例。保存在服务器的内存中，保存一个用户访问一个服务器页面切换仍然是同一个用户。用&lt;a href=&quot;.jsp&quot;&gt;后另一个页面仍能获得相同的session application对象是ServletContext类的实例。服务器的启动和关闭。get/setAttribute(,) page对象就是页面object pageContext对象可以获得所有session，response等对象 Config对象servlet初始化要用到的参数 请求重定向 请求转发重定向.sendRedirect：客户端行为response对象，两次请求，第一次请求对象不被保存（重定向到的页面无法获得原来的request内容。地址栏URL变化。 （登陆失败）转发：服务器行为。request.getRequestDispatcher().forward(req,resp)一次请求，转发后请求对象被保存（把request也转发，再把response传回原jsp），URL地址不变。（登陆成功）登陆成功12session.setAttribute("loginUser",username);request.getRequestDispatcher("success.jsp").forward(request,response); 在success.jsp获取1&lt;%=session.getAttribute("loginUser"); jsp动作标签和javaBean12345&lt;jsp:useBean id="u" class="U" scope="page"/&gt;&lt;jsp:setProperty name="u" property="*"&gt; 根据表单name自动和javabean的类自动匹配传统的表达式方式：&lt;%= u.getUsername()%&gt; &lt;jsp:getProperty name="u" property="username"&gt; 还可以用property+value设置值，可以通过param获得url传的参数 bean的四个作用域：page，request，session，application动作include、forward&lt;jsp:forward page=&quot;url&quot;/&gt;等同于request.getRequestDispatcher(“/url”).forward(request,response); mina创建连接1234//服务端SocketAcceptor acceptor = new NioSocketAcceptor();//客户端NioSocketConnector connector = new NioSocketConnector(); 设定过滤规则123456789101112DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();chain.addLast("obj",new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));//设置消息处理器 服务端acceptor.setHandler(new minaHandler());//服务器acceptor.bind(new InetSocketAddress(port));//客户端连接服务器ConnectFuture cf = connector.connect(new InetSocketAddress("localhost",9999));//客户端等待连接成功cf.awaitUninterruptibly();//客户端 发送cf.getSession().write(msg); 消息处理器extends IoHandlerAdapter重写session接收的方法 Spring配置文件读取bean declarationtx声明式事务配置文件 struts2 加入jar包：asm 替代反射，字节码操控框架；ognl struts2的标签库；xwork和webwork整合的包 sturts.xml放入src负责Action映射和Result定义、拦截器； &lt;include&gt;把每个功能的配置放到不同的xml文件里导入动态方法调用： 解决action太多&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value = &quot;true&quot;&gt; &lt;action name = &quot;addAction&quot; method=&quot;add&quot; class=&quot;&quot;&gt;遇到add.action时调用指定类中的add 方法 通过!add.action访问&lt;action&gt;&lt;result name=&quot;add&quot;&gt;/result.jsp&lt;/result&gt;对应action的方法中return &quot;add&quot;对应result的name字符串 通配符name = &quot;{2}_*&quot; method={1} class=&quot;..{1}Action&quot;访问helloworld_add.action可以匹配add和helloword默认错误路径 &lt;default-action-ref name=&quot;index&gt;并配置名为index的action 参数：&lt;contant name=&quot;struts.action.extension value=&quot;&quot;&gt;不用输入.action后缀 struts.properties 全局属性文件；可以不用，在struts.xml用constant元素 在web.xml配置核心过滤器 core包下的;/*.jsp和.html不拦截12345678&lt;filter&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;filter-class&gt;...dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;url-pattern&gt;\*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Struts原理 HttpServltRequest经过ActionContextCleanUp、各种Filter .action的请求会到ActionMapper返回Filter Filter发给ActionProxy 并读取struts的配置文件，找到具体的action类，通过ActionProxy代理创建Action实例 经过拦截器执行到action返回result是字符串对象对应视图（JSP/FreeMaker） 继续经过拦截器 通过HttpServletResponse返回到用户实例进行显示 Action搜索顺序: 顺着不存在的包名向上查，包名存在则查找action 动态方法调用： URL读取html1234567891011121314import java.net.*;import java.io.*;public class URLReader&#123; public static void main(String[] args) throws Exception&#123; URL cs = new URL("http://www.sina.com"); //直接获得inputStream BufferedReader in = new BufferedReader( new InputStreamReader(cs.openStream())); String inputLine; while((inputLine = in.readLine())!= null) sout(inputLine); in.close(); &#125;&#125; 意外处理try{}catch(MalformedURLexception e) 不符合URL常规的url异常-123URL url = new URL("https://baidu.com");HttpURLConnection conn = (HttpURLConnection)url.openConnection();BufferedInputStream in = new BufferedInputStream(conn.getInputStream()); tomcat server.xml 12345678910111213&lt;server&gt; &lt;service&gt; &lt;Connector&gt; &lt;/Connector&gt; &lt;Engine&gt; &lt;host&gt; 可以有多个host虚拟主机 &lt;Context&gt; web应用 &lt;/Context&gt; &lt;/host&gt; &lt;/Engine&gt;&lt;/server&gt; Connector 接收用户请求，Coyote实现(BIO)阻塞式IO adddress只监听的地址 acceptCount 没有空闲线程时的排队长度默认100 maxConnections 线程池的最大值 -1 不限制 线程池：事先创建一定数目的线程，减少了线程创建与销毁的过程12&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/&gt; Engine 处理Connector接收到的用户请求 maven在webapp &gt; WEB-INF &gt; lib中加入的jar包，发布到服务器中自动加载12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifiactId&gt;maven-compiler-plugin&lt;/artifiactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/compilerArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; pom 项目对象模型 &lt;properties&gt;中配置的常量属性可以用${property}取 子pom和父pom可以继承覆盖 Super POM中有默认设置 user/.m2/repository本地缓存的仓库 中央仓库生命周期clean:清理项目pre-clean clean post-clean default: 构建项目 validate，process-resources运行package会自动运行compile、testsite:生成站点文档&lt;scope&gt;provided&lt;/scope&gt;只在编译和测试时运行 依赖范围：&lt;scope&gt;6种 compile：默认。编译测试运行都有效。 provided在编译和测试时有效，运行无效。例如servlet-api因为web容器已经有api了 runtime：运行、测试有效。例如jdbc驱动api test:测试时有效。例如junit system：编译和测试有效，不可移植，与系统相关联。例如引入本地的JAVA_HOME import:只用在dependencyManagement中，表示从其它pom中继承的依赖。 命令mvn complie编译 test测试 package打包 clean删除target install安装jar包到本地仓库 archetype插件 建立符合规定的目录骨架mvn archetype:generate gitgit push -u origin master Servelet:运行在server端的java程序 1.java类 没有main方法 2.运行于容器 提供请求-响应的web服务 servlet处理流程 pom.xml:tomcat: 123&lt;configuration&gt; &lt;path&gt;/web_project_template&lt;/path&gt;&lt;/configuration&gt; servlet容器的配置文件web.xml找到对应的Servlet,转发到service方法 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;..TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;servlet-mapping&gt; 客户端请求http对象的时候service方法被调用 客户端使用get方法访问时doGet方法被调用TestServlet.java12345678910@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("doGet method"); PrintWriter pw = resp.getWriter(); //设置文件类型 response.setContentType("text/html;charset=utf-8") pw.print("/hello"); pw.close(); &#125; Servlet 生命周期生命周期方法由服务器调用 默认web客户端第一次请求容器，创建servlet实例 调用init(ServletConfig) 请求处理 转发请求 destory get通过header传输数据，post通过body传输 ServletConfig：以servlet为单位 123456789101112&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;data1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;data2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt; 12ServletConfig config = this.getServletConfig();String v1 = config.getInitParameter("data1"); context-param ：全局配置 ServletContext对象 web应用中全局唯一 1234&lt;context-param&gt; &lt;param-name&gt;globalData1&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt;&lt;/context-param&gt; 12ServletContext ctx = this.getServletContext();String v1 = ctx.getInitParameter("data1"); servletContext 可以CLUD共享不是事先知道的动态信息 12//在context中设置属性ctx.setAttribute("attribute1", "111"); 读取外部资源配置文件信息： ServletContext.getResource :URL .getResourceAsStream .getRealPath:File ??? Properties 对象 web.xml 部署描述符为一个servlet配置多个url-pattern、/*模糊匹配 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 匹配优先级规则 监听器 用途： 统计在线人数和在线用户 HttpSession 系统启动时加载初始化信息 缓存、数据库链接ServletContext 统计网站访问量 spring相关 用法： impletemts ServletContextListener 在web.xml注册 1&lt;listener&gt;&lt;listener-class&gt;&lt;/listener-class&gt;&lt;/listener&gt; 上下文对象，web启动时创建，web销毁 销毁 监听器的启动循序按注册顺序。 优先级：监听器&gt;过滤器&gt;servlet加载 监听器种类 ServletContext监听应用程序环境对象 HttpSession用户会话对象 ServletRequest请求消息对象 MIME 多用途 互联网 邮件 扩展 类型设定某种扩展名的文件用什么应用打开 1234&lt;mime-mapping&gt; &lt;extension&gt;java&lt;/extension&gt; 扩展名映射类型 &lt;mime-type&gt;text/plain&lt;/mime-type&gt;&lt;/mime-mapping&gt; Session &amp; Cookie Cookie 短时间，数据频繁访问 保存在客户端 V0: Set-Cookie: userName= “”; Domain= “” V1: Max-Age= 1000 实际： Version= “1” Session NANE为JSESIONID的 Cookie 保存在服务端 Cookie 会话cookie 关闭浏览器消失，保存在内存中 setMaxAge 设置cookie有效期，浏览器会把cookie保存到硬盘上 一个站点最多能保存20个cookie，每个4k以内cookie12345678910111213141516171819202122/***第一次请求把cookie设置好**/Cookie userNameCookie = new Cookie("userName", userName);Cookie pwdCookie = new Cookie("pwd", userPassword);/***设置时间**/userNameCookie.setMaxAge(10 * 60);pwdCookie.setMaxAge(10 * 60);/***把cookie放到响应中**/response.addCookie(userNameCookie);response.addCookie(pwdCookie);/***第二次从请求中获取cookies数组**/Cookie[] cookies = request.getCookies();//第二次if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals("userName")) &#123; userName = cookie.getValue(); &#125; if (cookie.getName().equals("pwd")) &#123; userPassword = cookie.getValue(); &#125; &#125;&#125; Session 默认有效期30分钟 setMaxInactiveInterval设置有效期 部署描述符设置有效期 invalidate Session失效 第一次请求：服务器创建session对象，把SessionID作为cookie发送给浏览器 12345678910//创建Session对象HttpSession session = request.getSession();session.setAttribute("userName", userName);// 第二次请求String name = (String) session.getAttribute("userName");if (name != null) &#123; //服务器已经保存了session System.out.println("second login: " + name); &#125; 第二次 Request:Cookie: JSESSIONID=B2980D3ABAB39EF6EA09F278F261C2A4; Session钝化：不不常使用的session对象序列化到文件/数据库tomcat两种钝化管理器 StandardManger tomcat 关闭重启时，web应用重启时（覆盖了web.xml)，钝化到文件。钝化到/work/Catalina/hostname/applicationname/SESSION.ser重启时加载删除 Persistentmanager Servlet3.0 @WebListner免注册声明为监听器转发与重定向 转发对象：RequestDispatcher(&quot;.jsp&quot;).forward(request,response) 重定向：是两次请求 获取不到原来的req tail -f 监视日志输出 javax.servlet Servlet 所有Servlet必须实现的方法 Config Servlet配置信息 Context 容器信息 GenericServlet底层（实现了5个servlet中的方法） javax.servlet.http HttpSession标识并存储客户端信息 HttpServletRequest getParameter(String key)获得第一个name和key一样的表单控件的数据 getParameterValues同上返回数组 getParameterMap 返回kv getParameterNames 返回所有表单控件的name值 HttpServlet 扩展GenericServlet Cookie 存储Servlet发送给客户端的信息 javax.servlet.annotation 注解 javaWeb域对象：存、取数据（Map） Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)]]></content>
      <tags>
        <tag>java</tag>
        <tag>javaNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mlpractice]]></title>
    <url>%2F2018%2F03%2F09%2Fmlpractice%2F</url>
    <content type="text"><![CDATA[混淆矩阵：误差矩阵标签传播LP算法（基于图）1.半监督学习的假设： 1）Smoothness平滑假设：相似的数据具有相同的label。 2）Cluster聚类假设：处于同一个聚类下的数据具有相同label。 3）Manifold流形假设：处于同一流形结构下的数据具有相同label。 2.相似度矩阵数据点为节点，包括labeled和unlabeled数据。边表示两点的相似度。假设图是全连接.边ij的权重$W_{ij}=exp(\frac{-||x_i-x_j||^2}{α^2})$ α是超参。另外可以构建KNN图 稀疏相似矩阵，指保留每个节点的k近邻权重，其它为0。 3.传播，权重越大传播概率越高 转移概率$P_{ij}=P(i-&gt;j)=\frac{w_{ij}}{\sum_{k=1}^nw_{ik}}$ 假设C个类，L个labeled的样本，则LxC矩阵$Y_L$i行是第i个样本的标签指示向量。如果第i个样本类别是j，则[i][j]为1，其它为0。 建立unlabeled的矩阵$Y_U$UxC同理。 合并得到NxC句矩阵。F=[Y_L;Y_U] (L+U=N行）保留样本i属于每个类别的概率。 4.算法步骤 F=PF：每个节点以P的概率传播给其它节点。 $F_L=Y_L$ (Y_L的标签是已知的，要保留，覆盖回原来的值) 重复以上两步直到F收敛。5.优化算法。$F_L$部分是不变的.浪费的计算。将概率转移矩阵变成$$P=\begin{bmatrix} P_{LL} &amp; P_{LU} \\ P_{UL} &amp; P_{uU} \\\end{bmatrix}$$只计算$F_U=P_{UU}F_U+P_{UL}Y_{L}$ 取决于无标签转移概率、有标签的相似度矩阵、无标签当前标签的转移概率。算法可以优化成并行的，切分F_U 1. Logistic 损失函数L：单个训练样本 $\hat{y}=p(y=1|x)$ 给定样本x的条件下，输出y=1的概率 成本(cost)函数J:全体训练样本$\frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})$ cost：每个样本的乘积的最大似然估计 *1/m Logistic损失函数 $L(\hat{y},y) = -(ylog\hat{y}+(1-y)log(1-\hat{y}))$ 当y=1,$L =-log\hat{y}$ 让误差最小，则让$\hat{y}$大，$\hat{y}$经过sigmoid小于1 当y=0,$L = -log(1-\hat{y})$,则$\hat{y}=0$ 矩阵乘法：左向量组，列数是向量的维度；右线性空间；相乘：将向量组线性变换到新的线性空间。 右边的行数最少要满足由基地向量构成的线性空间维度。 特征向量：向量值发生了伸缩变换，没有旋转。伸缩比例是特征值。 梯度下降 $w=w-\alpha\frac{dJ(w,b)}{dw}$ $b=b-\alpha\frac{dJ(w,b)}{db}$ 反向传播 计算loss对每个变量的梯度，通过链式法则a=sigmoid($\hat{y}$)正向传播:1.计算wx+b 2.经过sigmoid求出$\hat{y}$ 3.计算loss反向传播: da=loss对$\hat{y}$求导 dz = da*sigmoid求导 dw1 =dz*z对w1求导 向量化：不用一个for循环 正向传播 1.$z=w^Tx+b$ 2.np.dot(w.T,x)+b 3.$\hat{y}$=simgmoid(z) 反向传播 4.$dz = \hat{y} - y$ 5.dw = 1/m*np.dot(x,dz.T) 6.db = 1/m*np.sum(dz) 梯度下降 7.w = w-αdw 8.b = b-αdb以上for 梯度下降多少次 dcost = 1/m*np.sum(dz)- 创建一维向量不用要np.random.randn(5)因为a.shape=(5,)用： 列向量np.random.randn(5,1);行向量np.random.randn(1,5) 2. 浅层NNtanh是sigmoid的平移tanh效果好因为 激活函数平均值接近0，tanh在所有场景几乎最优 不用sigmoid了输出层用sigmoid：因为（0，1）之间的二分类问题 tanh和sigmoid的问题是z很大时，梯度很小，梯度下降效率低 $g’(tanh(z))=1-(tanh(z))^2$ ,$1-a^2$ ReLu:修正线性单元(rectified linear unit):ReLU:= $a=max(0,z)$ 只要z&gt;0,导数=1；z&lt;0,导数=0除了输出层，都用ReLU为激活函数 Leaky-ReLU：z&lt;0时让导数不为零，有一个很小低梯度max(0.01*z,z) 虽然有一半导数=0，但因为有足够多的隐藏单元另z&gt;0 $g’=1 if z&gt;0$ 神经网络初始化：不能初始化为0，这样两个隐藏单元会相同。$W^{[1]}$ = np.random.randn((2,2))0.01 使梯度较大$b^{[1]}$ = np.zero((2,1))$W^{[1]}$ = np.random.randn((2,2))0.01 二分类问题时da 最后一层$L(a,y) = -(ylog(a)+(1-y)log(1-a))$$da^{[1]} = -y/a + (1-y)/(1-a)$ bias偏差/variance方差 high bias -&gt; 欠拟合 -&gt;选择新的网络直到至少可以拟合训练集 high variance -&gt; 过拟合 -&gt;更多数据/正则化/回到1换模型 正则化- 高variance 过拟合 L2正则:w通常是一个高维参数矢量已经可以表达high variance 问题$+\frac{λ}2m||w||_2^2$ L1正则:$\frac{λ}m||w||_1$ 使用L1正则化，w最终会稀疏,w向量有很多0 Dropout随机失活 多用于图像 a3 表示三层网络各节点的值, $a3=[a^{[1]},a^{[2]},a^{[3]}]$ 权重转成0或1：d3=np.random.rand(a3.shape[0], a3.shape[1]) &lt; keepProb 删除节点：a3 = np.multiply(a3, d3) 为了不影响原来Z的期望，a3 /= keepProb http://archive.ics.uci.edu/ml/——最有名的机器学习数据资源来自美国加州大学欧文分校 http://aws.amazon.com/publicdatasets/美国人口普查数据、人类基因组注释的数据\维基百科的页面流量\维基百科的链接数据 http://www.data.gov——Data.gov启动于2009年，目的是使公众可以更加方便地访问政府的数据flavor 中加时间向量，对每一个flavor进行时序预测，sumflavor 有序字典 预测目标变量的值，则可以选择监督学习算法,需要进一步确定目标变量类型，如果目标变量是离散型，如是/否、1/2/3、A/B/C或者红/黄/黑等，则可以选择分类算法.k-近邻算法 线性回归 朴素贝叶斯算法 局部加权线性回归支持向量机 Ridge 回归决策树 Lasso 最小回归系数估计 科学函数库SciPy和NumPy使用底层语言（C和Fortran）编写，提高了相关应用程序的计算性能。 8.1 NumPy提供一个线性代数的库linalg，其中包含很多有用的函数。可以直接调用linalg.det()来计算行列式第9章 用分类算法来处理回归问题 15 MapReduce:数值型和标称型数据。 过去100年国内最高气温：每个mapper将产生一个温度，形如&lt;”max”&gt;，也就是所有的mapper都会产生相同的key：”max”字符串集成算法生成多个分类器再集成 全选分类器 求平均 pandas 时间序列关键点：极大值，极小值or拐点 用关键点代替原始时间序列。 合并关键点序列时间下标 得到等长序列 Lance距离 无量纲。欧式距离缺点L:有量纲，变差大的变量在距离中贡献大。 FCM算法 每条时间序列属于各个类的程度。 ARIMA自回归综合移动平均Auto-Regressive Integrated Moving Averages. Number of AR (Auto-Regressive) terms (p)： 现在点使用多少个过往数据计算。 Number of MA (Moving Average) terms (q)：使用多少个过往的残余错误值。 Number of Differences (d)：非季节性的个数（小编：其实是否求导数）。 日期范围 pd.date_range(‘4/1/2012’,’6/1/2022’) 默认按天 pd.date_range(start=’4/1/2012’,periods=20) 每个月最后一个工作日 “BM”频率pd.date_range(‘1/1/200’,’12/1/2000’,ferq=’BM’) 规范化到午夜 WOM日期 Week of Month freq=’WOM-3FRI’每月第3个星期五5 时区 numpy random.rand(4,4) -&gt; 4x4的 array 12arr_alice = arr[5:8]arr_alice[0] =11 arr的值也会改变np 的切片和赋值不会copy arr[5:8].copy()arr_alice = arr[5:8].copy()显示复制，arr不会被改变 多维数组 arr2d[0][2] == arr2d[0,2] np.random.randn(7,4)生成正态分布的随机数names==&#39;bob&#39; [True,Fales] list,data[names==&#39;bob] boolean数组可以用于索引data[-(names==&#39;bob&#39;)] 花式索引arr[[4,3,0,6]] 获取第4、3、0、6 行 array([1,2,3]) from numpy import array list对应元素相乘：某个向量沿着另一个向量的移动量。array(list)*array(list2)对应元素相乘 .dtype 同构数据元素的类型 zeros(10) ones(10) 全0or全1数组 empty((2,3,2)) 创建没有任何具体值的数组 np.dot(arr.T,arr) 内积nonzero(array) nonzeros(a)返回数组a中值不为零(Flase)的元素的下标 transpose([])转成array linspace(start,stop,num，endpoint=False)返回长为num的array 数值从start到stop渐变，endpoint=False递增 mat,matrix123- from numpy import mat, matrixmat([1,2,3])/matrix([1,3,4])mat([1,3,4])[0,1] #=3 矩阵相乘:矩阵相乘，multiply内积`mat(list)mat(list2).T` 内积 from numpy import shape 查看矩阵or数组的维数矩阵第一行元素jj[1,:]矩阵对应元素相乘:矩阵相乘还可以看成是列的加权求和矩阵相乘的MapReduce版本。??from numpy import multiply 1234multiply(mat(list),mat(list2))matrix([[ 2, 6, 12]])array(list)*array(list2)array([ 2, 6, 12]) 矩阵数组排序 .sort() 原地排序 结果占用原始存储空间 每个元素的排序序号： 123&gt;&gt;&gt; dd=mat([4, 5, 1])&gt;&gt;&gt; dd.argsort()matrix([[2, 0, 1]]) 数组/矩阵均值 .mean() 矩阵的逆.Ilinalg.inv(A) 矩阵要可逆必须要是方阵。如果某个矩阵不可逆，则称它为奇异（singular）或退化（degenerate）矩阵。 一种方法是对矩阵进行重排然后每个元素除以行列式。如果行列式为0，就无逆矩阵。 mat()*mat().I ≠1 计算机处理误差产生的结果 4×4的单位矩阵eye(4)/identity(4) 矩阵相关 行列式det(A) 秩 linalg.matrix_rank(A) 可逆矩阵求解 矩阵范数: 给向量赋予一个正标量值 到原点的距离 L1：Manhattan distance。z=[3,4] $||z||_1=3+4=7$各元素绝对值之和 任意阶范数公式 二阶linalg.norm([8,1,6]) 欧式距离 sqrt((v1-v2)*(v1-v2.T)) 曼哈顿距离 sum(abs(v1-v2)) 切比雪夫距离：国际象棋国王的步数abs(v1-v2).max() 夹角cosθcos = dot(v1,v2)/(linalg.norm(v1)*linalg.norm(v2)) 汉明距离 汉明距离：shape(nonzero(v1-v2)[1])[0] ？编辑距离：A=”909”，B=”090”。A与B的汉明距离H(A, B) = 3，编辑距离ED(A, B) =2。 ？文本相似度simHash Jaccard(杰卡德) 集合 相似性系数：样本集交集与样本集并集的比值，即J = |A∩B| ÷ |A∪B|：两个文档的共同都有的词除以两个文档所有的词 杰卡德距离 1-J=（并-交）/并：12import scipy.spatial.distance as distdist.pdist(mat,'jaccard') 相关系数 相关距离（线性相关）coefficient 系数；12345mv1= mean(mat[0])mv2= mean(mat[1])std1= std(mat[0])std2= std(mat[1])cor= mean(multiply(mat[0]-mv1,mat[1]-mv2))/(std1*std2) 马氏距离 协方差是对角阵、单位矩阵（两个样本向量之间独立同分布） 马氏距离为欧式距离 马氏距离 量纲无关 协方差矩阵的逆：linalg.inv(cov(mat))inv()矩阵求逆 tp =mat.T[0]-mat.T[1] dis = sqrt(dot(dot(tp,covinv),tp.T)) 特征向量特征值 evals(特征值）,evecs（特征向量） = linalg.eig(mat) ?手工求特征值 12#求方程根roots(A) 还原矩阵 $A=Q∑Q^-1$ 123#特征值构成的对角阵sigma = 特征值*eye(m)特征向量*sigma*linalg.inv(特征向量) 矩阵求导:A向量（2·1）对B（3·1）求导，得到3·2的矩阵 model = ARIMA(ts_log, order=(2, 1, 2))！qiudaoresults_ARIMA = model.fit(disp=-1)plt.plot(ts_log_diff)plt.plot(results_ARIMA.fittedvalues, color=’red’)plt.title(‘RSS: %.4f’% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))plt.show()dic:key不存在，就会触发KeyError错误 假设验证 实验结果是否有统计显著性或随机性 归一化：转换成无量纲 标准化后的值= （标准化前的值-分量的均值）/分量的标准差 标准化欧氏距离方差的倒数为权重的加权欧氏距离123456789101112# 欧氏距离mat([[1,2,3],[4,5,6]])v12 = vmat[0]-vmat[1]sqrt(v12*v12.T)# 标准化#1.方差vstd = std(mat.T,axis=0)#2.（标准化前的值-所有值的均值/方差norm = (mat-mean(mat))/vstd.T#3.欧式距离normv12 = norm[0]-norm[1]sqrt(normv12*nromv12.T)]]></content>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[problems]]></title>
    <url>%2F2018%2F03%2F09%2Fproblems%2F</url>
    <content type="text"><![CDATA[fallthrough 是什么idea提示代码过长怎么办？ docker toolo安装 vb环境变量后面要加’\’ 获取不到ip 等 加速器DaoCloud 要在etc/docker/deamon.json里去掉最后的逗号 并且要service docker restart netty in action&gt;&gt;The POM for nia:utils:jar:2.0-SNAPSHOT is missing, no dependency information availablemvn install -pl utils java ASM coding=UTF-8 IDEA Push failed: Failed with error: fatal: Could not read from remote repositoryIDEA-&gt;setting-&gt;git -&gt; ssh executable -&gt;native PYDEVD_LOAD_VALUES_ASYNC=True; disable “Show command line afterwards”https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000749030-How-to-stop-interactive-console-running Intel MKL FATAL ERROR: Cannot load mkl_intel_thread.dll. hexo markdown的坑小胡子语法两个大括号会报错！！！！二维数组！！ windows 启动zookeeper Server闪退；环境变量里要设置JAVA_HOME变量]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231]]></title>
    <url>%2F2018%2F03%2F09%2FCS231%2F</url>
    <content type="text"><![CDATA[4.1 backprop反向传播 链式法则的递归调用反向传播可以得到损失函数L因为$\frac{\partial L}{\partial x} = \frac{\partial L}{\partial z}\frac{\partial z}{\partial x}$利用上游传回的梯度 反向计算每个节点的本地梯度 最后一个节点的梯度总是1？ 加法门是gradient distributor加法节点之前的本地梯度是1,分支与上游又相同梯度 max门通过后本地梯度分别是0，1 （max只有一个值可以影响上游） mul乘法门 对上游值缩放]]></content>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About CentOS]]></title>
    <url>%2F2018%2F03%2F08%2FAbout-CentOS%2F</url>
    <content type="text"><![CDATA[开放端口firewall-cmd --permanent --add-port=8080-8085/tcpfirewall-cmd --reload如果开的是区间，关也要关区间firewall-cmd --permanent --remove-port=8080-8085/tcpfirewall-cmd --permanent --list-ports perf 监视java程序上下文切换情况 windows perfmon性能监视器 JDK自带的jvisualvm、jstack 修改主机名cat /ect/hostname 查找命令which ls ll tty终端 /dev/zero 零设备文件 /dev/null回收站 /dev/random 产生随机数 useradd tmpuser会在home下创建用户文件夹 df -h 查看存储容量 du -sh /usr 80%的空间占用是/usr tree -L 1树型显示一层 yum -y install tree 创建文件touch /home/{f1,f2}用集合创建两个文件{1..20}范围 copy -v-v, –verbose explain what is being done wc -l /var/log/messages显示文件行数 head tail查看头尾 less分页显示 grep &#39;root&#39; /etc/passwd在文件中用正则查找关键字的行 ll -a &gt;list.txt重定向到文件 7种文件类型（-文件 d目录 l软链接）-rw-r--r--10位权限 （r4 w2 x1 读写执行权限 -没有权限 rwx7r-x5r-x5）设计成2的幂次因为不会歧义rw-u所有者权限r--g所属组r--其他人 chmod [] 模式 文件名 修改权限chmod u+x,g+w xxx.avi赋予执行chmod u=rwx file所有人chmod a=rwx filechomd 777 fild RPM查找文件 r:读(cat,more head,tail) 目录(ls)w:写，追加(vi,echo 111&gt;file)但是不能删除 删除是上一级的权限 目录(touch新建目录，rm，mv，cp)x： 对目录可以(cd)目录的最高权限是x，文件最高权限是w 运行javajava xxx.class要在/etc/profile加入CLASSPATH=.:$JAVA_HOME/jre/lib/ext:source /etc/profile 文件系统 FHS文件层次结构标准颜色 黄色：表示设备文件 浅蓝色：链接（快捷方式）/usr(Unix Software Resource)软件/usr里面放置的数据属于可分享的与不可变动的(shareable, static) 相当于C:/windows /usr/local相当于c:/program/opt三方协力软件/etc配置文件/var系统运作相关/proc 进程：系统内存的映射/selinux：防火墙 ls -lh 查看文件属性pwd 当键目录ls -al --full-time完整显示文件修改时间 12345678# 查看 cpu 型号sudo dmidecode -s processor-version# 查看 cpu 个数grep 'physical id' /proc/cpuinfo | sort -u | wc -l# 查看核心数grep 'core id' /proc/cpuinfo | sort -u | wc -l# 查看线程数grep 'processor' /proc/cpuinfo | sort -u | wc -l fork 启动后台进程环境变量vi /etc/profile 软连接： 零拷贝：文件传输只通过内核空间传输给socket vi :q! 备份：cp server.xml server.xml.bak]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python modules]]></title>
    <url>%2F2018%2F03%2F08%2FPython-models%2F</url>
    <content type="text"><![CDATA[deque GIL线程安全的 list不安全copy：shallow copy 浅拷贝 id不一样。看起来隔离了，但是如果deque里[2]是一个可变对象list，拷贝的是索引 深拷贝：12import copyuser_deque2 = copy.deepcopy(user_deque) 多线程 global interpreter lock 全局解释器锁，python线程对应c中的线程一次只有一个线程在一个cpu上同一时刻只有一个线程在一个cpu上执行字节码。无法将多个线程映射到多个cpu上，并发受限 同时修改global变量的两个线程会不安全 py2和3不同。 按字节码行数/时间片，会释放全局解释器锁。io操作也会释放 Condition 条件变量两层锁：底层调用wait释放就能acquire。wait分配放入等待队列的锁，等notify。实现了__enter__和__exit__可以用with语句wait： 获得waitter锁 放到Condition的waiters双端队列里 会释放Condition的锁notify:从waiters队列弹出一个，释放waiter锁 Semaphore控制进入数量socketAF_IPX：linux进程间通信 SOCK_DGRAM：UDP 服务端.bind((&quot;0.0.0.0&quot;,8888))而不是127.0.0.1（本机局域网ip访问不到）客户端直接访问.connect((&#39;127.0.0.1&#39;,8888))并且send(&quot;&quot;.encode(&quot;utf-8&quot;))send的时候一定要发送byte类型 socket模拟http请求1234client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect((host,80))client.sent("GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection:close\r\n\r\n" .format(path,host).encode("utf8")) 装饰器 LEGB： encloseing函数内部与内嵌函数之间 【闭包】 装饰器与AOP reload 1. 函数元数据123456def f(): cc = 2 return lambda kk:cc**kk #不会因为f退出以后lambda访问不到ag = f()g.__closure__[0].cell_contents### 输出2 可以访问到cc 2. nonlocal嵌套的def中。允许修改修改嵌套作用域变量。把信息和回调函数联系起来：lambda or call timeout 是闭包内的一个自由变量，在setTimeout中timeout = k会创建本地timeout.nonlocal声明嵌套作用域下的变量 可修改参数的装饰器 为包裹函数添加一个属性函数，修改自由变量123456789101112131415161718192021from functools import wrapsimport timeimport loggingdef warn(timeout): def decorator(func): def wrapper(*args,**kargs): start = time.time() res = func(*args,**kargs) used = time.time() -start if used &gt;timeout: msg = '%s:%s&gt;%s' % (func.__name__,used,timeout) logging.warn(msg) return res #作为wrapper的一个属性 def setTimeout(k): nonlocal timeout timeout = k # 可以被调用 wrapper.setTimeout = setTimeout return wrapper return decorator 测试：123456789from random import randint@warn(1.5)def test(): print('int test') while randint(0,1): time.sleep(0.5)test.setTimeout(1)for _ in range(30): test() py2中没有nonnocal不能修改变量的引用，将timeout实现成一个可变对象12345def warn(timeout): timeout = [timeout] ... def setTimeout (k): timeout[0]=k hashable 不可哈希的元素有：list、set、dict可哈希的元素有：int、float、str、tuple unhashable type: ‘set’ ，dicc = {set([1]):222} set 不能当字典键 用frozenset12345#输出交集 if item&amp;frozenset(['2']): print item if item.intersection('2'): print item frozenset不可变 存在hash值 没用add\remove将集合作为字典的键值dict.update() 求并 123456a =frozenset([3])b =frozenset([2])list=[]list.append(a|b)listOut[12]: [frozenset(&#123;2, 3&#125;)] s.issuperset(t) 测试是否 t 中的每一个元素都在 s 中 Python虚拟机是单线程（GIL）只有I/O密集型才能发挥Py的并发行，计算密集型值需要轮询。 配置utf-8输出环境reload(sys)sys.setdefaultencoding(‘utf-8’) stringsplitlines() 按照行(‘\r’, ‘\r\n’, \n’)分隔splitlines(True)保留换行符 内置函数12345row = [p == '+' for p in line.split()[0]]#转换成T,F序列#对一个区间更改值row[i:j]=[not p for p in row[i:j]]all(row)#如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False； 返回对象的内存地址。 id(a)==id(b) issubclass(AA,A) AA是否是A的子类 python的=是引用 a=1,a=2 右值是int对象 id(a)改变数字&#39;{0:o},{1:x},{2:b}&#39;.format(64,64,64)八进制、16进制、2进制 enumerate 偏移值(index,value)for (offset,item) in enumerate(&#39;apple&#39;):print(item,offset)help(enumerate) 模块import syssys.path #模块搜索路径 roloadcopypython3 copy源码分析 immutable类型: int,float,complex |string tuple frozen set mutable: list,dict,set,byte arry copy使用各自的copy函数 12345copy.pyd[list] = list.copyd[dict] = dict.copyd[set] = set.copyd[bytearray] = bytearray.copy a= (1,2,[3]) tuple中的list可变a[1]=10 id(a) list的地址空间不变 12x= [[1,2,3]] y= x.copy(x)//y=copy.deepcopy(x) .copy(x) 浅id(x)!=id(y) id(x[0])==id(y[0]) .deepcopy(x) 深id(x[0])==id(y[0])递归调用 生成器 g = (x * x for x in range(10)) 每次调用next()遇到下一个yield返回 运算符重载 __getattr__ 点号运算 __getattribute__属性获取 __getitem__ 列表解析、元组赋值，map、for循环，索引、分片运算；L[::]分片是L(slice(,,)分片对象)的语法糖，getitem接收了slice对象 __get/setslice__已移除 __iter__ 迭代环境优先尝试iter 读文件 读文件的最佳方式for line in open(),readlines将整个文件加载到内存 while True：line = f.readline()比迭代器的for慢，因为迭代器以C语言速度运行，while循环版本通过py虚拟机运行python字节码迭代 for循环开始时，通过iter内置函数从迭代对象获得一个迭代器。返回的对象有next方法。 文件对象就是自己的迭代器。有自己的next方法 iter()启动迭代注解内置作用域 import builtins dir(builtins)前一半是内置的异常，后一半是内置的函数 LEGB法则python将最后扫描B模块 所以不需要导入 global123b=0def update(item): global w 在函数和类中对全局变量赋值，必须在该函数或者类中声明该变量为全局变量，否则经过赋值操作后，变量为本地变量。 第二章 .pyc保存py编译后的字节码（不是二进制码，py特定） PVM 虚拟机 py引擎编译得到的代码 pandas.Series是以时间戳为索引的 差分计算series.diff()切片 滞后观察（lag observation）列以及预测观察（forecast observation）resample 重采样、频率推断、生成固定频率日期范围 matplotlib动画lambda 匿名函数返回函数对象 列表解析mapord()返回单个字符的ASCII整数编码 map(f,list)将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456789101112131415161718192021res = list(map(ord,'spam'))res = [ord(x) for x in 'spam']#res =[115, 112, 97, 109][line.rstrip() for line in open('file').readlines()]list(map((lambda line:line.rstrip()),open('file')))#['aaa','bbb']listoftuple=[('bob',35,'mgr'),('amy',40,'dev')]list(map(lambda row:row[1]),listoftuple)#[35,40]#自己实现map def mymap(func,*seqs): res=[] for args in zip(*seqs): # *args 参数传递语法 可以收集多个序列 res.append(func(*args)) return resdef mymap(func,*seqs): return [func(*args) for args in zip(*seqs)] reduce:累积求和:sum(list)string2int zipzip是map的一个基本嵌套操作12list[zip([1,2,3],[2,3,4,5])]#[(1,2),(2,3),(3,4)] 列表中是表；元组为行，列是元组中的元素 cmp已经移除12345678910def tester(start): state = start #赋值过 def nested(lasted): nonlocal state #允许改变 必须已经在def作用域中赋值过 print(label,state) state+=1 return nestedF= tester(0)F('abc') #abc 0#每次调用F state都会+1 用函数属性实现nonlocal??P44012def tester(start): def nested(label): call让类看起来是一个可调用的函数123456789class tester: def __init__(self,start): self.state = start def __call__(self,lable): print(label,self,state) self.state+=1M = tester(99)M('juice')#juice 99#每次调用M state+1 operator b=operator.itemgetter(1) 获取对象的1索引 b(a) 获取 list a 的1索引 operator.itemgetter 定义了一个函数，作用到对象上获取值 与sorted一起用：sorted(dict,key = lambda x:x.values())按字典的values排序 按二维list中子元素的第三项排序 key = lambda student:student[2]/key = operator.itemgetter(2) operator.itemgetter(1,2) 第二项和第三项 panda 坑data = pd.read_csv(&#39;.\a.csv&#39;, parse_dates=[&#39;Month&#39;], index_col=&#39;Month&#39;,date_parser=dateparse) Only booleans, lists, and dictionaries are accepted for the ‘parse_dates’ parameter parse_dates=[&#39;Date&#39;] instead of parse_dates=&#39;Date&#39;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java风格练习]]></title>
    <url>%2F2018%2F03%2F07%2Fjavastyle%2F</url>
    <content type="text"><![CDATA[String必用方法：1.char[] toCharArray()123456 public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;&#125; 2.String(char[]value) //offset,count123public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 3.每个字节对应的ASCII码1Arrays.toString(str.getBytes()) 4.startsWith(String prefix,int toffset)指定位置开始是否是prefix开头5.str.replaceAll(&quot;[0-9]&quot;,&quot;*&quot;),str.replaceAll(&quot;\\d&quot;,&quot;*&quot;)6.拆分返回String[]System.out.println(Arrays.toString(c1.split(&quot;\\d&quot;,4)));7.静态方法valueOf()转换各种类型为String 12final String b = "b";//变成了常量String b1=b+"1";//编译期确定 =&gt;String b2="b1" ==b1 12345678private static String getString()&#123;//方法在运行期才能确定 return "c";&#125;main&#123;final String c= getString();//加不加final都false 方法一定在运行期确定String c1=c+1;String c2="c1";System.out.println(c1==c2);//不等&#125; 源码：1.final 的常量只能定义时赋值或在【默认】构造器里赋值一次12345private final char value[];public String(String original) &#123; this.value = original.value;//将常量池中的值赋值给新创建的String this.hash = original.hash;&#125; Object1.finalize 对象被回收时调用 不建议重写2.public final native Class&lt;?&gt; getClass(); 获取对象的方法区的类信息 Math.abs(Integer.MIN_VALUE+10085)=-2147473563 DecimalFormat保留两位小数System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi));百分比new DecimalFormat(&quot;#.##%&quot;).format(pi) StringBuffer12String c = a+b+1;//常量变量相加会产生5个对象 编译器会优化String d = "a"+1+2+"b";//常量相加只有一个对象 123StringBuffer sb = new StringBuffer(32);sb.append(a).append(b).append(1);//解决常量变量相加 产生3个对象sb.toString(); StringBuilderjavap -c查看编译后的指令1.String a =&quot;a&quot;+1;会生成builder加入a12.String b = a+&quot;b&quot;;执行一次append1234String c=null;for(i in 5)&#123; c+=i;//会创建5个StringBuilder 应该用append拼接&#125; clone 不用创建过程 不用重新计算对象的大小必须重写12345678910@Overridepublic Object clone()&#123; TreeNode newT = null; try&#123; newT = (TreeNode)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return newT;&#125; Comparable Comparator1.Arrys.sort:底层实现12Comparable pivot = (Comparable) a[start];if (pivot.compareTo(a[mid]) &lt; 0) 2.Comparator面向对象，对修改关闭对扩展开放新建类123xxxComparator implements Comparator&lt;T&gt;&#123; compare(T o1,T o2)&#123;&#125;&#125; sort传入比较器Arrays.sort(t1,new xxxComparator()) System1.时间123Date nowtime = new Date(System.currentTimeMillis());DateFormat df = new SimpleDateFormat("HH:mm:ss");String now = df.format(nowtime); 2..exit()退出JVM3.当前工作目录System.getProperty(&quot;user.dir&quot;) os.name/os.version/user.name/user.home/java.home/java.version4.安卓加载三方类库System.loadLibrary Runtime 不new靠静态方法获取对象 Runtime rt = Runtime.getRuntime();可用处理器数量rt.availableProcessors()jvm总内存数rt.totalMemory()jvm空间内存rt.freeMemory()jvm最大可用内存rt.maxMemory() 执行命令行命令rt.exec(&quot;notepad&quot;) vector1.ArrayListhe和Vector在用法上完全相同addElement(Object obj)和add(Object obj)没什么区别12345 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 123456 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; Vector里有一些功能重复的方法,这些方法中方法名更短的是属于后来新增的方法.更长的是原先vector的方法.而后来ArrayList是作为List的主要实现类. 线程同步不应该使用Vector 应该使用java.util.concurrent.CopyOnWriteArrayList class Stack&lt;E&gt; extends Vector&lt;E&gt; Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();LinkedList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, ArrayDeque循环数组https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位 void addFirst(E e)12elements[head = (head - 1) &amp; (elements.length - 1)] = e;//越界处理if (head == tail) doubleCapacity(); 1.head前有空位 2.head是0，加到最后，如果最后是tail则扩容： elements.length必需是2的指数倍，elements - 1就是二进制低位全1 跟head - 1相与之后就起到了【取模】的作用 当head-1=-1;相当于对其取相对于elements.length的补码(正数就是本身) 1234int head = 10;int length = 8;//8-&gt;1000 ;7-&gt;0111;10-1=9-&gt;1001 ;-&gt;1head = (head - 1) &amp; (length - 1); addLast12elements[tail] = e;if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); void doubleCapacity()System.arraycopy12345native void arraycopy(Object src, //原数组 int srcPos,//原数组起始位置 Object dest, //目标数组 int destPos, //起始 int length); //长度 1234567int p = head;int n = elements.length;int r = n - p; // head右边元素的个数//复制右半部分，对应上图中绿色部分System.arraycopy(elements, p, a, 0, r);//复制左半部分，对应上图中灰色部分System.arraycopy(elements, 0, a, r, p); pollFirst()删除并返回Deque首端(head)元素展开代码 1234567891011 public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result;&#125; pollLast()int t =(tail-1)&amp;(element.length-1); E peekFirst()&amp;E peekLast 返回但步删除 LinkedList 双向链表Queue queue = new LinkedList();内部静态类Node map遍历：1for(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;&#125; java那些事ava API: Holder 对象 1000_000编译器会直接删除_ 十六进制p表示指数 $专门出现在自动产生的变量名中 方法外声明常量 static final （因为和对象无关，声明成类变量） 负数小心用% 浮点寄存器优化 strictfp修饰符 (int).. cast操作符警告 用Math.toIntExact会异常（越界or丢精度） java不允许对象使用操作符 必须调用方法 input.split(“\s+”)以空格分割 在null上调用方法会空指针异常，所以与字面量比较要将文字串放前&quot;word&quot;.equals(word) code point 有效的unicode值 Random (1L &lt;&lt; 48) - 1 Integer12Integer i3 =100;Integer i4= 100;i3==i4;//(true)同一个对象 享元模式：共享对象 将1字节以内的数缓存 IntegerCache缓存数组 为避免重复创建对象 private static 内部静态类 只能在该类中访问,static用来做缓存new Integer(2)==new Integer(2) falseInteger.valueOf(2)==Integer.valueOf(2) true 变成1000的时候因为缓存不一样Integer.valueOf(2).intValue()==2 truenew Integer(2).equals(new Integer(2)) true 12345//缓存-128到127之间的值 cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); 12Integer i3 =1000;Integer i4= 1000;i3==i4;//(false)new了两个对象 123456public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //没用cache返回了新对象 return new Integer(i); &#125; 结论：Integer要用equals char2int: b.charAt(i–)-‘0’; StringBuilder StingBuilder线程不安全 连接大量字符串 .append .toString() StringBuffer 线程安全public synchronized StringBuffer append(String str) CharSequence字符序列类 euqals 没有实现equals的类：继承Object 1234public boolean equals(Object obj) &#123; //是否指向同一对象，equal和==相同 return (this == obj); &#125; Integer的实现 1234567891011public boolean equals(Object obj) &#123; //判断类型 if (obj instanceof Integer) &#123; //？？强制转型 return value == ((Integer)obj).intValue(); &#125; return false; &#125;public int intValue() &#123; return value; &#125; String实现 123456789101112131415161718192021222324public boolean equals(Object anObject) &#123; //指向引用 if (this == anObject) &#123; return true; &#125; //类型 写法注意！！ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; //长度？？可以调用private的value if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; ArrayList fianl修饰的变量，JVM也会提前给我们初始化好。??? 12345678//变量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;//构造函数，避免反复创建无用数组 指向同一个缓存Object[]数组this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA;&#125; .add(e) 创建Object数组，并拷贝 -&gt;ensureCapacityInternal(size+1)-&gt;ensureExplicitCapacity(size+1);-&gt;grow(size+1)-&gt;Arrays.copyOf-&gt;new Object[newLength]，System.arraycopy elementData[size++] = e; object的长度为10，size为逻辑长度，不是数组长度，minCapacity = Math.max(DEFAULT_CAPACITY=10, minCapacity 第一次扩容：就一个元素，在堆内存中占了10个位置 之后扩容：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//&gt;&gt;=/2 .remove(index) 1.将index+1后的numMoved个元素从index开始复制obj-&gt;obj12System.arraycopy(elementData, index+1, elementData, index, numMoved); 2.长度-1，最后一个null elementData[--size] = null; .romove(Object o) 循环查找o==null！=null-&gt;fastremove(index)(基本同上) 1234//当o！=null,按List规范重写equal!!if(o.equal(elementData[index]))&#123; fastRemove(index)&#125; Arrays @SuppressWarnings(&quot;unchecked&quot;)编译器消除警告 unchecked:执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 Arrays. native native是由操作系统实现的，C/C++实现，java去调用。 Arrays.copyOf-&gt;System.arraycopy(org,0,copy,0,len) Java8 default方法：接口内部有方法实现；实现两个接口有同名default名字冲突-&gt;报错 package java.util;里的常用类 Vector,Arraylist,LinkedList implements List LinkedList implents Queue List,Queue,Set implememts Collection Arraylist和Vector的区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍(可以改增量）。 vector:1int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity); 加锁和释放锁,在单线程的环境中，Vector效率要差很多。 和ArrayList和Vector一样，同样的类似关系的类还有HashMap和HashTable，StringBuilder和StringBuffer，后者是前者线程安全版本的实现。 synchronized JVM实现]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Front-end questions]]></title>
    <url>%2F2018%2F03%2F07%2FFront-end-questions%2F</url>
    <content type="text"><![CDATA[queryURLParameter字符串拆分法熟练掌握 字符串方法 substr substring slice match展开代码 12345678910111213function queryURLParameter(url) &#123; let obj = &#123;&#125;; if (url.indexOf('?') &lt; 0) return obj; let ary = url.split('?'); url = ary[1]; ary = url.split('&amp;'); for (let i = 0; i &lt; ary.length; i++) &#123; let cur = ary[i]; curAry = cur.split('='); obj[curAry[0]]=curAry[1]; &#125; return obj;&#125; 正则12345678String.prototype.MyURLquery=function()&#123; let reg=/([^=&amp;?]+)=([^=&amp;?]+)/g, obj=&#123;&#125; this.replace(reg,(...arg)=&gt;&#123; obj[arg[1]]=arg[2]; &#125;) return obj;&#125; 闭包相关123456var a = 12;function fn()&#123;//变量提升声明var a但没有赋值 console.log(a); var a = 13;&#125;fn() //输出undefine 123//报错并不继续执行console.log(a);a=12;//没有声明var 不会变量提升 12345678var foo=1;function bar()&#123; if(!foo)&#123;//2.!undefined-&gt;true var foo=10;//1.变量提升 &#125; console.log(foo);&#125;bar()//输出10 1234567891011var n =0;function a()&#123; var n =10; function b()&#123;n++;console.log(n)&#125;&#125; b()//内部执行了一次 return b;&#125;var c=a()//执行输出11c()//输出12console.log(n)//输出0 123456function b(x,y,a)&#123; arguments[2]=10 console.log(a)&#125;c=b(1,2,3)console.log(a)//10 123456789101112var ary=[1,2,3,4]function fn(ary)&#123; //arr得到了全局arr的地址，可以改变全局 ary[0]=0 //变成另一个地址 ary=[0]//[0]是一个地址，arr指向了新的堆内存 ary[0]=100 return ary&#125;var res = fn(ary)console.log(ary)//输出(4) [0, 2, 3, 4]console.log(res)//输出[100] 12345678function fn(i)&#123; return function(n)&#123; console.log(n+(--i)) &#125;&#125;var f = fn(2)//输出f(3)//输出4f(4)//4 1234567891011121314151617var num = 10var obj = &#123;num:20&#125;//&#123;num: 30, fn: ƒ&#125;obj.fn=(function(num)&#123; console.log(this)//window this.num=num*3//自执行函数this是window num++//21 return function(n)&#123; console.log("内"+this)//window this.num+=n; num++//向上级作用域找//22 console.log(num) &#125;&#125;)(obj.num)var fn = obj.fnfn(5)//22 //this是windowobj.fn(10)//23 此时fn的this是objconsole.log(num,obj.num)//65，30 1234567891011121314151617181920function Fn()&#123; this.x=100; this.y=200; this.getX=function()&#123; console.log(this.x); &#125;&#125;;Fn.prototype=&#123; y:400, getX:function()&#123; console.log(this.x); &#125;, getY:function()&#123; console.log(this.y); &#125;, sum:function()&#123; console.log(this.x+this.y); &#125;&#125;;Fn.prototype.sum()//undefined+400=NaN 12345678910111213var name = 'window'var Tom =&#123; name:"Tom", show:function()&#123; console.log(this.name) &#125;, wait:function()&#123; var fun = this.show//Tom.show fun()//前面没有. &#125;&#125;Tom.wait()//windowTom.show()//Tom front-end @import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; H5 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; 表单控件 geolocation 对象 Web Worker js多线程:专用线程Dedicated Worker和共享线程 Shared Worker;Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享 离线缓存manifest 新建的.appcache文件的缓存机制(不是存储技术)像cookie一样缓存清单上的资源。 如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 html5shim HTML5 styling for Internet Explorer 6-9, Safari 4.x (and iPhone 3.x), and Firefox 3.x.123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; &lt;![endif]--&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2F2018%2F03%2F06%2FMathJax%2F</url>
    <content type="text"><![CDATA[变量MATH$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$`$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[About SpringBoot]]></title>
    <url>%2F2018%2F03%2F06%2FAbout-SpringBoot%2F</url>
    <content type="text"><![CDATA[spring自动装配context.getBean(.class)获取对象 AnnotationConfigApplicationContext(App.class)注解形式上下文，用component标识bean,scan扫描自动执行component的构造函数,@Autowire加在有参构造函数上，自动装配参数到当前类，实现类的关联 ClassPathXmlApplicationContext(&quot;.xml&quot;)不用注解，用&lt;bean&gt;,和ref在maven下resources和java都是源码的根目录，所以在java里面读resources里的文件可以直接.xml 将组件扫描ComponentScan与启动类分离 范围是所在包和子包，可以加(“”)相当于在xml里配置&lt;context:component-scan base-package=&quot;&quot;/&gt; 1234ApplicationContext context = new ApplicationConfigApplicationContext(AppCfg.class);//AppCfg.java@Configuration@ComponentScan 引入spring test 基于junit自动引入上下文12345@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes=AppConfig.class)//不用再创建context，也不用getBean,自动注入直接用@Autowiredprivate CDplayer cdplayer; @Autowired 使用 有参构造函数 成员变量 反射 效率低 setCD(CD cd)等setter方法上 @Autowired(required=false)用接口注入成员对象时有两个实现类时，使用@Primary或者使用限定符Qualifier(&quot;&quot;)相互对应，或者把限定符写在@Component(&quot;&quot;)里。默认的限定符是类名小写使用Resource(name=&quot;&quot;) = @Autowired+@Qualifier 是jdk自带的标准 配置文件详解公共配置 DispatcherServlet 需要定义一个[servlet-name]-servlet.xml配置文件 HandlerMapping Controllers view解析相关的 定义ContextLoaderListerner 并指定配置文件 @RequestMapping:consumes:处理特定请求类型，’Content-Type’RestAPI 12@RequestMapping(Path="/users/&#123;userId&#125;")public String webMethod(@PathVariable String userId) 登陆场景表单 12public void login(@ModelAttribute User user, Writer writer)&#123; &#125; 123@RequestMapping("/user/login")@ResponseBodypublic String login(@RequestParam("name") String name,@RequestParam("password")String password)throws IOexception&#123;&#125; 上传文件定义bean1&lt;bean id = "multipartResolver"class="...CommonsMultipartResolver"&gt; 123@RequestMapping(path="/form",method = RequestMethod.POST) public String handleForm(@RequestParam("file"), MultipartFile file)&#123; &#125; IOC容器：ApplicationContext类一个ApplicationContext对象就是一个容器。属于spring-context模块 初始化 WebApplicationContext:在web应用中初始化 web.xml 1.全局参数配置 12345&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:application-context.xml &lt;/param-value&gt;&lt;/context-param&gt; 2.加载上下文环境配置 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 3.servlet入口 12345678&lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.添加servlet配置文件example-servlet.xml 名称符合spring标准：servletname-servlet &lt;bean &lt;context:component-scan base-package=&quot;&quot;/&gt;&gt; 5.@Controller @RequestMap(value=) `response.getWriter().write(&quot;&quot;);` 在测试.java的psvm中使用ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;); ApplicationContext context = new FileSystemXmlApplicationContext(&quot;.xml&quot;); Bean定义：&lt;bean id = &quot;bean类名&quot; class=&quot;类&quot;&gt; 获取对象 类名 a = context.getBean(&quot;bean类名&quot;,类.class） Bean作用域： singleton 默认&lt;bean scope=&quot;singleton&quot;&gt; prototype 每次引用创建一个实例web里仅有 Bean生命周期回调 创建&lt;bean init-method=&quot;init&gt; 销毁&lt;bean destory-method=&quot;cleanup&quot;&gt; 容器关闭:转换成支持close的子类 ((ConfigurableApplicationContext)context).close() 依赖注入 面向对象封装数据和方法，对象的依赖关系体现在对数据和方法的依赖上。把依赖注入交给框架or IOC完成，从具体对象手中交出控制（依赖关系）。Ioc容器是实现依赖控制反转的载体。在对象生成or初始化时直接将数据注入对象；？？注入对方法的调用的依赖：通过将对象引用注入对象数据域中的方法处理数据的对象和对象之间的相互依赖关系比较稳定。 强依赖（螺丝刀必须有刀头）：构造函数 可选依赖（可配置 颜色）：Setter方法 定义抽象接口，实现接口，以接口为基础注入 实现类有构造函数参数123456&lt;bean&gt; &lt;constructor-arg value = "值"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" vlaue =""&gt; &lt;constructor-arg type="java.lang.String" value=""&gt; &lt;constructor-arg name="color" value="red"&gt;&lt;/bean&gt; 注入集合Map&lt;String,String&gt; paras 每个key,value都是entry 123456&lt;constructor-arg&gt; &lt;map&gt; &lt;entry key = "color" value = "red"&gt;&lt;/entry&gt; &lt;entry key = "size" value = "15"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/constructor-arg&gt; 注入List &lt;list&gt;&lt;value&gt;14&lt;/value&gt;&lt;list&gt; &lt;set&gt;&lt;value&gt; 注入Properties对象 &lt;props&gt;&lt;prop key = &quot;color&quot;&gt;red&lt;/prop&gt; 配置文件 1234&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt;&lt;bean id = "headerProperties" class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name = "location" value = "classpath:header.properties"/&gt;&lt;/bean&gt; header-property: colr =green size =16 12Header heaer = context.getBean("header",子类.class);sout(header.getInfo()); bean 依赖 12345&lt;bean&gt; &lt;constructor-arg&gt; &lt;ref bean = "header"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 自动装配 不用构造函数&lt;constructor-arg&gt; &lt;bean autowire=&quot;byName&quot;&gt;/byType/constructor 使用setter方法 123public void setHeader(Header header)&#123; this.header = header;&#125; 用context.getBean(,.class)获取对象 注解 @Component定义Bean @Valueproperties注入Bean @Autowired&amp;@Resource自动装配依赖 如果后续会把springIOC去掉用后者(java标准javax.annotation.Resource) @PostConstruct&amp;PreDestroyBean的生命周期回调 使用注解 添加&lt;comtext:component-scan base-package=&quot;&quot;/&gt; @Component(“header”)和@value(“${color}”)替换 12&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt; 也不再需要setter函数 @Autowired 替换 &lt;bean autowire=&quot;byName&quot;&gt;不需要setter AOP完整的aop框架AspectJ Aspect非业务逻辑（日志、安全） Join point业务函数执行 Advice：切面在函数实现的功能。Aspect对函数打日志 5种类型 @Before 函数执行之前 @After returning 正常返回之后 @Around 函数执行前后 @After throwing 抛出异常之后 @After finally 函数返回之后 pointcut：匹配AOP目标函数的表达式+名称。哪些业务方法需要AOPexecution 匹配函数within 某个包某个类下面的函数*匹配所有 save*表示save开头的所有函数 所有public函数execution(public**(..)) 组合两个表达式execution(表达式1()&amp;&amp;表达式2() Aspectj使用 添加依赖 aspectjweaver.jar spring容器spring-context xml添加 xmlns:xml link space 类似于包 &lt;beans xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; http://www.springframework.org/schema/aop xsd:xml schema defination http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt; &lt;aop:aspectj-autoproxy /&gt; 新建Aspect类，定义类级别的@Aspect 添加&lt;bean&gt;配制（两个bean 切面和业务类） 定义Pointcut范围 匹配Caculator下的所有函数 123456@Aspectpublic class LoggingAspect &#123; @PointCut("execution(* ..Caculator.*(..)) &amp;&amp; args(a, ..)") private void arithmetic() &#123;//表达式的名称 &#125;&#125; 定义Advice：添加函数级别@Before(pointcut表达式/pointcut名称) Advice参数 获得上下文信息JoinPoint jp1234@Before("pointcut()")public void doLog(JoinPoint jp)&#123; //获得函数签名、函数参数 都是无类型的Object sout(jp.getSignature+","+jp.getArgs())&#125; @Around需要注入的是ProceedingJoinPoint pjp 获得函数的返回值 12@AfterReturning(pointcut="()",returning = retVal)public void doLog(Object retVal) 获得异常 是有类型的不是Exception 123@AfterThrowing(pointcut="()",throwing = "ex")public void doLog(IllegalArgumentException ex)&#123;&#125;&#125; 获得目标函数第一个参数 &amp;&amp;args(a,..) 12@Before("pc() &amp;&amp; args(a,..)")public void doLog(JoinPoint jp,int a)&#123;sout(a)&#125; Schema-based AOPaop:aspectJdbcTemplate DAO Data Access Object 数据访问接口由JDBC/Mybatis等ORM框架实现 spring-jdbc: 加载db配置文件&lt;context:property-placeholder location=&quot;db.properties&quot; /&gt; jdbc.driverClassName= com.mysql.jdbc.Driver jdbc.url= jdbc:mysql://:3306/example jdbc.username= jdbc.password= 配置数据源 1234567&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; 创建DAO类@Repository @Repository 定义一个Bean 代表DAO的bean,创建JDBC实例 1234567public class JdbcTemplateDao &#123;private JdbcTemplate jdbcTemplate;@Autowiredpublic void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource);&#125;&#125; application-context添加Autowired的搜索 1&lt;context:component-scan base-package="com.netease.course" /&gt; 数据转换成对象RowMapper 123456789new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setFirstName(rs.getString("first_name")); user.setLastName(rs.getString("last_name")); return user; &#125;&#125; NamedParameterJdbcTemplate JdbcTemplate 通过？传参，很多列的时候不明确this.jdbcTemplate.update(&quot;insert into user values (2, ?, ?)&quot;, &quot;Lei&quot;, &quot;Li&quot;); named where firest_name=:first_namequeryForObject(sql,Map&lt;Sting,?&gt;paramMap,RowMapper&lt;T&gt; rowMapper) SqlParameterSource在spring中用MapSqlParameterSource/BeanPropertySqlParameterSource(java对象（bean)) 异常处理SQLException是checked异常：需要捕获Spring的DataAccessException是unchecked异常 事务管理 MyBatisAOP 一组类共享相同行为（继承 @AspectAspectJ注解式切面 @Transcational 事务处理 @Cacheable 数据缓存 规则注解@interface 注解拦截类 @Action(name=””) 被拦截类 与（2）相同但是没有@Action 切面 @Aspect @PointCut声明切点：(“@annotation(注解(1))”) @After声明建言 反射： 电影例子 IoC控制反转 某一接口的实现控制权，从调用类中移除，由第三方决定 （导演选角色扮演者（具体实现类），放到电影中） DI 依赖注入 让调用类对某一实现类的依赖由第三方来注入。移除调用类对某一实现接口的依赖。 构造函数注入（构造函数的参数）:传入扮演者 1234567//电影 ljm; 构造函数（ljm)&#123;this.ljm = ljm&#125;//导演ljm = ldh；//(角色=演员)电影= 电影（ljm）wjd.action Setter并不是电影每个场景都要用到LJM-&gt;属性注入 123456//电影ljm;set(ljm)&#123;this.ljm=ljm;&#125;//导演电影.set(ljm)电影.action 接口注入 与属性注入没用本质区别 123456789interface&#123; void inject(ljm);&#125;电影 implements interface&#123; inject(ljm)&#123;this.ljm = ljm;&#125;&#125;导演&#123; 电影.inject(ljm)&#125; 注解 描述类和类之间的依赖关系自动完成类的初始化和依赖注入 1234//实例化&lt;bean id ="ljm" class = "ldh"/&gt; //ljm = new ldh;//建立依赖&lt;bean id ="wjd" class = "wjd" p:ljm-ref ="ljm"/&gt; 从容器中返回bean实例 SpringMVC前端调度器把请求分发给业务控制器，把生成的数据分发给视图模板。 js deguggger watch springboot遇到过的注解创建API@ResponseBody 标注返回值是json：在response的header中塞入contentType @Controller 修饰class创建http请求 @ResController -&gt; @RequestMapping(“/hello”)返回json method=RequestMethod.GET @Component -&gt; @Value(“${application.properties(属性名)}”) 单元测试： 随机数 1$&#123;random.value&#125; + $&#123;random.long&#125; + $&#123;random.int(10)&#125; + $&#123;random.int[10,20]&#125; --是对application.properties 中属性的标识-屏蔽命令行访问属性设置SpringApplication.setAddCommandLineProperties(false) -多环境配置文件格式application-{profile}.properties-激活spring.profiles.active = dev @RestController -&gt; @RequestMappint(value=”users”)等于@controller+ResponseBody 将java类用Jackason转换为JSON RequestMapping(“/“) GetMapping(“/get1”) PostMapping(“/postJson”) @RequestBody 对象 @RequestParam 接收?后的query参数 @ModelAttribute User user 绑定参数 @PathVariable url路径中的参数 绑定value=”/{id}” 12345@GetMapping("/hotels/&#123;htid&#125;/rooms/&#123;roomId&#125;")public Room getRoomById( @PathVariable String htid, @PathVariable Integer roomId)&#123;&#125; map.addAttribute(“host”,””) -&gt; th:text =”${host}” 使用Swagger2mvn依赖写法检索 mvnrepository12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; @Configuration 加载类配置 @Bean 跨域问题cors 协议、域名、端口不同 浏览器对ajax xhr的限制 jsonp 动态创建script 在script里发出请求（现在不用 只能get 原理：后台约定super(“callback”)=&gt;前台?callback=Jquery 函数名 参数值 12345678910111213$.ajax(&#123; url: base+"/get1", dataType: "jsonp", 后台约定 jsonp:"callback2", //结果可以被缓存 缓存-&gt;无&amp;_ cache: true, //返回的结果保存到result字段 success: function(json)&#123; //要求返回js代码。但是普通ajax请求，后台返回了json对象。加切面 result= json; &#125; &#125;) 查看返回类型：Network-&gt;右键-&gt;Response Headers-&gt;Content-Type ?calLback= json对象-&gt;函数调用 被调用方，返回允许调用client-&gt;另一个http服务器 在http服务器添加响应头 在应用服务器上添加跨域请求多了Origin:当前域名 @Bean FilterRegistrationBean 12bean.addUrlPatterns("/*")//所有请求都经过filterbean.setFilter(new CrosFilter()) doFilter 1234res.addHeader("Access-Control-Allow-Origin","http::")//,"*"允许所有域res.addHeader("Access-Control-Allow-Methods","GET")//,"*"//filter链chain.doFilter(,) 简单请求：GET/HEAD/POST；无自定义头；Content-Type 为&quot;text/plain&quot;`multipart/form-dataapplication/x-www-form-urlencoded` 非简单：put,delete、发送json、带自定义头的ajax； 调用方 代理，隐藏跨域http服务器-&gt;http服务器 Spring解决跨域 @CrossOrigin +类or方法上面 反向代理： 访问同一个域名的两个URL,去两个不同的服务器 J2EE架构 Apache/Nginx(处理静态请求、负载均衡）判断静态请求（js\css-&gt;直接返回给客户端； 动态请求（与用户数据有关的）客户端-&gt;http服务器-&gt;后台应用服务器(tomcat) IOC控制翻转 通过 DI依赖注入 实现spring-contextIOC容器创建Bean，将功能类Bean注入到Bean中。 配置元数据：xml配置、注解、java配置Spring容器解析配置元数据 Bean初始化、配置和管理依赖。 声明Bean的注解： @Component @Service @Repository @Controller 注入Bean @Autowired @Inject @Resource 用在set方法or属性上 编写功能类业务Bean的注解配置@Service，@Component，@Service，@Repository，@Controller 声明是Spring管理的Bean 使用功能类 @Autowired 注入Bean 添加功能 配置类（空的） @Configuration。@ComponentScan 自动扫描@Service，@Component,@Repository,@Controller的类 注册为Bean 运行 AnnotationConfigApplicationContext是Spring容器，参数：配置类(3).class 使用功能类（2） = 容器.getBean((2).class) 容器context.close() Java 配置 （1）、（2）不适用@Service和@Autowired;(2)+set (3)配置类不使用Scan包扫描 @Bean @Bean（1）返回名称为方法名（type:功能类）的Bean 法1：@Bean (2).set(1) 注入并直接调用(1) 法2：（2）直接传参(1) 123456789101112131415@Configuration //1public class JavaConfig &#123; @Bean //2 public FunctionService functionService()&#123; return new FunctionService(); &#125; @Bean public UseFunctionService useFunctionService()&#123; UseFunctionService useFunctionService = new UseFunctionService(); useFunctionService.setFunctionService(functionService()); //3 return useFunctionService; &#125;&#125; 只要容器中有Bean就可以在另一个Bean的方法参数中传入全局配置使用Java配置（数据库，MVC） 2.0的坑1.server.context-path-&gt;server.servlet.context-path]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射&静态代理&动态代理]]></title>
    <url>%2F2018%2F03%2F06%2FjavaAnnotation%2F</url>
    <content type="text"><![CDATA[注解12345@Target(ElementType.TYPE)//类注解@Retention(RetentionPolicy.SOURCE)//编译时会被忽略public @interface ThreadSafe &#123; String value() default "";&#125; 静态代理：为对象提供一种代理，控制这个对象的访问 对一个方法添加计算时间的业务 静态代理在于在运行期之前就有已经写好的actionProxy implements Action代理类展开代码 123456789101112131415161718192021222324252627282930313233//3.在真正的业务方法之前取一下时间，计算耗时//分离业务逻辑 同时实现相同的接口 代理使用（当作一个属性）业务类class actionProxy implements Action&#123; public Action action;//被代理对象 public actionProxy(Action action)&#123; this.action= action; &#125; public void doAction()&#123; //可以添加权限操作 long start = System.currentTimeMillis(); action.doAction(); long end = System.currentTimeMillis(); System.out.println("耗时"+(end-start)); &#125;&#125;//1.通过一个接口interface Action&#123; public void doAction();&#125;//2. 接口的实现类是具体的工作//没有代理的时候这个类依然能正常使用class UserAction implements Action&#123; public void doAction()&#123; System.out.println("用户工作逻辑"); &#125;&#125;public class staticproxy &#123; public static void main(String[] args) &#123; Action action = new UserAction(); actionProxy pro = new actionProxy(action); pro.doAction(); &#125;&#125; 反射 java.lang.reflect.* 在运行中分析类能力；运行中查看对象；Method对象 Class 是java基础类。虚拟机创建Class的实例。 三种方法获取class：对象.getClass。类.class。Class.forName（抛异常） 实例化对象： Class cls = Class.forName(className) （静态方法）获得类名的Class对象 cls.newInstance()调用className的默认无参构造方法，返回className类型) 获取所有构造方法 1Constructor&lt;?&gt;[] cs = acla.getDeclaredConstructors(); getModifiers()获得修饰符 获得指定参数的构造方法 会抛异常 1Constructor&lt;Bank&gt; c = b.getConstructor(Integer.class,Integer.class); 通过构造器得到实例 抛异常 1c.newInstance(1,3); 获取类的所有成员变量，get/set设置获取属性 1234//获取publicField[] fi = bb.getFields();//获取所有属性包括私有属性Field[] dd = bb.getDeclaredFields(); 获取修饰符 12int modifiers = f.getModifiers(); System.out.println(Modifier.toString(modifiers)); 获取所在的包Package getPackage() 获取公共方法（包括继承Object的 123Method[] methods = bb.getMethods();//调用方法methods[0].invoke(对象,参数); getDeclaredFields()不包含父类方法，包括私有方法。 但是私有方法不能invoke 调用私有方法:去除修饰符检查 12methods[3].setAccessible(true);methods[3].invoke(b); 动态代理可以代理多个接口 展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//1.生成代理类的类class CreateProxy implements InvocationHandler&#123; //2.被代理的对象 private Object target; //3 创建代理的方法 public Object create(Object target)&#123; this.target=target; //获得所有的接口getInterfaces Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); return proxy; &#125; //4.业务代码 @Override //代理类，被代理的方法，方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始"); method.invoke(target,args); System.out.println("结束"); return null; &#125;&#125;class Person implements Subject&#123; public void shopping()&#123; System.out.println("买东西"); &#125;&#125;interface Subject&#123; public void shopping();&#125;public class dynamicProxy &#123; public static void main(String[] args) &#123; //创建代理对象的对象 CreateProxy cp = new CreateProxy(); //被代理的对象 Subject person = new Person(); //代理 强制转换成被代理的类型 Subject proxy = (Subject)cp.create(person); //会调用invoke proxy.shopping(); &#125;&#125; 多一个接口,使用同一个代理对象1234567interface Hotel&#123;public void live();&#125;class Person implements Subject,Hotel&#123;live()&#123;&#125;&#125;@TestCreateProxy cp = new CreateProxy();Person person = new Person();Hotel proxy = (Hotel) cp.create(person);proxy.live(); proxy.getClass().getName() 是$Proxy0 不是InvocationHandler类型，是运行时动态生成的一个对象。1234Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); .newProxyInstance实现JavaCompiler编译器cglib动态代理（类）类加载器类加载器类加载：.class文件中的二进制数据，读入内存方法区，在堆中创建Class对象，封装方法区中的对象。主动引用被动引用 JavaBean规范 private,get/set能被IDE识别Apache BeanUtils 内省Java探针agent注解编译时注解 JDK：@Override，@Deprecated，@Suppvisewarnings@Autowired 自动注入 异常 未检查异常:访问null引用 不查看异常处理器（handler) 已检查异常：编译器检查是否提供了处理器&gt; 无处理器&gt; 终止 Throwable 是Exception类的超类 123catch(Exception e)&#123; e.printStackTrace()&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS224]]></title>
    <url>%2F2018%2F03%2F05%2FCS224%2F</url>
    <content type="text"><![CDATA[Word2Vec 词向量 one-hot p=[0,.,0,1,0,..0]用 Hash 表给每个词分配一个编号 维数灾难;词汇鸿沟”现象：任意两个词之间都是孤立的。 deeplearning：Distributed Representation实数向量[0.792, −0.177, −0.107, 0.109, −0.542, …]维度以 50 维和 100 维比较常见。相似的词可以计算距离or Cos Distributed representation 用来表示词，通常被称为“Word Representation”或“Word Embedding”，中文俗称“词向量”。相似词的词向量距离相近，这就让基于词向量设计的一些模型自带平滑功能，让模型看起来非常的漂亮。σ() softmax number -&gt; 分布 ??证明σ(-x) = 1-σ(x) skip gram一个词有两个向量，v 中心词向量 u 上下文向量U(like)’V(deep) 两个词共同出现的概率（max)分母是词汇表 binary logistic regression J(θ)：T窗口;j~P(w)随机抽取语料库的单词（min) 随机 unigram distribution U(w) 3/4 Stochastic gradients continuous bag of words(CBOW)：通过周围词向量的和来预测中心词而不是单个邻接词（skip gram) Cross entropy 交叉熵（loss for softmax) Context({})向模板提供数据 对co-occurrence矩阵降维： ！！！SVD singular value decomposition 奇异值分解$A=UΣV^T$ m*n的矩阵对角化-&gt;特征值、行列式、幂、指数函数 n阶矩阵相似于对角阵 &lt;=&gt;有n个线性无关的特征向量 实对称正交相似于对角阵 $Q^TAQ=Λ=diag(λ1…λn)$（特征值） 正交矩阵$Q=(v_1…v_n)$：$Av_i=λ_iv_i$ $Q^TQ=E$ $AV = UΣ$-&gt;V和U展开-&gt;Σ展开-&gt;r=rank(A)-&gt;$Av_i=σ_iu_i(i∈（1,r));Av_j=0$-&gt;两边转置-&gt;$A^TU=VΣ^T$-&gt;$A^Tu_i=σ_iv_i$ $A^TAv_i = σ_i^2v_i$(特，特向) $AA^Tu_i = σ_i^2u_i$原理 A(mxn)-&gt;$AA^T$为m阶实对称$A^TA$n阶实对称 特征值非负 证明：$x^TA^TAx = λx^Tx$-&gt;$||Ax||^2(&gt;=0)=λ||x||^2(&gt;0)$ $A^TA$与$AA^T$非零特征集合相同 证明:$r(AA^T)=r(A^T),r(A^TA)=r(A)$-&gt; $r(AA^T)=r(A^TA)=r(A)=R$几何意义：旋转、伸缩、旋转 $R^n-&gt;R^m x-&gt;Ax$变换 $x-V^Tx$旋转 $Σ$ 对前r个分量做伸缩 ??交叉熵与Kullback-Leibler derivative导数，gradient梯度 $timeit max-margin sigmoid函数求导:$ \frac{σ(y)}{dy}=σ(y)·(1-σ(y))$,接近0 梯度最大 语言模型Dynamic Memory NetworkDynamic Memory NetworkA Joint Many-Task Model:Growing a Neural Network for Multiple NLP Tasks 统计学习方法学习策略 感知机： $w·x+b=0$是平面 误分点到平面距离$(w·x_i+b)$,乘错误点的输出$·y_i$ 正确的点 输出和平面函数是一样的。 损失函数：所有误分点距离取正 min损失函数，对w,b求导；梯度下降 w+学习率(0,1]·对w求导；同理b。 损失函数3种： 结构风险函数： 正则化]]></content>
      <tags>
        <tag>NLP</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存知识]]></title>
    <url>%2F2018%2F03%2F05%2Fmemory%2F</url>
    <content type="text"><![CDATA[并行和并发的区别并行parallelism是并发concurrency的特例/子集。并发是一种逻辑结构的设计模式。并发是指逻辑上可以并行，并行是物理运行状态。编写一个多线程/进程的并发程序，没有多核处理器就不能并行。并行的两个进程一定是并发的。 文件/网络句柄handle 所有进程共有进程是容器 进程无法共享内存，通信通过TCP/IP端口实现/其它操作系统的方案线程：没有独立的地址空间，栈线程：PC指向进程的内存缓冲区溢出：用户名过长没有判断就放进内存，写入程序的内存部分TLS：Thread local strategy 线程的独立内存 缺页中断MMU访问虚拟内存时，这页虚拟内存还没有分配物理内存。向cpu发出缺页中断。cpu初始化物理页的内容分配，在进程页表添加映射。int n = *p当p所指向的地址在虚拟内存中，不是将p的值复制给内存，而是将p所在的虚拟内存的分页放入物理内存 内存虚拟化方案 影子页表(shadow Page Table) VMM(KVM)在宿主机内核中保存 虚拟机虚拟地址到宿主机物理地址。代价在于保持影子页表和虚拟机页表同步 EPT两次页表查找 不用同步。 可执行文件格式通过file 查看文件类型 进程的虚地址空间C语言指针的大小位数与虚拟空间的位数相同0x000000000062FE44123456#include&lt;stdio.h&gt;int main()&#123; int i =0; int *p = &amp;i; printf("0x%p",p); return 0;&#125; 进程访问了非法地址windows”进程因非法操作需要关闭”，linux “Segmentation fault” Linux内存布局windows默认将高2G分配给内核.Linux默认1G栈：函数调用上下文可执行文件映像 装载器共享库 装载地址在linux2.6挪到了靠近栈的0xbfxxxxxx 栈ulimit –s 8Mesp栈顶 esb活动记录（帧指针(frame pointer))不随函数执行变化，用于定位数据，函数返回时恢复 设置好ebp esp栈指针后 开辟栈空间，保存ebx（基地址(base)寄存器） esi, edi（源/目标索引寄存器”(source/destination index)）三个寄存器 将开辟出的空间初始化为0xCC 通过eax（累加器”(accumulator)）返回 恢复5个寄存器 ret返回 ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。 1int main()&#123;char p[12];&#125; 0xCCCC（即两个连续排列的0xCC）的汉字编码就是烫，所以0xCCCC如果被当作文本就是“烫”。如果一个指针变量的值是0xCCCCCCCC就是没初始化 堆原因：1.栈上数据在函数返回时被释放，无法将数据传递函数外。2.全局变量无法动态产生。 malloc的实现程序向操作系统申请堆空间，由程序运行库自己管理。linux两种堆空间分配的系统调用 int brk(void* end_data_segment) 设置进程数据段的结束地址, mmap()与windows的VirtualAlloc相似 起始地址和大小必须是系统页的整数倍 1void *mmp(void *start,size_t length,int prot,int flags,int fd,off_t offset); flag映射类型（文件映射/匿名映射） 匿名映射可以作为堆空间小于128k会在现有堆空间中分配，大于则使用mmap申请匿名空间 用mmap实现malloc12345void *malloc(size_t nbytes)&#123; void* ret = mmap(0,nbytes,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,0,0);//可读可写，匿名 if(ret == MAP_FAILED)return 0; return ret;&#125; mmap申请空间不能超过 空闲内存+空闲swap空间 windows 虚拟地址空间虚拟地址空间windows 每个线程默认栈大小1MNTDLL.DLL堆管理器APIwindows的堆不是向上增长 堆分配算法 空闲链表pre,next并有4个字节存储大小 位图，划分成大小相同的块。用2位11表示head，10表示body，00表示空闲 int32个字节，2个字节表示一个块的状态，假设1M堆，一块128字节=&gt;1M/128=8K个块 8K/(32/2)=512个int的数组存储 Head表示已分配区的头 对象池 io指令至少是没io的10^6倍并发：一个cpu上程序交替执行只有一个cpu只能执行一个进程进程：运行中的程序 内存原理 cpp返回对象的临时对象 输出： 经过了两次构造函数1次拷贝到栈上临时对象，1次拷贝到返回值ctor（create）ctorbefore return //已经被优化了，本来之后会输出copy ctoroperator=dtordtor（销毁）展开代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct cpp_obj&#123; cpp_obj()&#123; cout&lt;&lt;"ctor\n"; &#125; cpp_obj(const cpp_obj&amp; c)&#123; cout&lt;&lt;"copy ctor\n"; &#125; cpp_obj&amp; operator=(const cpp_obj&amp; rhs)&#123; cout&lt;&lt;"operator=\n"; return *this; &#125; ~cpp_obj()&#123; cout&lt;&lt;"dtor\n"; &#125;&#125;;cpp_obj return_test()&#123; cpp_obj b; cout&lt;&lt;"before return\n"; return b; //return cpp_obj() &#125;int main()&#123; cpp_obj n; n = return_test(); return 0;&#125; 汇编寄存器 gcc hellow.c -&gt;./a.out 预编译：gcc -E .\bigthingg.c -o .\bigthingg.i 展开宏 编译：链接生成汇编 gcc -S hello.i -o hello.s 汇编gcc -c hello.s -o hello.o 链接ld….64位汇编寄存器 虚拟内存CPU通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、IO设备等等，但从CPU发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由MMU将虚拟地址转换成物理地址再从地址总线上发出.CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。虚拟内存空间被组织为一个存放在硬盘上的M个连续的字节大小的单元组成的数组。页表是一个元素为页表条目（Page Table Entry, PTE）的集合，有效位代表这个虚拟页是否被缓存在物理内存中。处理缺页异常do_page_fault() inode文件读取磁盘的最小单位是多个扇区sector组成的 块block。一般4kb,8个sectorinode：文件系统的数据结构，文件元信息查看inodestat example.txt 系统调用、POSIX、C库、系统命令和内核函数 POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准基于UNIX的可移植 操作系统标准 内核提供的每个系统调用在C库中都具有相应的封装函数。 比如malloc函数和free函数都是通过brk系统调用来扩大或缩小进程的堆栈，execl、execlp、execle、 execv、execvp和execve函数都是通过execve系统调用来执行一个可执行文件。-系统命令位于C库的更上层，是利用C库实现的可执行程序，比如最为常用的ls、cd等命令。$trace pwd pwd调用了那些系统调用 2类寄存器：用户可见/控制和状态 寄存器 ？？3种I/O操作技术：可编程：处理器忙；中断驱动：；直接存储访问DMA 空间局部性 ： 更大的缓冲块，存储器控制逻辑+预处理 多道： 交错进程 进程状态： 执行上下文； 操作系统信息不允许被进程直接访问 上下文包括操作系统管理进程以及处理器正确执行进程所需要的所有信息，包括各种处理器寄存器的内容，如程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级以及进程是否在等待特定I/O事件的完成。 虚地址指的是存在于虚拟内存中的地址，它有时候在磁盘中有时候在主存中。 实地址指的是主存中的地址。 ??单体内核和微内核 os维护信息表： 内存,I/O,文件，进程 进程控制块：标识，？？处理器状态，进程控制信息 陷阱： 当面进程的错误or异常 中断例子： 时钟，I/O，内存失效 线程模式切换：？包含状态信息少 第4章 线程、对称多处理和微内核第7章 内存管理 内存管理 ： 重定位进程-&gt;就绪进程池-&gt;处理器利用率 运行时内存保护 进程共享内存 内部碎片、外部碎片：数据&lt;分区-&gt;浪费；？动态分区，分区外存储空间变多。 页： 进程和磁盘划分块；帧：主存划分块；一页装入一帧。 段： 长度可变 第8章 虚拟内存第10章 多处理器和实时调度第11章 I/O管理和磁盘调度]]></content>
      <tags>
        <tag>os</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown Syntax]]></title>
    <url>%2F2018%2F03%2F03%2Fmarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[网页字体颜色浅红色文字：浅红色文字：blah blah blah Content (md partial supported)]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Vue&JS]]></title>
    <url>%2F2018%2F03%2F03%2FAbout-Vue%2F</url>
    <content type="text"><![CDATA[123app.$watch("text",(newV,oldV)=&gt;&#123; console.log(`$&#123;newV&#125;,``)&#125; value、selected、checked默认情况下会被忽略 data是函数因为这样多次引用一个组件都创建新的的data实例 钩子函数create在 data初始化后调用，this指向vm，专门用来发送ajax axios基于promise1root["axios"] = factory(); axios挂在window上 promise 回调函数：将【后续】处理逻辑传入当前函数，当前事件完成后自动执行 12345678let a = ''function buy(callback) &#123; setTimeout(()=&gt;&#123; a="蘑菇" callback(a) &#125;,2000)&#125;buy((val)=&gt;&#123;console.log(val)&#125;) promise的三个状态：等待-&gt;成功/失败 12//ES6.JSfunction Promise(executor) &#123;&#125; 传入一个执行函数1Promise.prototype.then = function(onFulfilled,onRejected) &#123;&#125;; 不用传入回调函数，自动把值传入回调函数123456789101112131415function buyPack() &#123; //回调（成功函数，失败函数） return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5)&#123; resolve('买') &#125;else&#123; reject('不买') &#125; &#125;,1000); &#125;)&#125;//then(成功函数，失败函数)buyPack().then((data)=&gt;&#123;console.log(data);&#125;, (data)=&gt;console.log(data)) promise解决异步ajax 4步实现ajax 12345678910function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// 相当于readState=4 //防止404还是要： if（xhr.status==200） &#125; xhr.send()&#125;ajax(&#123;url:'./.json'&#125;).then 使用Promise 1234567891011121314151617function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// h5的新方法，等于xhr.readState=4 xhr.status=200 resolve(xhr.response) &#125;; xhr.onerror = function(err)&#123; reject(err) &#125; xhr.send() &#125;)&#125;ajax(&#123;url:'http://localhost:8089/getUser'&#125;).then( (res)=&gt;&#123;console.log(res)&#125;, (err)=&gt;&#123;console.log(err)&#125;) fetch完全基于promiseasync await 异步的终极解决方案 call和apply的区别是apply第2个参数传数组 var vm = new Vue({el:&#39;#app&#39;})给body加#app表示body里面的dom都是vue的管理区域 弹窗效果=两个div嵌套，遮罩div width整个屏幕，显示在所有图层上，现在body最上或最上，v-if=&quot;!modal.show v-on:click=&quot;modal.show=!modal.show&quot; ready:function(){this.getData()}与methods\data同级，对象加载好执行 ,this.methods中的方法（ajax请求更新data） getData函数中的reqwest函数中的this已经不是实例本身了，取不到data数据，指的是窗口12345678910111213methods:&#123; var self = this getData:function()&#123; reqwest(&#123; url: type: method: success:function(resp)&#123; self.comments = resp.results &#125; &#125;) &#125;&#125; computed：与methods写法基本相同，有缓存并且可以绑定数据class=&quot;&quot; 12345678computed:&#123; loadingOrNot:function()&#123; if(this.comments.length==0)return 'loading' &#125;else&#123; return "" &#125; &#125;&#125; [1,2,3].filter(isBigEnough)在computed中写过滤、验证表单 1234567filterdList:function()&#123; function useRuler(people)&#123; return people.heigh&gt;100 &#125; var newList = this.comments.filter(useRuler) return newList&#125; RESTful API PUT修改已有的某个资源 get是查 post增 返回响应码：201：删除、修改、创建成功； 400：失败 tokencookie.js token认证不能在加data里1234567891011getDate:function()&#123; var self = this reqwest(&#123; url: type:'json', headers:Cookies.get&#123;'token'&#125;?&#123;'Authorization':'Token '+Cookies.get('token')&#125;:&#123;&#125; success:function(resp)&#123; &#125; &#125;)&#125; vue难点 $emit() this.$nextTick() directive 自定义指令 vuex难点dom上的行间属性1234567891011121314// 注册Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') minxins 混入123456789101112131415161718// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; "hello from mixin!" vue123var message = ` hello $&#123;name&#125;! the answer is $&#123;40+2&#125;`.toUperCase() :root 选择器匹配文档根元素。 响应式布局@media screen and (min-width: 768px)@media 的媒介查询方式根据屏幕尺寸判断手机端还是PC端 不用history模式路径会有#（hasj模式）history.pushState API完成URL跳转不需要重新加载页面 微信history push注意 npm 缺少python2.7npm pythonnpm –add-python-to-path=’true’ –debug install –global windows-build-tools Weex 适配750px， 缩略 border，background 定位： 不支持z-index ，Android的overflow为hidden 渐变：不支持 radial-gradient；box-shadow只支持ios border-top-left-radius可以，安卓不可以 所有元素默认display:flex Ajax readyState 0-4请求初始化 服务器连接已建立 请求已接收 请求处理中 请求已完成request.onreadystatechange=function(){ } post 要用Content-Type：application/x-www-form-urlencoded9 post 参数用&amp;隔开 data=”name=” .value+”&amp;number=” ; request.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”) request.send(data) request.responseText请求参数：Request Payload eval 解析json字符串 eval(‘(‘+json+”)”); eval 中 值为alert() 会被执行Json.parse(request.responseText)JSONLint 格式化校验工具标记约定 “success”:true 产生跨域 localhost-&gt;127.0.0.1 方法1： 代理 后台 JSONP解决get请求跨域访问 dataType:”json”-&gt;”jsonp” jsonp:”参数名” 后台约定 H5 XHR2 “Access-Control-Allow-Oringin：*””Navigator Chrome浏览器信息 navigator.appVersion 用userAgent判断什么浏览器123navigatior.userAgent.indexOf("Chrome")&gt;-1//IE(8-10)indexOf("MSIE") Screen 对象screen.width/.height一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 元素尺寸var w= document.documentElement.clientWidth|| document.body.clientWidth; var h= document.documentElement.clientHeight|| document.body.clientHeight; scrollTop 可见内容相对顶部高度 offsetTop相对与页面的位置]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Java]]></title>
    <url>%2F2018%2F03%2F02%2FAbout-Java%2F</url>
    <content type="text"><![CDATA[使用StreamTokenizer比Scanner快12345678StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));while(in.nextToken()!=in.TT_EOF)&#123; int n = (int)in.nval; in.nextToken(); int m = (int)in.nval; out.println(dp[m]);&#125; 使用Integer 而不使用 int因为属性没设置，int为初始化为0，Integer是null。 java的Exception分两类普通的checked的extends Exception和throw new RuntimeException(e) 不用catch String+” “原来的string还是在的 要等垃圾回收 被动加载和主动加载final static List menu = Arrays.asList{}import static A.menu;A类不会被初始化 不会占用任何内存去掉final变成主动加载 位运算取模只要5个CPU周期 %至少26个CPU周期Character 内部静态类做cache 1234567891011121314private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; 2.123int digit(char ch, int radix) &#123; return digit((int)ch, radix);&#125; 当radix基数大于传入的数字，返回-1，只能传入小于radix的数字 @FunctionalInterface适合用lambda表达式 JIN123456System.loadLibrary("NativeMath");//中的sqrt c++实现#include&lt;math.h&gt;JNIEXPORT jdouble JNICALL Java_包名_sqrt(JNIEnv *env,jobject obj,jdouble value)&#123; return sqrt(value);&#125; 回调(控制反转)与代理回调:展开代码 123456789101112131415161718192021222324interface ICallBack&#123; public void callBack();&#125;class Caller&#123; public void call(ICallBack callBack)&#123; System.out.println("start"); callBack.callBack(); System.out.println("end"); &#125;&#125;public class callbackk &#123; public static void main(String[] args) &#123; Caller call = new Caller(); call.call(new ICallBack() &#123; @Override public void callBack() &#123; System.out.println("这个叫回调"); &#125; &#125;); &#125; &#125; 线程Thread是回调者，Runnable回调接口12345new Thread(new Runnable()&#123; @Override public void run()&#123; &#125;&#125;).start(); 观察者模式/回调函数 事件处理机制RPC基于TCP/IP的会话层协议set的contain时间复杂度是O(1),list的contain时间复杂度是O(n)chrome的source根据域名不同存放资源 可以打断点调试 丢失精度一定要用BigDecimal的string构造器devide(b,2,BigDecimal.Round_HALF_UP)保留两位小数四舍五入guaga:String-&gt;listSplitter.on(&quot;,&quot;).splitToList(&quot;a,b,c&quot;); simditor1.8中文API 全文搜索引擎Lucene Charactor.isLetterOrDigit()MD5增加复杂度saltUUID重置密码之前：验证完密码问题则写入token123String Token = UUID.randomUUID().toString();//放入本地缓存 防止空，放个前缀`token_`TokenCache.setKey("token_"+username,forgetToken); 生成的是一个永远不会重复的字符串把token放到本地cache中设置有效期 Guava中的本地缓存LoadingCache调用链模式没有顺序1234567891011121314151617181920212223242526//TokenCache::private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder() .initialCapacity(1000)//缓存的初始化容量1000 .maximumSize(10000)//缓存的最大容量，超过则会使用LRU（最少使用）算法移除 .expireAfterAccess(12,TimeUnit.HOURS)//有效期12个小时 .build(new CacheLoader&lt;String,String&gt;()&#123; //默认数据加载，调用get时，key没有命中，则调用这个 @Override public String load(String s) throws Exception&#123; //防空指针 return "null"; &#125; &#125;);public static void setKey(String key,String value)&#123; localCache.put(key,value);&#125;public static String getKey(String key)&#123; String value = null; try&#123; value = localCache.get(key); if("null".equals(value))return null; return value; &#125;catch (...)&#123;&#125; return null;&#125; joda.time字符串-&gt;Date()123DateTimeFormatter df = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");DateTime dt = df.parseDateTime("2015-04-20 2:2:2");return dt.toDate(); StringUtils.isBlank(&quot; &quot;)true CollectionUtils.isEmpty(List)枚举：限制取值 封装响应编码ResponseCode扩展的时候加枚举对象123456789101112131415161718public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 用法 在response对象里：12345@JsonIgnorepublic boolean isSuccess()&#123; //0 return this.status== ResponseCode.SUCCESS.getCode();&#125; 1234567enum color&#123; //枚举的3个实例化对象 外部不允许定义新的color对象 green,red,yellow&#125;color coenum;coenum = color.red;color[] values = color.values(); EnumSet1EnumSet&lt;color&gt; set = EnumSet.allOf(color.class); EnumMap&lt;color,String&gt;12EnumMap&lt;color,String&gt; map = new EnumMap&lt;color, String&gt;(color.class);map.put(color.red,"red"); 构造方法（私有）1234567891011enum Color&#123; red(10),green(20),yellow; private int color; private Color()&#123; System.out.println("无参构造器"); &#125; private Color(int color)&#123; this.color = color; System.out.println("有参构造器"+color); &#125;&#125; 当用Color.red时，会调用3次构造器创建red,green,yellow三个对象 实现接口添加方法12345public int getColor()&#123; return color;&#125;//输出0 Color.red.getColor输出10Color.yellow.getColor(); 也可以单独定义方法 添加抽象方法，每个对象要都实现.getBytes(&#39;iso8859-1&#39;)以iso编码读new String(,&quot;gb2312&quot;)静态代码块：用staitc声明，jvm加载类时执行，仅执行一次 printf(&quot;%n&quot;)总是输出正确的平台特定行分隔符，所以它是跨平台的 四大核心函数式接口 Consumer 消费者 接收一个值消费掉list.forEach 接收T返回void Function&lt;T,R&gt; 接收一个参数返回一个结果 1234public static String str(String str,Function&lt;String,String&gt; f)&#123; return f.apply(str);&#125;String s = str("functionnnntest",(str)-&gt; str.toUpperCase()); BiFunction&lt;T, U, R&gt; R apply(T t, U u); Supplier::T get();不传参数返回结果 123456public static List&lt;Integer&gt; getNumber(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i =0;i&lt;num;i++)&#123; list.add(sup.get());&#125; return list;&#125;List&lt;Integer&gt; list = getNumber(10,()-&gt;(int)(Math.random()*100)); Predicate::boolean test(T t);断言 123456789private static void predicate()&#123;&#125;private static List&lt;String&gt; filter(List&lt;String&gt;list,Predicate&lt;String&gt; prd)&#123; List&lt;String&gt; res=new ArrayList&lt;&gt;(); for(String s:list)&#123; if(prd.test(s))res.add(s); &#125; return res;&#125;List&lt;String&gt; sig = filter(words,(d)-&gt;d.contains("L")); Lambda：函数作为方法的参数当接口只有一个抽象方法，函数式接口，不会生成class 内部类写法 1234567interface Ido&#123; public void doo(String thing);&#125;class IdoImp implements Ido&#123; public void doo(String thing)&#123; System.out.println(thing+"adfadfa");&#125;&#125;//mainIdoImp idoimp = new IdoImp();idoimp.doo("thing"); Lambda写法 12interface Ido&#123; public void doo(String thing);&#125;Ido ido = (thing)-&gt; System.out.println(thing+"doooooo"); 比较对象Comparator&lt;Integer&gt; c = (x,y)-&gt;Integer.compare(x,y); 方法引用123Arrays.sort(strings,String::compareToIgnoreCase);Arrays.sort(strings,(x,y)-&gt;x.compareToIgnoreCase(y));System.out.println(Arrays.toString(strings)); ArrayList 打印全部元素list.forEach(x-&gt;sout(x))list.forEach(System.out::println) 内部类 方法内部类只能在方法内实例化，并且不能使用方法内的非final变量方法结束局部变量弹栈，但内部类对象可能需要对象回收 比方法生命周期长。用final在类加载会放入常量池，jdk1.8开始不需要final 编译器自动final，所以不能改变 静态内部类 能使用外部类的静态成员和方法 不用new外部类也能访问 使用内部类可以使用多继承 优先选择静态内部类(防止内存泄漏) 适配器安卓开发中常用，用A接口的子类转换B接口的子类 代理模式与AOP与模板方法不同：代理是控制对象 模板是延迟到子类定义操作，定义骨架 工厂模式 依赖注入策略模式和依赖倒置原则（面向接口编程）模板方法（设计模式） 权限管理 算法骨架不改变算法的结构，重新定义算法的特定步骤展开代码 1234567891011121314151617181920212223242526package javacoretest;abstract class BaseManager&#123; public void action(String username,String method)&#123; if("admin".equals(username))&#123; execute(method); &#125; else&#123; System.out.println("没有权限"); &#125; &#125; public abstract void execute(String Method);&#125;//延迟到子类实现ClassManager...子类有不同的实现class UserManager extends BaseManager&#123; @Override public void execute(String method)&#123; if("add".equals(method)) System.out.println("添加"); else if("del".equals(method)) System.out.println("删除"); &#125;&#125;public class Templete &#123; public static void main(String[] args) &#123; UserManager um = new UserManager(); um.action("admin","add"); &#125;&#125; MD5密码处理展开代码 1234567891011121314151617181920212223242526272829303132import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class MD5demo &#123; //数据库 所以密码只能重置不能查看 private static String savePassWord ="pmq7VoTEWWLYh1ZPCDRujQ=="; public static void main(String[] args) &#123; System.out.println(login("admin123456")); &#125; private static boolean login(String password)&#123; if(savePassWord.equals(md5(password)))&#123; return true; &#125;else &#123; return false; &#125; &#125; private static String md5(String password)&#123; try &#123; MessageDigest md = MessageDigest.getInstance("md5"); byte[] bytes = md.digest(password.getBytes("UTF-8")); String str = Base64.getEncoder().encodeToString(bytes); return str; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 位运算应用 判断奇偶：a&amp;1 = 0 偶数 a&amp;1 = 1 奇数 取模a &amp; (2^n - 1) 12System.out.println(999999&amp;7);System.out.println(999999%8);//相等 &amp;00001111是取get后4位 |00001111是set后4位为1 ^00001111是翻转后4位 java8时间LocalDate LocalTime LocalDateTime 国际化ResourceBundle simpledateformat??? 抗锯齿 异常e.getMassage()printStackTrace();调用堆栈 char 和 byte c++的char 8位，1字节。无byte。typedef unsigned char byte; java byte 静态方法没有this引用 包：保证类名的唯一性 工厂方法：返回一个类的新实例的静态方法 数组用Arraylist 因为内部管理数组，自动创建内部数组转移元素 扩容。 泛型类，自动装箱、自动拆箱 new ArrayList&lt;&gt;(Arrays.asList()) //[]-&gt;ArrayList asList固定长度 不支持add 输入输出 int.next() 读取空格分割的单词 ？？？？？读取密码用Console javaw runs Java code without association with current terminal/console (which is useful for GUI applications),there is no associated console window System.console() returns null.空指针异常 格式化字符串 System.out.printf(“%8.2f”,1000.0/3.0); (Integer).intValue() Object.clone()protected native Object clone() throws CloneNotSupportedException;浅拷贝，子类只能调用被保护的clone自己 Cloneable接口是空的。 实现了Cloneable只是标识 惯例重写Object.clone() 定义成public 1public A clone() throws CloneNotSupportedException 在没有实现Cloneable接口的实例上调用Object的clone方法会导致引发异常CloneNotSupportedException。 标记接口（tagging interface): 空的。使用目的：可以用instanceof Cloneable检查 ??enum toString的逆方法是valueOf super不是对象的引用。不能赋值给对象变量，是只是编译器调用超类方法的关键字 sout(char[]) √ char数组的打印有点特殊，int数组打印是打印出来一个地址，而char数组是打印数组里的内容。 如果重写了equals方法，请一并重写hashCode方法 重写类的equals方法-&gt;支持List 重写+hashCode方法-&gt;支持Set(HashMap,HashSet,LinkedHashMap,ConcurrentHashMap) (obj instanceof Person) 8种基本类型，其它都是对象（引用类型）-&gt; 包装类型 整型 byte short int long 浮点 float double 字符型 char 逻辑型 boolean 方法体里声明的基本数据类型在栈内存里 基本数据类型来说，赋值（=号）就相当于拷贝了一份值 当执行到new这个关键字，会在堆内存分配内存空间，并把该内存空间的地址赋值给arr1 注解 @interface元注解 注解只有一个成员，成员必须取名value（） 没有成员 标识注解 @Target（{}）作用域 @Retention（）生命周期 @Inherited 允许继承 Thread线程共享 *代码和数据空间线程由独立的运行栈和*程序计数器 线程的概念模型 虚拟cpu，在THREAD类中 将代码和数据传给thread类 线程体方法run()中的代码 构造线程的方法 定义线程类，重写run方法，通过start启动 12345678publc class FactorialThreadTester&#123; public static void main(String[] args)&#123; System.out.println("main thread starts"); FactorialThread thread = new FactorialThread(10); thread.start(); System.out.println("main thread ends"); &#125; &#125; runable 主方法main中创建一个新线程会等main执行完后再new 互斥锁 保证同一时刻有且只有一个线程在操作共享数据 解决端口占用123netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80 tasklist | findstr 2000 //端口号taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。 忽略序列化private transient String passwd;生命周期仅存于调用者的内存中而不会写到磁盘里持久化 final变量经常和static关键字一起使用，作为常量 final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写，只能被继承 final的类无法被继承 public void setLength(final int size)表示不能修改size的值 。对象则不能改变引用 类不能多继承，抽象类的方法可以不实现接口可以多继承 InterruptedException: 如何使HashMap线程安全的123Map&lt;,&gt; ht = new Hashtable&lt;&gt;();Map&lt;,&gt; sy = new Collections.synchronizedMap(new HashMap&lt;,&gt;())Map&lt;,&gt; concurr = new ConcurrentHashMap&lt;&gt;(); CHM（ConcurrentHashMap)性能最佳* Hashtable使用public synchronized阻塞，保证线程安全 .mf 是bean的JAR清单 迭代文件1234try(DirectoryStream&lt;Path&gt; entries = files.newDirectoryStream(dir))&#123; for(Path entry : entries)&#123; &#125;&#125; Map的方法put putAll String像数组一样取值 .charAt(i) 1@Native public static final int MAX_VALUE = 0x7fffffff; 0x7fffffff是补码表示的Integer的最小值(-2^31)和最大值(2^31-1),int是4字节。 String内部是通过char数组表示，数组的长度在Java中限制为一个int型所能表示的最大值 最小值 Math.min(,) substring(,)前闭后开 in-place 原地算法 删除重复元素 用!=略过并用unique的覆盖 最长公共前缀：indexOf if else语句中，是不能直接用break和continue的??? 123456//[2]不一样 if (source[i] != first) &#123; //[3]也不一样， while (++i &lt;= max &amp;&amp; source[i] != first); &#125; //直到下一个匹配的继续for中内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*@param source:左值（被查找）@param count长度*/ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; // 查找位置&gt;=左值长度 if (fromIndex &gt;= sourceCount) &#123; //traget空？返回左值长度 return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; // 右值为0，返回查找位置 if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; //最后一个匹配的下标，至少减去右值的长度 int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; // 跳过这次循环？ while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
