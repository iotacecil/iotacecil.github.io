<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F01%2Finterview-recite%2F</url>
    <content type="text"><![CDATA[body { max-width: 980px; border: 1px solid #ddd; outline: 1300px solid #fff; margin: 16px auto; } body .markdown-body { padding: 45px; } @font-face { font-family: fontawesome-mini; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff'); } .markdown-body { font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #333333; overflow: hidden; font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif; font-size: 16px; line-height: 1.6; word-wrap: break-word; } .markdown-body a { background: transparent; } .markdown-body a:active, .markdown-body a:hover { outline: 0; } .markdown-body b, .markdown-body strong { font-weight: bold; } .markdown-body mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; } .markdown-body sub, .markdown-body sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } .markdown-body sup { top: -0.5em; } .markdown-body sub { bottom: -0.25em; } .markdown-body h1 { font-size: 2em; margin: 0.67em 0; } .markdown-body img { border: 0; } .markdown-body hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; } .markdown-body pre { overflow: auto; } .markdown-body code, .markdown-body kbd, .markdown-body pre, .markdown-body samp { font-family: monospace, monospace; font-size: 1em; } .markdown-body input { color: inherit; font: inherit; margin: 0; } .markdown-body html input[disabled] { cursor: default; } .markdown-body input { line-height: normal; } .markdown-body input[type="checkbox"] { box-sizing: border-box; padding: 0; } .markdown-body table { border-collapse: collapse; border-spacing: 0; } .markdown-body td, .markdown-body th { padding: 0; } .markdown-body .codehilitetable { border: 0; border-spacing: 0; } .markdown-body .codehilitetable tr { border: 0; } .markdown-body .codehilitetable pre, .markdown-body .codehilitetable div.codehilite { margin: 0; } .markdown-body .linenos, .markdown-body .code, .markdown-body .codehilitetable td { border: 0; padding: 0; } .markdown-body td:not(.linenos) .linenodiv { padding: 0 !important; } .markdown-body .code { width: 100%; } .markdown-body .linenos div pre, .markdown-body .linenodiv pre, .markdown-body .linenodiv { border: 0; -webkit-border-radius: 0; -moz-border-radius: 0; border-radius: 0; -webkit-border-top-left-radius: 3px; -webkit-border-bottom-left-radius: 3px; -moz-border-radius-topleft: 3px; -moz-border-radius-bottomleft: 3px; border-top-left-radius: 3px; border-bottom-left-radius: 3px; } .markdown-body .code div pre, .markdown-body .code div { border: 0; -webkit-border-radius: 0; -moz-border-radius: 0; border-radius: 0; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 3px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; } .markdown-body * { -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body input { font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.4; } .markdown-body a { color: #4183c4; text-decoration: none; } .markdown-body a:hover, .markdown-body a:focus, .markdown-body a:active { text-decoration: underline; } .markdown-body hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } .markdown-body hr:before, .markdown-body hr:after { display: table; content: " "; } .markdown-body hr:after { clear: both; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 15px; margin-bottom: 15px; line-height: 1.1; } .markdown-body h1 { font-size: 30px; } .markdown-body h2 { font-size: 21px; } .markdown-body h3 { font-size: 16px; } .markdown-body h4 { font-size: 14px; } .markdown-body h5 { font-size: 12px; } .markdown-body h6 { font-size: 11px; } .markdown-body blockquote { margin: 0; } .markdown-body ul, .markdown-body ol { padding: 0; margin-top: 0; margin-bottom: 0; } .markdown-body ol ol, .markdown-body ul ol { list-style-type: lower-roman; } .markdown-body ul ul ol, .markdown-body ul ol ol, .markdown-body ol ul ol, .markdown-body ol ol ol { list-style-type: lower-alpha; } .markdown-body dd { margin-left: 0; } .markdown-body code, .markdown-body pre, .markdown-body samp { font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 12px; } .markdown-body pre { margin-top: 0; margin-bottom: 0; } .markdown-body kbd { background-color: #e7e7e7; background-image: -moz-linear-gradient(#fefefe, #e7e7e7); background-image: -webkit-linear-gradient(#fefefe, #e7e7e7); background-image: linear-gradient(#fefefe, #e7e7e7); background-repeat: repeat-x; border-radius: 2px; border: 1px solid #cfcfcf; color: #000; padding: 3px 5px; line-height: 10px; font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace; display: inline-block; } .markdown-body>*:first-child { margin-top: 0 !important; } .markdown-body>*:last-child { margin-bottom: 0 !important; } .markdown-body .headerlink { font: normal 400 16px fontawesome-mini; vertical-align: middle; margin-left: -16px; float: left; display: inline-block; text-decoration: none; opacity: 0; color: #333; } .markdown-body .headerlink:focus { outline: none; } .markdown-body h1 .headerlink { margin-top: 0.8rem; } .markdown-body h2 .headerlink, .markdown-body h3 .headerlink { margin-top: 0.6rem; } .markdown-body h4 .headerlink { margin-top: 0.2rem; } .markdown-body h5 .headerlink, .markdown-body h6 .headerlink { margin-top: 0; } .markdown-body .headerlink:hover, .markdown-body h1:hover .headerlink, .markdown-body h2:hover .headerlink, .markdown-body h3:hover .headerlink, .markdown-body h4:hover .headerlink, .markdown-body h5:hover .headerlink, .markdown-body h6:hover .headerlink { opacity: 1; text-decoration: none; } .markdown-body h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } .markdown-body h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } .markdown-body h3 { font-size: 1.5em; line-height: 1.43; } .markdown-body h4 { font-size: 1.25em; } .markdown-body h5 { font-size: 1em; } .markdown-body h6 { font-size: 1em; color: #777; } .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre, .markdown-body .admonition { margin-top: 0; margin-bottom: 16px; } .markdown-body hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul { margin-top: 0; margin-bottom: 0; } .markdown-body li>p { margin-top: 16px; } .markdown-body dl { padding: 0; } .markdown-body dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } .markdown-body dl dd { padding: 0 16px; margin-bottom: 16px; } .markdown-body blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } .markdown-body blockquote>:first-child { margin-top: 0; } .markdown-body blockquote>:last-child { margin-bottom: 0; } .markdown-body table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } .markdown-body table th { font-weight: bold; } .markdown-body table th, .markdown-body table td { padding: 6px 13px; border: 1px solid #ddd; } .markdown-body table tr { background-color: #fff; border-top: 1px solid #ccc; } .markdown-body table tr:nth-child(2n) { background-color: #f8f8f8; } .markdown-body img { max-width: 100%; -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body code, .markdown-body samp { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } .markdown-body code:before, .markdown-body code:after { letter-spacing: -0.2em; content: "\00a0"; } .markdown-body pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .markdown-body .codehilite { margin-bottom: 16px; } .markdown-body .codehilite pre, .markdown-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } .markdown-body .codehilite pre { margin-bottom: 0; word-break: normal; } .markdown-body pre { word-wrap: normal; } .markdown-body pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .markdown-body pre code:before, .markdown-body pre code:after { content: normal; } /* Admonition */ .markdown-body .admonition { -webkit-border-radius: 3px; -moz-border-radius: 3px; position: relative; border-radius: 3px; border: 1px solid #e0e0e0; border-left: 6px solid #333; padding: 10px 10px 10px 30px; } .markdown-body .admonition table { color: #333; } .markdown-body .admonition p { padding: 0; } .markdown-body .admonition-title { font-weight: bold; margin: 0; } .markdown-body .admonition>.admonition-title { color: #333; } .markdown-body .attention>.admonition-title { color: #a6d796; } .markdown-body .caution>.admonition-title { color: #d7a796; } .markdown-body .hint>.admonition-title { color: #96c6d7; } .markdown-body .danger>.admonition-title { color: #c25f77; } .markdown-body .question>.admonition-title { color: #96a6d7; } .markdown-body .note>.admonition-title { color: #d7c896; } .markdown-body .admonition:before, .markdown-body .attention:before, .markdown-body .caution:before, .markdown-body .hint:before, .markdown-body .danger:before, .markdown-body .question:before, .markdown-body .note:before { font: normal normal 16px fontawesome-mini; -moz-osx-font-smoothing: grayscale; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; line-height: 1.5; color: #333; position: absolute; left: 0; top: 0; padding-top: 10px; padding-left: 10px; } .markdown-body .admonition:before { content: "\f056\00a0"; color: 333; } .markdown-body .attention:before { content: "\f058\00a0"; color: #a6d796; } .markdown-body .caution:before { content: "\f06a\00a0"; color: #d7a796; } .markdown-body .hint:before { content: "\f05a\00a0"; color: #96c6d7; } .markdown-body .danger:before { content: "\f057\00a0"; color: #c25f77; } .markdown-body .question:before { content: "\f059\00a0"; color: #96a6d7; } .markdown-body .note:before { content: "\f040\00a0"; color: #d7c896; } .markdown-body .admonition::after { content: normal; } .markdown-body .attention { border-left: 6px solid #a6d796; } .markdown-body .caution { border-left: 6px solid #d7a796; } .markdown-body .hint { border-left: 6px solid #96c6d7; } .markdown-body .danger { border-left: 6px solid #c25f77; } .markdown-body .question { border-left: 6px solid #96a6d7; } .markdown-body .note { border-left: 6px solid #d7c896; } .markdown-body .admonition>*:first-child { margin-top: 0 !important; } .markdown-body .admonition>*:last-child { margin-bottom: 0 !important; } /* progress bar*/ .markdown-body .progress { display: block; width: 300px; margin: 10px 0; height: 24px; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; background-color: #ededed; position: relative; box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1); } .markdown-body .progress-label { position: absolute; text-align: center; font-weight: bold; width: 100%; margin: 0; line-height: 24px; color: #333; text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000; -webkit-font-smoothing: antialiased !important; white-space: nowrap; overflow: hidden; } .markdown-body .progress-bar { height: 24px; float: left; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; background-color: #96c6d7; box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1); background-size: 30px 30px; background-image: -webkit-linear-gradient( 135deg, rgba(255, 255, 255, .4) 27%, transparent 27%, transparent 52%, rgba(255, 255, 255, .4) 52%, rgba(255, 255, 255, .4) 77%, transparent 77%, transparent ); background-image: -moz-linear-gradient( 135deg, rgba(255, 255, 255, .4) 27%, transparent 27%, transparent 52%, rgba(255, 255, 255, .4) 52%, rgba(255, 255, 255, .4) 77%, transparent 77%, transparent ); background-image: -ms-linear-gradient( 135deg, rgba(255, 255, 255, .4) 27%, transparent 27%, transparent 52%, rgba(255, 255, 255, .4) 52%, rgba(255, 255, 255, .4) 77%, transparent 77%, transparent ); background-image: -o-linear-gradient( 135deg, rgba(255, 255, 255, .4) 27%, transparent 27%, transparent 52%, rgba(255, 255, 255, .4) 52%, rgba(255, 255, 255, .4) 77%, transparent 77%, transparent ); background-image: linear-gradient( 135deg, rgba(255, 255, 255, .4) 27%, transparent 27%, transparent 52%, rgba(255, 255, 255, .4) 52%, rgba(255, 255, 255, .4) 77%, transparent 77%, transparent ); } .markdown-body .progress-100plus .progress-bar { background-color: #a6d796; } .markdown-body .progress-80plus .progress-bar { background-color: #c6d796; } .markdown-body .progress-60plus .progress-bar { background-color: #d7c896; } .markdown-body .progress-40plus .progress-bar { background-color: #d7a796; } .markdown-body .progress-20plus .progress-bar { background-color: #d796a6; } .markdown-body .progress-0plus .progress-bar { background-color: #c25f77; } .markdown-body .candystripe-animate .progress-bar{ -webkit-animation: animate-stripes 3s linear infinite; -moz-animation: animate-stripes 3s linear infinite; animation: animate-stripes 3s linear infinite; } @-webkit-keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } } @-moz-keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } } @keyframes animate-stripes { 0% { background-position: 0 0; } 100% { background-position: 60px 0; } } .markdown-body .gloss .progress-bar { box-shadow: inset 0 4px 12px rgba(255, 255, 255, .7), inset 0 -12px 0 rgba(0, 0, 0, .05); } /* MultiMarkdown Critic Blocks */ .markdown-body .critic_mark { background: #ff0; } .markdown-body .critic_delete { color: #c82829; text-decoration: line-through; } .markdown-body .critic_insert { color: #718c00 ; text-decoration: underline; } .markdown-body .critic_comment { color: #8e908c; font-style: italic; } .markdown-body .headeranchor { font: normal normal 16px fontawesome-mini; line-height: 1; display: inline-block; text-decoration: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .headeranchor:before { content: '\e157'; } .markdown-body .task-list-item { list-style-type: none; } .markdown-body .task-list-item+.task-list-item { margin-top: 3px; } .markdown-body .task-list-item input { margin: 0 4px 0.25em -20px; vertical-align: middle; } /* Media */ @media only screen and (min-width: 480px) { .markdown-body { font-size:14px; } } @media only screen and (min-width: 768px) { .markdown-body { font-size:16px; } } @media print { .markdown-body * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; } .markdown-body { font-size:12pt; max-width:100%; outline:none; border: 0; } .markdown-body a, .markdown-body a:visited { text-decoration: underline; } .markdown-body .headeranchor-link { display: none; } .markdown-body a[href]:after { content: " (" attr(href) ")"; } .markdown-body abbr[title]:after { content: " (" attr(title) ")"; } .markdown-body .ir a:after, .markdown-body a[href^="javascript:"]:after, .markdown-body a[href^="#"]:after { content: ""; } .markdown-body pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; } .markdown-body pre, .markdown-body blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; } .markdown-body .progress, .markdown-body .progress-bar { -moz-box-shadow: none; -webkit-box-shadow: none; box-shadow: none; } .markdown-body .progress { border: 1px solid #ddd; } .markdown-body .progress-bar { height: 22px; border-right: 1px solid #ddd; } .markdown-body tr, .markdown-body img { page-break-inside: avoid; } .markdown-body img { max-width: 100% !important; } .markdown-body p, .markdown-body h2, .markdown-body h3 { orphans: 3; widows: 3; } .markdown-body h2, .markdown-body h3 { page-break-after: avoid; } } /*GitHub*/ .codehilite {background-color:#fff;color:#333333;} .codehilite .hll {background-color:#ffffcc;} .codehilite .c{color:#999988;font-style:italic} .codehilite .err{color:#a61717;background-color:#e3d2d2} .codehilite .k{font-weight:bold} .codehilite .o{font-weight:bold} .codehilite .cm{color:#999988;font-style:italic} .codehilite .cp{color:#999999;font-weight:bold} .codehilite .c1{color:#999988;font-style:italic} .codehilite .cs{color:#999999;font-weight:bold;font-style:italic} .codehilite .gd{color:#000000;background-color:#ffdddd} .codehilite .ge{font-style:italic} .codehilite .gr{color:#aa0000} .codehilite .gh{color:#999999} .codehilite .gi{color:#000000;background-color:#ddffdd} .codehilite .go{color:#888888} .codehilite .gp{color:#555555} .codehilite .gs{font-weight:bold} .codehilite .gu{color:#800080;font-weight:bold} .codehilite .gt{color:#aa0000} .codehilite .kc{font-weight:bold} .codehilite .kd{font-weight:bold} .codehilite .kn{font-weight:bold} .codehilite .kp{font-weight:bold} .codehilite .kr{font-weight:bold} .codehilite .kt{color:#445588;font-weight:bold} .codehilite .m{color:#009999} .codehilite .s{color:#dd1144} .codehilite .n{color:#333333} .codehilite .na{color:teal} .codehilite .nb{color:#0086b3} .codehilite .nc{color:#445588;font-weight:bold} .codehilite .no{color:teal} .codehilite .ni{color:purple} .codehilite .ne{color:#990000;font-weight:bold} .codehilite .nf{color:#990000;font-weight:bold} .codehilite .nn{color:#555555} .codehilite .nt{color:navy} .codehilite .nv{color:teal} .codehilite .ow{font-weight:bold} .codehilite .w{color:#bbbbbb} .codehilite .mf{color:#009999} .codehilite .mh{color:#009999} .codehilite .mi{color:#009999} .codehilite .mo{color:#009999} .codehilite .sb{color:#dd1144} .codehilite .sc{color:#dd1144} .codehilite .sd{color:#dd1144} .codehilite .s2{color:#dd1144} .codehilite .se{color:#dd1144} .codehilite .sh{color:#dd1144} .codehilite .si{color:#dd1144} .codehilite .sx{color:#dd1144} .codehilite .sr{color:#009926} .codehilite .s1{color:#dd1144} .codehilite .ss{color:#990073} .codehilite .bp{color:#999999} .codehilite .vc{color:teal} .codehilite .vg{color:teal} .codehilite .vi{color:teal} .codehilite .il{color:#009999} .codehilite .gc{color:#999;background-color:#EAF2F5} 面试卡片https://blog.csdn.net/jackfrued/article/details/44921941 https://github.com/randian666/algorithm-study https://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2 https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md http://www.linya.pub/ https://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2 https://www.nowcoder.com/discuss/111311 架构扫盲 https://github.com/doocs/advanced-java 1.数据库 SQL生命周期： 应用服务器与数据库服务器建立一个连接 数据库进程拿到请求sql 解析并生成执行计划，执行 读取数据到内存并进行逻辑处理 通过步骤一的连接，发送结果到客户端 关掉连接，释放资源 数据库连接池 1.数据库更适合长连接，复用连接，维护连接对象、分配、管理、释放，也可以避免创建大量的连接对DB引发的各种问题 2.通过请求排队缓解对db的冲击 mysql 的其他引擎 设计数据库表 1.数据库里的乐观锁和悲观锁 共享锁、排他锁 悲观锁：select ... for update; 主键明确&amp;有结果行锁，无结果集（查空）无锁。 查询无主键或者不走索引where id&lt;&gt;'66' like，表索 。 乐观锁：数据库version字段 2.索引什么时候会失效：模糊匹配、类型隐转、最左匹配 1）有or or中的每个列都要有索引 2）like 以%开头 用覆盖索引index_all 只访问索引的查询 using index &amp; using where： 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 例如联合索引a,b一般不能单独用b的索引，但是count就能用 3）如果where=字符串 一定要加引号 4)如果数据太少还是全表扫描快就不用，如果查询的列太多，数据太多，会直接走主键全表扫描 5）is null或者is not null 3.Mysql 有哪些索引 数据结构：B+，hash，全文索引，R-Tree 物理存储：聚集索引、非聚集索引 逻辑角度：主键、单列索引、多列索引、空间索引、覆盖索引（？） 4.数据库隔离界别 5.mybatis和jdbc比有什么好处 1)动态sql 持久层框架 6.防止sql注入如何实现 #{} 会被替换成sql中的？调用PreparedStatement set进参数 ${} 是替换值 字段名不一样，定义resultMap，id标签映射主键并设置column，其他列用result标签 写模糊查询不要写在sql，用#{}传入 7.分页原理： 物理分页：limit offset 逻辑分页 8.数据库索引INNDB的好处 事务，主键索引，外键 自增长列必须是主键，索引的第一个列，而且因为不是表锁要考虑并发增长。 innodb其实不是根据每个记录产生行锁的，根据页加锁，而且用位图。 意向锁。锁定对象分为几个层次，支持行锁、表锁同时存在。 一致性非锁定读：读快照 多版本并发控制：read committed是最新快照，重复读是事务开始时的快照。通过undo完成的。 redo 保证事务的一致性、持久性。undo 保证事务的一致性（回滚）和MVCC多版本并发控制。 不走索引表锁。 myisam 缓冲池之缓存索引文件，不缓存数据。 索引和数据分文件。 脏读 脏页是最终一致性的，数据库实例内存和磁盘异步造成的。脏（数据）读违反了隔离性。 9.mysql日志文件（不是引擎） binlog(逻辑日志，是sql）记录了数据库更改的所有操作。 有3种格式 Statement：sql语句。 row：记录行的更改情况，很占空间，而且对复制的网络开销也增加。mixed。 用于point-in-time恢复、主从复制 只有事务提交时写磁盘一次。 慢查询、查询、错误 数据完整性：记录每个页的更改物理情况 redo重做日志缓存，按一定频率写到重做日志文件 是innodb的。 事务进行中，缓存每秒写入一次文件。 内部xa事务 事务提交先写binlog再写reodlog也写入磁盘。 doublewrite：内存中的2M buffer，磁盘上共享表空间的128个页（2M） 在应用重做日志之前，需要通过副本还原页。页刷新都首先要放入doublewrite。 因为只有一个主键并且建了B+树，所以其他辅助索引的插入是离散的，所以，有insert buffer mysql为什么可重复读 不可重复读重点在于update和delete，而幻读的重点在于insert。 幻读：虽然可重复读对第一次读到的数据加锁，但是插入还是可以的，就多了一行。 因为binlog的Statement以commit顺序 可重复读会对读取到的数据进行加锁（行锁），保证其他事务无法修改这些已经读过的数据， MVCC实现可重复读 只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度 每个数据行会添加两个额外的隐藏列，分别记录这行数据何时被创建以及何时被删除，这里的时间用版本号控制 所有的SELECT操作无需加锁，因为即使所读的数据在下一次读之前被其他事务更新了 行锁会用gap锁锁住一个区间，阻止多个事务插入到同一范围内。是为了解决幻读问题。 一个事务select * from t where a&gt;2 for update;对[2+)加锁，另一个事务插入5失败。 mysql主从复制 主节点创建线程发送binlog，读取binlog时会加锁。 mysql在事务提交前，记录binlog。 主库通过发送信号告知从库有新事件。 从节点I/O线程接受binlog，保存在relaylog中继log。 从节点SQL线程读取relaylog，并执行sql。完成数据一致性。 也可以开启放到自身的二进制日志中。 在主库上并发的操作变成串行的。 主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。 复制一个库，先dump一个快照，得到当前快照时对应binlog中的偏移量：日志文件坐标 mysql的两种复制方式： 语句复制：只记录修改数据的查询。更新是串行的，需要很多锁 基于行的复制：实际数据记录在binlog。 但是例如全表更新的操作 行数据让会binlog很大。 10.数据库最左匹配原理 2.网络 web服务器 1.一个端口的连接数太多 Linux中，一个端口能够接受tcp链接数量的理论上限是？无上限 client端的情况下，最大tcp连接数为65535 server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。 server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万 是没问题的 有一个接口一下子快一下子慢 1）用户怎么排查 2）开发者怎么排查 如果是一个数据库接口 2.反爬虫 1）单个IP、session统计 对header user-agent、referer检测 3.7层模型是哪7层 表示层：数据格式变化，加密解密，压缩和恢复 会被放到应用层和会话层 会话层：建立连接，有序传输数据。建立、管理、终止会话。使用校验点，使会话失效时从同步点/校验点恢复通信。（传文件）ADSP ASP 传输层：第一个端到端通信。根据端口分报文到不同的进程。 4.http 如果输入163.com跳转到www.163 301 重定向 206 客户端发送range，服务端有accept-range 响应码 nginx会检查的 405 Not Allowed 必须是GET/POST等指定的方法，header不合法，有下划线等 414 Request URI too Large 请求行太长，超过buffer 400 Bad request 单个header超过单个buffer大小 413 Request Entity Too Large 浏览器发送的Content-Length 超过服务器的包体大小。 504 QUIC协议已经标准化为Http3协议。基于UDP，但提供了可靠性和流量控制。 可以避免Http2的前序包阻塞 重定向的响应头为302，并且必须要有Location响应头； 服务器通过response响应，重定向的url放在response的什么地方？ 后端在header里的设置的Location url 重定向可以用于均衡负载 5.nginx 10w以上的并发连接 Nginx是如何工作的？是如何配置的？ 工作模式： 进程模式：一个master进程管理worker进程，监听连接请求。worker进程处理业务请求，每个worker可以并行处理数千个并发连接和请求。 事件模式：网络、信号、定时器 惊群现象 1)事件驱动、全异步网络I/O 极少进程切换 2）sendfile系统调用 硬盘-&gt;网络 3）可靠性：多进程独立 epoll：通过内核与用户空间mmap同一块内存实现的 tomcat nginx apache 区别 Apache和nginx是 Http静态服务器 tomcat 是 Servlet 的容器，处理动态资源。 cookie跨域问题 web1想要拿到web2的cookie KV并且让path变成/web1发ajax，type：get，dataType：jsonp。jsonp利用回调函数，服务端response的outputstream返回document.cookie="k=v;path=/web1"（返回可执行的js代码，回调函数自动执行js） nginx nginx的负载均衡策略 1.轮询round robin 按配置文件中的顺序分发 2.最少连接 活动连接数量最少的服务器 3.IP地址哈希 方便session保存 http { upstream myapp1 { //ip_hash, least_conn; server srv1.example.com; server srv2.example.com; server srv3.example.com; } 4.基于权重的均衡负载 nginx限流是漏桶法 6.正向代理和反向代理的区别 正向代理：隐藏了真实的请求客户端，服务端不知道真实的客户端是谁。需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回。 反向代理：接收外网请求，转发给内网上游服务器，并将结果返回给外网客户端。 先接受完请求的1G文件，缓存客户端请求， 建立转发，降低上游服务器负载（占用服务器的连接时间会非常短）。 其他web服务器有哪些 7.nodejs为什么快？ 用户态异步实现 单进程，非阻塞异步IO，通过回调高度用户 事件驱动 超过5w 主进程现在只要专心处理一些与I/O无关的逻辑处理 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈 8.为什么是三次握手 三次握手的过程： https://juejin.im/post/5a0444d45188255ea95b66bc 客户端 端口+SYN=1+序号a SYN_SENT， 服务端 SYN=1，ACK=1,序号b，ack=序号a+1, 客户端ESTABLISHED 客户端 ACK = 1，序号=a+1,ack=b+1,服务端ESTABLISHED 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 三次通信是理论上的最小值。 1）初始化序号 （来解决网络包乱序（reordering）问题），互相通知自己的序号。 2）为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 如果A发送2个建立链接给B，第一个没丢只是滞留了，如果不第三次握手只要B同意连接就建立了。 如果B以为连接已经建立了，就一直等A。所以需要A再确认。 首次握手隐患：服务器收到ACK 发送SYN-ACK之后没有回执，会重发SYN-ACK。产生SYN flood。 用tcp_syncookies 参数 SYN 洪水攻击：服务端收到客户端SYN后发送SYN和ACK后，客户端不回复，导致服务端大量SYN_RCVD 设置syn ack retry参数加快半连接回收速度。 或者调大syn backlog 9.拥塞控制的方法 快恢复：网络拥塞后ssthresh设为拥塞的一半，cwnd不是变成1再慢开始 10.快重传 当发送方连续收到了3个重复的确认响应的时候，就判断为传输失败，报文丢失，这个时候就利用快重传算法立即进行信息的重传。 拥塞控制主要通过【慢开始，快重传，快恢复和避免拥塞】来实现的。 快恢复 与快重传配合使用，当发送方接收到连续三个重复确认请求，为了避免网络拥塞，执行拥塞避免算法 11.可靠传输的方法 可靠性 1.序号 确认应答 超时重传 2.连接管理 数据校验 3.数据合理分片和排序 - UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报. - TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。 4、流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 5、拥塞控制：当网络拥塞时，减少数据的发送。 TCP滑动窗口window size 16bit位 可靠性+流量控制+拥塞控制 流量控制： 本质是 动态缓冲区。接收端动态调整窗口大小放在ACK的header中。 拥塞控制：慢启动、拥塞避免、拥塞发生、快速恢复4个算法 慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半 同时拥塞窗口重置为 1 window 接收端告诉发送端自己还有多少缓冲区可以接收数据rwnd option中还有一个窗口扩大因子 12.为什么四次分手 1)TCP半关闭。于TCP连接是全双工的，因此每个方向都必须单独进行关闭。 当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。 收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 13.为什么要TIME_WAIT等2MSL 最大报文寿命 Maximum Segment Lifetime TCP报文段是以IP数据报在网络中传输，IP数据报有TTL字段。 IP数据报对TTL的限制是跳数，不是定时器。 主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。 【rst】是一种关闭连接的方式。 1）可靠地实现TCP全双工连接终止。等最后一个ACK到达。 如果没收到ACK，则被动方重发FIN，再ACK正好是两个MSL。 2)让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。 为什么是2MSL是让某个方向上最多存活MSL被丢弃，另一个方向上的应答最多存活MSL被丢弃。 14.TIME_WAIT 和 CLOSE_WAIT 1）发送FIN变成FIN_WAIT1，然后收到对方ACK+FIN，发完ACK 2）FIN_WAIT1 收到ACK之后到FIN_WAIT2，然后收到FIN，发送ACK。如果最后一个ACK失败，重发FIN但是对方已关闭会得到RST，发送FIN方会报错。 这个状态等2MSL后就CLOSED 作用：让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。 HTTP长连接主动关闭的是server，TIME_WAIT可以修改参数解决。 net.ipv4.tcp_tw_recycle = 1可以快速回收TIME-WAIT CLOSE_WAIT 被动关闭后没有释放连接，一般是代码写的有问题。 TCP连接状态书上一共11种 15.和UDP区别 1）无连接 不可靠 无序 2）广播 3）速度快 报头只有8字节 TCP是【字节流】 20字节（1行32位4字节)，数据分段TCP是无边界的，UDP面向【报文】，保留了边界。 16.ping命令原理 https://juejin.im/post/5ba0bb05e51d450e6f2e38a0 输入 ping IP 后敲回车，发包前会发生什么？ 如果是域名先要差dns解析ip 1.根据目的IP和路由表决定走哪个【网卡】 2.根据【网卡的子网掩码】地址判断目的IP是否在【子网】内。 同一网段： 3.不在则会通过【arp缓存】查询IP的网卡地址 4.不存在的话会通过[arp广播]询问目的IP的mac地址 5.同一个网段的Ping：A得到mac地址后，把B的MAC地址封装到ICMP包中，向主机B发送一个回显请求 不同网段： 3.发送arp找网关MAC 4.把目的MAC是网关，目的IP是主机C的ICMP包 5.路由器去掉原来ICMP的MAC头，MAC源地址改成自己的MAC出地址，目的是查询到C的MAC 6.主机C直接ICMP回显 ICMP回显应答时要输出 序号、TTL、往返时间，目的主机IP地址。 type:回显询问ICMP_ECHO 和回答ICMP_ECHOREPLY code 总是 0 在ICMP报文的标识符字段设为发送的进程ID。即使多个ping程序也可以识别出返回信息。 序号，用于查看是否有分组 丢失、失序、重复。 输入主机名，ping会用DNS确定主机对应的IP地址。 第一个RTT会比较长，因为会发送一个ARP报文。 发送ICMP请求报文（类型8）一定会从host或者getway返回一个ICMP 响应报文(类型0) 发送一个32字节的测试数据，TTL经过一个路由器就-1. ping 127.0.0.1 TTL是128. 17.输入URL之后经历什么 DNS解析 1）查DNS，浏览器缓存，操作系统先查hosts，查本地DNS缓存，路由器缓存，向DNS服务器发UDP包 2）IP包到网关需要知道网关的MAC地址，用ARP 3）DNS服务器会去查根据名服务器得到注册的域名服务器 TCP建立连接 4）得到IP给浏览器，浏览器，发TCP建立连接 HTTP请求/响应 5）接到重定向到Https， 18.HTTP 长连接怎么实现 HTTP管道是什么，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 19.http https HTTP+ 加密 + 认证 + 完整性保护 =HTTPS 总共有3个随机数，客户端随机数，服务端随机数，预主密钥, 对2个随机数和预主密钥生成主密钥用于之后数据加密 https的过程： - 握手过程 1.客户端client hello发送 随机数+支持的套件 2.服务端server hello返回2个包，1）随机数+选择套件，2）证书（身份认证） 3.握手完成，客户端返回用服务端公钥加密的预主密钥 完成后两边都有预主密钥+2个随机数，用约定的hash算法，生成主密钥进行数据传输 http先和ssl通信，再ssl和tcp通信。 在交换密钥环节使用【公开密钥】加密方式， 之后的建立通信交换报文阶段则使用【共享密钥】加密方式。 对称和非对称 随机码用来？ 随机码用服务端的公钥加密， http 有9种方法 RSA: 两种方式： 1）全密文：用对方公钥加密，对方用私钥解密 2）明文+印章（防抵赖）：用自己私钥签名，对方用公钥验签 使用AOP实现 20.网络编程的一般步骤 21.Nagel和ACK延迟 ACK延迟 将ACK和数据包一起发送 有定时器 20字节IP首部，20字节TCP 一起用会出现延迟40ms超时后才能回复ACK包 3.操作系统 1.三态转换 2.进程间通信 套接字，管道，命名管道、邮件槽、远程过程调用、消息队列，共享内存，信号量,信号。 使用场景：进程间数据共享：共享内存 进程间数据交换：socket、消息队列。 信号：异步的通知机制，用来提醒进程一个事件已经发生 信号是在软件层次上对中断机制的一种模拟。 trap -l trap "" INT 表明忽略SIGINT信号，按Ctrl+C也不能使脚本退出 https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/IPC.md 管道只能两个进程 消息队列能多个进程 管道 【随进程持续】： 管道的本质是内核维护了一块缓冲区与管道文件相关联。 1）单向 半双工：把一个程序的输出直接连接到另一个程序的输入 2）除非读端已经存在，否则写端的打开管道操作会一直阻塞 3）只能父子进程、兄弟进程 4）无格式字节流，需要事先约定数据格式。 匿名管道：内存文件描述符（内核）。 1）pipe(2)系统调用时，这个函数会让系统构建一个匿名管道 2）这样在进程中就打开了两个新的，打开的文件描述符：父进程关闭管道读端，子进程关闭管道写端。 3）一般再fork一个子进程，然后通过管道实现父子进程间的通信。 4）通过只在【内存】（内核）中的文件描述符fd[0]表示读 fd[1]表示写。（父子进程分别关闭一端组合成父进程-&gt;子进程/子进程-&gt;父进程的管道） 命名管道FIFO文件：提供一个路径名与之关联，以FIFO文件形式存在于【文件系统】 mkfifo() 可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接。 1)读管道程序 mkfifo创建管道文件，死循环read 2)写程序 打开管道文件写。 借助了文件系统的file结构和VFS的索引节点inode。过将两个file 结构指向同一个临时的VFS 索引节点，而这个VFS引节点又指向一个物理页面 管道和命名管道都是随进程持续的，而消息队列还有后面的信号量、共享内存都是随内核持续的 消息队列（链表） msgget（同一台机器） 系统内核： （一种逐渐被淘汰的方式） msgid = msgget((key_t)1234, 0666 | IPC_CREAT);msgget()msgrcv() 1）异步：消息队列本身是【异步】的，消息队列独立于进程存在。它允许接收者在消息发送很长时间后再取回消息 2）消息必须以long int 开头 , 接收程序可以通过消息类型有选择地接收数据。 3）可以同时通过发送消息，避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。 4）轮询：收者必须轮询消息队列，才能收到最近的消息。 5）优先级 6）与管道相比，消息队列提供了有格式的数据 【读写双方都需要msgget建立消息队列】 7）和信号相比，消息队列能够传递更多的信息 共享内存shmget 最快但是无法解决同步 1）shmget创建一个 结构体大小的共享内存，有权限 2）shmat 映射到进程的地址空间。 3）读写的时候要用written标志防止两个进程同时读写 而且要把written变成原子操作 4）shmdt可以分离共享内存 struct shared_use_st{ int written; char text[2048]; }; 同一个Linux机器的两个进程访问同一块共享内存，他们访问共享内存中的同一个对象的时候，指针相同吗？ 可能相同也可能不同 信号量semget 有权限 不是线程同步的posix信号量，是SYSTEM V信号量 信号量能解决 共享内存同步问题 3.进程调度方式 CFS 调度周期 计算运行时间vruntime Linux CFS 完全公平调度器： 1.设定一个【调度周期】（sched_latency_ns），目标是让每个进程在这个周期内至少有机会运行一次。每个进程等待CPU的时间最长不超过这个调度周期。 2.进程的数量，大家平分这个调度周期内的CPU使用权，由于进程的优先级即nice值不同，分割调度周期的时候要加权； 3.每个进程的【累计运行时间】保存在自己的vruntime字段里，哪个进程的vruntime最小就获得本轮运行的权利。 细节 问题1：新进程 fork之后的子进程优先于父进程 每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，防止一直fork获得时间片，新进程一般要设置比min_vruntime大。 问题2：休眠进程 唤醒抢占特性 被唤醒时当新进程重新设置vruntime 问题3：频繁抢占 CFS设定了进程占用CPU最小时间，如果进程太多，调度周期会根据最小时间x进程数 问题4：进程切换CPU 为保持相对公平，vruntime要减去当前CPU的min，在加到CPU2的min上 红黑树而不用最小堆 每个核用红黑树选区vruntime最小的进程 进程调度有很多遍历操作，需要完全排序 红黑树插入最多两次旋转，删除最多3次旋转，染色Logn 进程的上下文切换：切换会保存寄存器、栈，需要用户态切换到内核态 4.内存分页与swap 内存屏障 指令乱序 分支预测 CPU亲和性affinity Netfilter和iptables 5. 死锁 原因：资源不足、进程运行推进顺序不合理、资源分配不当、占用资源的程序崩溃 5.1死锁条件 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 死锁的发生必须满足以下四个条件： - 互斥条件：一个资源每次只能被一个进程使用。 - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 - 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 5.2死锁处理策略 1）预防死锁 前面4个条件 2）避免死锁 银行家算法 3）死锁检测再解除 互斥条件：SPOOLing 技术，将打印机变成共享设备，加一个队列。 不剥夺条件：得不到就放弃自己的 或者直接抢 请求和保持条件：静态分配（进程运行前一次性分配全部资源） 循环等待条件：顺序资源分配法 对资源加编号 同类资源一次性分配完 4.java基础 1.Java 类加载的过程 将编译好的类文件中的字节码文件加载到内存中，放在方法区内并创建Class对象。 双亲委派原则：每个加载器对应不同的加载目录。先检查这个类是否加载过，不然调用父加载器的loadClass，如果父加载器（在搜索范围内没这个类）抛出异常，调用自己的findClass()。 好处：避免类的重复加载，避免核心API被纂改。无论哪个类加载器要加载。都委派给启动类加载器，类随类加载器有层级关系，Objet都是同一个类。 类加载的过程包括了【加载、链接（验证、准备、解析）、初始化】五个阶段 加载：1）获取二进制字节流2）静态存储结构（字面量和符号引用）放到【运行时数据区】。堆中生成3）Class对象，作为方法区类数据的访问入口，hotspot放在方法区里。 验证：文件格式、元数据、字节码（数据流、控制流）、符号引用 验证 准备：分配内存，设初始值 解析：符号引用-&gt;直接引用 初始化：如果父类没有初始化，会先初始化父类 解析可能在初始化之后。 初始化阶段有且只有5种主动加载的情况： 1）new,静态方法、静态字段（被final放到常量池的静态字段除外） 2）反射Class.forName 3）作为父类，子类被初始化 4）调用main 5）MethodHandle 2.java8的新特性 3.Object有哪些方法 还有getClass() 和finalize wait 方法必须在synchronized内用 4.JVM分哪几个区 - JVM内存模型 虚拟机运行时数据区、类加载器、执行引擎、本地方法库 线程独占： 1）程序计数器-多线程轮流切换并分配处理器执行时间，多线程切换后恢复到正确的执行位置。 2）虚拟机栈 3）本地方法栈 线程共享： 堆、方法区（永久代、metaspace） 介绍JVM堆和栈，有什么用 虚拟机栈：生命周期与线程相同。Java 方法执行的内存模型，局部变量表、返回地址、操作数栈、动态链接（？） JVM结构 新生代有什么算法 4大算法：引用计数，复制，标记清除，标记压缩 7个垃圾收集器 串行收集器适合单核CPU或者非常小堆。ES默认使用CMS收集器 5.Java内存分配策略 Java对象的内存分配主要是指在堆上分配（也有经过JIT编译后被拆散为标量类型并间接地在栈上分配的情况），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，则将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。 怎么把对象分配到老年代上 6.泛型的好处 泛型：向不同对象发送同一个消息，不同的对象在接收到时会产生不同的行为（即方法）；也就是说，每个对象可以用自己的方式去响应共同的消息。消息就是调用函数，不同的行为是指不同的实现（执行不同的函数）。 用同一个调用形式，既能调用派生类又能调用基类的同名函数。 7.方法的重载和重写都是实现多态的方式， 区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 为什么不能根据返回类型来区分重载? 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 虚函数是实现多态 &ldquo;动态编联”的基础，C++中如果用基类的指针来析构子类对象，基类的析构要加virtual，不然不会调用子类的析构，会内存泄漏。 8.虚拟机如何实现多态 解析调用：方法是一个常量池中的符号引用。静态方法（类型绑定），私有方法（外部不可访问）在类加载【解析】阶段把所有符号引用变为可确定的直接引用。 分派调用： 重载：静态分派，编译期间依赖静态类型（左边）定位方法版本。应用：重载。变异期间选择重载版本。 静态多分派，动态单分派。 重写：动态分派，虚拟机根据实际类型分派，invokevirtual指令 调用虚方法。运行期在操作数栈顶找到对象的实际类型（运行时确定方法的接收者类型），将常量池中的方法符号引用解析到不同的直接引用上。 每个类在方法区中有 虚方法表，子类重写方法，子类放发表里换替换为子类实现的版本地址。 相同签名的方法，在父类、子类需方发表都应有一样的序号。 链接阶段进行初始化方法表（？） 9.除了基本类型还有那些类能表示数字 包装类，高精度BigDecimal，原子类 Atomic内部用native方法，使用了硬件支持的CAS 1.8新加的原子类LongAdder 分离热点 把value变成一个数组，变成hash计数，计数结果就是累加结果。 10. java修饰符 访问修饰符： 可以对 类、变量、方法、构造方法访问控制 private不能修饰外部类 protected不能修饰外部类 非访问修饰符：static final abstract synchronized volatile 11.线程调度方式 时间片轮转调度，优先级调度，多级反馈队列调度，高响应比优先调度 vmstat 看cs 是context switch 线程上下文切换次数 pidstat -w cswch/s 主动上下文修换 nvcswch/s 被动上下文切换 上下文切换还包括系统调用。 us 用户CPU时间 sy 系统CPU时间 协同式线程调度（协程，每个线程执行时间由线程本身控制） java：抢占式线程调度（操作系统分配时间） java线程是映射到操作系统原生线程上的。 12.String StringBuilder StringBuffer String 存在JVM哪里 1）一旦有一个用引号的字符串就会放到字符串常量池。 2）拼接创建的只在堆里。 3）堆里面创建新的字符串，用intern可以放【引用】到常量池（jdk1.7之前只只能放一个副本放到常量池） 方法区，方法区是JVM的一种规范。元空间MetaSpace和永久代PermGen都是方法区的实现。 原来在永久代里的字符串常量池移到了堆中。而且元空间替代了永久代。 本来永久代使用的是JVM内存，而元空间使用的是本地内存，字符串常量不会有性能问题（intern）和内存溢出。 5.分布式 使用过zookpeeper吗 1.使用场景 2.解决的问题 3.特点 4.和其他同类型的框架的比较 全局唯一id mysql实现 create table `tic`( `id` bigint(20) unsigned not null auto_increment, `stub` char(1) not null default &#39;&#39;, primary key (`id`), unique key `stub` (`stub`) )engine = myisam; start transaction; replace into tic(stub) values(&#39;a&#39;); select last_insert_id(); commit; 1.zookeeper的应用场景 分布式协调 节点注册监听 分布式锁 2.XA事务 分布式事务 事务管理器（Mysql客户端）和资源管理器（Mysql数据库）之间用两阶段提交，等所有参与全局事务的都能提交再提交 用JAVA JTA API 6.数据结构 1.二叉平衡树的应用 红黑树原理 关键性质：红黑树确保没有一条从根到叶子的路径会比其他从根到叶子的路径长出两倍 1）根、叶子节点、红色节点的两个儿子都是黑色 2）任一节点到其每个叶子节点的所有简单路径 包含相同数目的黑色节点 AVL树是严格的平衡二叉树 如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。 windows对进程地址空间的管理用到了AVL树 2.排序 希尔排序复杂度 当步长为1时，算法变为普通插入排序 已知最好n(log^2)n 3.最小生成树的两种算法 Prim算法，标记已选点，选标记点可达的最近点标记，直到标记完所有点。 贪心选择与当前顶点集合中距离最短的顶点。 把点划分为3类：不可达（不可选），可选，已选 维护一个数组：dis，作用为已用点到未用点的最短距离。 证明：对于任意一个顶点v，连接到该顶点的所有边中的一条最短边(v, vj)必然属于最小生成树（即任意一个属于最小生成树的连通子图，从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树） 复杂度：O（n^2) n为图中顶点数。适合稠密图。邻接矩阵O(v^2) 邻接表O(elog2v) Kruskal算法，存在相同权值的边。O(mlogm) m为边树，与顶点数无关 扩展边，每次贪心选择剩余边中最小权重的边。 从权值最小的边开始遍历，直到图的点全部在一个连通分量中。 复杂度： 4.Hash碰撞的方法 1）开放地址法（Nginx的散列表） 开放地址法分： 线性探测法（会聚集）、平方探测、双散列 2）链地址法 不成功平均查找长度，要按照冲突解决方法查找到当前位置为空位置。最后/散列函数的mod（hash函数的分类个数） 7.框架 1.Spring容器初始化过程 ioc aop原理 2.ioc怎么实现 3.Springboot的启动流程 4.SpringMVC工作原理 1）servlet一共三个层次 HttpServletBean:直接继承java的HttpServlet，将Servlet中的配置参数设置到相应的属性。 FrameworkServlet：初始化WebApplicationContext 抽象类静态方法 将不同类型请求合并到一个方法统一处理。还发布了一个事件。 DispatcherServlet:初始化9大组件 doService方法保存redirect转发的参数和include的request快照。 调用的doDispatch方法4步 1）根据request找到handler（@RequestMapping） 2）用mapper根据handler找到handlerAdapter 处理不同参数（不只是request和response） 3）handlerAdapter处理，先执行拦截器。Last-Modified 4）processDispatchResult处理View 8.并发 1.协程 轻量化 用户态调度 切换代价比线程上下文切换低 非抢占式用户态线程 与进程和线程的区别：通过抢占式调度 内核态异步编程：内核线程（轻量级进程LWP，用户可操作的内核态线程） 大量内核态县城会干扰内核调度 影响其他应用 go的调度器分为：内核线程M，P内核处理器，G goroutine 协程 用户态线程 通过P，把无限多的G均分到有限的M上。 Java 第三方协程框架 2.currentHashMap https://blog.csdn.net/qq_33256688/article/details/79938886 1.7之前是头插，1.8之后是尾插 hashmap为了避免尾部遍历，链表插入使用头插，不然rehash要每次都遍历到链表尾。 头插会死循环，因为如果2个线程在rehash， 线程1:原来[3]-&gt;3-&gt;7，保存的next是7.挂起 线程2已经rehash好了变成[3]-&gt;7-&gt;3 线程1恢复，开始rehash，变成new[3]-&gt;3 next = 7 继续变成[3]-&gt;7-&gt;3。并且线程2已经把7-&gt;3连好了，现在next还是3，变成[3]-&gt;3-&gt;7-&gt;3 3.next还是7死循环 问题在于，本来从链表头部拿，next一定会拿到null，但是另外一个线程使next倒置，导致线程1先rehash好了后面的节点，然后原链表继续next实际上已经在新链表里了。 不能为null hashmap也是尾插 保留了顺序，不会死循环。 currentHashMap原理：1.7分段锁，降低锁定程度，1.8CAS自旋锁 3.CAS算法原理？优缺点？ CAS 流程：线程在读取数据时不进行加锁，在写回数据时，比较原值是否修改，如果未被其它线程修改，则写回，不然重新读取。 乐观认为并发操作不是总会发生。 通过操作系统原语实现，保证操作过程中不会被中断。 https://juejin.im/post/5ba66a7ef265da0abb1435ae 非阻塞算法：一个线程的失败或者挂起不会导致其他线程也失败或者挂起。 无锁算法：算法的每个步骤，都存在某个线程能执行下去。多个线程竞争CAS总有一个线程胜出并继续执行。 CAS 是实现非阻塞同步的计算机指令，它有三个操作数，内存位置，旧的预期值，新值， 对于多个状态变量的场景，通过AtomicReference包装这个对象，每次更新先获取旧值，再创建新值，用这两个值进行CAS原子更新。 CAS 实现原子操作的三大问题 1) ABA问题 解决：用AtomicStampedReference 不可变对象pair 2）循环CPU开销 JVM pause指令 Unsafe.park()遇到线程中断不会抛异常，会立刻返回再次运行，CPU可能飙升，一直是RUNNABLE。 3）多个共享变量 解决：用AtomicReference 线程安全的链表 每个node有锁，保存链表尾指针 AQS利用CAS原子操作维护自身的状态，结合LockSupport对线程进行阻塞和唤醒从而实现更为灵活的同步操作。 MCS自旋锁 基于链表 公平自旋锁 在本地属性变量上自旋 CLH自旋锁 基于链表 公平自旋锁 在前驱结点上自旋 有N个线程 L个锁 空间需要O(L+N) 4.AQS AQS：队列同步器 AQS的核心思想是基于volatile int state这样的一个标志位1表示有线程占用，其它线程需要进入同步队列 同步队列是一个双向链表，当获得锁的线程等待条件，进入等待队列（可以有多个），满足后重新进入同步队列，获取锁竞争 Unsafe类提供CAS方法 同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。 private volatile int state; ReentrantLock用来表示所有者重复获取该锁的次数 Semaphore表示剩余许可数量 FutureTask用于表示任务状态(现在FutureTask不用AQS了)但也是state 当线程尝试更改AQS状态操作获得失败时，会将Thread对象抽象成Node对象 形成CLH队列，LIFO规则。 5.线程池的运行流程，使用参数以及方法策略 https://juejin.im/entry/59b232ee6fb9a0248d25139a#%E6%80%BB%E7%BB%93 线程池中的线程包装成工作线程Worker放在HashSet中，Worder继承AQS实现了不可重入锁，Worker的run方法是for循环一直take队列中的runable对象执行 运行流程： 1）如果运行的线程小于corePollsize，则创建核心线程，即使其他是空闲的。 2）当线程池中线程数量&gt;corePollsize，判断缓冲队列是否满，没满放入队列，等待线程空闲执行。 如果队列满了，判断是否达到最大线程数，没达到创建新线程，如果达到了，执行拒绝策略。 只有当workQueue满才去创建新线程处理任务 ！！先判断队列再判断最大线程数 3）如果没有空闲，任务封装成Work对象放到等待队列 4) 如果队列满了，用handler指定的策略 （5种） ctl 状态值（高3位）和有效线程数（29位） 线程池的状态： RUNNING： 能接受提交 SHUTDOWN: 不能提交，但是能处理。 STOP： 不接受提交也不处理 TIDYING： 所有任务都已经终止 有效线程数为0 TERMINATED： 标识 一共有5种线程池： 1）fixed 无界队列缓冲队列，适用于任务数量不均匀，内存压力不敏感，系统负载敏感。 只要线程个数比核心线程个数多并且当前空闲则回收 2）cached 核心0，最大INT_MAX,缓冲队列：synchronousQueue只要没有空闲线程就会新建（没有队列缓冲）不限制线程数，低延迟短期任务。处理大量短时间工作任务 长期闲置的时候不会消耗资源 3）sigle 1个线程，异步执行，保证顺序执行多个任务 4）scheduled 定时、周期工作调度 最大线程数是Integer.MAX_VALUE， 空闲工作线程生存时间是0， 阻塞队列是DelayedWorkQueue，是堆 按延迟时间获取任务的优先级 ScheduledFutureTask实现了Comparable接口，是按照任务执行的时间来倒叙排序的 5）newWrokStealingPoll 工作窃取，固定并行度的多任务队列，适合任务执行时长不均匀 6.如何优化线程池参数 1.核心线程数 2.最大线程数 3.4 线程的空闲时间（可以通过allowcorethreadtimeout方法允许核心线程回收） 5 缓冲队列ArrayBlockingQueue 有界队列 LinkedBlockingQueue 无界队列 SynchronousQueue 同步队列没有缓冲区 6.线程工厂方法，用于定制线程的属性 例如线程的group，线程名 优先级 7.线程池满时的拒绝策略4种Abourt异常（默认） Discard 抛弃 callerruns 提交者执行 discardoldest 丢弃最早 怎么配置参数 7.线程同步的方法 1.CAS 2.synchronize 3.Lock synchronize 可重入 对象头 Monitor(管程) 分三块：entry set，owner,wait set https://blog.csdn.net/javazejian/article/details/72828483 正确说法：给调用该方法的【对象】加锁。在一个方法调用结束之前，其他线程无法得到这个对象的控制权。 方法同步通过ACC_SYNCHRONIZED 代码块同步通过monitorenter monitorexit 缺点：只能实现方法级别的排他性，不能保证业务层面（多个方法）。 Synchronized的锁优化机制 JVM提供了3种Monitor实现：偏向锁、轻量级锁、重量级锁 偏向锁（默认）：优先同一线程获取锁，JVM在对象头上Mark word设置线程ID，用CAS操作。 轻量级锁:有另外线程试图锁定已经偏向锁的对象，JVMrevoke撤销偏向锁。 如果失败，短暂自旋。轻量级锁用CAS试图获得锁操作Mark Work，如果成功就轻量级锁，如果失败重量级锁。 notify和wait notify方法调用后不会释放锁！ 放置在sychronized作用域中，wait会释放synchronized关联的锁阻塞， 实现存库为1的生产者消费者。 wait和sleep的不同 1.wait是object类，sleep是thread类 2.wait会释放对象锁，sleep不会 3.wait需要在同步块中使用，sleep可以在任何地方使用 4.sleep要捕获异常，wait不需要 join 方法 join(long millis) 获取t2的对象锁， 判断t2是否alive， 放弃对t2的锁,将当前t3放入t2的【等待池】中， 等待t2notify，一个线程结束后会调用notifyAll， 被notify后会进入t2的锁池等待竞争锁 wait(0)是一直等待 Thread t3 = new Thread(new Runnable() { @Override public void run() { try { // 引用t2线程，等待t2线程执行完 t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;t3&quot;); } }); 如果没有判断isAlive,join的线程根本没启动会永远等待下去 10.1信号量 Semaphore ： 管理多线程竞争 例子：100个线程抢10个数据库连接。 10.2 Condition ： 线程通信 多个阻塞队列线程间通信 目的：Condition 可以在多线程中创建多个阻塞队列。 例子1：实现 【仓库数量&gt;1】 的生产者消费者： 将生产者和消费者放入不同的阻塞队列，精准控制。 生产者判断full满就阻塞，加入商品后唤醒所有阻塞empty的消费者线程。 Condition 1）由Lock对象生成 2）await 会释放锁，阻塞。 signal能唤醒。 wait和notify只能建立一个阻塞队列。 10.3锁 Lock ReentreantLock 1）可中断 2）可定时轮询 3）锁分段，每个链表节点用一个独立的锁，多线程能对链表的不同部分操作。 4）公平性/非公平性 5）tryLock，得不到锁立即返回 读写锁 适合读并发多写并发少，读不用互斥另一个方法是copyonwrite Sync继承AQS， 公平锁新来的线程有没有可能比同步队列中等待的线程更早获得锁。 5）可重入Thread.currentThread() 可重入是如何实现的？ 6)业务锁 同一个账户的存钱、取钱业务应该先完整完成一次后才释放锁。 Lock可以跨方法锁对象：登录加锁，登出释放。 tryLock如果获取锁失败会立刻返回 false，不会阻塞。 读写锁 降级：获得写入锁能不能不释放获得读取锁。 升级：一般不支持，因为两个读线程同时升级为写入锁，会死锁。 非公平锁（默认）：写线程降级为读线程可以，不能从读线程升级为写。 公平锁:如果读线程持有，写线程请求，其他读线程都不能去锁，直到写完。 用处：包装map、linkedhashmap等，在put前后上写锁，get上读锁。 StampedLock 使用CLH的乐观锁 防止写饥饿 1.8新加。是单独的类型，不可重入，锁不是持有线程为单位的。 问题：读写锁使得读和读可以完全并发，但是读锁会完全阻塞写锁。 思路：试着先修改，然后通过validate方法确认是否进入了写模式，如果进入，则尝试获取读锁。 读操作不需要等写操作完。 StampedLock 是乐观锁， 写锁long stamp = .writeLock，.unlockWrite 读锁long stamp = .tryOptimisticRead() ， .validate(stamp) .unlockRead(stamp 还可以强行时候悲观读 实现：基于CLH锁：自旋锁，维护一个等待队列，保证没有饥饿并且FIFO。用一个volatile long表示写锁、当前正在读取的线程数量。 8.JMM java内存模型 线程工作内存，保存主内存副本拷贝。线程对变量的所有读取、赋值都必须在工作内存完成，不能直接读写主内存变量。 处理并发过程中的**原子性、可见性、有序性。 volatile变量定义了8种操作顺序的规则，能保证代码执行的顺序与程序顺序相同。保证long和double不被拆分。 定义了8个happen before原则 1）单线程控制流程序次序 2）管程 3）volatile 4）线程启动、5终止、6中断 7）对象finalize 8）传递性 为什么要padding cache伪共享：多个线程读写同一个缓存行，volitale变量无关但是多个线程之间仍然要同步。 把热点数据隔离在不同的缓存行 8个原子操作 主内存变量线程独占： 1）lock 线程独占， 同个线程可以lock多次，会清空工作内存中这个变量的值执行引擎use前要load assign 2）unlock 释放，之前会同步回主存 主内存-&gt;工作内存： 3）read 从主内存读入工作内存 4）load 将read的变量存入工作内存的变量副本 工作变量和执行引擎： 5）use 工作内存变量传递给执行引擎 6）assign 执行引擎赋值给工作变量 工作内存-&gt;主内存 7）store 工作内存传入主内存 8）write 将store的值放入主内存 9.快速失败fail-fast 和 安全失败 fail-safe 快速失败：迭代器遍历过程中，集合对象修改会改modCount，和expected不一样，报错。java.util包下的集合类都是 快速失败的。 安全失败：遍历是先拷贝在遍历。遍历过程中的修改不会影响迭代器，不会报错。java.util.concurrent包下都是安全失败。 ThreadLocal 使用弱引用的Map保存变量 线程数据隔离 LinkedBlockingQueue 直接交接队列SynchronousQueue不使用缓存，没有空闲线程就开线程，需要限定好线程池最大数量。 atomic 9.redis 1.redis高性能的原因 1）内存 2）单线程 3）网络请求io单进程多路复用 “多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 2.redis持久化 持久化方式： 1）快照 Mysql Dump和Redis RDB 2）写日志 Mysql Binlog Hbase Hlog Redis AOF RDB是保存数据库中的键值对，AOF保存redis执行的命令。 RDB RDB是压缩过的二进制文件,会生成临时文件，把老的RDB文件替换掉。 BGSAVE不会阻塞服务器进程，会创建子进程创建RBD文件。copy-on-write策略，但是父进程写入还会做副本 内存开销大。 触发机制：从节点全量复制主节点会生成RDB文件。 debug reload 、 shutdown。 缺点磁盘性能，宕机没快照的丢了。但是恢复速度快。 AOF AOF更新频率通常比RDB高。 写【命令】先从redis 写到硬盘缓冲区 再根据3种策略（everysec每秒，always，no（操作系统自己刷)）fsync到硬盘AOF文件。 AOF会开子进程重写。 redis主从复制 数据是单向的。可以通过slaveof 或者配置方式slave-read-only yes实现。 进入redis用info replication可以查看主从状态 老版本当从节点slaveof之后发送PSYNC，并发送自己的ID 主节点bgsave向从节点发送rdb文件，设置offset， 将偏移量之后的数据存在定长有界队列【积压缓冲区1M】中，一个字节一个offset。 从节点发送offset给主节点继续从缓冲区同步。 之后命令传播。 主从复制（副本）集群是为了解决多请求，读写分离，高可用， 分布式是为了解决一个请求的多个步骤。 redis主从同步的问题 master挂了，从节点全部得全量复制，复制风暴 redis集群一致性hash如何解决分布不均匀 全量复制 1）第一次是全量复制full resync master会BGSAVE。 2）从节点的数据全部清除Flushing old data，通过网络接受RDB文件，加载RDB文件到内存。 info server |grep run 3）在同步期间master的写命令会单独记录，rdb同步完后通过偏移同步给slave。 可以看到redis实例的run_id。如果从复制的主节点的id发生变化，则需要全量复制。 部分复制 info replication 可以看到master的偏移量master_repl_offset和slave的偏移量slave_repl_offset，主节点可以看到各个从节点的偏移量。 偏移量主比从大表示主写入了数据还没同步到从。 如果主从连接断了，先重连，从服务器发送runid和offset，主服务器发送buffer中的部分数据。 redis 高可用 sentinel redis写失败怎么办 更新数据库，缓存删除失败 方法1： 将需要删除的key发送到消息队列，发送给自己，继续消费，重新向redis删除。 方法2： 订阅数据库binlog （2）数据库会将操作信息写入binlog日志当中 （3）订阅程序提取出所需要的数据以及key （4）另起一段非业务代码，获得该信息 （5）尝试删除缓存操作，发现删除失败 （6）将这些信息发送至消息队列 （7）重新从消息队列中获得该数据，重试操作。 mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能 软工和测试 白盒测试是什么 怎么评价一个软件系统的好坏 java的进程通信 管道 Java中没有命名管道 // 启动子进程 ProcessBuilder pb = new ProcessBuilder(&quot;java&quot;, &quot;com.test.process.T3&quot;); Process p = pb.start(); // 或者 Runtime rt = Runtime.getRuntime(); Process process = rt.exec(&quot;java com.test.process.T3&quot;); // 子进程的输出 BufferedInputStream in = new BufferedInputStream(p.getInputStream()); 共享内存 nio有内存映射文件mmap https://cloud.tencent.com/developer/article/1031860 RandomAccessFile raf = new RandomAccessFile(&quot;D:/a.txt&quot;, &quot;rw&quot;); FileChannel fc = raf.getChannel(); // 核心 系统调用mmap MappedByteBuffer mbb = fc.map(MapMode.READ_WRITE, 0, 1024); FileLock fl = fc.lock();//文件锁 mmap和共享文件的区别 操作系统划分出一块内存来共多个进程共享使用 mmap需要把内容写回到文件，所以还需要与文件打交道；而SM则是完全的内存操作，不涉及文件IO，效率上可能会好很多。还有就是SM使用的系统调用是shmget和shmctl。 FileChannel 是将共享内存和磁盘文件建立联系的文件通道类。 信号 OperateSignal operateSignalHandler = new OperateSignal(); Signal sig = new Signal(&quot;SEGV&quot;);//SEGV 这个linux和window不同 Signal.handle(sig, operateSignalHandler); public class OperateSignal implements SignalHandler{ @Override public void handle(Signal arg0) { System.out.println(&quot;信号接收&quot;); } } 线程池 参数，常用的 callable 11.C++虚函数作用及底层实现 虚函数是使用虚函数表和虚函数表指针实现的。 虚函数表：一个类 的 虚函数 的 地址表：用于索引类本身及其父类的虚函数地址，如果子类重写，则会替换成子类虚函数地址。 虚函数表指针： 存在于每个对象中，指向对象所在类的虚函数表的地址。 多继承：存在多个虚函数表指针。 12.千万数据的表怎么优化 表设计： SQL优化： 1）超过500w要分表 数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分 水平切分的实现： Merge存储引擎允许将一组使用MyISAM存储引擎的并且表结构相同（即每张表的字段顺序、字段名称、字段类型、索引定义的顺序及其定义的方式必须相同）的数据表合并为一个表，方便了数据的查询。 CREATE TABLE log_merge( dt DATETIME NOT NULL, info VARCHAR(100) NOT NULL, INDEX(dt) ) ENGINE = MERGE UNION = (log_2004, log_2005, log_2006, log_2007) INSERT_METHOD = LAST; 2）Explain 索引设置 3）减少查询列 应用层优化 4）减少返回的行 limit 5）拆分大的delete和insert，不然会一次锁住很多数据 sql优化 计算两点距离 100公里以内的餐馆，不要查询圆，查询方形 两个between，如果第一列是范围查询，无法索引后面的列，所以只能索引第一个列。 13. 15.基于比较的算法的最优时间复杂度是O(nlog(n)) 因为n个数字全排列是n! 一次比较之后，两个元素顺序确定，排列数为 n!/2! 总的复杂度是O(log(n!)) 根据斯特林公式就等于O(nlog(n)) 18 没有中序没办法确定二叉树 前序 根左右 后序 左右根 找不到左右的边界 19 redis动态字符串sds的优缺点 结构：1）len 2）free 3）buf数组 优点 1）以\0结尾，可以复用c string的库函数。 2）O(1)复杂度获取长度 3) 杜绝缓冲区溢出 （c如果没分配够空间就直接覆盖了) 4) 减少内存重分配（空间预分配和惰性空间释放） 5）二进制安全（可以存图片等特殊格式），c字符串中不能包含空字符。 20 数据库三范式 目的：减少冗余、插入删除更新异常 第一范式：列不可拆分 目的：列原子性 第二范式：每个属性要【完全依赖】于主键，如果主键有多个候选键，属性 第三范式：非主键关键字段之间不能存在依赖关系，避免更新、插入、删除异常。每一列都要与主键直接相关。【消除传递依赖】。 例子： 各种信息只在一个地方存储，不出现在多张表中。 如果成员表已经有部门编号，不应该有部门表中的部门名称。 BCNF：表的部分主键依赖于非主键部分 应该拆分。 第四范式：两个均是1：N的关系，当出现在一张表的时候，会出现大量的冗余。所以就我们需要分解它，减少冗余。 20 数据库 5约束 主键约束PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。 唯一约束UNIQUE 默认值约束DEFAULT 非空约束NOT NULL 外键约束FOREIGN KEY CHECK （CHECK (P_Id&gt;0)） 20 自然连接 NATURAL JOIN columns with the same name of associate tables will appear once only. 自然连接是指关系R和S在所有公共属性(common attribute)上的等接(Equijoin). 但在得到的结果中公共属性只保留一次, 其余删除. 控制文件：Oracle服务器在启动期间用来标识物理文件和数据库结构的二进制文件 21 内存溢出OOM和内存泄漏memory leak jstat 22 四种引用类型 强引用，软引用，弱引用，虚引用 软引用：内存不够二次回收 弱引用：回收 弱引用应用：优惠券 WeakHashMap&lt;Coupan, &lt;List&lt;WeakReference &lt;User&gt;&gt;&gt; weakCoupanHM.put(coupan1,weakUserList); 当某个优惠券（假设对应于coupan2对象）失效时，我们可以从coupanList里去除该对象，coupan2上就没有强引用了，只有weakCoupanHM对该对象还有个弱引用，这样coupan2对象能在下次垃圾回收时被回收，从而weakCoupanHM里就看不到了。 当某个用户（假设user1）注销账号时，它会被从List类型的userList对象中被移除。 虚引用：要和引用队列一起使用，用于跟踪垃圾回收的过程 23 Java线程状态 6种 New， Runnable， Timed Waiting， Waiting，Blocked，Terminated 创建线程 new状态 调用start方法后j进入Runnable状态，不能马上运行，要先进入就绪状态等待线程调度（Ready），获取到CPU后到Running状态 如果运行中获取锁失败Blocked状态，获取到后再变成就绪状态 调用Thread.join 或者LockSupport.park方法会进入Waiting可以通过notify或者unpark回到就绪状态。 24 生产者消费者问题（消费的是同一个东西） 1个互斥2个同步 P表示-1，V表示+1 事件关系： 1）互斥：缓冲区是临界资源，需要互斥访问 2）同步：缓冲区满，生产者等待消费者取 （先后顺序） 3）同步：缓冲区空，消费者等生产者生产 （先后） 信号量机制：一个关系一个信号量 1）互斥信号量初始化为1 2）缓冲区同步的信号量根据系统资源初始值设定 1）生产者：空闲缓冲区数量 信号量初始值empty = n 2）消费者：缓冲区产品数量 初始值full = 0 互斥信号量是在同一个进程之间操作的。 一前一后同步关系 ，两个信号量的PV操作在不同的进程 生产者： product(){ while(1){ P(empty) P(mutex) //放入缓冲区 V(mutex) V(full) } } custom(){ while(1){ P(full) P(mutex) // 取出 V(mutex) V(empty) } } 注意点： 1）对于P操作 一定要先操作同步信号量再操作互斥信号量，不然互斥加锁然后同步阻塞 循环等待 就死锁了。 V操作顺序无所谓 2）生产和使用操作不要放到PV操作（临界区）里面，时间太多 25 多生产者 多消费者 （一个临界区，但是生产者和消费者有特定类型） 例子：只有一个盘子，父亲-儿子之间生产-消费 苹果，母亲-女儿之间生产-消费 橘子 关系： 1）互斥：盘子 2）同步：父亲儿子 消费-生产 3）同步：母亲女儿 消费-生产 4）同步：盘子空（事件） 之后 放入水果 事件信号量： 1）互斥1 2）盘子中的苹果 0 3) 盘子中的橘子 0 4）盘子中的剩余空间 1 注意： 1）如果盘子资源为1，不用加互斥，剩余空间就可以用来互斥了 2）如果盘子资源为2以上，不加互斥会数据覆盖 26 读者-写者问题 count计数器 1）允许多个读 2）只许一个写 3）完成写之前不允许读/写 4）写之前要没有读/写操作 关系： 1）互斥：写-写 2）互斥：写-读（第一个读进程要对文件加锁）(最后一个进程解锁) 信号量： 1）互斥 是否有进程在访问文件 semaphore rw = 1 2) 当前有几个读进程在访问 int count = 0 3）互斥count：隐藏3 mutex = 1 因为判断是不是第一个和计数不原子，所以判断+增加要加锁 问题：实际上是读优先。读进程太多会导致写进程饿死 改进：用信号量semaphore w = 1; semaphore rw = 1 // 文件互斥 int count = 0 // 读进程计数 semaphore mutex = 1 // count计数互斥 semaphore w = 1 // 写进程优先 writer(){ while(1){ P(w) P(rw) // 写文件 V(rw) V(w) } } reader(){ while(1){ // 如果前一个读执行到释放w后， // w会被写抢走，下一个读会等待写完成 P(w) // 用于count互斥访问 P(mutex) if(count == 0) P(rw) count++ V(mutex) // 写会抢走 V(w) P(mutex) count-- if(count == 0) V(rw) V(mutex) } } 不是疯狂写优先。是读写公平的。先来先服务的。 27 哲学家问题 两个临界资源 防止死锁 5个哲学家 5个筷子 拿起左然后右吃饭 方法1：只允许4个人吃饭(初始值为4的信号量) 方法2：奇数号的先拿左边，偶数号的先拿右边 方法3：用一个信号量同时对拿左边拿右边加锁 28 银行家算法（避免死锁） 安全序列 不会死锁 手里有100亿钱，A要最多借70，B最多借40，C最多借50，借完了就会全部还回来。现在已经分别借了ABC一些，ABC其中一个再发起了一个请求，应不应该借？ 银行家算法：每次分配资源之前，判断是否会进入不安全状态（可能会产生死锁（没钱借又拿不会钱） 找安全序列： 用剩余资源 遍历所有进程 还需资源，如果可以分配，则分配+拿回全部资源+加入安全序列+从遍历中移除，再从头遍历所有进程。 31 页面置换算法 OPT：知道后面会访问什么。向之后看，之后最后出现/没出现的的先删除 缺页中断 页面置换（满了才换） 缺页率：缺页次数/请求次数 FIFO：Belady异常。 LRU：如果满了，将内存块中的数值向前找，最早出现的那个删除。 CLOCK：时钟置换算法，NRU最近未用算法。 循环队列。 访问位。 问题 LRU：出现一次冷数据批量查询，误淘汰大量热点数据 LFU：起始频率值低，导致最近新加入的数据总会很容易被剔除 FIFO：特殊领域：作业调度、消息队列 33 ajax的四个步骤 1)创建xhr对象 2)open方法参数：method，url，同步或异步 3)send 4)注册一个监听器onreadystatechange readyState=4和status200 获得响应.responseText 34 XSS攻击，跨站脚本攻击 网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些恶意的脚本代码（HTML、JavaScript）到Web页面中去，使别的用户访问都会执行相应的嵌入代码。 解决方法： 1）cookie设置成http Only 不让前端document.cookie拿到 2）对输入多做一些检查 对 html危险字符转义 CSRF 盗取用户cookie或者session伪造请求 1)每次提交加随机数token 2）检查referer 35 防止表单重复提交 1）submit方法最后把按钮disable掉 2）用token 3）重定向 38 IO模型 阻塞和非阻塞： 阻塞IO：等待数据（收到一个完整的TCP包）和系统内核拷贝到用户内核都阻塞了。 非阻塞IO：内核数据没准备好直接返回错误，需要轮询。 非阻塞IO需要和IO通知机制一起使用。 I/O通知机制：1） I/O复用函数【向内核注册一组事件】，内核通过I/O复用函数把就绪事件通知给应用程序。 I/O复用函数本身是阻塞的，可以同时监听多个I/O事件。 2）SIGIO信号。 accept()为什么会阻塞？ 即使用多线程，serverSocket.accept()询问操作系统的客户端连接accept()还是单线程的，系统级别的【同步】网络I/O模型。 阻塞，非阻塞是程序级别的，同步非同步时操作系统级别的。 多路复用IO模型：操作系统在一个端口上同时接受多个客户端I/O事件。 事件驱动IO。select阻塞轮询所有socket，可以同时处理多个连接，（连接数不高的话不一定比多线程阻塞IO好）优势不在于单个连接处理更快，在于能处理更多的连接。而且单线程执行，事件探测和事件响应在一起。 以上三个都属于同步IO，都会阻塞进程。 select/poll/epoll都需要等待读写时间就绪后读写，异步IO会把数据从内核拷贝到用户。 epoll是根据每个fd上面的callback函数实现的。而且有mmap内核空间和用户空间同处一块内存空间。 如何理解 nio是同步非阻塞 边缘触发和水平触发 边缘触发：只能处理非阻塞套接字，如果没有处理完缓冲区，这个套接字没有心事件，无法再次从epoll_wait调用中再次获取这个事件。 如果没有彻底将缓冲区数据处理完，会导致缓冲区中的用户请求得不到相应。 水平触发：可以处理非阻塞和阻塞的套接字，一个事件的缓冲区还有数据，就可以epoll_wait获取这个事件。 https://www.jianshu.com/p/7835726dc78b ET边缘触发：即使有数据可读,但是没有新的IO活动到来,epoll也不会立即返回. epoll默认是LT水平触发 Level信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发 Epoll事件分派接口可以表现为边沿前触发 (ET)和 水平触发(LT).这两个机制之间的区别可以描述如下。 ET模式只有在被监控文件描述符发生变化时才递交事件 同步和异步 事件处理模式 Reactor模式实现同步I/O，处理I/O操作的依旧是产生I/O的程序 异步I/O 订阅-通知：立即返回，内核完成数据准备+拷贝数据之后发送给用户进程一个信号。 Proactor实现异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。 异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。 39异常 Error 和 Exception的区别 1）Error是JVM负责的 2）RuntimeException 是程序负责的 3）checked Exception 是编译器负责的 异常处理机制： 在堆上创建异常 try catch中有return之前都会先执行finally的return java进程间通信 java 线程通信：wait notify，共享变量的synchronize，Lock同步机制 全局变量 2个线程之间的单向数据连接 NIO pipe 写sink 读source。 java线程同步的方法 41 什么时候对象会被回收？如果互相引用 http://blog.jobbole.com/109170/ 强引用=null 引用计数算法 无法解决互相引用的情况。 所以用的是 可达性分析算法：判断对象的引用链是否可达。 如果循环引用，没有人指向这个环也会被回收。 从GC root（栈中的本地变量表中的对象、类（方法区）常量、静态属性保存的是对象……） JIT编译时会在安全点记录下很多OopMap(一个对象内 偏移量：类型数据)压缩在内存中。 GC的时候扫描对应偏移量 类回收： ClassLoader已经被回收，Class对象没有引用，所有实例被回收。 资源管理，如果数据库连接对象被收回，但是没有调用close，数据库连接的资源不会释放，数据库连接就少一个了，要放在try()里。 full GC 1）System.gc()方法的调用 2）老年代空间 3）Minor GC后超过老年代可用空间 45 布隆过滤器 黑名单 如果数据量有8G，hash冗余要保证16G 构造：使用16/8 = 2G 可以表示16G个bit位。 set：用8个随机函数，得到0-16G中8个随机数，并将这8位设置为1。 get：同样用这8个随机函数，查看这8位是否都为1。 46 精确的接口限流。 /禁止重复提交：用户提交之后按钮置灰，禁止重复提交 如果做到精确5秒里只能访问10次 漏桶法 流量整形 个固定容量的漏桶，按照常量固定速率流出水滴 令牌桶（对业务的峰值有一定容忍度） 固定容量令牌的桶，按照固定速率往桶里添加令牌 前端做还是后台做 大数据相关的 47 linux 怎么查询一个端口 48 操作系统 进程通信 进程和线程的区别 1）地址空间 线程的内存描述符 将直接指向 父进程的内存描述符 ，打开的资源 2）通信，全局变量：线程通信要加锁 3）调度和切换：切换快。 4）进程不是可执行的实体 文件是进程创建的信息逻辑单元 每个进程有专用的线程表跟踪进程中的线程。和内核中的进程表类似。 进程结构：代码段、数据段、堆栈段 代码段：多个进程运行同一个程序，可以使用同一个代码段。 数据段：全局变量、常量、静态变量。 栈：用于存放 【函数调用】，存放函数的 【参数】，函数内部的【局部变量】 PCB位于核心堆栈的底部。 进程组ID是一个进程的必备属性。 子进程： 当调用fork时，子进程完全复制了父进程地址空间的内容，包括：堆、栈、数据段，并和父进程共享代码段，因为代码段是只读的，不会被修改。 在Linux上，对于多进程，子进程继承了父进程的下列哪些？ A 进程地址空间 B 共享内存 C 信号掩码 D 已打开的文件描述符 E 以上都不是 子进程对数据段和堆、栈段的修改不会影响父进程。 “写时复制”：现在fork不会立刻复制，当子进程要修改的时候才会分配进程空间 并复制。 创建一个守护进程 java守护线程JVM的垃圾回收、内存管理等线程都是守护线程。 Main退出，前台线程执行完毕，后台线程也直接结束了。生命周期 终端：系统与用户交互的界面，运行进程的终端被称为 【控制终端】。 控制终端关闭时，进程都会关闭，除了守护进程。 1）fork()一个子进程并退出父进程。 子进程拷贝了父进程的 【会话期、进程组、控制终端、工作目录、父进程的权限掩码、打开的文件描述符】。 2）在子进程中创建会话setid()让进程摆脱1）原会话2）进程组3）控制终端 的控制。 3）工作目录换成根目录chdir("/") 4）文件权限掩码设置成0 umask(0) 5）关闭所有打开的文件描述符 僵尸进程 子进程退出，父进程没有调用wait，子进程的进程描述符仍然在系统中。父进程应该调用wait取得子进程的终止状态。 如果父进程退出，僵尸进程变成孤儿进程给init（1）进程，init会周期性调用wait清除僵尸进程。 49 线程之间什么是共享的 1）地址空间2）全局变量3）打开文件4）子进程5）即将发生的定时器6）信号与信号处理程序6）账户信息 线程试图实现：共享同一组资源的多个线程的执行能力 50 栈为什么要线程独立 一个栈帧只有最下方的可以被读写，处于工作状态，为了实现多线程，必须绕开栈的限制。 每个线程创建一个新栈。多个栈用空白区域隔开，以备增长。 每个线程的栈有一帧，供各个被调用但是还没有从中返回的过程使用。 该栈帧存放了相应过程的局部变量、方法参数、过程调用完成后的返回地址，线程私有不共享。 例如X调用Y，Y调用Z， 执行Z时，X和Y和X使用的栈帧会全部保存在堆栈中。 每个线程有一个各自不同的执行历史。 栈内存分配运算内置于处理器的指令集中，效率很高 运行时在模块入口时，数据区需求是确定的。 栈是编译器可以管理创建和释放的内容，堆需要GC 栈很少有碎片 静态全局变量、静态局部变量 https://blog.csdn.net/hushpe/article/details/45396059 static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 1.全局变量：源程序作用域。 所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问extern 2.静态全局变量：文件作用域。 如果加了static，就会对其它源文件隐藏。不能用extern导出。 例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心【命名冲突】。 全局变量、静态全局变量存储在静态数据区。只有程序刚开始运行时唯一一次初始化。 3.静态局部变量：static局部变量只被初始化一次，下一次依据上一次结果值。 ！！！ 单例模式！！！ 作用域：作用域（可见性）仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。 class Singleton { private: Singleton(){} Singleton(const Singleton &amp;s); Singleton &amp; operator = (const Singleton &amp;s); public: static Singleton * GetInstance() { static Singleton instance; //局部静态变量 return &amp;instance; } }; 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 局部变量改变为静态变量后是改变了它的存储方式即改变了它的【生存期】。 把全局变量改变为静态变量后是改变了它的【作用域】，限制了它的使用范围。 4.static函数作用域只在本文件 从原来的栈中存放改为【静态存储区】。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件. 静态存储区：内存在程序编译的时候就已经分配好 已经初始化过的全局变量在.data段，而未初始化的全局变量在.bss段。 .bss段不占用可执行文件的大小，而是在加载程序的时候由操作系统自动分配并初始化为0 目标文件 用于二进制文件、可执行文件、目标代码、共享库和核心转储 的标准文件格式。 分为3种： 1）可重定位的目标文件 .o文件 .a静态库文件 未链接 可以经过链接生成可执行的目标文件和可被共享的目标文件。 没有程序进入点。 2）可执行的目标文件 链接处理之后的 3）可【共享】的目标文件 .so。 动态库文件。 java static static方法不能被覆盖override：因为方法覆盖是运行时动态绑定的，static是编译时静态绑定的。 Hashtable 和 HashMap的区别 Hashtable不允许键或者值是null hashMap线程不安全，遍历的时候会有环死循环 Hashtable 不能支持符合操作：若不存在则添加、若存在则删除，即使单个方法加锁，符合方法也线程不安全。 currentHashMap cas无锁，不涉及上下文切换效率高。 1.7版本分为16个segment分段锁，允许16个线程同时读写操作不同的段。 ArrayList 每次扩容1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 线程不安全，扩容的时候会发生数组越界 LinkedList LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用. Comparable和Comparator接口 区别 Comparable 是该类支持排序 实例具有内在的排序关系 不能跨越不同类型的对象比较 Comparator 是外部比较器，需要一个非标准的排序关系。有多个域，按不同的域排序。加了很多default方法。 Enumeration接口和Iterator接口 的区别 Enumeration快 Iterator允许调用者删除底层集合里面的元素 finalize 方法 JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 任何对象的finalize只会被调用一次 final finally finalize的区别 Exception和Error的区别 事务是什么 数据库并发控制的基本单位。 一个类里面有两个方法A和B，方法A有@Transaction，B没有，但B调用了A，外界调用B会不会触发事务？ 51ThreadPoolExecutor 怎么实现的 1）线程池状态 ExecutorService 源码 52 Java多继承 https://juejin.im/post/5a903ef96fb9a063435ef0c8#heading-1 内部类:每个内部类都能独立地继承自一个（接口的）实现，内部类允许继承多个非接口类型. socket编程 mq有几种模式 Binding:Exchange和Queue的虚拟连接 接口和抽象类的区别 抽象类里面能不能有非抽象方法 能不能被重写 String不能被继承 重写和重载的区别 53 sb依赖注入控制反转。 IOC:控制反转 控制：Java Bean的生命周期（创建、销毁） 反转：容器管理依赖关系。 IOC是一种设计模式。将对象-对象关系解耦和对象-IOC容器-对象关系。容器管理依赖关系。依赖对象的获得被反转了。调用者不用创建被调用的实例，容器管理单例对象。 IOC的实现方式： 1)设置注入/属性注入setter方法元素 2）构造器注入 3）工厂方法注入 依赖注入DI方式:把底层类作为参数传递给上层类，实现上层对下层的“控制”。 setter、接口、构造函数。 组件之间依赖关系由容器在运行期决定。 SpringBoot Autowired是自动注入，自动从spring的上下文找到合适的bean来注入 IOC容器初始化 1）Resource定位 2）载入：把定义的Bean表示成IOC的数据结构（不包括Bean依赖注入） 3）注册到容器的HashMap中 IOC容器通过和注解配置(Controller) 1）IOC容器就是ApplicationContext 可以通过web.xml或者加载xml或者文件用application-context.xml初始化。 2）定义bean 然后getBean()就获取了对象可以调用方法了 bean的作用域6种 默认是单例，多次getBean是同一个。prototype每次都是新的。 bean有创建和销毁的回调函数。 3）如果要用两个类的组合，一个类里需要new另一个类，这样那个类的构造参数都需要在这个类里面改，这样强耦合。所以这个外部对象应该用构造函数（强依赖）/setter（可选依赖（可配置的（颜色）））等方法注入。 通过配置文件的方法，注入依赖的参数。 Springboot的启动流程 tomcat的启动流程 Spring 怎么解决循环引用 构造器循环依赖：通过使用bean创建时的标识值 setter循环依赖：通过引入objectfactory解决 Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。 /** Cache of singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256); /** Cache of singleton factories: bean name --&gt; ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16); /** Cache of early singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); singletonFactories ： 单例对象工厂的cache earlySingletonObjects ：提前暴光的单例对象的Cache singletonObjects：单例对象的cache AOP 面向切面编程 关注点分离，抽离业务逻辑 知识图谱 之间的关系 和结构存储neo4j vue的特点 和react的比较 54 前后端跨域怎么实现 浏览器的同源策略导致了跨域。 1)JSONP 但是只能直接发get请求&lt;script src="http://127.0.0.1:8897"&gt;&lt;script&gt; 2)Access-Control-Allow-Origin':'*' 3)nginx反向代理 XSS 跨站脚本攻击：篡改网页，注入恶意html脚本。 CSRF 跨站请求伪造（利用用户登陆态） Cookie的 SameSite属性strict 55 cookies 1) 存储 浏览器的cookie数据库中 2）服务器产生 3）会威胁客户隐私 4）用于跟踪用户访问和状态 cookie有两种:会话cookie（退出浏览器删除， 没设置discard或者expires 或者max-age） 持久cookie cookie的实现 cookie加密 原本需要由web服务器创建会话的过程转交给Spring-Session进行创建，本来创建的会话保存在Web服务器内存中，通过Spring-Session创建的会话信息可以保存第三方的服务中，如：redis,mysql等 redis string redis redis常用数据结构 string, hash,set,sorted set,list redis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; (integer) 2 redis&gt; GEODIST Sicily Palermo Catania &quot;166274.1516&quot; redis&gt; GEORADIUS Sicily 15 37 100 km 1) &quot;Catania&quot; redis&gt; GEORADIUS Sicily 15 37 200 km 1) &quot;Palermo&quot; 2) &quot;Catania&quot; redis&gt; redis 有序集合 skiplist和dict会共享元素的成员和分值。 zset中的dict创建了一个从成员到分值的映射，程序可用O(1)的时间查找到【分值】(zscore)。 跳跃表实现zrank,zrange 还有查找全是logN 如果一个千万条数据的表怎么优化 数据库分片： 1）分片ID 2）无需分片的表 61 linux shell 如何传文件 scp 如何查进程 ps -ef |grep 如何在文件找查一个字符串 grep 'abc' abc.txt grep 'abc' abc* 从abc开头的文件查找 参数-o只输出正则匹配的部分 参数-v输出不含正则的内容 遍历文件夹查找所有文件中的一个字符串的所有行 grep -r "要查找的内容" ./ 文件夹大小： du -sh . 如果grep不带文件就等输入 echo不支持标准输入 如何查找一个文件 find默认是递归查找的 find ~ -name "abc.java sed 替换 awk 切片统计 终端 /dev/tty当前终端 vi： ZZ：命令模式下保存当前文件所做的修改后退出vi； 怎么调整top多久刷新，top间隔默认是多少 默认3秒 top -d 任务队列 和 CPU Load netstat 列出所有tcp端口 netstat -at 显示pid和进程名netstat -p 可以查看所有套接字的连接情况 top 可以查看到哪些指标 1： CPU 平均负载1min，5min,15min 在一段时间内CPU正在处理以及等待CPU处理的 【进程数】 之和。CPU使用队列的长度的统计信息。 2：进程、cpu状态、内存状态（系统内核控制的内存数） 打开的文件lsof 序列化的性能 短链接 特征模型 归并排序 多线程归并排序 线程上下文类加载器 JNDI服务，使用线程上下文加载器，父类加载器请求子类加载器完成类加载。 OSGi自定义加载器，程序模块和它的类加载器一起替换掉。 运行时字节码生成 动态代理 动态代理：原始类和接口还未知的时候就确定了代理类的代理行为。 代理类与原始类脱离直接联系后，可以用于不同的应用场景。 jvm以byte数组为单位拼接出 传入接口的每个方法的实现，并且调用外部传入this的invoke方法，的字节码文件。 RCU机制 http://blog.jobbole.com/107958/ 分布式锁 1）互斥性：保证不同节点的线程之间互斥2）同一个节点同一个线程可重入3）支持超时防死锁 for update悲观锁 大并发不建议 数据库是各个服务进程的临界资源。如果已经下订单了还没减库存，但是没加锁就会脏读。 乐观锁：因为查询加行锁开销比较大，用版本号，查询出版本号之后update或者delete的时候需要判断当前的版本号和刚才读的是否一致，这样就不用for update ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。 锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。 redis分布式锁 流程1）setnx(key,currenttime+timeout)2)expire(key)3)业务执行完后del(key) 其他tomcat获取不到锁返回0流程 1）get(key)判断当前时间和value的时间， 2)如果key超时了可以先get再setgetset(key,currenttime+timeout) 如果get的值是null或者和之前的锁一样（？）继续expire(key)走加锁流程&hellip; 面向对象和面向过程的区别 封装：隐藏内部代码 继承：复用现有代码 多态：改写对象行为 面向过程是结构化开发方法，面向数据流的开发方法，用数据流图建立系统的功能模型。自顶向下，逐层分解，适合数据处理领域，难以适应需求变化。每个模块确定输入输出。 结构化方法包括了：结构化分析SA，结构化设计SD（转换成软件体系结构图），结构化程序设计SPD 结构化设计包括：体系结构设计、数据设计、接口设计（内部和外部接口）、过程设计 面向对象：UML是标准建模语言。面向对象分析，面向对象设计、面向对象实现，界限不明显。 面向对象= 对象+分类+继承+消息通信 需求经常变化，但是客观世界的对象和对象与对象间的关系比较稳定，所以OO的结果也相对稳定。 完整表述现实世界的数据结构，表达数据间的嵌套、递归联系。 封装性和继承性提高了软件可重用性。 面向过程会导致结构体里出现不是本模块的成员 对象的产生方式有 1）原型对象(prototype 原型链)为基础的 （所有对象都是实例） 2）基于类（Java)的对象模型。 分布式文件系统HDFS 1）每个文件拆分成很多小块128M（并行处理和负载均衡）. 2）文件以多副本存储（副本因子），高可用。 3）有一个节点存储着存储信息 1个Master，NameNode。N个Slave DataNode。 NameNode：1）处理客户端请求 文件系统的读写操作 2）元素据 DataNode：1）块的存储和操作 2）定期心跳 分布式文件系统一致性 HDFS 文件只能写1次 除了 append和truncate 而且不能多并发写。 节点失效 为什么本地文件系统不使用hash 2.25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？ 5轮找出各组第一；5组第一跑一次，得出第一，只有前3的组可能是前3；最后一次A2, A3, B1, B2, C1参赛得出第二第三名。 13.100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？ topK问题 1.找出N个数中最小的K个数 大小为K的【大根堆】。好处，不用全部读入内存。时间复杂度NlogK 2.从N个有序数组/队列找到最小的K个值 用每个队列最小的元素组成一个N个元素的【小根堆】，获取堆顶，将堆顶这个元素的队列的下一个元素放入堆，重复，直到堆有K个数。 算法复杂度是（N+K-1）*logK 分布式 1）均衡负载技术 均衡负载的算法有：随机 round roubin 一致性hash 2）容灾设计 3）高可用系统 rpc通信 jsonrpc没法区分int和long 通信开销 加密和压缩 秒杀项目相关 https://mp.weixin.qq.com/s/ktq2UOvi5qI1FymWIgp8jw 秒杀项目的请求流程 需求：秒杀地址隐藏，记录订单，减库存 1.下订单和减库存如何保持一致？ ACID强一致性，利用关系型数据库的强一致性，【订单表和库存表】放在一个关系型数据库事务，实时一致性。 高并发场景提高关系型数据库吞吐量和存储，应该吧库存和订单放入同一个数据库分片。 主从复制只能提高数据库读。 BASE思想：分布式事务拆分，每个步骤都记录状态，使用【写前日志】或者数据库来记住任务的执行状态，一般通过行级锁实现比写前日志更快。 2.缓存与数据库一致性 读请求和写请求串行化，串到一个内存队列里去。串行化就不会不一致。 先更新数据库再删除缓存。 缓存更新的时候加锁 防止大量请求直接访问数据库雪崩或者缓存不一致 常用的缓存使用模式 Cache Aside 同时更新缓存和数据库， ！先更新数据库，【删除缓存】，下次使用会添加到缓存 这种模式不保证 数据库和cache的一致性！ 数据库中的数据可以随时被外部进程修改，但是cache不会变。 如果数据库是有备份的，经常同步问题会很严重。 出问题的场景只有并发读和写，读在写之前读到数据库，在写返回删除缓存之后，读请求返回写旧缓存。基本不可能发生。 可以通过2PC或者PAXOS保证一致性，实际操作还是设置过期时间。 （并发操作包装成一个事务？） 数据库被外部进程修改的场景： mysql读写分离： 如果先删除缓存，请求B从从库查询，但是还没完成主从同步，旧值写入缓存。 解决方案是 异步延迟删除，保证读请求完了再删除。 如果删除缓存失败！！cache中是旧数据。 1.失效时间 2.mq重试 3.二次删除效率低 解决方案还是binlog 各个应用实例一定要用同样的分布式缓存。 适用场景：数据是不变的，可以启动时预加载的 Read/Write Through： 先更新缓存，缓存负责同步更新数据库 读：Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。 写:当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作） 1 每次写缓存都更新 2 写缓冲，下一次写强制刷新 Write Behind Cacheing： linux文件系统的page cache 只更新缓存，缓存定期异步更新数据库 write-behind 缓存中，数据的读取和更新通过缓存进行，与 write-through 缓存不同，更新的数据并不会立即传到数据库。 相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到数据库中。 缓存会合并这些脏记录。只保证最后一次更新。 会出现一瞬间cpu负载变高 redis怎么保证缓存一致性 更新cache成功，更新数据库失败怎么办？强一致性，你需要使用“两阶段提交协议 3.更新数据库的同时为什么不是马上更新缓存而是删除缓存 更新数据库后更新缓存可能会因为多线程下导致写入脏数据（比如线程A先更新数据库成功，接下来要取更新缓存，接着线程B更新数据库，但B又更新了缓存，接着B的时间片用完了，线程A更新了缓存） （？） 4.缓存穿透：数据库中没这个数据，缓存中也没有，数据库被大量查询 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。 哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。 1）查询结果为空的也缓存(命中不高 但是频繁更新的数据) 2）对可能为空的key统一存放（命中不高 更新不频繁） 3）如果后面插入了新数据要删除相应缓存（或者设置较短超时时间） 缓存击穿 热点数据key过期，大量访问数据库 1）用分布式锁，保证只有一个线程从数据库拉取数据 2）后台异步脚本更新key过期时间 缓存雪崩 缓存不可用（宕机） 大量缓存key失效 多级缓存、随机超时、提高可用性 5.数据库乐观锁减库存 先查库存，在减库存的时候判断当前库存是否与读到的库存一样 乐观锁适用冲突少的情况，会导致大量回滚 死循环 cpu占用高 6.读写锁能不能用在大并发场景 7.为什么要把页面放到redis中？ 页面缓存，将整个页面手动渲染，加上所有vo，设定有效期1分钟，让用户1看到的是1分钟前的页面 详情页应该不能放（？）库存更新怎么办（？） 只是把页面商品信息放到了redis中 8.秒杀地址 + 接口限流 如果有很多手机账号，公不公平？ 按收货地址（？） 9.如果订单表和库存表不在同一个数据库 除了分布式锁更轻量级的做法？消息队列-异步处理 10.为什么秒杀系统需要mq 秒杀排队系统 多redis扣库存 一旦缓存丢失需要考虑恢复方案。比如抽奖系统扣奖品库存的时候，初始库存=总的库存数-已经发放的奖励数，但是如果是异步发奖，需要等到MQ消息消费完了才能重启redis初始化库存，否则也存在库存不一致的问题。 需要一个分布式锁来控制只能有一个服务去初始化库存 11.为什么秒杀系统需要mq 秒杀排队系统 https://www.infoq.cn/article/yhd-11-11-queuing-system-design 1）削峰:减少瞬间流量。处理失败的消息退回队列，接收的下一条还是这个消息，这是因为消息传递不仅要保证一次且仅一次，还要保证顺序。 2）限流保证数据库不会挂掉，不然会影响其他服务。主要还是为了减少数据库访问 透这么多请求来数据库没有意义,会有大量锁冲突导致读请求会发生大量的超时。如果均成功再放下一批. 3）持久化:就算库存系统出现故障,消息队列也能保证消息的可靠投递confirm模式将状态写入消息db(mysql),不会导致消息丢失。定时将状态失败的任务重新执行。 4）订单和库存解耦. #从队列里每次取几个 spring.rabbitmq.listener.simple.prefetch= 1 # 消费失败会重新压入队列 spring.rabbitmq.listener.simple.default-requeue-rejected= true # spring.rabbitmq.publisher-confirms= true spring.rabbitmq.publisher-returns= true 异步下单： 异步下单的前提是确保进入队列的购买请求一定能处理成功。Redis天然是单线程的，其INCR/DECR操作可以保证线程安全。而且入队之前要对用户user+goodsId判重。 假设处理一个秒杀订单需要1s，而将秒杀请求（或意向订单/预订单）加入队列（或消息系统等）可能只需要1ms。异步化将用户请求和业务处理解耦 其他消息中间件 如何用redis list实现mq 12.消息中间件的作用 1）解耦 基于数据的接口层 2）冗余（持久化） 3）扩展性 解耦了 处理过程 4）削峰 5）降低进程耦合度 6）顺序消费 7）缓冲 8）异步通信 rabbitMQ 的confirm通知是否持久化成功，ack或者nack方法，等到有千条消息再一次性刷新到磁盘 确保持久化： 1.放到redis ， DB，消息状态：发送中 2.投递消息，ack后删除消息 3.定时任务获取redis中的 发送中消息，补偿性投递，补偿次数&gt;3 失败，由人工排查 补偿方案要设计幂等性 乐观锁：操作库存的时候带上商品version 13.mq集群模式 Master-Slave模式 NetWork模式 两组Master-Slave模式 14.mq怎么实现的 https://tech.meituan.com/2016/07/01/mq-design.html AMQP协议: 虚拟主机（virtual host），交换机（exchange），队列（queue）和绑定（binding）。一个虚拟主机持有一组交换机、队列和绑定. broker(消息队列服务端) 1）数据流：例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。 2）RPC:两次RPC发送者把消息投递到服务端（broker），服务端再将消息转发一手到接收端，消费端最终做消费确认的情况是三次RPC。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。 3）消息堆积:存储消息，在合适的时机投递消息。 4）广播：我维护消费关系，可以利用zk/config server等保存消费关系。 生产者和消费者是完全解耦. ？因为保证可靠消费？这样redis预减的库存就真的减少到mysql里了？不用再同步回来（？ 持久化？ 消息队列时需要考虑到的问题，如RPC、高可用、顺序和重复消息、可靠投递、消费关系解析等 直接模式 15. mq的持久化 交换机持久化、队列持久化、消息持久化 持久化包括：队列索引和消息存储，队列索引维护队列中落盘的消息（消息的存储地点，是否已给消费者，是否已被消费者ack） 队列中的消息有4种状态： alpha 消息和索引都在内存 beta：消息内容在磁盘，索引在内存 gamma：内容在磁盘，索引在磁盘和内存（持久化消息） delta：内容、索引都在磁盘 内部存储分为5个子队列，经历从内存到磁盘再到内存，消费者从Q4读取。 默认：队列中消息尽可能存在内存中，即使持久化消息，被写入磁盘的同时，内存中也有备份，当需要释放内存时，换页到磁盘会阻塞队列操作。 惰性队列：目标：支持更长队列，更多消息存储，消息存入磁盘，消费者消费到再加载到内存。 流量控制 存储成一个完整的流控链， Connection处理进程，Channel处理进程，队列处理进程，消息持久化进程]]></content>
  </entry>
  <entry>
    <title><![CDATA[国内公司面试高频题]]></title>
    <url>%2F2019%2F05%2F29%2Falg-cd%2F</url>
    <content type="text"><![CDATA[638 大礼包输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释:有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 547 朋友圈输入:[[1,1,0], [1,1,0], [0,0,1]]输出: 2说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 322找钱最少硬币数 （递归求最小步数的解法）！贪心算法一般考举反例。不能用贪心的原因：如果coin={1,2,5,7,10}则使用2个7组成14是最少的，贪心不成立。满足贪心则需要coin满足倍数关系{1,5,10,20,100,200} 输入：coins = [1, 2, 5], amount = 11输出：3 (11 = 5 + 5 + 1) 递归mincoins(coins,11)=mincoins(coins,11-1)+1=(mincoins,10-1)+1+1..=(mincoins,0)+n 递归 记忆子问题 剩下3，用2的硬币变成剩下1的子问题和 剩下2，用1的硬币 剩下1的子问题是相同的。递归给count赋值是从下往上的。123456789101112131415161718public int coinChange3(int[] coins, int amount) &#123; if(amount&lt;1)return 0; return coinChange2(coins,amount,new int[amount]);&#125;private int coinC(int[] coins,int left,int[] count)&#123; if(left&lt;0)return -1; if(left==0)return 0; //关键，不然超时 if(count[left]!=0)return count[left]; int min = Integer.MAX_VALUE; for(int coin:coins)&#123; int useCoin = coinC(coins,left-coin,count); if(useCoin &gt;=0&amp;&amp;useCoin&lt;min)&#123; min = 1+useCoin; &#125; &#125; return count[left] = (min==Integer.MAX_VALUE)?-1:min; &#125; dp: 注意点：初值如果设为Int的max，两个都是max的话+1变成负数，所以设amount+1 j 从coin开始81%~94% 不稳定 123456789int[] dp = new int[amount+1];Arrays.fill(dp,amount+1);dp[0] =0;for(int coin:coins)&#123; for(int j = coin;j&lt;=amount;j++)&#123; dp[j]=Math.min(dp[j],dp[j-coin]+1); &#125;&#125;return dp[amount]&gt;amount?-1:dp[amount]; 最正确的方法：dfs分支限界 1.逆序coins数组 贪心从大硬币开始试 2.dfs终止条件是 找到硬币整除了，或者idx==0但是不能整除 3.剪枝条件是 考虑用当前coins[idx]i个之后，用下一个硬币至少1个，如果超了break99% 12345678910111213141516171819202122232425262728int minCnt = Integer.MAX_VALUE;public int coinChangedfs(int[] coins,int amount)&#123; Arrays.sort(coins); dfs(amount,coins.length-1,) return minCount == Integer.MAX_VALUE?-1:minCount;&#125;private void dfs(int amount,int idx,int[] coins,int count)&#123; if(amount%coins[idx]==0)&#123; int bestCnt = count+amount/coins[idx]; //当[1,2,5] 11, 用掉两个5，count=2 idx=0,cnt+1=3 return if(bestCnt&lt;minCnt)&#123; minCnt = bestCnt; //这个return放在里面97% return; &#125; //本来应该放在这里 94% &#125; if(idx==0)return; for(int i = amount/coins[idx];i&gt;=0;i--)&#123; int leftA = amount - i*coins[idx]; int useCnt = count+i; int nextCoin = coins[idx-1]; //保证只要left&gt;0都还需要至少1枚硬币 //或者简单一点if(useCnt+1&gt;minCount)break; 98% if(useCnt+(leftA+nextCoin-1)/nextCoin&gt;=minCount)break; dfs(leftA,idx-1,coins,useCnt); &#125;&#125; 55 ?jump gamejump gamei+nums[i]大于lastp表示i位置可以跳到lastp位置。将lastp更新成现在的i。再向前直到lastp变成0，表示0位置可以到下一个lastp一直到len-1。1234lastp = len-1;for(int i =len-1;i&gt;=0;i--) if(i+nums[i]&gt;=lastp)lastp==i;return lastp==0; 45 jump game最少跳跃次数754 向左向右走1-n步到达target，求最小nInput: target = 3Output: 2Explanation:On the first move we step from 0 to 1.On the second step we step from 1 to 3. 10^9的题一般是logn或者sqrt的问题思路：相等于1..n中间放正负号等于target如果1..n=target+dd是偶数很重要，因为改变一个数的符号会导致sum-2x target=111+2+3+4+5 =15 (dif=4) 翻转2的符号oktarget=12dif=3 +6 dif=9 +7 dif=16-&gt;凑一个8(1+3+4)//奇偶性??12345678910111213public int reachNumber(int target) &#123; target = Math.abs(target); int sum = 0; int cnt = 1; while (target&gt;sum || (target-sum)%2!=0)&#123; sum+=cnt; cnt++; // System.out.println(cnt+" "+sum); &#125; return cnt-1; &#125;&#125; 673 最长递增子序列的个数Input: [1,3,5,4,7]Output: 2Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7]. 223 矩形重叠后的总面积给出两个矩形的左下角 右上角坐标输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45思路： 计算重叠区域的长宽 注意int越界12345678910public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int x = 0; if(Math.min(C,G)&gt;Math.max(A,E))&#123; x = Math.min(C,G)-Math.max(A,E); &#125;; int y = 0; if(Math.min(D,H)&gt;Math.max(B,F))&#123; y = Math.min(D,H)-Math.max(B,F); &#125; return (int)((D-B)*(C-A)+(G-E)*(H-F) -x*y); &#125; 836 矩形重叠矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]输出：true 关键：rec2在rec1的上、下、左、右都只要和一个坐标比就可以了。12345678class Solution &#123; public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123; return !(rec1[2] &lt;= rec2[0] || // left rec1[3] &lt;= rec2[1] || // bottom rec1[0] &gt;= rec2[2] || // right rec1[1] &gt;= rec2[3]); // top &#125;&#125; 1return rec1[0] &lt; rec2[2] &amp;&amp; rec2[0] &lt; rec1[2] &amp;&amp; rec1[1] &lt; rec2[3] &amp;&amp; rec2[1] &lt; rec1[3]; 230 二叉搜索树/BST第K小元素输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 方法1：计算节点数 53%1234567891011private int cntNodes(TreeNode root)&#123; if(root==null)return 0; return cntNodes(root.left)+cntNodes(root.right)+1;&#125;//left = 2 k=1 public int kthSmallest(TreeNode root, int k) &#123; int left = cntNodes(root.left); if(left == k-1)return root.val; else if(left &lt; k-1)return kthSmallest(root.right,k-1-left); else return kthSmallest(root.left,k); &#125; 方法2：中序遍历第k步的时候100%12345678910111213141516int rst = -1;int kk = 0;public int kthSmallest(TreeNode root, int k) &#123; kk = k; find(root); return rst;&#125;private void find(TreeNode root)&#123; if(root.left!=null)find(root.left); kk--; if(kk==0)&#123; rst = root.val; return; &#125; if(root.right!=null)find(root.right);&#125; 方法3：用栈中序迭代54%1234567891011121314151617181920public int kthSmallest(TreeNode root, int k) &#123; Deque&lt;TreeNode&gt; stk = new ArrayDeque&lt;&gt;(); while(root!=null)&#123; stk.push(root); root = root.left; &#125; while(k&gt;0)&#123; TreeNode cur = stk.pop(); k--; if(k==0)return cur.val; if(cur.right!=null)&#123; root = cur.right; while(root!=null)&#123; stk.push(root); root = root.left; &#125; &#125; &#125; return -1;&#125; 846 一手顺子Input: hand = [1,2,3,6,2,3,4,7,8], W = 3Output: trueExplanation: Alice’s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]. 1234567891011public boolean isNStraightHand(int[] hand, int W) &#123; int[] cnt = new int[W]; for(int v:hand)&#123; // 关键 cnt[v%W]++; &#125; for(int i = 1;i&lt;W;i++)&#123; if(cnt[i]!=cnt[i-1])return false; &#125; return true;&#125; 19删除倒数第k个结点难点：1如果要删除的是头节点 2快指针在null的时候相差n步正好是倒数第n个，所以要在前一个，在.next!=null的时候就要停止1234567891011121314public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode p = head; ListNode pp = head; while(n--&gt;0)p=p.next; //关键 if(p==null)return head.next; //关键 while(p.next!=null)&#123; p = p.next; pp = pp.next; &#125; pp.next = pp.next.next; return head;&#125; 560 和为K的子数组个数 tc输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 12整数转罗马输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3. 123456789101112public String intToRoman(int num) &#123; int[] nums = &#123;1,4,5,9,10,40,50,90,100,400,500,900,1000&#125;; String[] rm = &#123;"I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M"&#125;; StringBuilder sb = new StringBuilder(); for(int i = rm.length-1;i&gt;=0 &amp;&amp; num&gt;0;i--)&#123; while(num &gt;= nums[i])&#123; sb.append(rm[i]); num -= nums[i]; &#125; &#125; return sb.toString();&#125; ！！！32 最长括号子串输入: “)()())”输出: 4解释: 最长有效括号子串为 “()()” 1234567891011121314151617181920public int longestValidParentheses(String s) &#123; Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;(); stk.push(-1); int n = s.length(); int rst = 0; for(int i = 0;i &lt; n;i++)&#123; if(s.charAt(i) == '(')&#123; stk.push(i); &#125;else &#123; stk.pop(); if(stk.isEmpty())&#123;// 正确匹配串的左边一位可能是-1也可能是一个错误的右括号的位置 stk.push(i); &#125;else// 每次正确的右括号 记录串长 rst = Math.max(rst,i-stk.peek()); &#125; &#125; return rst;&#125; 左右扫描两遍123456789101112131415161718192021222324252627282930313233343536public int longestValidParentheses(String s) &#123; int rst = 0; int left = 0; int right = 0; int n = s.length(); for(int i = 0;i&lt;n;i++)&#123; if(s.charAt(i)=='(')&#123; left++; &#125;else if(s.charAt(i)==')')&#123; right++; &#125; if(left == right)&#123; rst = Math.max(rst,left*2); &#125; else if(right &gt; left)&#123; left = 0; right = 0; &#125; &#125; left = 0; right = 0; for(int i = n-1;i&gt;=0;i--)&#123; if(s.charAt(i)=='(')&#123; left++; &#125;else if(s.charAt(i)==')')&#123; right++; &#125; if(left == right)rst = Math.max(rst,left*2); //关键 else if(left &gt; right)&#123; left = 0; right = 0; &#125; &#125; return rst;&#125; 765 情侣牵手 aqy输入: row = [0, 2, 1, 3]输出: 1解释: 我们只需要交换row[1]和row[2]的位置即可。 思路：贪心 每次取一对，遍历所有之后的，将匹配的换上来，再下一对 有趣的排序任取数组中的一个数然后将它放置在数组的最后一个位置。问最少操作多少次可以使得数组从小到大有序？419 7 8 25out:419 7 8 257 8 19 25思路：统计有多少个不用移动位置123456789101112int cnt = 0;int[] arr2 = arr.clone();Arrays.sort(arr2);int p1 = 0;int p2 =0;while(p1&lt;n &amp;&amp; p2&lt;n)&#123; if(arr[p1] == arr2[p2])&#123; p1++; p2++; cnt++; &#125;else p1++;&#125;System.out.println(n-cnt); hiho1892 S中字符可以移动首部，移动最少次数得到T选定S中的一个字符Si，将Si移动到字符串首位。例如对于S=”ABCD”，小Ho可以选择移动B从而得到新的S=”BACD”；也可以选择移动C得到”CABD”；也可以选择移动D得到”DABC”。请你计算最少需要几次移动操作，可以使S变成T。in:ABCDDBACout:2 思路：T的最后一个字符找到S中的对应位置之后 也就是说 S这个位置之后的，都应该是被提到最前面去了。然后S和T 都向前一格是一样的子问题。。12345678910111213141516171819202122public static int trans3(String s,String t)&#123; if(s.length() != t.length())return -1; int n = s.length(); int[] scnt = new int[256]; int[] tcnt = new int[256]; for (int i = 0; i &lt;n ; i++) &#123; scnt[s.charAt(i)]++; tcnt[t.charAt(i)]++; &#125; for (int i = 0; i &lt;256 ; i++) &#123; if(scnt[i]!=tcnt[i])return -1; &#125; int tidx = n-1; int ans = 0; for (int i = n-1; i &gt;=0 ; i--) &#123; if(s.charAt(i) == t.charAt(tidx))&#123; ans++; tidx--; &#125; &#125; return n-ans;&#125; 330 从1-n中选哪些数字可以求和得到1-n 贪心 tx最少需要给nums加几个数字，使其能组成[1,n]之间的所有数字输入: nums = [1,3], n = 6输出: 1解释:根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。 思路：int miss = [1-n] 中不能表示的最小值,如果 现在能凑出1，遇到3 &gt; miss 需要+miss这个数，不然凑不出 + 2，当前miss是4，遇到3，则可以凑出[1-4+3), 思考原来可以用1，2凑出[1,2,3]，每个数字+3注意：循环条件 miss&lt;=n，不是数组，考虑空数组也应该++ 1234567891011121314151617public int minPatches(int[] nums, int n) &#123; long miss = 1; int len = nums.length; int idx = 0; int cnt = 0; while(miss &lt;= n)&#123; //如果可以 if(idx &lt; len &amp;&amp; nums[idx] &lt;= miss)&#123; miss+= nums[idx]; idx++; &#125;else &#123; cnt++; miss+=miss; &#125; &#125; return cnt;&#125; 805 能否将数组划分成均值相等的两个数组第i个石头的位置是stones[i]，最大的位置和最小的位置是端点。每次可以移动一个端点到一个非端点。如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。1,2,5-&gt;2,3,5-&gt;3,4,5当无法移动时游戏结束。问最少结束游戏的步数和最大结束的步数。输入：[7,4,9]输出：[1,2]解释：我们可以移动一次，4 -&gt; 8，游戏结束。或者，我们可以移动两次 9 -&gt; 5，4 -&gt; 6，游戏结束。 688 马K步留在棋盘的概率123456789101112131415161718192021222324 int[][]dirs = &#123;&#123;-1,2&#125;,&#123;-2,1&#125;,&#123;1,2&#125;,&#123;2,1&#125;,&#123;-1,-2&#125;,&#123;-2,-1&#125;,&#123;2,-1&#125;,&#123;1,-2&#125;&#125;;public double knightProbability(int N, int K, int r, int c) &#123; memo = new double[N][N][K+1]; return dfs(N,r,c,K);&#125;double[][][]memo;double dfs(int N,int x,int y,int K)&#123; if(x&gt;=N || x&lt;0 || y&lt;0 ||y&gt;=N)&#123; return 0; &#125; if(memo[x][y][K] &gt;0)return memo[x][y][K]; if(K == 0)&#123; memo[x][y][K] = 1; return 1; &#125; double rate = 0; for(int[] dir:dirs)&#123; rate += 0.125 * dfs(N,x+dir[0],y+dir[1],K-1); &#125; memo[x][y][K] = rate; return rate; &#125; 71 !!简化路径输入：”/a/./b/../../c/“输出：”/c” 12345678910111213141516171819public String simplifyPath(String path) &#123; String[] paths = path.split("/"); Deque&lt;String&gt; stk = new ArrayDeque&lt;&gt;(); for(String p :paths)&#123; p = p.replace("/",""); if(p.equals("..") &amp;&amp; !stk.isEmpty())&#123; stk.pop(); &#125; if(!p.equals(".")&amp;&amp; !p.equals("")&amp;&amp;!p.equals(".."))&#123; stk.push(p); &#125; &#125; StringBuilder sb = new StringBuilder(); while(!stk.isEmpty())&#123; sb.insert(0,"/"+stk.pop()); &#125; if(sb.length()==0)return "/"; return sb.toString();&#125; 135 Candy 分数发糖你需要按照以下要求，帮助老师给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。输入: [1,0,2]输出: 5解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 https://leetcode.com/problems/candy/discuss/42774/Very-Simple-Java-Solution-with-detail-explanation 正常思路：计算递增序列的同时计算递减序列的长度，当递增or相等时，用求和公式结算递减序列长度。 思路：1.从左向右扫，把所有上升序列设置成从1开始的递增糖数2.从右向左扫，更新右边向左边的递增糖数。 相似题目： 32 最长匹配括号 1234567891011121314151617181920public int candy(int[] ratings) &#123; int sum = 0; int n = ratings.length; int[] left = new int[n]; Arrays.fill(left,1); int[] right = new int[n]; Arrays.fill(right,1); for(int i = 1;i&lt;n;i++)&#123; if(ratings[i]&gt;ratings[i-1])&#123; left[i] = left[i-1]+1; &#125; if(ratings[n-1-i] &gt; ratings[n-i])&#123; right[n-1-i] = right[n-i]+1; &#125; &#125; for(int i = 0;i&lt;n;i++)&#123; sum += Math.max(left[i],right[i]); &#125; return sum; &#125; 问题很大786 第 K 个最小的素数分数输入: A = [1, 2, 3, 5], K = 3输出: [2, 5]解释:已构造好的分数,排序后如下所示:1/5, 1/3, 2/5, 1/2, 3/5, 2/3.很明显第三个最小的分数是 2/5. 思路：先把所有数字/最后一个数 1/5，2/5，3/5放进去？？？排序方法：p/q&lt;x/y &lt;==&gt; py&lt;xq取k-1次，如果分母序号-1&gt;分子，入堆123456789101112131415161718public int[] kthSmallestPrimeFraction(int[] A, int K) &#123; int n = A.length; //a[0]/a[1]&lt;b[0]/b[0] -&gt; a[0]b[1] - b PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;&#123; return A[a[0]]*A[b[1]] - A[a[1]]*A[b[0]]; &#125;); for (int i = 0; i &lt;n-1 ; i++) &#123; pq.add(new int[]&#123;i,n-1&#125;); &#125; while (--K &gt;0)&#123; int[] p = pq.poll(); if(--p[1]&gt;p[0])&#123; pq.add(p); &#125; &#125; return new int[]&#123;A[pq.peek()[0]],A[pq.peek()[1]]&#125;;&#125; 二分查找不是找k个而是找一个m，使比m小的正好有7个。构建成 从左往右递减，从上下往下递增。确定一个m，从右上角向左向下。可以用O(n)确定有多少个&lt;=m.复杂度log(max)n难点：二分搜索的精度A[i] will be between 1 and 30000.所以精度到1/300001231/2 1/3 1/5- 2/3 2/5- - 3/5 378 719 726 化学式中各原子的数量输入:formula = “K4(ON(SO3)2)2”输出: “K4N2O14S4”解释:原子的数量是 {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}。 460 LFU Cache cd tx最不经常使用LFU缓存。最近最少使用的将被删除难点：put如何在O(1)找到访问频率最少的kv删掉，如果频次相同，把时间戳最远的删掉。注意：每次get/put修改堆中元素的排序指标并堆不会自动重排，要删除再插入。并且注意用堆不是O（1）正确做法：3个hashMap 394 字符串解码 hw aqy123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 1234567891011121314151617181920212223242526272829303132333435363738public String decodeString(String s) &#123; String res = ""; Deque&lt;Integer&gt; nums = new ArrayDeque&lt;&gt;(); Deque&lt;String&gt; strs = new ArrayDeque&lt;&gt;(); int idx = 0; while(idx &lt; s.length())&#123; if(Character.isDigit(s.charAt(idx)))&#123; int tmp = 0; while (Character.isDigit(s.charAt(idx)))&#123; tmp = 10*tmp + (s.charAt(idx) - '0'); idx++; &#125; nums.push(tmp); &#125; else if(s.charAt(idx) == '[')&#123; // 关键 strs.push(res); res = ""; idx ++; &#125; else if(s.charAt(idx) == ']')&#123; // res = c tmps = a num = 2 res = acc tmps="" res = acc*3 StringBuilder tmps =new StringBuilder(strs.pop()); int num = nums.pop(); for (int i = 0; i &lt;num ; i++) &#123; //关键 tmps.append(res); &#125; // 关键 res = tmps.toString(); idx++; &#125;else&#123; res += s.charAt(idx++); &#125; &#125; return res;&#125; 664 奇怪的打印机wy打印机每次只能打印同一个字符。每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。输入: “aba”输出: 2解释: 首先打印 “aaa” 然后在第二个位置打印 “b” 覆盖掉原来的字符 ‘a’。 123456789101112131415161718192021public int strangePrinter(String s) &#123; int n = s.length(); int[][] dp = new int[n][n]; return dfs(s, 0, n-1, dp); &#125;private int dfs(String s, int i,int j,int[][] dp)&#123; if(i &gt; j)return 0; if(dp[i][j] == 0)&#123; //最坏情况，后面的一个一个打 dp[i][j] = dfs(s,i,j-1,dp)+1; for (int k = i; k &lt; j; k++) &#123; // 可以同时打印 k和j if(s.charAt(k) == s.charAt(j))&#123; dp[i][j] = Math.min(dp[i][j],dfs(s,i,k,dp)+dfs(s,k+1,j-1,dp) ); &#125; &#125; &#125; return dp[i][j];&#125; 546 移除盒子 不会tc+cd可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。12345678910Input:[1, 3, 2, 2, 2, 3, 4, 3, 1]Output:23Explanation:[1, 3, 2, 2, 2, 3, 4, 3, 1] ----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) ----&gt; [1, 3, 3, 3, 1] (1*1=1 points) ----&gt; [1, 1] (3*3=9 points) ----&gt; [] (2*2=4 points)定义状态dp[i][j][k]表示j右边有k个和j一样的元素，可以消除掉j和k中间的其它元素一起消除这k+1个，得到的分数。或者可以选择继续把ij区间拆分， 1234567891011121314151617public int removeBoxes(int[] boxes) &#123; int n = boxes.length; int[][][] dp = new int[101][101][101]; return dfs(boxes, 0, n-1, 0, dp);&#125;private int dfs(int[] boxes,int l,int r,int k,int[][][] dp)&#123; if(r&lt;l)return 0; while (l&lt;r &amp;&amp; boxes[r-1] == boxes[r])&#123;--r;++k;&#125; if(dp[l][r][k] &gt; 0)return dp[l][r][k]; dp[l][r][k] = (1+k)*(1+k) + dfs(boxes, l, r-1, 0, dp); for (int i = l; i &lt; r ; i++) &#123; if(boxes[i] == boxes[r])&#123; dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes,l,i,k+1,dp) +dfs(boxes,i+1,r-1,0,dp)); &#125; &#125; return dp[l][r][k];&#125; 问题不大33 !!旋转数组查找Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 关键：第一步分割：mid&gt;=最左，表示旋转点在mid右边，从左到mid是递增的，再考虑target在不在左侧&gt;=left。else 旋转点在左侧，12345678910111213141516171819202122232425public int search(int[] nums, int target) &#123; int n = nums.length; if(n &lt;1)return -1; int l = 0; int r = n-1; while(l&lt;=r)&#123; int mid = l+(r-l)/2; if(nums[mid] == target)return mid; // 旋转点在中位数右侧 if(nums[mid] &gt;= nums[l])&#123; if(target &lt; nums[mid] &amp;&amp; target &gt;= nums[l])&#123; r = mid-1; &#125;else&#123; l = mid+1; &#125; &#125; else &#123; if(target &gt;nums[mid] &amp;&amp; target&lt;= nums[r])&#123; l = mid+1; &#125; else r = mid-1; &#125; &#125; return -1;&#125; 93 分割IP地址注意：3个点之后还是要判断长度和数量关系 53 最大子数组和12345678910public int maxSubArray(int[] nums) &#123; int sum = 0; // 关键：测试用例[-1] int rst = nums[0]; for(int num:nums)&#123; sum = Math.max(sum+num,num); rst = Math.max(sum,rst); &#125; return rst;&#125; ！！42 雨水Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 思路：1 一个格子的水有两个边界，2 如果左边or右边有更低的，水都会流走，尽量从两边让墙越来越高3 如果当前格子靠近低的那侧，这个格子没可能更大了，最多就是left-A[i]水量，可以继续考虑这个格子更里那个格子。 正确做法：双指针1234567891011121314151617181920public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 两个数组做法：left保存当前位置左边的max。right保存当前位置右边的max。注意 第0位置没有left，left只要计算到n-2个元素n-1没有right,只要计算到第1个元素123456789101112131415161718public int trap(int[] height) &#123; int n = height.length; int[] left = new int[n]; int[] right = new int[n]; for(int i = 1;i&lt;n;i++)&#123; left[i] = Math.max(left[i-1],height[i-1]); &#125; for(int i = n-2;i&gt;=0;i--)&#123; right[i] = Math.max(right[i+1],height[i+1]); &#125; int rst = 0; for(int i = 0;i&lt;n;i++)&#123; int tmp = Math.min(left[i],right[i]) - height[i]; if(tmp &gt;0) rst += tmp; &#125; return rst;&#125; 2 链表数字相加注意：p1,p2,p不要忘了前进。carry用除，值用取余。 3 ！无重复的最长子串输入:abba输出：2 注意：测试用例” “，注意last应该递增1234567891011121314public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int max = -1; int last = 0; for(int i = 0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; last = Math.max(last,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); // 注意为了统一 “ ” 这个测试用例必须+1 max = Math.max(max,i-last+1); &#125; return max==-1?s.length():max;&#125; 440 ！字典序的第k小 计数！1-n的第k小Input:n: 13 k: 2Output:10Explanation:The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.dfs超时思路：高效计算同层每个两个数字在树中的间隔，并递归计算每一层。字典序是10进制1层例如n=100 1和2之间的距离gap -&gt;[1-2)的距离1 + [10-20)的距离10 + [100 -100]的距离 1 =12（注意计数，右边界n2如果不在当前树n2-n1，如果n2&gt;n ,右边界在这棵树中，这棵树中的节点数统计为n+1-n1。利用gap前进，如果k&gt;gap则说明在当前子树。当前树根下移。 123456789101112131415161718192021222324252627282930public int findKthNumber(int n, int k) &#123; int cur = 1; k--; while(k&gt;0)&#123; int gap = getGap(n,cur,cur+1); if(k &lt; gap)&#123; cur*=10; k--; &#125;else&#123; k -= gap; cur++; &#125; &#125; return cur;&#125;private int getGap(int n,long n1,long n2)&#123; int gap = 0; while(n1 &lt;= n)&#123; if(n2 &gt;n)&#123; gap += n-n1+1; &#125;else&#123; gap += n2-n1; &#125; n1 *=10; n2 *=10; &#125; return gap;&#125; 826 安排工作以达到最大收益 wy输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]输出: 100解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。 排序ac12345678910111213public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) &#123; List&lt;Pair&lt;Integer, Integer&gt;&gt; jobs = new ArrayList&lt;&gt;(); int N = profit.length, res = 0, i = 0, maxp = 0; for (int j = 0; j &lt; N; ++j) jobs.add(new Pair&lt;Integer, Integer&gt;(difficulty[j], profit[j])); Collections.sort(jobs, Comparator.comparing(Pair::getKey)); Arrays.sort(worker); for (int ability : worker) &#123; while (i &lt; N &amp;&amp; ability &gt;= jobs.get(i).getKey()) maxp = Math.max(jobs.get(i++).getValue(), maxp); res += maxp; &#125; return res;&#125; 493 Reverse Pairs 逆序对的个数 cd如果 i &lt; j and nums[i] &gt; 2*nums[j].算一个逆序对Input: [1,3,2,3,1]Output: 2 12345678910111213141516171819202122232425262728public static int ret;public static int reversePairs(int[] nums) &#123; ret = 0; mergeSort(nums, 0, nums.length-1); return ret;&#125;public static void mergeSort(int[] nums, int left, int right) &#123; if (right &lt;= left) &#123; return; &#125; int middle = left + (right - left)/2; mergeSort(nums, left, middle); mergeSort(nums,middle+1, right); //count elements int count = 0; for (int l = left, r = middle+1; l &lt;= middle;) &#123; if (r &gt; right || (long)nums[l] &lt;= 2*(long)nums[r]) &#123; l++; ret += count; &#125; else &#123; r++; count++; &#125; &#125; //sort Arrays.sort(nums, left, right + 1);&#125; 718 !!最长公共子串 最长公共子数组Input:A: [1,2,3,2,1]B: [3,2,1,4,7]Output: 3Explanation:The repeated subarray with maximum length is [3, 2, 1]. 思路：A从位置i开始，和B从j开始匹配的最大长度 123456789101112131415public int findLength(int[] A, int[] B) &#123; int n = A.length; int m = B.length; int max = 0; int[][] dp = new int[n+1][m+1]; for(int i = 1;i&lt;=n;i++)&#123; for(int j =1;j&lt;=m;j++)&#123; if(A[i-1]==B[j-1])&#123; dp[i][j] = dp[i-1][j-1]+1; max = Math.max(max,dp[i][j]); &#125; &#125; &#125; return max; &#125; 386 字典序数字dfs 112ms 71%123 1 2 3 ... /\ /\ /\10 ...19 20...29 30...39 .... 1234567891011121314151617public List&lt;Integer&gt; lexicalOrder(int n) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 10; i++) &#123; dfs(rst,n,i); &#125; return rst;&#125;private void dfs(List&lt;Integer&gt; rst,int n,int cur)&#123; if(cur&gt;n)return; else&#123; rst.add(cur); for (int i = 0; i &lt;10 ; i++) &#123; if(cur*10+i&gt;n)return; dfs(rst,n,10*cur+i); &#125; &#125;&#125; 相关：permutation的字典序思想：字典序全排列算法：保证尽可能长的前缀不变，后缀慢慢增加 abc 保证前面不变，后面增加一点点 -&gt; acb ，cb不能增大了，-&gt;bac 从右向左扫描 例如 321 是递增的 表示不能再增加 从右向左扫描到第一次增大的位置，和右边比较大的数交换。1 2 3 扫描到2，和3交换。 1 3 2 扫描到1降了，1和2交换 2 3 1 31不是最小后缀 变成2 1 3 算法： 1.从右想左 找到第一次下降位置 2.用后缀中比当前位置大的最小数字交换 3.保证后缀最小（翻转？） 4位25个字符的编码假定一种编码的编码范围是a ~ y的25个字母，从1位到4位的编码，如果我们把该编码按字典序排序，形成一个数组如下： a, aa, aaa, aaaa, aaab, aaac, … …, b, ba, baa, baaa, baab, baac … …, yyyw, yyyx, yyyy 其中a的Index为0，aa的Index为1，aaa的Index为2，以此类推。 编写一个函数，输入是任意一个编码，输出这个编码对应的Index. 输入：baca输出：16331 a开头的长度为4的编码一共有25^3个，长度为3有25^2个，长度为2有25个，长度为1有1个。例：bcd第一位是b所以处在第二大块，result += 1 * (25^3+25^2+25+1)第二位是c， result += 2 *（25^2+25+1）+1第三位是d， result += 3* （25+1）+1 （加一是因为最前面有个空）第四位是空，不管，因为空就是第一个result = 17658 123456789101112131415public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str = sc.next(); int n = str.length(); int rst = 0; if(n&gt;0) rst += (str.charAt(0)-'a')*(25*25*25+25*25+25+1); if(n&gt;1) rst += (str.charAt(1)-'a')*(25*25+25+1)+1; if(n&gt;2) rst += (str.charAt(2)-'a')*(25+1)+1; if(n&gt;3) rst += (str.charAt(3)-'a')+1; System.out.println(rst);&#125; 没有问题1014 最佳观光组合一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 111234567891011public int maxScoreSightseeingPair(int[] A) &#123; int n = A.length; int[] score = new int[n]; score[0] = A[0]; int rst = 0; for(int i = 1;i&lt;n;i++)&#123; rst = Math.max(rst,A[i]+score[i-1]-i); score[i-1] =Math.max(socre[i-1],A[i]+i); &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表题]]></title>
    <url>%2F2019%2F03%2F29%2Falg-linklist%2F</url>
    <content type="text"><![CDATA[2. Add Two NumbersInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 1234567891011121314151617181920212223public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alg-tree]]></title>
    <url>%2F2019%2F03%2F29%2Falg-tree%2F</url>
    <content type="text"><![CDATA[114 Flatten Binary Tree to Linked List123456789101112131415161718in: 1 / \ 2 5 / \ \3 4 6out:1 \ 2 \ 3 \ 4 \ 5 \ 6 用一个全局变量保存右边flatten好的根节点，移动到当前flatten节点的右边。后序遍历，并且先右节点再左节点。123456789TreeNode prev = null;public void flatten(TreeNode root) &#123; if(root == null)return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root;&#125; 513. Find Bottom Left Tree ValueInput:1234567 1 / \ 2 3 / / \4 5 6 / 7 Output:7 123456789101112131415public int findBottomLeftValue(TreeNode root) &#123; Deque&lt;TreeNode&gt; que = new ArrayDeque&lt;&gt;(); que.add(root); int rst = root.val; while(!que.isEmpty())&#123; int size = que.size(); rst = que.peek().val; while(size-- &gt;0)&#123; TreeNode tmp = que.poll(); if(tmp.left!=null)que.add(tmp.left); if(tmp.right!=null)que.add(tmp.right); &#125; &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关]]></title>
    <url>%2F2019%2F03%2F28%2Fquest-db%2F</url>
    <content type="text"><![CDATA[内存表内存表会把表结构存放在磁盘上，把数据放在内存中。 临时表CREATE TEMPORARY TABLE临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。临时表默认的是MyISAM innodb自增id在内存1、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？(1)如果表的类型是MyISAM，那么是18因为MyISAM表会把自增主键的最大ID记录到数据【文件】里，重启MySQL自增主键的最大ID也不会丢失（2）如果表的类型是InnoDB，那么是15InnoDB表只是把自增主键的最大ID记录到【内存】中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失 自增id重复插入过了17，删除之后插入又是17MySQL采用执行类似select max(id)|1 from t1;方法来得到AUTO_INCREMENT。而这种方法就是造成自增id重复的原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[括号相关]]></title>
    <url>%2F2019%2F03%2F27%2Falg-parentheses%2F</url>
    <content type="text"><![CDATA[301 ！！！Remove Invalid Parentheses 删除无效括号删除数量最少的所有正确可能输入: “(a)())()”输出: [“(a)()()”, “(a())()”] 241 !!! Different Ways to Add Parentheses 给运算表达式加括号改变优先级输入: “2-1-1”输出: [0, 2]解释:((2-1)-1) = 0(2-(1-1)) = 2 本质是wrod break ？？？括号串达到匹配需要最小的逆转次数Input: exp = “}}}{“Output: 2 将匹配的括号都去掉，{的个数是m=3，}的个数是n=3m/3+n/2 = 2+1=312345678910111213141516171819202122private int minReversal(String s)&#123; int len = s.length(); if((len&amp;1)!=0)return -1; Deque&lt;Character&gt; que = new ArrayDeque&lt;&gt;(); int n=0; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(c=='&#125;'&amp;&amp;!s.isEmpty())&#123; if(que.peek()=='&#123;')que.pop(); else &#123; que.push(c); &#125; &#125; &#125; int mn = que.size(); while (!que.isEmpty()&amp;&amp;que.peek()=='&#123;')&#123; que.pop(); n++; &#125; //当m+n是偶数的时候ceil(n/2)+ceil(m/2)= return (mn/2+n%2);&#125; !!! 32 Longest Valid Parentheses 字符串中最长有效括号子串Input: “)()())”Output: 4 “()()” 思路:遇到(，把位置入栈，遇到)，弹出一个(位置，栈顶一定是这个“)”匹配的”(“的最左非匹配位置。初始非匹配位置为-112345678910111213141516171819public int longestValidParentheses(String s) &#123; Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;(); stk.push(-1); int rst = 0; for(int i = 0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(c == '(')&#123; stk.push(i); &#125;else if(c == ')')&#123; stk.pop(); if(stk.isEmpty()) stk.push(i); else &#123; rst = Math.max(rst,i-stk.peek()); &#125; &#125; &#125; return rst;&#125; 正确方法：从左向右扫一遍，累计”(“数量和”)”数量，当两者相等，更新最大长度，当”)”数量超过”(“数量，清零。再从右往左扫一遍更新max。 相似题目：135 按分数分糖最少数量 1234567891011121314151617181920212223242526272829public int longestValidParentheses(String s) &#123; int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * right); &#125; else if (right &gt;= left) &#123; left = right = 0; &#125; &#125; left = right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * left); &#125; else if (left &gt;= right) &#123; left = right = 0; &#125; &#125; return maxlength;&#125; 22 Generate Parentheses 生成n对匹配的括号 （卡特兰数）For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 注意加左括号和右括号是两个分支，不是if else的关系123456789101112131415161718public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); gene(rst,"",n,n); return rst;&#125;private void gene(List&lt;String&gt; rst,String tmp,int left,int right)&#123; if(left == 0 &amp;&amp; right == 0)&#123; rst.add(tmp); return; &#125; // ( left = 2 right = 3 if(left &gt;0)&#123; gene(rst,tmp+"(",left-1,right); &#125; if(right &gt; 0 &amp;&amp; left&lt;right)&#123; gene(rst,tmp+")",left,right-1); &#125;&#125; 还有一种迭代的https://leetcode.com/problems/generate-parentheses/discuss/10127/An-iterative-method.123456789f(0): &quot;&quot;f(1): &quot;(&quot;f(0)&quot;)&quot;f(2): &quot;(&quot;f(0)&quot;)&quot;f(1), &quot;(&quot;f(1)&quot;)&quot;f(3): &quot;(&quot;f(0)&quot;)&quot;f(2), &quot;(&quot;f(1)&quot;)&quot;f(1), &quot;(&quot;f(2)&quot;)&quot;So f(n) = &quot;(&quot;f(0)&quot;)&quot;f(n-1) , &quot;(&quot;f(1)&quot;)&quot;f(n-2) &quot;(&quot;f(2)&quot;)&quot;f(n-3) ... &quot;(&quot;f(i)&quot;)&quot;f(n-1-i) ... &quot;(f(n-1)&quot;)&quot; 20 Valid ParenthesesInput: “()[]{}”Output: true 1234567891011121314public boolean isValid(String s) &#123; Deque&lt;Character&gt; stk = new ArrayDeque&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!stk.isEmpty()&amp;&amp; ((stk.peek() == '&#123;' &amp;&amp; c == '&#125;') || (stk.peek() == '[' &amp;&amp; c == ']') || (stk.peek() == '(' &amp;&amp; c == ')')))&#123; stk.pop(); &#125;else&#123; stk.push(c); &#125; &#125; return stk.isEmpty();&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alg-stack-queue]]></title>
    <url>%2F2019%2F03%2F25%2Falg-stack-queue%2F</url>
    <content type="text"><![CDATA[373 start和end数组 拼成[start,end] 求start+end最小的k个点对226224 Basic Calculator 有括号的计算器Input: “(1+(4+5+2)-3)+(6+8)”Output: 23 关键：三个变量一个栈。遇到括号的时候把之前的值存入stack，一个无括号表达式保留一个rst，遇到符号改sign，用于下一个值的加减，遇到num的时候计算rst，最后一个数字要单独处理。 1234567891011121314151617181920212223242526272829303132333435363738394041public int calculate(String s) &#123; Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;(); int rst = 0; int num = 0; // 下一个数的符号 int sign = 1; for (int i = 0; i &lt;s.length() ; i++) &#123; char c = s.charAt(i); if(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; num = num * 10 + (int)(c-'0'); &#125;else if(c == '+')&#123; rst += sign*num; num = 0; sign = 1; &#125;else if(c == '-')&#123; rst += sign*num; num = 0; sign = -1; // 括号开始等于开启一个新的表达式逻辑 // 并且最后存在rst里的只有括号前的值和括号前的符号 &#125;else if(c == '(')&#123; // 先放值再放符号 stk.push(rst); stk.push(sign); // 括号开头第一个是正的 sign = 1; // 关键 rst = 0; &#125;else if(c == ')')&#123; // rst是当前括号中的表达式值 rst += sign *num; num = 0; // 括号前的符号 rst *= stk.pop(); // 括号前表达式的值 rst += stk.pop(); &#125; &#125; if(num !=0)rst+=sign*num; return rst;&#125; 225 Implement Stack using Queues 用栈实现队列熟练展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041class MyQueue &#123; // 1 2 3 Stack&lt;Integer&gt; in; Stack&lt;Integer&gt; out; /** Initialize your data structure here. */ public MyQueue() &#123; in = new Stack&lt;&gt;(); out = new Stack&lt;&gt;(); &#125; // in: 1 2 3 pop()-&gt; out:3 2 1-&gt; 3 2 push(4)-&gt; /** Push element x to the back of queue. */ public void push(int x) &#123; in.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(out.isEmpty())&#123; while(!in.isEmpty())&#123; out.push(in.pop()); &#125; return out.pop(); &#125;else return out.pop(); &#125; /** Get the front element. */ public int peek() &#123; if(out.isEmpty())&#123; while(!in.isEmpty())&#123; out.push(in.pop()); &#125; return out.peek(); &#125;else return out.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return in.isEmpty()&amp;&amp;out.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alg-greedy]]></title>
    <url>%2F2019%2F03%2F21%2Falg-greedy%2F</url>
    <content type="text"><![CDATA[&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 316 !!!Remove Duplicate Letters 删掉重复字符保证原顺序的 最小字典序 1081 不同字符的最小子序列去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 输入: “cbacdcbc”输出: “acdb” ======= 316 Remove Duplicate Letters 删掉重复字符保证原顺序的 最小字典序 refs/remotes/origin/hexo-edit 122 买卖任意次数的股票Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 熟练只要后一天涨就买。 12345678910public int maxProfit(int[] prices) &#123; int n = prices.length; int rst = 0; for(int i = 1;i&lt;n;i++)&#123; if(prices[i]-prices[i-1]&gt;0)&#123; rst += prices[i]-prices[i-1]; &#125; &#125; return rst;&#125; 45. Jump Game IIInput: [2,3,1,1,4]Output: 2 12345678910111213public int jump(int[] nums) &#123; int cur = 0; int cnt = 0; int max = nums[0]; for(int i = 0;i&lt;nums.length;i++)&#123; if(cur&lt;i)&#123; cur=max; cnt++; &#125; max = Math.max(max,i+nums[i]); &#125; return cnt;&#125; 41克以下的宝石（可能是41克以下不包括41克的任意重量），他只能携带一个天平和【四个砝码】去称重，请问他会携带哪些重量的砝码？A1 3 9 27B1 10 20 30 40C1 4 16 32D1 3 10 21 3、9、27可以组成3的倍数，多一克可以加1，少一克可以减1 选A带了四个砝码，即可以用四个进制位表示。设进制数为n，那么n^0+n^1+n^2+n^3&gt;=40。用等比数列的公式可以求得n=3。所以四个砝码分别是1(3^0)、3(3^1)、9(3^2)、27(3^3)。选A 德·梅齐里亚克的砝码问题https://baike.baidu.com/item/%E5%BE%B7%C2%B7%E6%A2%85%E9%BD%90%E9%87%8C%E4%BA%9A%E5%85%8B%E7%9A%84%E7%A0%9D%E7%A0%81%E9%97%AE%E9%A2%9840磅的砝码，由于跌落在地而碎成4块.后来，称得每块碎片的重量都是整磅数，而且可以用这4块来称从1至40磅之间的任意整数磅的重物.问这4块砝码碎片各重多少？ lg1658现在你手上有N种不同面值的硬币，每种硬币有无限多个。为了方便购物，你希望带尽量少的硬币，但要能组合出1到X之间的任意值。20 41 2 5 10 5如果已经凑出x以内的数(1)，枚举a[i]找到&lt;=x+1的最大数则1-x+a[i]都可以凑出 从1开始凑，然后凑2，用面值最大的(1,2)凑。然后可以凑到的最大值为3，下面凑4，用面值最大的(1,2,2)凑。当前可以凑到最大值是5，下次凑6，用面值最大的(1,2,2,5)凑。当前可以凑到的最大为10,下次凑11，用面值最大的(1,2,2,5,10)凑。可以凑的的总数&gt;20 ok 1234567891011121314151617Arrays.sort(coins);if(coins[0]!=1) System.out.println(-1);else&#123; int cnt = 0; //凑最大面值 int sum = 0; while (sum &lt; x)&#123; int i; // 关键 for (i =n-1; i&gt;=0 ; i--) &#123; if (coins[i] &lt;= sum + 1) break; &#125; cnt++; sum+=coins[i]; &#125; System.out.println(cnt);&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试真题]]></title>
    <url>%2F2019%2F03%2F21%2Falg-real%2F</url>
    <content type="text"><![CDATA[mt01 切割树 树形DP计数https://www.luogu.org/problemnew/show/CF461B给你一棵含有n个结点的树，编号为0~n-1，这n个结点都被染成了黑色或白色。显然，对于一棵树而言，我们每去掉一条边就能把树分成两部分。现在，要求你把这棵树切开，使得每一个连通块内只有一个白色结点。问共有多少种切开的方式满足以上条件，如果被删除的边集不同，我们则认为两种方式不同，反之，认为相同。请输出对1000000007取模后的结果。30 01 0 0输出样例1：2输入样例2：100 0 1 2 0 5 1 2 31 0 0 1 0 0 1 1 0 1输出样例2：3转移方程12345678910f[u]表示u的连通区域有一个白的方案数 g[u]表示u的连通区域没有白的方案数 // u的连通区域有1个白 自己是白，可以断开的方案数+自己不是白，不能断开的方案数 // 多个孩子节点为什么是乘法（？）// 1）自己是白 子树有/没有白f[u]*(g[son]+f(u)) 2)自己是黑，子树有白g[u]*f[son]f[u]=f[u]*g[son]+f[u]*f[son]+g[u]*f[son] // 例子，如果dfs返回的一个son是白f[son] = 1,g[son] = 0当前也是白f[u] = 1 =0+1+0// 包括当前节点的树 没有白 子树怎么样都行的方案数g[u]=g[u]*g[son]+g[u]*f[son]// 每个节点的初始条件，如果是白，则f[u] = 1 不然g[u] = 1 123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; static long[] f; static long[] g; final static long mod = 1000000007; public static void dfs(List[] tree,int[]color,int idx,int fd)&#123; // 白色 if(color[idx] == 0)f[idx] = 1; else g[idx] = 1; List&lt;Integer&gt; nexts = tree[idx]; for(Integer next : nexts)&#123; if(next == fd)continue; dfs(tree,color,next,idx); f[idx] =(f[idx]*g[next]%mod + f[next]*f[idx]%mod + g[idx] *f[next]%mod)%mod; g[idx] =(g[idx]*g[next]%mod + g[idx] * f[next]%mod)%mod; &#125; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); List&lt;Integer&gt;[] tree = new ArrayList[n]; for (int i = 0; i &lt;n ; i++) &#123; tree[i] = new ArrayList&lt;&gt;(); &#125; // 连接 当前节点 i+1和读入的father for (int i = 0; i &lt;n-1 ; i++) &#123; int fd = sc.nextInt(); tree[fd].add(i+1); tree[i+1].add(fd); &#125; int[] color = new int[n]; f = new long[n]; g = new long[n]; // 每个节点的颜色 0 白色 1 黑色 for (int i = 0; i &lt;n ; i++) &#123; color[i] = sc.nextInt(); &#125; dfs(tree,color,0,-1); System.out.println(f[0]); &#125; jd02 寻找子串给出m个字符串，和一个字符串T，在T中选出经可能多的子串，同时满足1）这些子串在T中互不相交2）这些子串是这m个中的T最多能选多少个子串（注意一个串可以用好几次）（b,b,aa)(b,b,ac)3aabacbbaac输出3 jd01 逃生1是根，每个位置上只能有1个人，一分钟移动1个，问全部移动到1最短时间多少input63 22 14 35 26 1 output412345678910111213141516171819202122232425262728293031323334353637383940414243444546public class taosheng &#123; static class Node&#123; int val; List&lt;Integer&gt; nexts; public Node(int val) &#123; this.val = val; this.nexts = new ArrayList&lt;&gt;(); &#125; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 邻接表 Node[] graph = new Node[n]; for (int i = 0; i &lt;n ; i++) &#123; graph[i] = new Node(i); &#125; for (int i = 0; i &lt;n-1 ; i++) &#123; int v = sc.nextInt(); int w = sc.nextInt(); graph[v-1].nexts.add(w-1); graph[w-1].nexts.add(v-1); &#125; int max = 0; // 计算根节点的所有相邻点 的最大深度 List&lt;Integer&gt; roots = graph[0].nexts; for(Integer root : roots)&#123; int count = getEdgeCnt(graph,root,0); max = Math.max(max, count); &#125; System.out.println(max+1); &#125; //dfs遍历计算子节点(边）个数 private static int getEdgeCnt(Node[] graph, Integer root, int i) &#123; int cnt = 0; List&lt;Integer&gt; nexts = graph[root].nexts; // 忽略到 父节点 i 的边 cnt += nexts.size()-1; for(Integer next:nexts)&#123; if(next == i)continue; cnt += getEdgeCnt(graph, next, root); &#125; return cnt; &#125;&#125; tt 变身程序员 lc9941是新鲜橘子，2是烂橘子,全部变成烂橘子的最少分钟数Input: [[2,1,1],[1,1,0],[0,1,1]]Output: 4ac bd lc 871最低加油次数ali02班上同学聚餐吃火锅，一锅煮了的M(1&lt;=M&lt;=50)个鱼丸和N(1&lt;=N&lt;=50)个肉丸，现欲将M个鱼丸和N个肉丸分到K(1&lt;=K&lt;=50)个碗中，允许有空碗，鱼丸和肉丸不允许混在同一个碗里，问共有多少种装法？假设碗足够大，能装50个鱼丸或者50个肉丸，碗之间也没有区别，因此当M=N=1，K=3时，只有1种装法，因为(1,1,0)(1,0,1)(0,1,1)被看作是同一种装法。 ali01小明、小华，是校内公认的数据算法大牛。两人组队先后参加了阿里云天池大赛多项奖金赛事，多次获奖，小明是其中的队长。最近的一次工业数据智能竞赛中，两人又斩获季军，获得奖金1万元。 作为算法大牛，两人竞赛奖金分配也有独特方式，由两人共同编写的一个程序来决定奖金的归属。每次获奖后，这个程序首先会随机产生若干0~1之间的实数{p_1, p_2, …, p_n}，然后从小明开始，第一轮以p_1的概率将奖金全部分配给小明，第二轮以p_2的概率将奖金全部分配给小华，这样交替地小明、小华以p_i的概率获得奖金的全部，一旦奖金被分配，则程序终止，如果n轮之后奖金依旧没发出，则从p_1开始继续重复（这里需要注意，如果n是奇数，则第二次从p_1开始的时候，这一轮是以p_1的概率分配给小华）；直到100轮，如果奖金还未被分配，程序终止，两人约定通过支付宝将奖金捐出去。 输入:输入数据包含N+1行，第一行包含一个整数N接下来N行，每行一个0~1之间的实数，从p_1到p_N输出:单独一行，输出一个小数，表示小明最终获得奖金的概率，结果四舍五入，小数点后严格保留4位(这里需要注意，如果结果为0.5，则输出0.5000)。输入范例:10.999999输出范例:1.0000 123456789101112131415161718192021222324int N; cin &gt;&gt; N; vector&lt;double&gt; p(N);for (int i = 0; i &lt; N; i++)&#123; cin &gt;&gt; p[i];&#125;vector&lt;double&gt; p100(100);for (int i = 0; i &lt; 100; i++)&#123; int index = i % N; p100[i] = p[index];&#125;double sum = 0.0;double pre = 1.0;for (int i = 0; i &lt; 50; i+=2)&#123; sum += pre * p100[i]; pre *= ((1.0 - p100[i]) * (1.0 - p100[i + 1]));&#125;printf("%.4f\n", sum); bd02叶子节点的最大乘积 !543树中两点的最远路径，自己到自己0将每个点试当成转折点,在更新左右最长高度的同时更新rst = Max(rst,l+r); wz02有n个勇士，都要要学会k个技能，有m个先知，先知教一个勇士1分钟，一个勇士只能同时学1个技能，一个先知同时也只能教一个勇士学技能不同先知或不同勇士可以在同一时间教授/学习技能一轮可以学m个技能，最有剩下少于m个技能只需要1秒。123456789if (m &gt;= n) &#123; System.out.println(k);&#125;if (m &lt; n) &#123; double M = (double) (m); double res = (n * k) / M; long result = (long) Math.ceil(res); System.out.println(result);&#125; tt03 lc135n个人有得分，领取奖品如果某个人分数比左右的人高，那么奖品数量比左右多每个人至少得到一个奖品第一行表示测试样例个数样例第一行，人数n，第二行是分数，输出应该准备的最少奖品数量输入：221 241 2 3 3 输出38 tt04N根绳子长度为Li 需要M根登场的，不能拼接，m根绳子最长长度输入：3 43 5 4输出：2.5 poj1064 n条线段切割成等长k段 的最大长度 in: 4 11 8.02 7.43 4.57 5.39out:2.00 (4+3+2+2=11) 展开代码 123456789101112131415161718192021222324/** * 长度为L的绳子 最多可以切 floor(L/x)段 * @param x * @return */public static boolean C(double x)&#123; int num = 0; for (int i = 0; i &lt;n ; i++) &#123; num+=(int)(lines[i]/x); &#125; return num&gt;=k;&#125;public static double howlong(double[] lines,int k)&#123; //All cables are at least 1 meter and at most 100 kilometers in length. double l = 0,h = 100001; // while ((h-l)&gt;1e-6)&#123; //可以达到10^-30的精度 for (int i = 0; i &lt;100 ; i++) &#123; double mid = (l+h)/2; if(C(mid))l = mid; else h = mid; &#125; return Math.floor(h*100)/100;&#125; tx03剪刀石头布3种排，无限张。牛妹选n张，小Qn张。依次比对，如果Q赢，Q得一分，现在已知牛妹的每一张牌和小Q的最终得分，问小Q有多少种选择卡片的方案（多少种不同的排列）？n，s（小Q的得分）牛妹的牌0石头1布2剪刀n&lt;=2000 ,s&lt;=2000 tx04 lc76有m种不同颜色的气球，编号1-m，一共n发子弹，连续开了n抢，在这n枪重打爆所有颜色的气球最少用连续几枪？输入n&lt;=1000000 m&lt;=2000一个打爆的气球颜色序列输出最短包含m个颜色气球的长度 如果无法打爆-1 tx05给n 1-n代表n个楼，第i个楼高度为i，每个楼会有一种颜色有多少种排列满足从左往右（站在左边很远的地方看）能看到L种颜色（看到了L-1次颜色的变化）答案对1e9+9取模如果两个相同颜色的楼高度分别为H1，H2(H1&lt;H2)，H1在左边，H1和H2之间的楼都比H1矮，那么左边看来是一种颜色。能看到一个楼的前提是这个楼之前的楼都比它矮。输入n L[1,1296] 1&lt;=L&lt;=nn个楼颜色 pdd 04给两个不一定合法的括号字符串，交错这两个序列，（在组成的新字符串中，每个初始字符串都保持原来的顺序）得到一个新的合法的圆括号表达式（不同的交错方式可能会得到相同的表达式，这种情况分开计数，求共有多少结果合法的交错方式（无法得到合法表达式则输出0)结果mod 10^9+7输入： 长度&lt;2500(()())输出：19 pdd 抢劫 (后缀最大值)在一条街上的有n个银行，银行在xi位置，有ai元，然后有两个抢劫犯找两个相距不小于d的银行，使得这两个银行的权值加起来最大输入：6 31 13 54 86 410 311 2输出：11 思路：用两个一维数组保存包括位置i以及i右边 money最大值和最大值的index位置：1 3 4 6 10 11利润：1 5 8 4 3 2dp1 :8 8 8 4 3 2dp2 :2 2 2 3 4 5因为位置数组有序，用二分查找当前位置w[i]相距d之后的第一个符合的位置。就可以查找dp1得到选择w[i]银行 和距离d右边可能得到的最大利润，并且用dp2得到位置。 pdd的题目银行位置不递增。可以考虑位置数组用于排序，用map记录位置和利润。1234567891011121314151617181920212223242526272829303132333435363738394041// 输出[0,n]public static int lowerBound(long[] nums, long target) &#123; if (nums == null || nums.length == 0) return -1; int lb = -1, ub = nums.length; while (lb + 1 &lt; ub) &#123; int mid = lb + (ub - lb) / 2; if (nums[mid] &gt;= target) &#123; ub = mid; &#125; else &#123; lb = mid; &#125; &#125; return ub;&#125;public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int d = sc.nextInt(); long[] w = new long[n]; Map&lt;Long,Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt;n ; i++) &#123; w[i] = sc.nextLong(); map.put(w[i],sc.nextLong()); &#125; Arrays.sort(w); long max = -1; // [i:n-1]的最大值 long[] backsmax = new long[n+1]; backsmax[n] = -1; for (int i = n-1; i &gt;= 0; i--) &#123; backsmax[i] = Math.max(backsmax[i+1],map.get(w[i])); &#125; for (int i = 0; i &lt;n ; i++) &#123; long tmp = w[i] + d; int idx = lowerBound(w, tmp); if(backsmax[idx] + map.get(w[i]) &gt; max)&#123; max = Math.max(max, backsmax[idx] + map.get(w[i])); &#125; &#125; System.out.println(max);&#125; 手串莫队算法：有n个数组成一个序列，有m个形如询问L, R的询问，每次询问需要回答区间内至少出现2次的数有哪些。 n个珠子的环，无色或有一个珠子很多种颜色，一共c种颜色，m个珠里同种颜色最多出现1次。给定n个珠的颜色输出：有多少种颜色在任意连续m个串珠中出现了至少两次。接下来n行每行的第一个数num_i(0 &lt;= num_i &lt;= c)表示第i颗珠子有多少种颜色。依次读入num_i个数字，每个数字x表示第i颗柱子上包含第x种颜色(1 &lt;= x &lt;= c)输入n=5 m=2 c=33 1 2 302 2 31 21 3输出2 思路：滑动窗口]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algBacktrack]]></title>
    <url>%2F2019%2F03%2F07%2FalgBacktrack%2F</url>
    <content type="text"><![CDATA[60 Permutation Sequence 字典序第k个排列Input: n = 3, k = 3Output: “213” 康拓展开：计算排列与字典序排名的映射关系 32 下一个排列图解https://leetcode.com/problems/next-permutation/discuss/13994/Readable-code-without-confusing-ij-and-with-explanation 思路：1）找到最后非递增的子数组725321 -&gt; 5321 已经是这4个数字排列的最大值了。2）只能增大前面的72，从5321中挑一个比2大最少的数交换，增量最小。3）交换完后变成5221反转一下变成最小。 12345678910111213141516171819202122public void nextPermutation(int[] nums) &#123; int n = nums.length; int idx = n-2; for(;idx&gt;=0;idx--)&#123; if(nums[idx] &lt; nums[idx+1])break; &#125; // idx停留在递增前一个 3 2 1 idx = -1 if(idx &gt;= 0)&#123; int mindif = Integer.MAX_VALUE; int minidx = idx + 1; // 和最右稍大那个换，这样逆序之后最小 for(int i = n-1;i &gt;= idx+1;i--)&#123; if(nums[i]&gt;nums[idx] &amp;&amp; nums[i] - nums[idx] &lt; mindif)&#123; mindif = nums[i] - nums[idx]; minidx = i; &#125; &#125; swap(nums,idx,minidx); &#125; int left = idx+1; int right = n-1; while(left&lt;right)swap(nums,left++,right--); &#125; 139 word break 用字典中的此能否拆分字符串输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 memory方法1：用set记录不能划分的位置memory方法2：用set记录划分过的单词 9ms 77% 1234567891011121314151617181920public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); HashSet&lt;String&gt; wd = new HashSet&lt;&gt;(wordDict); return canBreak(s,wd,set);&#125;private boolean canBreak(String s,Set&lt;String&gt; wordDict,Set&lt;String&gt; set)&#123; if(s.isEmpty())&#123; return true; &#125; if(set.contains(s))&#123; return false; &#125; set.add(s); for(String word : wordDict)&#123; if(s.startsWith(word) &amp;&amp; canBreak(s.substring(word.length()), wordDict, set))&#123; return true; &#125; &#125; return false;&#125; 1.状态：boolean[n+1]长度为i的前缀能否由字典组成2.初始值：[0]=true 空字符串3.转移方程if(dp[i]==true&amp;&amp;dic.contains(sub(i,i+j))) dp[i+j]=true4.结果 6ms 88%1234567891011121314public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int n = s.length(); boolean[] cb = new boolean[n+1]; cb[0] = true; for(int k = 1;k &lt; n + 1;k++)&#123; for(int st = 0;st &lt; k;st++)&#123; if(cb[st] &amp;&amp; wordDict.contains(s.substring(st,k)))&#123; cb[k] = true; break; &#125; &#125; &#125; return cb[n];&#125; 90 有重复的subset[1,2,2,2] 选不同的2得到{1,2}是重复的 次序不同得到{1,2},{2,1}是重复的先排序，再去重。关键：i!=idx 当[2,2]idx+1那次不应该被去重 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); dfs(new ArrayList&lt;&gt;(),rst,nums,0); return rst;&#125;private void dfs(List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; rst,int[] nums,int idx)&#123; rst.add(new ArrayList&lt;&gt;(tmp)); for(int i = idx;i&lt;nums.length;i++)&#123; if(i!=idx &amp;&amp; nums[i] == nums[i-1])continue; tmp.add(nums[i]); dfs(tmp,rst,nums,i+1); tmp.remove(tmp.size()-1); &#125;&#125; 还有一种迭代计数的方法//todo 78 subset 数组的子集1234567891011121314public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); back(rst,new ArrayList&lt;&gt;(),nums,0); return rst; &#125;private void back(List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; item,int[] nums,int index)&#123; rst.add(new ArrayList&lt;&gt;(item)); for(int i =index;i&lt;nums.length;i++)&#123; item.add(nums[i]); // 易错 i+1不是idx+1 back(rst,item,nums,i+1); item.remove(item.size()-1); &#125;&#125; 位运算迭代：1234567891011121314public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); int n = nums.length; for(int i = 0;i&lt;(1&lt;&lt;n);i++)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for(int j = 0;j&lt;n;j++)&#123; if(((i&gt;&gt;j)&amp;1)==1)&#123; tmp.add(nums[j]); &#125; &#125; rst.add(tmp); &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algDP]]></title>
    <url>%2F2019%2F03%2F07%2FalgDP%2F</url>
    <content type="text"><![CDATA[517 每台可同时向两边分发，使数组每个值相等的最少步数 亚马逊输入: [1,0,5]输出: 3解释:第一步: 1 0 1 1 4第二步: 1 &lt;– 1 2 1 3第三步: 2 1 2 2 2 思路2：12345678910111213141516public int findMinMoves(int[] machines) &#123; int sum = 0; for(int i: machines) sum+=i; int n = machines.length; if(sum%machines.length!=0) return -1; int avg = sum/n; int toleft = 0; int toright = 0; int rst = 0; for(int load: machines)&#123; toright += load-avg; rst = Math.max(Math.max(rst, Math.max(toleft + toright , toright )),toleft); toleft = -toright; &#125; return rst;&#125; 思路1：计算每个位置和平均值的差数组[-1,-2,3]所以1要平衡，要求第二个位置多给一个变成[0,-3,3],再往后推[0,0,0]平衡了。要关心的值是差数组的最大值（原来的差（正的最大值，因为负的最大每次可以从两边接受2个）和每次递推的差的绝对值）1234567891011public int findMinMoves(int[] machines) &#123; int total = 0; for(int i: machines) total+=i; if(total%machines.length!=0) return -1; int avg = total/machines.length, cnt = 0, max = 0; for(int load: machines)&#123; cnt += load-avg; //关键 load-avg不用绝对值 max = Math.max(Math.max(max, Math.abs(cnt)), load-avg); &#125; return max;&#125; lc312 lt168 吹气球每次吹气球i可以得到的分数为 nums[left] * nums[i] * nums[right]，Input: [3,1,5,8]Output: 167Explanation: nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; [] coins = 315 + 358 + 138 + 181 = 167思路 可以把这个问题建模成矩阵链,每次相乘之后中间一维就消失了变成5个矩阵A1(1x3)A2(3x1)A3(1,5)A4(5x8)A5(8x1)最优解是(((A1(A2xA3))A4)A5)i&gt;=j dp[i][j] = 0dp[i][j] = max(k∈[i,j]){dp[i][k]+dp[k+1][j]+nums[i-1]*nums[k]*nums[j]} 12345678910111213141516171819public int maxCoins(int[] nums) &#123; int n = nums.length; int[] arr = new int[n+2]; int[][] dp = new int[n+2][n+2]; System.arraycopy(nums, 0, arr, 1, n); arr[0] =1; arr[n+1] = 1; n = n+2; // n+1个矩阵 for (int k = 2; k &lt; n; k++) &#123; for(int left = 0;left &lt;n-k;left++)&#123; int right = left+k; for (int i = left+1; i &lt;right ; i++) &#123; dp[left][right] = Math.max(dp[left][right],arr[left]*arr[i]*arr[right] + dp[left][i]+dp[i][right] ); &#125; &#125; &#125; return dp[0][n-1]; &#125; 回溯法超时ac 1[4,1,5,10]1 如果最后是1[1]1,上一次只有两种可能性1[4,1]1,1[1,5]1。 12345678910111213141516171819public int maxCoins(int[] iNums) &#123; int[] nums = new int[iNums.length + 2]; int n = 1; for (int x : iNums) if (x &gt; 0) nums[n++] = x; nums[0] = nums[n++] = 1; int[][] memo = new int[n][n]; return burst(memo, nums, 0, n - 1);&#125;public int burst(int[][] memo, int[] nums, int left, int right) &#123; if (left + 1 == right) return 0; if (memo[left][right] &gt; 0) return memo[left][right]; int ans = 0; for (int i = left + 1; i &lt; right; ++i) ans = Math.max(ans, nums[left] * nums[i] * nums[right] + burst(memo, nums, left, i) + burst(memo, nums, i, right)); memo[left][right] = ans; return ans;&#125; 968 树形dp 监控照相机覆盖Input: [0,0,null,0,0]Output: 1Explanation 正确做法贪心dfs：，叶子节点不放，到cover不住叶子的时候再放3种状态：0.叶子节点 ： left和right返回状态都是21.子节点有个叶子 ++,放照相机，被覆盖2.null / 子节点有个有照相机 ：没有照相机但是被覆盖 考虑如果dfs返回就是叶子节点状态，need没有增加，要手动+1123456789101112131415161718int need = 0;public int minCameraCover(TreeNode root) &#123; if(dfs(root)==0)return need+1; return need;&#125;private int dfs(TreeNode root)&#123; if(root == null)return 2; int left = dfs(root.left); int right = dfs(root.right); if(left == 0 || right == 0)&#123; need++; return 1; &#125; if(left == 1 ||right == 1)return 2; else if(left == 2 &amp;&amp;right == 2)return 0; // return什么都行 else return 0;&#125; dp[3]记录3种状态当前节点及子树放的照相机数量。状态1：子树已经cover，这个节点还没状态2：子树和这个节点被cover，不放照相机状态3：子树和这个节点被cover，在此放置照相机（可能cover父节点）12345678910111213public int minCameraCover(TreeNode root) &#123; int[] rst = solve(root); return Math.min(rst[1],rst[2]);&#125; public int[]solve(TreeNode node)&#123; if(node == null)return new int[]&#123;0,0,1&#125;; // left not cover , left cover , left parent covered int[] l = solve(node.left); int[] r = solve(node.right); return new int[]&#123;l[1]+r[1], Math.min(l[0]+r[0]+1, Math.min(l[2]+r[1],l[1]+r[2])), Math.min(l[0],l[1])+Math.min(r[0],r[1])+1&#125;;&#125; lg p1352337 树形house robber 不能抢相邻层123456789Input: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. 每个节点有两种状态，偷或者不偷，保存的是当前节点及以下的最大利润12345678910111213public int rob(TreeNode root) &#123; int[] rst = robb(root); return Math.max(rst[0],rst[1]); &#125; private int[] robb(TreeNode root)&#123; if(root == null)return new int[2]; int[] rst = new int[2]; int[] left = robb(root.left); int[] right = robb(root.right); rst[0] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]); rst[1] = root.val+left[0]+right[0]; return rst; &#125; 派间谍 二维背包1 lg 1910https://www.luogu.org/problemnew/show/P1910 称砝码 多重背包1nowcoder利用给定的数量的砝码可以称出的不同的重量数21 22 1输出5 123456789101112131415161718192021public static int fama(int n, int[] weight, int[] nums)&#123; int sum = 0; for (int i = 0; i &lt;n ; i++) &#123; sum += weight[i]*nums[i]; &#125; boolean[][] dp = new boolean[n+1][sum+1]; dp[0][0] = true; for (int i = 0; i &lt;n ; i++) &#123; // 使用这个物品，尝试凑出这个总量，并且尝试使用几个 for (int j = 0; j &lt;=sum ; j++) &#123; for (int k = 0; k &lt;= nums[i] &amp;&amp; k*weight[i]&lt;=j ; k++) &#123; dp[i+1][j] |= dp[i][j-k*weight[i]]; &#125; &#125; &#125; int cnt = 0; for (int i = 0; i &lt;=sum ; i++) &#123; if(dp[n][i])cnt++; &#125; return cnt;&#125; 击鼓传花每个同学都可以把花传给自己左右的两个同学中的一个（左右任意）有多少种不同的方法可以使得从小赛手里开始传的花，传了m次以后，又回到小赛手里。对于传递的方法当且仅当这两种方法中，接到花的同学按接球顺序组成的序列是不同的，才视作两种传花的方法不同。比如有3个同学1号、2号、3号，并假设小赛为1号，花传了3次回到小赛手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 746. Min Cost Climbing Stairs付钱可以跳1阶或者2阶台阶。可以从第0阶或者第1阶开始Input: cost = [10, 15, 20]Output: 15dp定义为离开第i个台阶的最小花费，递推到离开第min(dp[n-2],dp[n-1])个楼梯 dp定义为 到达第n阶楼梯的最小花费12345678public int minCostClimbingStairs(int[] cost) &#123; int n = cost.length; int[] dp = new int[n+1]; for(int i = 2;i&lt;=n;i++)&#123; dp[i] += Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); &#125; return dp[n]; &#125; 491 复制或者复制一半长度到n的最少操作次数字符串“A”，有两种操作1）copyall 设定当前长度为一次粘贴的长度 C = K2）粘贴n次copy长度 K += C如何最快得到长度N这道题就是将N分解为M个数字的乘积，且M个数字的和最小输入: 3输出: 3解释:最初, 我们只有一个字符 ‘A’。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 ‘AA’。第 3 步, 我们使用 Paste 操作来获得 ‘AAA’。1-&gt;0,2-&gt;cp(2),3-&gt;cpp(3),4-&gt;cpcp(4),5-&gt;cp(AA)ppp(5),6cppcp(5) 求n的所有质因数之和。// 6可以通过长度3的复制，再递归得到3需要多少步。思路：从长度为2开始试（？）12345678910public int minSteps(int n) &#123; int s = 0; for (int d = 2; d &lt;= n; d++) &#123; while (n % d == 0) &#123; s += d; n /= d; &#125; &#125; return s;&#125; 91 1-26数字对应26个字母，问一个数字对应多少种解码方式226-&gt;2(B)2(B)6(F),22(V)6(F),2(B)26(Z) 3.dp[i]表示s[0..i]的解码方式关键：1）长度为0的时候解码方式为12）判断前1位数字和前2位的合法性，加上前i-1,i-2长度的方案数3）越过012345678910111213public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0)!='0'?1:0; for(int i =2;i&lt;=n;i++)&#123; int one = Integer.valueOf(s.substring(i-1,i)); if(one &lt;10 &amp;&amp; one &gt;0)dp[i] += dp[i-1]; int two = Integer.valueOf(s.substring(i-2,i)); if(two &lt;=26 &amp;&amp; two &gt;=10)dp[i] += dp[i-2]; &#125; return dp[n];&#125; 展开代码 1递归：8%12345678910111213141516Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();public int numDecodings(String s)&#123; if(s.length()&lt;1)return 1; if(map.containsKey(s))return map.get(s); if(s.charAt(0)=='0')return 0; if(s.length()==1)return 1; // 取一个数字之后的解码方式 w = numDecodings(s.substring(1)); // 取两个数字之后的解码方式 int pre2 = Integer.parseInt(s.substring(0,2)); if(pre2&lt;=26)&#123; w+=numDecodings(s.substring(2)); &#125; map.put(s,w); return w;&#125; 2递归改成index 63%123456789101112131415public int numDecodings(String s)&#123; return help(s,0,s.length()-1); &#125;private int help(String s,int l,int r)&#123; if(l&gt;s.length()-1)return 1; if(s.charAt(0)=='0')return 0; if(l&gt;=r)return 1; w = help(s,l+1,r); int pre2 = (s.charAt(l)-'0')*10+s.charAt(l+1)-'0'; if(pre2&lt;=26)&#123; w+=help(s,l+2,r); &#125; map2.put(l,w); return w;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algString]]></title>
    <url>%2F2019%2F03%2F05%2FalgString%2F</url>
    <content type="text"><![CDATA[Sliding Window76 Minimum Window Substring30 Substring with Concatenation of All Words3395159lt 386 lc 340 Longest Substring with At Most K Distinct Characters 最多有k个不同字符的最长子字符串输入: S = “eceba” 并且 k = 3输出: 4解释: T = “eceb” 1234567891011121314151617181920212223242526272829public int lengthOfLongestSubstringKDistinct(String s, int k) &#123; int n = s.length(); int e = 0;int ss = 0; int[] ch = new int[256]; if(k == 0)return 0; int cnt = 0; int rst = 0; while (e&lt;n)&#123; char c = s.charAt(e); if(ch[c]==0)&#123; cnt++; ch[c]++; while (ss &lt;e &amp;&amp; cnt &gt; k) &#123; rst = Math.max(rst,e-ss); char cs = s.charAt(ss); ch[cs]--; if (ch[cs] == 0) cnt--; ss++; &#125; &#125;else&#123; ch[c]++; &#125; if(cnt&lt;=k)&#123; rst = Math.max(rst,e-ss+1); &#125; e++; &#125; return rst;&#125; 925 是否是因长按重复的字符串 Input: name = “leelee”, typed = “lleeelee”Output: true 双指针1234567891011121314151617181920212223public boolean isLongPressedNameCnt(String name, String typed) &#123; int ls1 = name.length(); int ls2 = typed.length(); if (ls1 &lt; 1 || ls2 &lt; ls1) &#123; return false; &#125; int p2 = 0; int p1 = 0; while (p2 &lt; ls2)&#123; if(p1 &lt; ls1 &amp;&amp; name.charAt(p1) == typed.charAt(p2))&#123; p1++; p2++; &#125; // 关键 p1已经到下一个不相同的字符了，p2还在上一个 else if(p1&gt;0 &amp;&amp; name.charAt(p1-1) == typed.charAt(p2))&#123; p2++; &#125; // 关键 else return false; &#125; return p1 == ls1;&#125; 459 Repeated Substring Pattern 子串重复N次 S = N*TInput: “ababab”Output: TrueExplanation: It’s the substring “ab” 3次. abcabc abcabc -&gt; b|c[abcabc]a|b1234public boolean repeatedSubstringPattern(String str) &#123; String s = str + str; return s.substring(1, s.length() - 1).contains(str);&#125; 151. Reverse Words in a StringInput: “ hello world! “Output: “world! hello” 115 Distinct Subsequences 计算在S的子序列中T出现的次数Input: S = “rabbbit”, T = “rabbit”Output: 3 关键：dp初始化T长度为0的时候匹配数量是1dp[i][j] S[0,i)和T[0,j)的匹配数量123456789101112131415161718public int numDistinct(String s, String t) &#123; int n = s.length(); int m = t.length(); int[][] dp = new int[n+1][m+1]; // 当t=”“ for (int i = 0; i &lt;=n ; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 1; j &lt;=m ; j++) &#123; if(s.charAt(i-1) == t.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; &#125;else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[n][m];&#125; 392 Is Subsequence 判断是否是子序列Example 1:s = “abc”, t = “ahbgdc”Return true. 123456789101112131415public boolean isSubsequence(String s, String t) &#123; int n1 = s.length(); int n2 = t.length(); int p1 = 0; int p2 = 0; while(p1&lt;n1)&#123; while(p2&lt;n2 &amp;&amp; s.charAt(p1) != t.charAt(p2))p2++; if(p2 &gt;= n2)return false; if(s.charAt(p1) == t.charAt(p2))&#123; // 注意p2也要++ p2++; p1++; &#125; &#125; return p1&gt;=n1;&#125; 344. Reverse String 逆转char数组Input: [“h”,”e”,”l”,”l”,”o”]Output: [“o”,”l”,”l”,”e”,”h”] 熟练12345678910public void reverseString(char[] s) &#123; int j = s.length-1; int i = 0; while(i&lt;j)&#123; char tmp = s[j]; s[j] = s[i]; s[i] =tmp; i++;j--; &#125;&#125; 383 Ransom Note 从str2中选字符可以组成str1canConstruct(“aa”, “ab”) -&gt; falsecanConstruct(“aa”, “aab”) -&gt; true 熟练展开代码 123456789101112131415public boolean canConstruct(String str1, String str2) &#123; int[] cnt = new int[26]; int n = str1.length(); int m = str2.length(); if(n&gt;m)return false; for(int i = 0;i&lt;m;i++)&#123; cnt[str2.charAt(i)-'a']++; if(i&lt;n) cnt[str1.charAt(i)-'a']--; &#125; for(int i:cnt)&#123; if(i &lt;0)return false; &#125; return true;&#125; 387. First Unique Character in a String 第一个不同的字符位置s = “leetcode”return 0. 思路：扫描两遍字符串找到频率为1的直接return较熟练123456789public int firstUniqChar(String s) &#123; int freq [] = new int[26]; for(int i = 0; i &lt; s.length(); i ++) freq [s.charAt(i) - 'a'] ++; for(int i = 0; i &lt; s.length(); i ++) if(freq [s.charAt(i) - 'a'] == 1) return i; return -1;&#125; 58. Length of Last Word 最后一个单词的长度Input: “Hello World”Output: 5 注意空字符的坑12345678public int lengthOfLastWord(String s) &#123; int cnt =0; for(int i = s.length()-1;i&gt;=0;i--)&#123; if(cnt &gt;0 &amp;&amp; s.charAt(i) ==' ')return cnt; else if(s.charAt(i)!=' ')cnt++; &#125; return cnt;&#125; 14. Longest Common Prefix 字符串数组最长前缀Input: [“flower”,”flow”,”flight”]Output: “fl” 不断缩短第一个单词的长度1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return ""; String pre = strs[0]; int i = 1; while(i &lt; strs.length)&#123; while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); i++; &#125; return pre;&#125; 有bug要调展开代码 1234567891011121314public String longestCommonPrefix(String[] strs) &#123; if(strs.length&lt;1)return ""; int minlen = Integer.MAX_VALUE; for(String s:strs)&#123; minlen = Math.min(minlen,s.length()); &#125; for(int i =1;i&lt;strs.length;i++)&#123; if(!strs[i-1].substring(0,minlen).equals(strs[i].substring(0,minlen)))&#123; minlen--; i=0; &#125; &#125; return strs[0].substring(0,minlen);&#125; 28字符串indexOf匹配暴力 Substring SearchInput: haystack = “hello”, needle = “ll”Output: 2 1234567891011public int strStr(String str1, String str2) &#123; for(int i =0;;i++)&#123; for(int j = 0;;j++)&#123; if(j == str2.length())return i; if(i+j == str1.length())return -1; if(str1.charAt(i+j)!=str2.charAt(j))&#123; break; &#125; &#125; &#125;&#125; 各种字符串匹配算法http://www-igm.univ-mlv.fr/~lecroq/string/https://algs4.cs.princeton.edu/53substring/方法1是维持一个pattern长度的buffer流的情况下 没有backup123ADA B RACADA[C]R i-=j ADACR !!!Boyer-Moore 74% 5ms 亚线性alg41.构建right表示target中字符的最右位置是NEEDLE2.source从左到右扫描，target从右向左如果出现不匹配T是target里没有的，i到j+1如果出现不匹配N是target里的，则用right，将target里N的位置和它对齐当前j=3,right[‘N’] = 0,skip=3第三种情况，至少保证i不能回退 123456789101112131415161718192021222324 public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int[] right = new int[R]; for (int c = 0; c &lt; R; c++) right[c] = -1; for (int j = 0; j &lt; target.length(); j++) right[target.charAt(j)] = j; int m = target.length(); int n = source.length(); int skip; for (int i = 0; i &lt;= n - m; i += skip) &#123; skip = 0; for (int j = m-1; j &gt;= 0; j--) &#123; if (target.charAt(j) != source.charAt(i+j)) &#123; skip = Math.max(1, j - right[source.charAt(i+j)]); break; &#125; &#125; if (skip == 0) return i; &#125; return -1;&#125; RabinKarp 31% 8ms 线性 正确性：线性求mod123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// private long longRandomPrime()&#123;// BigInteger prime = BigInteger.probablePrime(31,new Random());// return prime.longValue();// &#125;int R = 256;long q;private long hash(String key, int m) &#123; long h = 0; for (int j = 0; j &lt; m; j++) h = (R * h + key.charAt(j)) % q; return h;&#125; //变成拉斯维加斯算法private boolean check(String source,String target, int i) &#123; for (int j = 0; j &lt;target.length() ; j++) if (target.charAt(j) != source.charAt(i + j)) return false; return true;&#125;public int searchRabinKarp(String source,String target)&#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int m = target.length(); int n = source.length(); long RM = 1; q = 1877124611;//保证不冲突 for (int i = 1; i &lt;=m-1 ; i++) &#123; RM = (R * RM) % q; &#125; long patHash = hash(target,m); long txtHash = hash(source, m); //一开始就匹配成功 if ((patHash == txtHash) &amp;&amp; check(source,target, 0)) return 0; // check for hash match; if hash match, check for exact match for (int i = m; i &lt; n; i++) &#123; // Remove leading digit, add trailing digit, check for match. txtHash = (txtHash + q - RM*source.charAt(i-m) % q) % q; txtHash = (txtHash*R + source.charAt(i)) % q; // match int offset = i - m + 1; if ((patHash == txtHash) &amp;&amp; check(source, target,offset)) return offset; &#125; // no match return -1;&#125; 暴力 O（MN）双指针i的位置是txt已匹配过的最后位置15% 13ms123456789101112131415public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(source==null||source.length()==0)return 0; int i,N = source.length(); int j,M = target.length(); for (i = 0,j=0; i &lt;N&amp;&amp;j&lt;M ; i++) &#123; if(source.charAt(i)==target.charAt(j))j++; else&#123; i-=j; j=0; &#125; &#125; if(j==M)return i-M; else return -1;&#125; 按indexOf简化 43% 7ms12345678910111213141516171819202122public int strStr(String source, String target) &#123;if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int lens = source.length(); int tar = target.length(); char[] targetArr = target.toCharArray(); char[] sourceArr = source.toCharArray(); char first = targetArr[0]; int max = lens-tar; for (int i = 0; i &lt;= max ; i++) &#123; if(sourceArr[i]!=first)&#123; while (++i&lt;=max&amp;&amp;sourceArr[i]!=first); &#125; if(i&lt;=max)&#123; int j = i+1; int end = j+tar-1; for (int k = 1; j &lt;end&amp;&amp;sourceArr[j]==targetArr[k] ; k++,j++) ; if(j == end)return i; &#125; &#125; return -1;&#125; java indexOf实现 最长公共前缀：indexOf73% 5ms123public int strStr(String source, String target) &#123; return indexOf( source.toCharArray(),0,source.length(),target.toCharArray(),0,target.length(),0);&#125; 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*@param source:左值（被查找）@param count长度*/ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; // 查找位置&gt;=左值长度 if (fromIndex &gt;= sourceCount) &#123; //traget空？返回左值长度 return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; // 右值为0，返回查找位置 if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; //最后一个匹配的下标，至少减去右值的长度 int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍给定的一个长度为N的字符串str,查找长度为P(P&lt;N)的字符串在str中的出现次数.下面的说法正确的是()正确答案: D 你的答案: D (正确)不存在比最坏时间复杂度O(NP)好的算法不存在比最坏时间复杂度O(N^2)好的算法不存在比最坏时间复杂度O(P^2)好的算法存在最坏时间复杂度为O(N+P)的算法存在最坏时间复杂度为O(log(N+P))的算法以上都不对 KMP匹配算法 时间复杂度为O（N+P） 基于DFA用一个dfa[][]记录j回退多远1对target构建dfa构造DFA的时间是O（MR）的，可以对每个状态设置一个匹配/非匹配去掉R9ms 24%12345678910111213141516171819202122232425262728293031323334public static int serachByKMP(String source,String target)&#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int M = target.length(); int N = source.length(); int[] dfa = new int[M]; int k = 0; dfa[0] =0; //For the pattern “AAACAAAAAC”, //lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] for (int i = 1; i &lt; M; i++) &#123; while (k&gt;0&amp;&amp;target.charAt(k)!=target.charAt(i)) k = dfa[k-1]; if(target.charAt(k)==target.charAt(i))&#123; k++; &#125; dfa[i]=k; &#125; int q = 0; //[0, 0, 0, 1, 0] //"mississippi", // "issip" q=4 i=5 dfa[3]=1 // "issip" q=1 i=5 // "issip" for (int i = 0; i &lt;N ; i++) &#123; while(q&gt;0&amp;&amp;target.charAt(q)!=source.charAt(i)) q = dfa[q-1]; if(target.charAt(q)==source.charAt(i)) q++; if(q==M) return i-M+1; &#125; return -1;&#125; 2.对source遍历一遍dfa12.44% 39ms12345678910111213141516171819202122public int strStr(String source, String target) &#123; if(source.length()&lt;target.length())return -1; if(target==null||target.length()==0)return 0; int R = 256; int M = target.length(); int[][] dfa = new int[R][M]; //构建DFA dfa[target.charAt(0)][0] =1; for(int X = 0,j=1;j&lt;M;j++)&#123; for (int c = 0; c &lt; R; c++) dfa[c][j] = dfa[c][X];//复制上一列匹配失败 dfa[target.charAt(j)][j] = j+1;//更新匹配成功 X = dfa[target.charAt(j)][X];//重启状态 &#125; //模拟一遍DFA int i,j,N = source.length(); for (i = 0,j=0; i &lt; N&amp;&amp;j&lt; M; i++) &#123; j = dfa[source.charAt(i)][j]; &#125; if(j==M) return i-M; else return -1;&#125; 文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。1 子序列 不连续 2 字串 连续KMP:getIndexOfd之前【最长前缀】和【最长后缀】的匹配长度(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)所以最长匹配是3：abc,记录在d位置上int[]next = f(“abcabcd”)={-1,0,0,1，2，3}关键加速求解匹配]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algArr]]></title>
    <url>%2F2019%2F03%2F04%2FalgArr%2F</url>
    <content type="text"><![CDATA[lt912 最佳见面地点 meeting point现在有三人分别居住在(0,0), (0,4), 和 (2,2)123451 - 0 - 0 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0 点(0, 2)是最佳见面地点，最小的路程总和为2+2+2=6，返回6。 思路：只要见面地点在A,B中间，到A,B的花费都是 AB长度。把横/纵坐标排序，每次取最大最小的两个，差就是AB。 1234567891011121314151617181920212223242526public int minTotalDistance(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; List&lt;Integer&gt; cols = new ArrayList&lt;&gt;(); List&lt;Integer&gt; rows = new ArrayList&lt;&gt;(); for(int i =0;i&lt;n;i++)&#123; for(int j = 0;j&lt;m;j++)&#123; if(grid[i][j] == 1)&#123; cols.add(j); rows.add(i); &#125; &#125; &#125; cols.sort(Integer::compareTo); rows.sort(Integer::compareTo); int sum = 0; int l = 0; for(int i =0;i&lt;cols.size()/2;i++)&#123; sum += cols.get(cols.size()-1 - i)-cols.get(i); &#125; for(int i =0;i&lt;rows.size()/2;i++)&#123; sum += rows.get(rows.size()-1 - i)-rows.get(i); &#125; return sum;&#125; 462 选一个数字 +1 / -1 元素相等的最小步数Input:[1,2,3] Output:2 1234567891011public int minMoves2(int[] nums) &#123; Arrays.sort(nums); int i = 0, j = nums.length-1; int count = 0; while(i &lt; j)&#123; count += nums[j]-nums[i]; i++; j--; &#125; return count;&#125; 719 数组中两两匹配，第k小的两数之差nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。 532 数组中有几个相差k的pair输入: [3, 1, 4, 1, 5], k = 2输出: 2解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。 set的解法33% //todo比双指针慢 220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素 Input: nums = [1,2,3,1], k = 3, t = 0Output: true 2.桶 1.40% 用容量k的TreeSet,超过k删除最左判断能否和ceiling合floor&lt;=t如果不能 放入treeset等待 219 是否有重复元素 下标相差&lt;=kInput: nums = [1,2,3,1], k = 3Output: true 放进一个FIFO大小为(k+1) 相差k 的set，当有add失败的时候就true 数对x和y均不大于n, 并且x除以y的余数大于等于k，一共有多少对(x,y)输入：5 2输出：7满足条件的数对有(2,3),(2,4),(2,5),(3,4),(3,5),(4,5),(5,3)思路：如果 y &gt; x 能产生的余数是1-(y-1), 所以y&gt;k，并且产生的余数&gt;=k的有(y-k)个对于一个y，n个数字产生的完整余数区间有n/y个y = 3 -&gt; +2 (2,3)(5,3) 1-5的余数 1 2 0| 1 2y = 4 -&gt; +2 (2,4)(3,4) 1-5的余数 1 2 3 0 | 1y = 5 -&gt; +3 (2,5)(3,5)(4,5) 1-5的余数 1 2 3 4 | 0对于最后一个区间不满y个数，最后一个区间&gt;=k的个数是n%y+1-k ,例如5%3-&gt;2最后一个循环有2个符合的 特殊情况如果k=0 xy可以相等n*n个12345678910111213141516public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); int k = sc.nextInt(); if(k == 0)System.out.println(n*n); else &#123; long cnt = 0; for (int y = k + 1; y &lt;= n; y++) &#123; cnt += (n / y) * (y - k); if (n % y &gt;= k) &#123; cnt += (n % y) + 1 - k; &#125; &#125; System.out.println(cnt); &#125;&#125; 215 Kth Largest Element in an ArrayInput: [3,2,1,5,6,4] and k = 2Output: 5 用快排用头中尾的中位数最快。找第k个最大，就是找下标为k = len-k = 4的数字 12345678910111213141516171819202122232425public int findKthLargest(int[] nums,int k)&#123; k = nums.length-k; int l = 0; int r = nums.length-1; while(l&lt;r)&#123; int idx = part(nums,l,r); if(idx&lt;k)l=idx+1; else if(idx&gt;k) r = idx-1; else break; &#125; return nums[k];&#125;// 闭区间[l,r],r作为pivotprivate int part(int[] nums,int l,int r)&#123; int i = l-1; int j = r; while(true)&#123; while(++i&lt;j&amp;&amp;nums[i]&lt;nums[r]); while(--j&gt;i&amp;&amp;nums[r]&lt;nums[j]); if(i&gt;=j)break; swap(nums,i,j); &#125; swap(nums,r,i); return i;&#125; 376. Wiggle Subsequence 最长摇摆序列Input: [1,17,5,10,13,15,10,5,16,8]Output: 7One is [1,17,10,13,10,16,8].第一个差能正能负，差正负交替的最长子序列。 贪心：12345678910public int wiggleMaxLength(int[] nums) &#123; if (nums == null) return 0; if (nums.length &lt;= 1) return nums.length; int f = 1, b = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[i-1]) f = b + 1; else if (nums[i] &lt; nums[i-1]) b = f + 1; &#125; return Math.max(f, b);&#125; 正确做法：动态规划只要记住-1位置上的最大值就好了12345678910111213141516public int wiggleMaxLength(int[] nums) &#123; if(nums == null)return 0; int n = nums.length; if(n &lt; 2)return n; int predif = 0; int cnt = 1; for(int i =1;i&lt;n;i++)&#123; int dif = nums[i] - nums[i-1]; if(dif &gt;0 &amp;&amp; predif &lt;=0 || dif &lt;0 &amp;&amp; predif &gt;=0)&#123; cnt++; predif = dif; &#125; &#125; return cnt; &#125; ！974 和整除k的子数组个数Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 1)用前缀和可以快速得到区间和P = [0,4,9,9,7,4,5],2）如果(sums[i] - sums[j]) % K == 0，说明sums[i]和sums[j]都是K的倍数，所以得出sums[i] % K == sums[j] % K例如：%K ==0的位置 [0]和[6] 得到子数组[4, 5, 0, -2, -3, 1]同余的如果有4个，两两组合的位置数有C(4,2)=6 注意：presum为负数的时候，取模应该(p % K + K) % K-1 % 5 = -1, but we need the positive mod 4例如presum[1] = -1 presum[4] = 41234567891011121314151617public int subarraysDivByK(int[] A, int K) &#123; int n = A.length; int rst = 0; int[] presum = new int[n+1]; //[1]-[0] = pre[0:1) for(int i =0;i&lt;n;i++)&#123; presum[i+1] = presum[i]+A[i]; &#125; int[] mod = new int[K]; for(int p:presum)&#123; mod[((p%K)+K)%K]++; &#125; for(int c:mod)&#123; rst += (c*(c-1))/2; &#125; return rst;&#125; 209最小连续子数组 和&gt;=K 的长度Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] 123456789101112131415public int minSubArrayLen(int s, int[] nums) &#123; int n = nums.length; int e = 0; int st = 0; int minl = n+1; int sum = 0; while(e &lt; n)&#123; sum += nums[e++]; while (st&lt;=e&amp;&amp;sum&gt;=s) &#123; minl = Math.min(minl, e - st); sum -= nums[st++]; &#125; &#125; return minl==n+1?0:minl;&#125; 1 二分搜索暴力法搜索前缀数组sum[j]-sum[i]+nums[i]&gt;=k的最短ij二分发寻找sum[j] &gt;= sum[i]-nums[i]+k j的最小值 560 数组中有多少个和为k的子数组输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 同930 一模一样,查找可以组成k的前缀，计数前缀69%展开代码 123456789101112public int subarraySum(int[] nums, int k) &#123; int psum = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int cnt =0; for(int i =0;i&lt;nums.length;i++)&#123; psum += nums[i]; cnt += map.getOrDefault(psum - k,0); map.put(psum,map.getOrDefault(psum,0)+1); &#125; return cnt;&#125; 930 01数组中有多少个和=target的子数组输入：A = [0,0,0,0,0], S = 0输出：15 5+4+3+2+1 思路： 计算前缀和[1,1,2,2,3]并放入map计数,{1:2,2:2,3:1}步骤[0,0,0,0,0] 初始化map{0:1},扫描到第一个0,查找map中S-0=0有几个，cnt=1,更新map{0:2} ,扫描到第二个0，cnt=1+2…最后一个0，cnt+1+2+3+4+5 = 1512345678910111213public int numSubarraysWithSum(int[] A, int S) &#123; Map&lt;Integer, Integer&gt; c = new HashMap&lt;&gt;(); c.put(0, 1); int psum = 0, res = 0; for (int i : A) &#123; psum += i; // 查找前缀 res += c.getOrDefault(psum - S, 0); // 当前前缀计数 c.put(psum, c.getOrDefault(psum, 0)+1); &#125; return res;&#125; 713 乘积&lt;k的子数组的个数Input: nums = [10, 5, 2, 6], k = 100Output: 8Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. 输入[1,2,3,4] k = 10当s = 0,e = 0 窗口只有[1]窗口乘积p = 1 ，子数组个数 1 :[1] s = 0,e = 1 窗口[1,2]p = 2 子数组个数3: [[1], [2],[1,2]] (+2) s = 0,e = 2 窗口[1,2,3]p = 6 子数组个数3: [[1],[2][1,2], [3],[2,3],[1,2,3]] (+3) 每次子数组的增长个数就是窗口大小如果 p &gt;k 则s向右s = 1,e = 3 窗口[2,3,4]p = 24s = 2,e = 3窗口[3,4]p = 12 子数组个数[[3], [4][3,4]]] (+2) 展开代码 12345678910111213141516 public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int n = nums.length; int s = 0; int e = 0; int p = 1; int rst = 0; //[2]+1 [2,3] +2 [2,3,4]-&gt;[3,4]+2 while(e&lt;n)&#123; p *= nums[e++];// e = 1 while(s&lt;e &amp;&amp; p&gt;=k)&#123; p /= nums[s++]; &#125;// s = 0 rst += (e-s); &#125; return rst;&#125; 1234567891011121314public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int p = 1; int cnt =0; for(int s = 0, e = 0; e &lt; nums.length;e++)&#123; p *= nums[e]; while(p&gt;=k &amp;&amp; s&lt;e)&#123; p /= nums[s++]; &#125; if(p &lt; k)&#123; cnt += (e - s + 1); &#125; &#125; return cnt;&#125; 862 和至少为K的最短子数组Input: A = [2,-1,2], K = 3Output: 3 思路：用前缀和找区间和，关键：递增有序栈，用当前值更新队尾，如果当前的presum比队尾presum小，则下一个减这个得到的区间更短而且值更大。 12345678910111213141516171819202122232425262728public int shortestSubarrayWindow(int[] A, int K) &#123; int n = A.length; long[] presum = new long[n+1]; for (int i = 0; i &lt;n ; i++) &#123; if(A[i] &gt;=K)return 1; presum[i+1] = presum[i] +A[i]; &#125; int minlen = n+1; Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt;n ; i++) &#123; while (deque.size() &gt;0 &amp;&amp; presum[i] - presum[deque.getFirst()] &gt;= K)&#123; minlen = Math.min(minlen, i-deque.pollFirst()); &#125; // 关键 while (deque.size() &gt; 0 &amp;&amp; presum[i] &lt;= presum[deque.getLast()])&#123; deque.pollLast(); &#125; deque.addLast(i); &#125; return minlen == n+1?-1:minlen;&#125; 283 Move Zeroes 所有0移到后面把0都放到后面并且保证原来顺序不变。 没有额外空间。Input: [0,1,0,3,12]Output: [1,3,12,0,0]思路：两个指针，如果找到非零，则和前面那个指针的交换j保证左边没有0，扫一遍i保证所有的非0都移到j的左边。011-&gt;101-&gt;1101234567public void moveZeroes(int[] nums) &#123; for(int i = 0,j =0; i &lt; nums.length; i++) &#123; if(nums[i] != 0) &#123; swap(nums,i,j++); &#125; &#125;&#125; 优化点：如果数组全部都是非零元素，每个元素都自己和自己交换了，防止自己和自己交换这种操作：123456789public void moveZeroes(int[] nums) &#123; for(int i = 0,j =0; i &lt; nums.length; i++) &#123; if(nums[i] != 0) &#123; if(i!=j) swap(nums,i,j++); else j++; &#125; &#125;&#125; 88 Merge Sorted ArrayInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 12345public void merge(int A[], int m, int B[], int n) &#123; int i=m-1, j=n-1, k=m+n-1; while (i&gt;-1 &amp;&amp; j&gt;-1) A[k--]= (A[i]&gt;B[j]) ? A[i--] : B[j--]; while (j&gt;-1) A[k--]=B[j--];&#125; 展开代码 123456789101112public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int len = m+n-1; int i = m-1; int j = n-1; while(len&gt;=0)&#123; if(j&lt;0 || (i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp; nums1[i] &gt;= nums2[j]))&#123; nums1[len--] = nums1[i--]; &#125;else if(i&lt;0 || (i&gt;=0 &amp;&amp; j&gt;=0 &amp;&amp; nums1[i] &lt; nums2[j])) &#123; nums1[len--] = nums2[j--]; &#125; &#125;&#125; 75 ！!！Sort ColorsInput: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] 不会！思路：left 左边都是0 是1right 右边都是2 right是0/1 用idx遍历，1）如果从left开始是1，可以后移，保证00011是正确的顺序2）如果是2，和right换，right–，因为idx是后面的数字还没遍历，所以idx不动3）如果是0，和left换，但是left是肯定对的，所以idx++，left被换成0了，保证了左边是0，left++。4）注意终止条件，因为right可能是0，所以当i==right的时候还可能跟right换一下，直到i&gt;right123456789101112131415public void sortColors(int[] nums) &#123; int n = nums.length; int left = 0; int right = n-1; int i = 0; while(i &lt;= right)&#123; if(nums[i] == 0)&#123; swap(nums,i++,left++); &#125; else if(nums[i] == 2)&#123; swap(nums,i,right--); &#125;else i++; &#125;&#125; 228 Summary Ranges输入: [0,1,2,4,5,7]输出: [“0-&gt;2”,”4-&gt;5”,”7”] 217 Contains Duplicate判断数组中是否有重复元素Input: [1,2,3,1]Output: true1)两个for循环2）排序3）set 275 H-Index II排好序的h-indexInput: citations = [0,1,3,5,6]Output: 3 274 H-Index所有学术文章N中有h篇论文分别被引用了至少h次，他的H指数就是h.其他N-h篇论文都没有h次引用Input: citations = [3,0,6,1,5]Output: 3解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 AC 方法不对正确做法：桶计数1234567891011121314public int hIndex(int[] citations) &#123; int n = citations.length; int[] cnt = new int[n+1]; for(int ci : citations)&#123; if(ci &gt; n)cnt[n]++; else cnt[ci]++; &#125; int rst = 0; for(int i = n;i&gt;=0;i--)&#123; rst+=cnt[i]; if(rst &gt;= i)return i; &#125; return 0;&#125; 485 Max Consecutive Ones 最多连续的1Input: [1,1,0,1,1,1]Output: 3 AC1234567891011121314public int findMaxConsecutiveOnes(int[] nums) &#123; int cnt = 0; int max = 0; for(int i =0;i&lt;nums.length;i++)&#123; if(nums[i] != 1 &amp;&amp; cnt&gt;0)&#123; max = Math.max(max,cnt); cnt =0; &#125;else if(nums[i] ==1)&#123; cnt++; &#125; &#125; max = Math.max(max,cnt); return max;&#125; 229 Majority Element II找到所有出现次数超过 ⌊ n/3 ⌋ 次的数字Input: [3,2,3]Output: [3] 不会思路：1）超过n/3的数最多只能有2个 注意顺序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public List&lt;Integer&gt; majorityElement(int[] nums) &#123; int n = nums.length; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); int r1 = 0;int r2 = 0; int cnt1 = 0;int cnt2 = 0; for(int num:nums)&#123; if(num == r1)&#123; cnt1++; &#125; else if(num == r2)&#123; cnt2++; &#125;else if(cnt1 == 0)&#123; r1=num; cnt1++; &#125;else if(cnt2 == 0)&#123; r2 = num; cnt2++; &#125; else&#123; cnt1--; cnt2--; &#125; &#125; cnt1 = 0;cnt2 = 0; for(int num:nums)&#123; if(num == r1)&#123; cnt1++; if(cnt1&gt;n/3)&#123; rst.add(r1); break; &#125; &#125; &#125; if(r2== r1)return rst; for(int num:nums)&#123; if(num == r2)&#123; cnt2++; if(cnt2&gt;n/3)&#123; rst.add(r2); break; &#125; &#125; &#125; return rst; &#125; !!!169 众数 Boyer-Moore Voting AlgorithmInput: [3,2,3]Output: 3 关键：计数变量123456789101112131415public int majorityElement(int[] nums) &#123; int rst = 0; int cnt =0; for(int num:nums)&#123; if(cnt == 0)&#123; rst = num; &#125; if(rst != num)&#123; cnt--; &#125;else&#123; cnt++; &#125; &#125; return rst;&#125; 展开代码 1.hashmap,直到有计数&gt;n/2 break-&gt;return 11%2.随机数44% 因为一半以上都是这个数，可能只要循环两边就找到了1234567891011public int majorityElement(int[] nums)&#123; Random random = new Random(System.currentTimeMillis()); while(true)&#123; int idx = random.nextInt(nums.length); int choose = nums[idx]; int cnt = 0; for(int num:nums)&#123; if(num==cur&amp;&amp;++cnt&gt;nums.length/2)return num; &#125; &#125;&#125; 3.39% 计算用每个数字的每一位投票，1的个数&gt;n/2则为11234567891011121314public int majorityElement(int[] nums)&#123; int n = nums.length; int rst =0; int mask =0; for(int i=0;i&lt;32;i++)&#123; mask = 1&lt;&lt;i; int cnt =0; for(int num:nums)&#123; if((num&amp;mask)!=0)cnt++; &#125; if(cnt&gt;n/2)rst|=mask; &#125; return rst;&#125; 4.moore voting 在线算法92%123456789101112131415public int majorityElement(int[] nums)&#123; //假设就是第一个数 int maj = nums[0]; int cnt=0; for(int num:nums)&#123; //第一个数就cnt=1 if(num==maj)cnt++; else if(--cnt==0)&#123; //等于0 从头开始做 cnt=1; maj = num; &#125; &#125; return maj;&#125; 优化100%每次取两个不同的数删除，最后剩下的返回 展开代码1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums==null)return -1; int res=0; int count=0; for(int e : nums)&#123; if(count==0)&#123; res=e; &#125; if(res!=e)&#123; count--;//删除这个数 &#125; else count++; &#125; return res; &#125;&#125; 5.排序取中间的数6.C++专有 部分排序1234int majorityElement(vector&lt;int&gt; &amp; nums)&#123; nth_element(nums.begin(),nums.begin()+nums.size()/2,nums.end()); return nums[nums.size()/2];&#125; 7.分治??? 119 ！Pascal’s Triangle II 帕斯卡三角形的第k行Input: 3Output: [1,3,3,1] 不会 118 Pascal’s TriangleInput: 5Output:1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 12345678910111213public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;numRows;i++)&#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); for(int j = 1;i&gt;1&amp;&amp;j&lt;i;j++)&#123; row.add(rst.get(i-1).get(j-1)+rst.get(i-1).get(j)); &#125; if(i&gt;0)row.add(1); rst.add(row); &#125; return rst;&#125; 134 ！Gas Station 环形加油站出发点找到一个起点可以获得gas[i]汽油，到下一个花费cost[i]可以遍历完所有加油站回到起点的点。Input:gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3 AC但是方法不对前段总的余量为负，即油不够用，要想有解，那么后段油量应该为正，此时才可能有解. 反之，如果前段就为正了，那么显然可以直接选择前面的点为起点； 如果整段加起来都是负的，那么无解 12345678910111213public int canCompleteCircuit(int[] gas, int[] cost) &#123; int sum = 0;int total = 0;int rst = 0; for(int i = 0;i&lt;gas.length;i++)&#123; sum += (gas[i]-cost[i]); if(sum&lt;0)&#123; total +=sum; rst = i+1; sum = 0; &#125; &#125; total +=sum; return total&gt;=0?rst:-1;&#125; 299 !Bulls and Cows 猜对了几个字符A表示位置对+数值对，B表示位置不对。Input: secret = “1123”, guess = “0111”Output: “1A1B” 关键：计数，如果secret当前字符的计数&lt;0，表示在guess出现过，b++,然后再计数这个字符。注意对secret和guess的当前字符都判断是否之前出现过，分别计数b。 12345678910111213public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for (int i = 0; i&lt;secret.length(); i++) &#123; if (secret.charAt(i) == guess.charAt(i)) bulls++; else &#123; if (numbers[secret.charAt(i)-'0']++ &lt; 0) cows++; if (numbers[guess.charAt(i)-'0']-- &gt; 0) cows++; &#125; &#125; return bulls + "A" + cows + "B";&#125; 41 !First Missing Positive 数组中第一个不存在的正数Input: [1,2,0]Output: 3 不会 思路：用[0-n-1]存储数组中出现的[1-n]如果超出长度不计，再遍历一遍第一个没标记的1234567891011121314151617181920212223public int firstMissingPositive(int[] nums) &#123; int n = nums.length; if(n&lt;1)return 1; int i = 0; while(i&lt;n)&#123; if(nums[i]&gt;0 &amp;&amp; nums[i]-1&lt;n &amp;&amp; i!=nums[i]-1 &amp;&amp; nums[nums[i]-1]!=nums[i] )&#123; swap(nums,i,nums[i]-1); &#125; else i++; &#125; i = 0; while(i&lt;n)&#123; if(i+1!=nums[i])break; i++; &#125; return i+1; &#125;private void swap(int[] arr,int i,int j)&#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; 189 Rotate Array 旋转数组Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4] 注意划分[0,k-1],[k,n-1]1234567891011121314151617public void rotate(int[] nums, int k) &#123; int n = nums.length; if(n&lt;2 || k == 0)return; k %= n; reverse(nums,0,n-1); reverse(nums,0,k-1); reverse(nums,k,n-1); &#125;private void reverse(int[] nums,int i,int j)&#123; while(i&lt;j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; i++;j--; &#125;&#125; 277 Find the Celebrity (lintcode) Celebrity Problem 所有人都认识他但是他不认识所有人方法1：找全是0的行，O(n^2)方法2： 如果A认识B，则A肯定不是名人 O(N)；A不认识B，则A可能是名人，B肯定不是名人A,B不认识，重新入栈AA,C认识，入栈C 方法3：双指针12345678910111213141516171819int findCele(int[][]Matrix)&#123; int n = Matrix.length; int a = 0; int b = n-1; while (a&lt;b)&#123; if(Matrix[a][b]==1)&#123; a++; &#125; else&#123; b--; &#125; &#125; for (int i = 0; i &lt;n ; i++) &#123; //不是自己，但是别人不认识他，或者他认识别人 if(i!=a&amp;&amp;Matrix[i][a]!=1||Matrix[a][i]==1) return -1; &#125; return a;&#125; 80 !Remove Duplicates from Sorted Array II有序数组只保留每个2个不同元素Given nums = [1,1,1,2,2,3],length = 5 调了好久1234567public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i &lt; 2 || n &gt; nums[i-2]) nums[i++] = n; return i;&#125; 26 ！Remove Duplicates from Sorted Array 有序数组只保留不同元素Given nums = [1,1,2],2 长度bug调了好久1234567891011public int removeDuplicates(int[] nums) &#123; int n = nums.length; if(n&lt;2)return n; int cnt = 1; for(int i =1;i&lt;n;i++)&#123; if(nums[i]-nums[i-1]&gt;0)&#123; nums[cnt++] = nums[i]; &#125; &#125; return cnt;&#125; 27 Remove Element熟练123456789public int removeElement(int[] nums, int val) &#123; int cnt = 0; for(int i =0;i&lt;nums.length;i++)&#123; if(nums[i]!=val)&#123; nums[cnt++] = nums[i]; &#125; &#125; return cnt;&#125; 121 Best Time to Buy and Sell Stock 只能买卖一次 买卖股票的利润 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 能一次AC 熟练1234567891011 public int maxProfit(int[] prices) &#123; if(prices.length &lt;1)return 0; // 之前最低 int pre = prices[0]; int rst = 0; for(int i = 1;i &lt; prices.length;i++)&#123; rst = Math.max(rst,prices[i]-pre); pre = Math.min(pre,prices[i]); &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algBitMap]]></title>
    <url>%2F2019%2F03%2F04%2FalgBitMap%2F</url>
    <content type="text"><![CDATA[CF558C Amr and Chemistry每个元素可以乘2 除2 变成相同元素的最少操作数思路：相当于可以左移1，右移1记录每个数字到变成每个数字的最小步数，而且变成的这个数一定是&lt;=最大的数的输入：33 5 6输出：5内存超 318 ！Maximum Product of Word Lengths 字符串数组中不共享字符的字符串长度的乘积find the maximum value of length(word[i]) * length(word[j])输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]输出: 16解释: 这两个单词为 “abcw”, “xtfn”。 不会思路：每个字符串表示成一个【26位的int】，如果这两个int &amp; 是0，表示没有重合的位。123456789101112131415161718public int maxProduct(String[] words) &#123; int n = words.length; int[] map = new int[n]; for(int i =0;i&lt;n;i++)&#123; for(char c : words[i].toCharArray())&#123; map[i] |= (1&lt;&lt;(c-'a')); &#125; &#125; int max = 0; for(int i =0;i&lt;n-1;i++)&#123; for(int j = i+1;j &lt; n;j++)&#123; if((map[i] &amp; map[j]) == 0)&#123; max = Math.max(max,words[i].length() * words[j].length()); &#125; &#125; &#125; return max;&#125; 868 Binary Gap 二进制1的间距输入：22输出：2解释：22 的二进制是 0b10110 。在 22 的二进制表示中，有三个 1，组成两对连续的 1 。第一对连续的 1 中，两个 1 之间的距离为 2 。第二对连续的 1 中，两个 1 之间的距离为 1 。答案取两个距离之中最大的，也就是 2 。 260 Single Number III 两个数字只出现一次，其它出现2次Input: [1,2,1,3,2,5]Output: [3,5] 137 Single Number II 所有数字都出现3次，只有一个出现1次Input: [0,1,0,1,0,1,99]Output: 99 三进制不进位加法不会12345678public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; 190 Reverse Bits 逆序二进制位Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000 不熟练12345678public int reverseBits(int n) &#123; int rst = 0; for(int i = 0;i&lt;32;i++)&#123; rst &lt;&lt;= 1; rst += (n&gt;&gt;&gt;i)&amp;1; &#125; return rst;&#125; 191 Number of 1 Bits 十进制数int有几个二进制1Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits. 熟练123456789public int hammingWeight(int n) &#123; int cnt =0; while(n!=0)&#123; n = n&amp;(n-1); n&gt;&gt;&gt;=1; cnt++; &#125; return cnt;&#125; 268 Missing Number 0-n个数字放进长度n-1的数组，少了哪个Input: [3,0,1]Output: 2 熟练 位运算12345678public int missingNumber(int[] nums) &#123; int n = nums.length; int rst = n; for(int i =0;i&lt;n;i++)&#123; rst ^= i^nums[i]; &#125; return rst;&#125; 89 !Gray Code 格雷编码两个连续的数值仅有一个位数的差异。Input: 2Output: [0,1,3,2]Explanation:00 - 001 - 111 - 310 - 2 不会G(i) = i^ (i/2)1234567public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); for(int i =0;i&lt;(1&lt;&lt;n);i++)&#123; rst.add(i^(i&gt;&gt;&gt;1)); &#125; return rst;&#125; 回溯？123456789101112131415161718int num = 0;public List&lt;Integer&gt; grayCodeBack(int n) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); backtrack(rst, n ); return rst;&#125;private void backtrack(List&lt;Integer&gt; rst,int n)&#123; if(n ==0)&#123; rst.add(num ); return; &#125; else&#123; backtrack(rst, n-1); num ^= (1&lt;&lt; n-1); backtrack(rst, n-1); &#125;&#125; 338 !Counting Bits 数1-num各数分别有几个1Input: 2Output: [0,1,1] 不会0 1 1 2 2 30 1 2 3 4 5如果偶数，f[n] = f[n/2] // 4：100 2：010如果奇数f[n] = f[n/2]+1 // 1：001 3：0111234567public int[] countBits(int num) &#123; int[] cnt = new int[num+1]; for(int i = 0;i&lt;num+1;i++)&#123; cnt[i] = cnt[i/2] + i%2; &#125; return cnt;&#125; 371 !!Sum of Two Integers 不用加减求和Input: a = 1, b = 2Output: 3 不会x2123456public int getSum(int a, int b) &#123; int rst = a^b; int carry = (a&amp;b)&lt;&lt;1; if(carry!=0)return getSum(rst,carry); return rst;&#125; 201 ！Bitwise AND of Numbers Range 闭区间所有数字的与输入: [0,1] [m,n]输出: 0 不会公共左边的部分。去掉n最右边的1,直到n&lt;=m1234public int rangeBitwiseAnd(int m, int n) &#123; while(m&lt;n) n = n &amp; (n-1); return n;&#125; 393. ！UTF-8 Validation1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.返回 true 。这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。 不会思路：先确定第一个int应该后面带几个10开头的，然后数后面能不能-到0.123456789101112131415public boolean validUtf8(int[] data) &#123; int cnt = 0; for(int d :data)&#123; if(cnt == 0)&#123; if((d &gt;&gt; 5)==0b110)cnt = 1; else if((d &gt;&gt; 4) == 0b1110)cnt = 2; else if((d &gt;&gt; 3) == 0b11110) cnt = 3; else if((d &gt;&gt; 7) == 1)return false; &#125;else &#123; if((d &gt;&gt; 6)!=0b10)return false; cnt--; &#125; &#125; return cnt == 0;&#125; 136 Single Number 都出现2次，数组中只出现一次的数字Input: [4,1,2,1,2]Output: 4 方法2：数学：都出现2次 没想到$$2(a+b+c)-(a+a+b+b+c)$$2*sum(set(list))-sum(list) 方法1：异或 0^12=12,12^12=0 位运算比较熟练1234567public int singleNumber(int[] nums) &#123; int rst = nums[0]; for(int i = 1;i&lt;nums.length;i++)&#123; rst ^= nums[i]; &#125; return rst;&#125; 389 Find the Difference 两个字符串打乱后多余的字符String t is generated by random shuffling string s and then add one more letter at a random position.Input:s = “abcd”t = “abcde”Output:e 位运算：‘b’异或两次同一个字符，会回到原来的。异或自己变成0，再异或一个其它字符就是赋值。123456789public char findTheDifference(String s, String t) &#123; int n = t.length(); char c = t.charAt(n - 1); for (int i = 0; i &lt; n - 1; ++i) &#123; c ^= s.charAt(i); c ^= t.charAt(i); &#125; return c;&#125; 正常做法：熟练展开代码 123456789101112public char findTheDifference(String s, String t) &#123; int[] cnt = new int[26]; for(int i =0;i&lt;t.length();i++)&#123; if(i &lt; s.length()) cnt[s.charAt(i)-'a']++; cnt[t.charAt(i)-'a']--; &#125; for(int i =0;i&lt;26;i++)&#123; if(cnt[i] &lt; 0)return (char)(i+'a'); &#125; return ' ';&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[produbbo]]></title>
    <url>%2F2019%2F03%2F01%2Fprodubbo%2F</url>
    <content type="text"><![CDATA[Dubble: Java RPC框架1)面向接口的远程调用 2）智能容错和负载均衡 3）服务注册和发现 RPC：远程过程调用协议 ，C/S模式，通过网络。生产者：注册发布接口消费者：订阅调用接口注册中心：Zookeeper 消费者向注册中心订阅，会收到注册中心的通知notify]]></content>
      <categories>
        <category>项目流程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es搜房网]]></title>
    <url>%2F2019%2F01%2F07%2FproHouse%2F</url>
    <content type="text"><![CDATA[Elasticsearch 搭建不能以root启动1234groupadd elasticsearchuseradd elasticsearch -g elasticsearch -p elasticsearchchown -R elasticsearch.elasticsearch *su elasticsearch 安装es插件12345678910111213141516171819wget https://github.com/mobz/elasticsearch-head/archive/master.zip# 安装nodejssudo yum install nodejscd elasticsearch-headnpm install# 两个进程跨域cd elasticsearch-5.5.2vim config/elasticsearch.yml# 最后加 并且绑定iphttp.cors.enable: truehttp.cors.allow-origin: "*"## 启动es./elasticsearch -d## 启动headnpm run startps aux | grep ‘elastic’sysctl -w vm.max_map_count=262144 改limit需要重启(?) 堆大小检查：JVM堆大小调整可能会出现停顿，应把Xms和Xmx设成相同文件描述符： 每个分片有很多段，每个段有很多文件。ulimit -n 65536 只对当前终端生效/etc/security/limits.conf 配置* - nofile 65536最大线程数nproc最大虚拟内存：使用mmap映射部分索引到进程地址空间，保证es进程有足够的地址空间as为unlimited最大文件大小 fsize 设置为unlimited！！虚拟内存区域最大数：确保内核允许创建262144个【内存映射区】sysctl -w vm.max_map_count=262144 临时，重启后失效/etc/sysctl.conf添加vm.max_map_count=262144 然后执行sysctl -p立即 永久生效 initial heap size [536870912] not equal to maximum heap size [994050048];修改config/jvm.options 修改xms和xmx相等 ES 安装问题不能用root启动 max_map太小123chown -R es:es elasticsearch...su sysctl -w vm.max_map_count=262144 es经常卡住，而且新增房源要加到百度云麻点之类的功能 1.后台工程spring data和jpa仓库的基础包，事务，数据源属性前缀,实体类管理工厂123456789spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://:3306/xunwuspring.datasource.username=spring.datasource.password=spring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=validatelogging.level.org.hibernate.SQL=debug 1234567891011121314151617181920212223242526272829@Configuration@EnableJpaRepositories(basePackages = "com.houselearn.repository")@EnableTransactionManagementpublic class JPAConfig &#123; @Bean @ConfigurationProperties(prefix = "spring.datasource") public DataSource dataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() &#123; HibernateJpaVendorAdapter japVendor = new HibernateJpaVendorAdapter(); japVendor.setGenerateDdl(false); LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean(); entityManagerFactory.setDataSource(dataSource()); entityManagerFactory.setJpaVendorAdapter(japVendor); entityManagerFactory.setPackagesToScan("com.houselearn.entity"); return entityManagerFactory; &#125; @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) &#123; JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(entityManagerFactory); return transactionManager; &#125;&#125; 关掉security1security.basic.enabled=false 单元测试添加依赖，添加h2数据库12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建数据库实体要兼容h2所以自增用IDENTITY1234567891011121314151617181920212223242526272829@Entity@Table(name = "user")public class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String password; private String email; @Column(name = "phone_number") private String phoneNumber; private int status; @Column(name = "create_time") private Date createTime; @Column(name = "last_login_time") private Date lastLoginTime; @Column(name = "last_update_time") private Date lastUpdateTime; private String avatar; &#125; 创建dao 基础的crud1public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;&#125; 创建entity测试包，新建测试类12345678910public class UserRepositoryTest extends ApplicationTests&#123; @Autowired private UserRepository userRepository; @Test public void testFindOne()&#123; User user = userRepository.findOne(1l); Assert.assertEquals("name1", user.getName()); &#125;&#125; 集成h2数据库用于测试，配置分离1234# h2spring.datasource.driver-class-name=org.h2.Driver# 内存模式spring.datasource.url=jdbc:h2:mem:test 测试类使用test配置文件12345678RunWith(SpringRunner.class)@SpringBootTest@ActiveProfiles("test")public class ApplicationTests &#123; @Test public void contextLoads() &#123; &#125;&#125; 创建h2数据库放在test的resources下加配置12spring.datasource.schema=classpath:db/schema.sqlspring.datasource.data=classpath:db/data.sql 集成模板引擎禁止thymeleaf缓存,thymeleaf html模式123456# devspring.thymeleaf.cache=false# 通用spring.thymeleaf.mode=HTMLspring.thymeleaf.suffix=.htmlspring.thymeleaf.prefix=classpath:/templates/ 新建用maven方式启动Command line：clean package spring-boot:run -Dmaven.test.skip=true devtools 热加载工具12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; Settings-Compiler-Build project automaticallyshift+ctrl+alt+/ - Registry - automake 打开mvc更新测试12345@RequestMapping(value = "/index",method = RequestMethod.GET)public String index(Model model)&#123; model.addAttribute("name","不好"); return "index";&#125; 12345678910&lt;html xmlns="http://www.thymeleaf.org" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;helloooooooohhhhh&lt;span th:text="$&#123;name&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 2. 架构设计2.1前后端数据格式123456public class ApiResponse &#123; private int code; private String message; private Object data; private boolean more;&#125; 定义内部枚举类，设定一些模板code和msg状态1234567891011121314151617public enum Status &#123; SUCCESS(200, "OK"), BAD_REQUEST(400, "Bad Request"), NOT_FOUND(404, "Not Found"), INTERNAL_SERVER_ERROR(500, "Unknown Internal Error"), NOT_VALID_PARAM(40005, "Not valid Params"), NOT_SUPPORTED_OPERATION(40006, "Operation not supported"), NOT_LOGIN(50000, "Not Login"); private int code; private String standardMessage; Status(int code, String standardMessage) &#123; this.code = code; this.standardMessage = standardMessage; &#125;&#125; 添加静态工厂，直接传入对象包装成success\没有data只有code和msg\枚举类-&gt;接口类1234567891011public static ApiResponse ofMessage(int code, String message) &#123; return new ApiResponse(code, message, null);&#125;public static ApiResponse ofSuccess(Object data) &#123; return new ApiResponse(Status.SUCCESS.getCode(), Status.SUCCESS.getStandardMessage(), data);&#125;public static ApiResponse ofStatus(Status status) &#123; return new ApiResponse(status.getCode(), status.getStandardMessage(), null);&#125; 2.2 异常拦截器（页面/api）关闭whitelabel error页面新建 base - AppErrorController继承ErrorController 注入ErrorAttributes12345678910111213141516@Controllerpublic class AppErrorController implements ErrorController &#123; private static final String ERROR_PATH = "/error"; private ErrorAttributes errorAttributes; @Override public String getErrorPath() &#123; return ERROR_PATH; &#125; @Autowired public AppErrorController(ErrorAttributes errorAttributes) &#123; this.errorAttributes = errorAttributes; &#125;&#125; 页面处理，在template里添加404，500页面12345678910111213@RequestMapping(value = ERROR_PATH, produces = "text/html")public String errorPageHandler(HttpServletRequest request, HttpServletResponse response) &#123; int status = response.getStatus(); switch (status) &#123; case 403: return "403"; case 404: return "404"; case 500: return "500"; &#125; return "index";&#125; RequestMapping中的consumes和produce区别Http协议中的ContentType 和AcceptAccept：告诉服务器，客户端支持的格式content-type：说明报文中对象的媒体类型consumes 用于限制 ContentTypeproduces 用于限制 Accept 处理api错误包装request成Attributes 获取错误信息， 状态码要从request中获取1234567private int getStatus(HttpServletRequest request) &#123; Integer status = (Integer) request.getAttribute("javax.servlet.error.status_code"); if (status != null) &#123; return status; &#125; return 500;&#125; 包装错误对象12345678910RequestMapping(value = ERROR_PATH)@ResponseBodypublic ApiResponse errorApiHandler(HttpServletRequest request) &#123; RequestAttributes requestAttributes = new ServletRequestAttributes(request); Map&lt;String, Object&gt; attr = this.errorAttributes.getErrorAttributes(requestAttributes, false); int status = getStatus(request); return ApiResponse.ofMessage(status, String.valueOf(attr.getOrDefault("message", "error")));&#125; 3. 管理员页面 文件上传 本地+腾讯云管理员页面1.登陆 2.欢迎 3.管理员中心 4.添加房子 securityWebMvcConfig 在thymeleaf 添加 SpringSecurity方言配置页面解析器并且注册ModelMapper1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter implements ApplicationContextAware &#123; @Value("$&#123;spring.thymeleaf.cache&#125;") private boolean thymeleafCacheEnable = true; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; /** * 静态资源加载配置 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/"); &#125; /** * 模板资源解析器 * @return */ @Bean @ConfigurationProperties(prefix = "spring.thymeleaf") public SpringResourceTemplateResolver templateResolver() &#123; SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver(); templateResolver.setApplicationContext(this.applicationContext); templateResolver.setCharacterEncoding("UTF-8"); templateResolver.setCacheable(thymeleafCacheEnable); return templateResolver; &#125; /** * Thymeleaf标准方言解释器 */ @Bean public SpringTemplateEngine templateEngine() &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); // 支持Spring EL表达式 templateEngine.setEnableSpringELCompiler(true); // 支持SpringSecurity方言 SpringSecurityDialect securityDialect = new SpringSecurityDialect(); templateEngine.addDialect(securityDialect); return templateEngine; &#125; /** * 视图解析器 */ @Bean public ThymeleafViewResolver viewResolver() &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(templateEngine()); return viewResolver; &#125; @Bean public ModelMapper modelMapper() &#123; return new ModelMapper(); &#125; &#125; 权限配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@EnableWebSecurity@EnableGlobalMethodSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * HTTP权限控制 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(authFilter(), UsernamePasswordAuthenticationFilter.class); // 资源访问权限 http.authorizeRequests() .antMatchers("/admin/login").permitAll() // 管理员登录入口 .antMatchers("/static/**").permitAll() // 静态资源 .antMatchers("/user/login").permitAll() // 用户登录入口 .antMatchers("/admin/**").hasRole("ADMIN") .antMatchers("/user/**").hasAnyRole("ADMIN", "USER") .antMatchers("/api/user/**").hasAnyRole("ADMIN", "USER") .and() .formLogin() .loginProcessingUrl("/login") // 配置角色登录处理入口 .failureHandler(authFailHandler()) .and() .logout() .logoutUrl("/logout") .logoutSuccessUrl("/logout/page") // 登出擦除密码 .deleteCookies("JSESSIONID") .invalidateHttpSession(true) .and() .exceptionHandling() .authenticationEntryPoint(urlEntryPoint()) .accessDeniedPage("/403"); //ifarme开发需要同源策略 http.csrf().disable(); http.headers().frameOptions().sameOrigin(); &#125; /** * 自定义认证策略 */ @Autowired public void configGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; //添加默认用户名密码 auth.inMemoryAuthentication().withUser("admin").password("admin").roles("ADMIN").and(); &#125;&#125; 对接数据库做真实的权限认证,获取用户名，从数据库查找密码比对输入的密码authentication.getCredentials()1234567891011121314151617181920212223242526272829public class AuthProvider implements AuthenticationProvider &#123;@Autowiredprivate IUserService userService;private final Md5PasswordEncoder passwordEncoder = new Md5PasswordEncoder();@Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; String userName = authentication.getName(); String inputPassword = (String) authentication.getCredentials(); User user = userService.findUserByName(userName); if (user == null) &#123; throw new AuthenticationCredentialsNotFoundException("authError"); &#125; if (this.passwordEncoder.isPasswordValid(user.getPassword(), inputPassword, user.getId())) &#123; return new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities()); &#125; throw new BadCredentialsException("authError");&#125;@Overridepublic boolean supports(Class&lt;?&gt; authentication) &#123; return true;&#125; 用户实体 实现security的方法…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Entity@Table(name = "user")public class User implements UserDetails &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String password; private String email; @Column(name = "phone_number") private String phoneNumber; private int status; @Column(name = "create_time") private Date createTime; @Column(name = "last_login_time") private Date lastLoginTime; @Column(name = "last_update_time") private Date lastUpdateTime; private String avatar; &#125; // 注意不在数据库中的属性，不持久化，避免jap检查 @Transient private List&lt;GrantedAuthority&gt; authorityList; public List&lt;GrantedAuthority&gt; getAuthorityList() &#123; return authorityList; &#125; public void setAuthorityList(List&lt;GrantedAuthority&gt; authorityList) &#123; this.authorityList = authorityList; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return this.authorityList; &#125; public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return name; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125; 用户service12public interface IUserService &#123; User findUserByName(String userName); 用户dao12public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; User findByName(String userName); 添加role信息123456789@Entity@Table(name = "role")public class Role &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "user_id") private Long userId; private String name; role查询 组装到userservice123public interface RoleRepository extends CrudRepository&lt;Role, Long&gt; &#123; List&lt;Role&gt; findRolesByUserId(Long userId);&#125; userservice 通过名字查用户id，通过id查用户权限，并设置好完整的user返回1234567891011121314151617181920 @Autowiredprivate RoleRepository roleRepository;@Overridepublic User findUserByName(String userName) &#123; User user = userRepository.findByName(userName); if (user == null) &#123; return null; &#125; List&lt;Role&gt; roles = roleRepository.findRolesByUserId(user.getId()); if (roles == null || roles.isEmpty()) &#123; throw new DisabledException("权限非法"); &#125; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); roles.forEach(role -&gt; authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()))); user.setAuthorityList(authorities); return user;&#125; security的认证逻辑12345678@Autowired public void configGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authProvider()).eraseCredentials(true); &#125; @Bean public AuthProvider authProvider() &#123; return new AuthProvider(); &#125; 添加用户登出接口HomeController 设置默认页面的页面跳转1234567891011121314151617181920212223242526@Controllerpublic class HomeController &#123; @GetMapping(value = &#123;"/", "/index"&#125;) public String index(Model model) &#123; return "index"; &#125; @GetMapping("/404") public String notFoundPage() &#123; return "404"; &#125; @GetMapping("/403") public String accessError() &#123; return "403"; &#125; @GetMapping("/500") public String internalError() &#123; return "500"; &#125; @GetMapping("/logout/page") public String logoutPage() &#123; return "logout"; &#125; 普通用户的controller1234567891011121314151617@Controllerpublic class UserController &#123; @Autowired private IUserService userService; @Autowired private IHouseService houseService; @GetMapping("/user/login") public String loginPage() &#123; return "user/login"; &#125; @GetMapping("/user/center") public String centerPage() &#123; return "user/center"; &#125; 无权限跳转到普通/管理员的登陆入口123456789101112131415161718192021222324public class LoginUrlEntryPoint extends LoginUrlAuthenticationEntryPoint &#123; private final Map&lt;String, String&gt; authEntryPointMap; private PathMatcher pathMatcher = new AntPathMatcher(); public LoginUrlEntryPoint(String loginFormUrl) &#123; super(loginFormUrl); authEntryPointMap = new HashMap&lt;&gt;(); // 普通用户登录入口映射 authEntryPointMap.put("/user/**", "/user/login"); // 管理员登录入口映射 authEntryPointMap.put("/admin/**", "/admin/login"); &#125;&#125;@Overrideprotected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response,AuthenticationException exception) &#123; String uri = request.getRequestURI().replace(request.getContextPath(), ""); for (Map.Entry&lt;String, String&gt; authEntry : this.authEntryPointMap.entrySet()) &#123; if (this.pathMatcher.match(authEntry.getKey(), uri)) &#123; return authEntry.getValue(); &#125; &#125; return super.determineUrlToUseForThisRequest(request, response, exception);&#125; 添加config1234@Beanpublic LoginUrlEntryPoint urlEntryPoint() &#123; return new LoginUrlEntryPoint("/user/login");&#125; 添加.authenticationEntryPoint(urlEntryPoint()) 登陆失败1234567891011121314151617public class LoginAuthFailHandler extends SimpleUrlAuthenticationFailureHandler &#123; private final LoginUrlEntryPoint urlEntryPoint; public LoginAuthFailHandler(LoginUrlEntryPoint urlEntryPoint) &#123; this.urlEntryPoint = urlEntryPoint; &#125; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; String targetUrl = this.urlEntryPoint.determineUrlToUseForThisRequest(request, response, exception); targetUrl += "?" + exception.getMessage(); super.setDefaultFailureUrl(targetUrl); super.onAuthenticationFailure(request, response, exception); &#125; 注册123456789@Beanpublic LoginUrlEntryPoint urlEntryPoint() &#123; return new LoginUrlEntryPoint("/user/login");&#125;@Beanpublic LoginAuthFailHandler authFailHandler() &#123; return new LoginAuthFailHandler(urlEntryPoint());&#125; 12.loginProcessingUrl("/login") // 配置角色登录处理入口.failureHandler(authFailHandler()) 前端thymeleaf 公共头部templates/admin/common.html在common里定义&lt;header th:fragment=&quot;header&quot; class=&quot;navbar-wrapper&quot;&gt;头部样式在要使用的页面使用那个header&lt;div th:include=&quot;admin/common :: head&quot;&gt;&lt;/div&gt; 图片上传 腾讯云添加post接口123456789101112131415161718192021@PostMapping(value = "admin/upload/photo",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)@ResponseBodypublic ApiResponse uploadPhoto(@RequestParam("file") MultipartFile file)&#123; if(file.isEmpty())&#123; return ApiResponse.ofStatus(ApiResponse.Status.NOT_VALID_PARAM); &#125; String fileName = file.getOriginalFilename(); File target = new File("E:\\houselearn\\tmp\\"+fileName); try &#123; file.transferTo(target); PutObjectResult result = tecentService.uploadFile(target); String s = gson.toJson(result); System.out.println(s); System.out.println(result); TecentDTO ret = gson.fromJson(s, TecentDTO.class); return ApiResponse.ofSuccess(ret); &#125; catch (IOException e) &#123; e.printStackTrace(); return ApiResponse.ofStatus(ApiResponse.Status.INTERNAL_SERVER_ERROR); &#125;&#125; 文件上传配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Configuration@ConditionalOnClass(&#123;Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class&#125;)@ConditionalOnProperty(prefix = "spring.http.multipart", name = "enabled", matchIfMissing = true)@EnableConfigurationProperties(MultipartProperties.class)public class WebFileUploadConfig &#123; private final MultipartProperties multipartProperties; public WebFileUploadConfig(MultipartProperties multipartProperties) &#123; this.multipartProperties = multipartProperties; &#125; /** * 上传配置 */ @Bean @ConditionalOnMissingBean public MultipartConfigElement multipartConfigElement() &#123; return this.multipartProperties.createMultipartConfig(); &#125; /** * 注册解析器 */ @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) @ConditionalOnMissingBean(MultipartResolver.class) public StandardServletMultipartResolver multipartResolver() &#123; StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver(); multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily()); return multipartResolver; &#125; @Value("$&#123;tcent.secretId&#125;") private String secretId; @Value("$&#123;tcent.secretKey&#125;") private String secretKey; @Value("$&#123;tcent.bucket&#125;") private String bucket; @Value("$&#123;tcent.region&#125;") private String region; // 1 初始化用户身份信息（secretId, secretKey）。 @Bean public COSCredentials cred()&#123; return new BasicCOSCredentials(secretId, secretKey); &#125; //2 区域 @Bean public ClientConfig clientConfig()&#123; return new ClientConfig(new Region(region)); &#125; // 上传 @Bean public COSClient cosClient()&#123; return new COSClient(cred(), clientConfig()); &#125;&#125; 文件配置属性1234spring.http.multipart.enabled=truespring.http.multipart.location=E:\\houselearn\\tmpspring.http.multipart.file-size-threshold=5MBspring.http.multipart.max-request-size=20MB 定义和前端的图片大小dto 用imageIO 获取图片大小 4.地区、地铁信息等表单数据库查询注意地址表中存储区和市信息，用一个字段level区分。并且有belong_to 字段形成树形结构。123456789101112131415161718192021222324@Entity@Table(name = "support_address")public class SupportAddress &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 上一级行政单位 @Column(name = "belong_to") private String belongTo; @Column(name = "en_name") private String enName; @Column(name = "cn_name") private String cnName; private String level; @Column(name = "baidu_map_lng") private double baiduMapLongitude; @Column(name = "baidu_map_lat") private double baiduMapLatitude; 12345678910111213141516171819202122public enum Level &#123; CITY("city"), REGION("region"); private String value; Level(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public static Level of(String value) &#123; for (Level level : Level.values()) &#123; if (level.getValue().equals(value)) &#123; return level; &#125; &#125; throw new IllegalArgumentException(); &#125;&#125; 为了分页统一包装成带数量的list类123public class ServiceMultiResult&lt;T&gt; &#123; private long total; private List&lt;T&gt; result; 在address实体中定义枚举类 用于按level查找所有城市123public ServiceMultiResult&lt;SupportAddressDTO&gt; findAllCities() &#123; List&lt;SupportAddress&gt; addresses = supportAddressRepository.findAllByLevel(SupportAddress.Level.CITY.getValue()); // to DTO 查询地区需要City12345678@Overridepublic ServiceMultiResult&lt;SupportAddressDTO&gt; findAllRegionsByCityName(String cityName) &#123;// 判空 List&lt;SupportAddress&gt; regions = supportAddressRepository.findAllByLevelAndBelongTo(SupportAddress.Level.REGION .getValue(), cityName); //转 DTO return new ServiceMultiResult&lt;&gt;(regions.size(), result);&#125; 一旦用户选择好了市，直接发送2个xhr查地铁线和区地铁也按城市名查询，地铁站用地铁id查AddressService封装所有地铁、城市的查询。 存储房屋实体到数据库，分别对应房屋、详情、图片、tag表，将整个表单定义成一个类接受前端表格定义service中的save方法在adminController中定义接口，并对前端数据做表单验证，注入addressService用于验证城市列表、城市的区域列表调用save方法会返回一个DTO12345678910111213141516171819202122@PostMapping("admin/add/house")@ResponseBodypublic ApiResponse addHouse(@Valid @ModelAttribute("form-house-add") HouseForm houseForm, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; return new ApiResponse(HttpStatus.BAD_REQUEST.value(), bindingResult.getAllErrors().get(0).getDefaultMessage(), null); &#125; if (houseForm.getPhotos() == null || houseForm.getCover() == null) &#123; return ApiResponse.ofMessage(HttpStatus.BAD_REQUEST.value(), "必须上传图片"); &#125; Map&lt;SupportAddress.Level, SupportAddressDTO&gt; addressMap = addressService.findCityAndRegion(houseForm.getCityEnName(), houseForm.getRegionEnName()); if (addressMap.keySet().size() != 2) &#123; return ApiResponse.ofStatus(ApiResponse.Status.NOT_VALID_PARAM); &#125; ServiceResult&lt;HouseDTO&gt; result = houseService.save(houseForm); if (result.isSuccess()) &#123; return ApiResponse.ofSuccess(result.getResult()); &#125; return ApiResponse.ofSuccess(ApiResponse.Status.NOT_VALID_PARAM);&#125; 并定义相应的DTO 将controller、dto、entity、repository放到web目录下并记得修改JPA配置 5后台浏览增删功能redis保存session1234@GetMapping("admin/house/list") public String houseListPage() &#123; return "admin/house-list"; &#125; redis session123456spring.redis.database=0spring.redis.host=10.1.18.25spring.redis.password=spring.redis.port=6379spring.redis.pool.min-idle=1spring.redis.timeout=3000 添加依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis配置123456789@Configuration@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400)public class RedisSessionConfig &#123; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; return new StringRedisTemplate(factory); &#125;&#125; Unable to configure Redis to keyspace notifications忘了写密码 monitor查看效果 “PEXPIRE” “spring:session:sessions:6ca6dd6b-a63a-4676-b1b0-db95fde689cc” “86700000” ？怎么看 多维度排序和分页后台查询条件表单实体1234567891011121314151617181920212223public class DatatableSearch &#123; /** * Datatables要求回显字段 */ private int draw; /** * Datatables规定分页字段 */ private int start; private int length; private Integer status; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date createTimeMin; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date createTimeMax; private String city; private String title; private String direction; private String orderBy; 用Sort实现默认查询排序pageable实现分页ServiceMultiResult&lt;HouseDTO&gt; adminQuery(DatatableSearch searchBody);1public interface HouseRepository extends PagingAndSortingRepository&lt;House, Long&gt;, JpaSpecificationExecutor&lt;House&gt; &#123; 编辑按钮编辑页面get方法从数据库从查询到的房屋表格数据放在model中编辑页面post方法增加find所有房屋表信息的service、update更新的service 点击图片删除图片的接口、添加、删除tag接口1234567891011@DeleteMapping("admin/house/photo")@ResponseBodypublic ApiResponse removeHousePhoto(@RequestParam(value = "id") Long id) &#123; ServiceResult result = this.houseService.removePhoto(id); if (result.isSuccess()) &#123; return ApiResponse.ofStatus(ApiResponse.Status.SUCCESS); &#125; else &#123; return ApiResponse.ofMessage(HttpStatus.BAD_REQUEST.value(), result.getMessage()); &#125;&#125; 待审核到发布修改数据库房屋状态 6. 客户页面房源搜索搜索请求1234567891011public class RentSearch &#123; private String cityEnName; private String regionEnName; private String priceBlock; private String areaBlock; private int room; private int direction; private String keywords; private int rentWay = -1; private String orderBy = "lastUpdateTime"; private String orderDirection = "desc"; 跳转类如果session里没有city跳转到首页如果前端传入的数据有城市，放到session中123456789101112131415161718192021222324252627282930313233343536373839@GetMapping("rent/house") public String rentHousePage(@ModelAttribute RentSearch rentSearch, Model model, HttpSession session, RedirectAttributes redirectAttributes) &#123; if (rentSearch.getCityEnName() == null) &#123; String cityEnNameInSession = (String) session.getAttribute("cityEnName"); if (cityEnNameInSession == null) &#123; redirectAttributes.addAttribute("msg", "must_chose_city"); return "redirect:/index"; &#125; else &#123; rentSearch.setCityEnName(cityEnNameInSession); &#125; &#125; else &#123; session.setAttribute("cityEnName", rentSearch.getCityEnName()); &#125; ServiceResult&lt;SupportAddressDTO&gt; city = addressService.findCity(rentSearch.getCityEnName()); if (!city.isSuccess()) &#123; redirectAttributes.addAttribute("msg", "must_chose_city"); return "redirect:/index"; &#125; model.addAttribute("currentCity", city.getResult()); ServiceMultiResult&lt;SupportAddressDTO&gt; addressResult = addressService.findAllRegionsByCityName(rentSearch.getCityEnName()); if (addressResult.getResult() == null || addressResult.getTotal() &lt; 1) &#123; redirectAttributes.addAttribute("msg", "must_chose_city"); return "redirect:/index"; &#125; model.addAttribute("searchBody", rentSearch); model.addAttribute("regions", addressResult.getResult()); model.addAttribute("priceBlocks", RentValueBlock.PRICE_BLOCK); model.addAttribute("areaBlocks", RentValueBlock.AREA_BLOCK); model.addAttribute("currentPriceBlock", RentValueBlock.matchPrice(rentSearch.getPriceBlock())); model.addAttribute("currentAreaBlock", RentValueBlock.matchArea(rentSearch.getAreaBlock())); return "rent-list"; &#125; 房屋排序类123456789101112131415161718192021222324252627282930313233public class HouseSort &#123; public static final String DEFAULT_SORT_KEY = "lastUpdateTime"; public static final String DISTANCE_TO_SUBWAY_KEY = "distanceToSubway"; private static final Set&lt;String&gt; SORT_KEYS = Sets.newHashSet( DEFAULT_SORT_KEY, "createTime", "price", "area", DISTANCE_TO_SUBWAY_KEY ); public static Sort generateSort(String key, String directionKey) &#123; key = getSortKey(key); Sort.Direction direction = Sort.Direction.fromStringOrNull(directionKey); if (direction == null) &#123; direction = Sort.Direction.DESC; &#125; return new Sort(direction, key); &#125; public static String getSortKey(String key) &#123; if (!SORT_KEYS.contains(key)) &#123; key = DEFAULT_SORT_KEY; &#125; return key; &#125;&#125; 7.添加ES构建索引API地址https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/transport-client.html添加依赖注册客户端1234567891011121314151617181920212223242526272829@Configurationpublic class ElasticSearchConfig &#123; @Value("$&#123;elasticsearch.host&#125;") private String esHost; @Value("$&#123;elasticsearch.port&#125;") private int esPort; @Value("$&#123;elasticsearch.cluster.name&#125;") private String esName; @Bean public TransportClient esClient() throws UnknownHostException &#123; Settings settings = Settings.builder() .put("cluster.name", this.esName) // 自动发现节点 .put("client.transport.sniff", true) .build(); InetSocketTransportAddress master = new InetSocketTransportAddress( InetAddress.getByName(esHost), esPort ); TransportClient client = new PreBuiltTransportClient(settings) .addTransportAddress(master); return client; &#125; 配置123elasticsearch.cluster.name=elasticsearchelasticsearch.host=10.1.18.25elasticsearch.port=9300 索引接口123456789101112public interface ISearchService &#123; /** * 索引目标房源 * @param houseId */ void index(Long houseId); /** * 移除房源索引 * @param houseId */ void remove(Long houseId); 构建索引index方法：新增房源（上架），从数据库中查找到房源数据，建立索引分3种情况1单纯创建 2es里有，是update 3es异常，需要先删除再创建 ES基础语法定义索引名、索引类型（mapper下面那个）123456789@Servicepublic class SearchServiceImpl implements ISearchService &#123; private static final Logger logger = LoggerFactory.getLogger(ISearchService.class); private static final String INDEX_NAME = "shoufhang"; private static final String INDEX_TYPE = "house"; private static final String INDEX_TOPIC = "house_build"; 建立索引结构和对应的索引类，用于对象转成json传给es API，官方推荐jackson的ObjectMapper添加Logger index方法创建一个Json文档12345678910111213141516private boolean create(HouseIndexTemplate indexTemplate) &#123; try &#123; IndexResponse response = this.esClient.prepareIndex(INDEX_NAME, INDEX_TYPE) .setSource(objectMapper.writeValueAsBytes(indexTemplate), XContentType.JSON).get(); logger.debug("Create index with house: " + indexTemplate.getHouseId()); if (response.status() == RestStatus.CREATED) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (JsonProcessingException e) &#123; logger.error("Error to index house " + indexTemplate.getHouseId(), e); return false; &#125;&#125; 更新，需要传入一个具体的文档目标12345678910111213141516private boolean update(String esId, HouseIndexTemplate indexTemplate) &#123; try &#123; UpdateResponse response = this.esClient.prepareUpdate(INDEX_NAME, INDEX_TYPE, esId) .setDoc(objectMapper.writeValueAsBytes(indexTemplate), XContentType.JSON).get(); logger.debug("Update index with house: " + indexTemplate.getHouseId()); if (response.status() == RestStatus.OK) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (JsonProcessingException e) &#123; logger.error("Error to index house " + indexTemplate.getHouseId(), e); return false; &#125;&#125; 删除创建，查询再删除，传入多少个查到的数据，比较删除的行数是否一致1234567891011121314151617private boolean deleteAndCreate(long totalHit, HouseIndexTemplate indexTemplate) &#123; DeleteByQueryRequestBuilder builder = DeleteByQueryAction.INSTANCE .newRequestBuilder(esClient) .filter(QueryBuilders.termQuery(HouseIndexKey.HOUSE_ID, indexTemplate.getHouseId())) .source(INDEX_NAME); logger.debug("Delete by query for house: " + builder); BulkByScrollResponse response = builder.get(); long deleted = response.getDeleted(); if (deleted != totalHit) &#123; logger.warn("Need delete &#123;&#125;, but &#123;&#125; was deleted!", totalHit, deleted); return false; &#125; else &#123; return create(indexTemplate); &#125;&#125; 一条文档还需要tag和detail、地铁城市信息123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void index(Long houseId) &#123; House house = houseRepository.findOne(houseId); if (house == null) &#123; logger.error("Index house &#123;&#125; dose not exist!", houseId); return; &#125; HouseIndexTemplate indexTemplate = new HouseIndexTemplate(); modelMapper.map(house, indexTemplate); HouseDetail detail = houseDetailRepository.findByHouseId(houseId); modelMapper.map(detail, indexTemplate); //ES中是字符串只有name 不用数据库格式的id和houseID List&lt;HouseTag&gt; tags = tagRepository.findAllByHouseId(houseId); if (tags != null &amp;&amp; !tags.isEmpty()) &#123; List&lt;String&gt; tagStrings = new ArrayList&lt;&gt;(); tags.forEach(houseTag -&gt; tagStrings.add(houseTag.getName())); indexTemplate.setTags(tagStrings); &#125; // 先查询这个ID有没有数据 SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME).setTypes(INDEX_TYPE) .setQuery(QueryBuilders.termQuery(HouseIndexKey.HOUSE_ID, houseId)); logger.debug(requestBuilder.toString()); SearchResponse searchResponse = requestBuilder.get(); boolean success; long totalHit = searchResponse.getHits().getTotalHits(); if (totalHit == 0) &#123; success = create(indexTemplate); &#125; else if (totalHit == 1) &#123; String esId = searchResponse.getHits().getAt(0).getId(); success = update(esId, indexTemplate); &#125; else &#123; //同样的数据存了好多个 success = deleteAndCreate(totalHit, indexTemplate); &#125; if (success)&#123; logger.debug("Index success with house " + houseId); &#125;&#125; 先写一个单测试一下报错log4j2ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console…之前腾讯云把log4j和sl4j都删掉了还要添加一个log4j12345&lt;dependency&gt;&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;&lt;version&gt;2.7&lt;/version&gt;&lt;/dependency&gt; 123456789public class SearchServiceTests extends ApplicationTests&#123; @Autowired private ISearchService searchService; @Test public void testIndex()&#123; Assert.assertTrue(searchService.index(15L)); &#125;&#125; 修改数据库并再次执行测试可以看到索引页更新了 删除索引（下架or出租了）1234567891011121314@Overridepublic void remove(Long houseId) &#123; DeleteByQueryRequestBuilder builder = DeleteByQueryAction.INSTANCE .newRequestBuilder(esClient) .filter(QueryBuilders.termQuery(HouseIndexKey.HOUSE_ID, houseId)) .source(INDEX_NAME); logger.debug("Delete by query for house: " + builder); BulkByScrollResponse response = builder.get(); long deleted = response.getDeleted(); logger.debug("Delete total", deleted);&#125; 单测1234@Testpublic void testRemove()&#123; searchService.remove(15L);&#125; 将索引方法逻辑加入到之前的状态变化方法中houseService的update方法123if (house.getStatus() == HouseStatus.PASSES.getValue()) &#123; searchService.index(house.getId());&#125; updateStatus方法 123456// 上架更新索引 其他情况都要删除索引if (status == HouseStatus.PASSES.getValue()) &#123; searchService.index(id);&#125; else &#123; searchService.remove(id);&#125; 测试发布按钮是否添加了索引 异步构建索引https://kafka.apache.org/quickstartzookeeper添加listener的IPkafka:commit_memory(0x00000000c0000000, 1073741824, 0) failed; error=’Cannot allocate memory’ (errno=12)内存不够了 有点问题12bin/zookeeper-server-start.sh config/zookeeper.propertiesbin/kafka-server-start.sh config/server.properties Option zookeeper is deprecated, use –bootstrap-server instead. 1234567zkServer.sh startzkServer.sh status[root@localhost kafka_2.12-2.2.0]# jps -l17889 org.apache.zookeeper.server.quorum.QuorumPeerMain30578 org.elasticsearch.bootstrap.Elasticsearch3653 sun.tools.jps.Jps18799 kafka.Kafka server.properties里设置zookeeper 127.0.0.1可以启动创建topic要设置副本数和分区数12345678910111213141516171819202122# 创建topic[root@localhost kafka_2.12-2.2.0]# bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic testCreated topic test.# topic[root@localhost kafka_2.12-2.2.0]# bin/kafka-topics.sh --list --bootstrap-server 10.1.18.25:9092__consumer_offsetstest# 发送消息[root@localhost kafka_2.12-2.2.0]# bin/kafka-console-producer.sh --broker-list 10.1.18.25:9092 --topic test&gt;aaaaa&gt;aaa&gt;# 接收消息[root@localhost kafka_2.12-2.2.0]# bin/kafka-console-consumer.sh --bootstrap-server 10.1.18.25:9092 --topic test --from-beginningaaaaaaaa# 删除[root@localhost kafka_2.12-2.2.0]# bin/kafka-topics.sh --delete --bootstrap-server 10.1.18.25:9092 --topic test#查看是否删除[root@localhost kafka_2.12-2.2.0]# bin/kafka-topics.sh --bootstrap-server 10.1.18.25:9092 --list__consumer_offsets 为什么要用kafka，es服务可能不可用，上架不希望等待es建立完索引再响应 配置kafka123# kafkaspring.kafka.bootstrap-servers=10.1.18.25:9092spring.kafka.consumer.group-id=0 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt; SearchService1234567891011121314151617181920212223@Autowiredprivate KafkaTemplate&lt;String, String&gt; kafkaTemplate;@KafkaListener(topics = INDEX_TOPIC)private void handleMessage(String content) &#123; try &#123; HouseIndexMessage message = objectMapper.readValue(content, HouseIndexMessage.class); switch (message.getOperation()) &#123; case HouseIndexMessage.INDEX: this.createOrUpdateIndex(message); break; case HouseIndexMessage.REMOVE: this.removeIndex(message); break; default: logger.warn("Not support message content " + content); break; &#125; &#125; catch (IOException e) &#123; logger.error("Cannot parse json for " + content, e); &#125;&#125; 自定义消息结构体,用户创建和删除两个操作12345678910111213141516public class HouseIndexMessage &#123; public static final String INDEX = "index"; public static final String REMOVE = "remove"; public static final int MAX_RETRY = 3; private Long houseId; private String operation; private int retry = 0; /** * 默认构造器 防止jackson序列化失败 */ public HouseIndexMessage() &#123; &#125;&#125; es实现客户页面关键词查询多值查询，先按城市+地区的英文名过滤ａ标签当作按钮来使用，但又不希望页面刷新。这个时候就用到上面的javascript:void(0)； ISearchService单测 地点、根据关键词从0取10个查询到的ID12345678910@Testpublic void testQuery() &#123; RentSearch rentSearch = new RentSearch(); rentSearch.setCityEnName("bj"); rentSearch.setStart(0); rentSearch.setSize(10); rentSearch.setKeywords("国贸"); ServiceMultiResult&lt;Long&gt; serviceResult = searchService.query(rentSearch); Assert.assertTrue(serviceResult.getTotal() &gt; 0);&#125; 查到ID还需要去houseService中mysql查询，有关键字的时候才用ES参数：es得到的id数量，es得到的id List123456789101112@Overridepublic ServiceMultiResult&lt;HouseDTO&gt; query(RentSearch rentSearch) &#123; if (rentSearch.getKeywords() != null &amp;&amp; !rentSearch.getKeywords().isEmpty()) &#123; ServiceMultiResult&lt;Long&gt; serviceResult = searchService.query(rentSearch); if (serviceResult.getTotal() == 0) &#123; return new ServiceMultiResult&lt;&gt;(0, new ArrayList&lt;&gt;()); &#125; return new ServiceMultiResult&lt;&gt;(serviceResult.getTotal(), wrapperHouseResult(serviceResult.getResult())); &#125; return simpleQuery(rentSearch);&#125; 通过ID查mysql （+house+detail+tag)，查询结果需要按es重排序12345678910111213141516171819private List&lt;HouseDTO&gt; wrapperHouseResult(List&lt;Long&gt; houseIds) &#123; List&lt;HouseDTO&gt; result = new ArrayList&lt;&gt;(); Map&lt;Long, HouseDTO&gt; idToHouseMap = new HashMap&lt;&gt;(); Iterable&lt;House&gt; houses = houseRepository.findAll(houseIds); houses.forEach(house -&gt; &#123; HouseDTO houseDTO = modelMapper.map(house, HouseDTO.class); houseDTO.setCover(this.cdnPrefix + house.getCover()); idToHouseMap.put(house.getId(), houseDTO); &#125;); wrapperHouseList(houseIds, idToHouseMap); // 矫正顺序 for (Long houseId : houseIds) &#123; result.add(idToHouseMap.get(houseId)); &#125; return result;&#125; simpleQuery 是原来db查询 添加关键词功能123456789boolQuery.must( QueryBuilders.multiMatchQuery(rentSearch.getKeywords(), HouseIndexKey.TITLE, HouseIndexKey.TRAFFIC, HouseIndexKey.DISTRICT, HouseIndexKey.ROUND_SERVICE, HouseIndexKey.SUBWAY_LINE_NAME, HouseIndexKey.SUBWAY_STATION_NAME )); 但是还是不准添加面积 ALL 是空1234567891011RentValueBlock area = RentValueBlock.matchArea(rentSearch.getAreaBlock()); if (!RentValueBlock.ALL.equals(area)) &#123; RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery(HouseIndexKey.AREA); if (area.getMax() &gt; 0) &#123; rangeQueryBuilder.lte(area.getMax()); &#125; if (area.getMin() &gt; 0) &#123; rangeQueryBuilder.gte(area.getMin()); &#125; boolQuery.filter(rangeQueryBuilder); &#125; 添加价格1234567891011RentValueBlock price = RentValueBlock.matchPrice(rentSearch.getPriceBlock()); if (!RentValueBlock.ALL.equals(price)) &#123; RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(HouseIndexKey.PRICE); if (price.getMax() &gt; 0) &#123; rangeQuery.lte(price.getMax()); &#125; if (price.getMin() &gt; 0) &#123; rangeQuery.gte(price.getMin()); &#125; boolQuery.filter(rangeQuery); &#125; 朝向、租赁方式1234567891011if (rentSearch.getDirection() &gt; 0) &#123; boolQuery.filter( QueryBuilders.termQuery(HouseIndexKey.DIRECTION, rentSearch.getDirection()) );&#125;if (rentSearch.getRentWay() &gt; -1) &#123; boolQuery.filter( QueryBuilders.termQuery(HouseIndexKey.RENT_WAY, rentSearch.getRentWay()) );&#125; 分析分词效果get http://10.1.18.25:9200/_analyze?analyzer=standard&amp;pretty=true&amp;text=这是一个句子等于没分 添加中文分词包https://github.com/medcl/elasticsearch-analysis-ik 1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.2/elasticsearch-analysis-ik-5.5.2.zip 删除索引 集群变黄？1curl -XDELETE 修改索引，标题、desc都用analyzed加分词器123456"title": &#123; "type": "text", "index": "analyzed", "analyzer": "ik_smart", "search_analyzer": "ik_smart" &#125;, 对数据库批量做索引 自动补全 ES的Suggesters接口123456789 @GetMapping("rent/house/autocomplete")@ResponseBodypublic ApiResponse autocomplete(@RequestParam(value = "prefix") String prefix) &#123; if (prefix.isEmpty()) &#123; return ApiResponse.ofStatus(ApiResponse.Status.BAD_REQUEST); &#125; ServiceResult&lt;List&lt;String&gt;&gt; result = this.searchService.suggest(prefix); return ApiResponse.ofSuccess(result.getResult());&#125; 新建ES返回的类型，添加到es结构中123public class HouseSuggest &#123; private String input; private int weight = 10; // 默认权重 Templateprivate List&lt;HouseSuggest&gt; suggest;再修改es的索引结构123"suggest": &#123; "type": "completion"&#125;, 新增updateSuggest方法，在创建or更新索引的时候调用1234private boolean create(HouseIndexTemplate indexTemplate) &#123; if(!updateSuggest(indexTemplate))&#123; return false; &#125; Elasticsearch里设计了4种类别的Suggester，分别是:Term SuggesterPhrase SuggesterCompletion SuggesterContext Suggester 而是将analyze过的数据编码成FST和索引一起存放。对于一个open状态的索引，FST会被ES整个装载到内存里的，进行前缀查找速度极快。但是FST只能用于前缀查找，这也是Completion Suggester的局限所在。 逻辑：获得分词，封装到es请求类中构建分词请求，输入用于分词的字段，设置分词器获取分词 123456789101112131415161718192021222324252627282930313233343536private boolean updateSuggest(HouseIndexTemplate indexTemplate) &#123; AnalyzeRequestBuilder requestBuilder = new AnalyzeRequestBuilder( this.esClient, AnalyzeAction.INSTANCE, INDEX_NAME, indexTemplate.getTitle(), indexTemplate.getLayoutDesc(), indexTemplate.getRoundService(), indexTemplate.getDescription(), indexTemplate.getSubwayLineName(), indexTemplate.getSubwayStationName()); requestBuilder.setAnalyzer("ik_smart"); AnalyzeResponse response = requestBuilder.get(); List&lt;AnalyzeResponse.AnalyzeToken&gt; tokens = response.getTokens(); if (tokens == null) &#123; logger.warn("Can not analyze token for house: " + indexTemplate.getHouseId()); return false; &#125; List&lt;HouseSuggest&gt; suggests = new ArrayList&lt;&gt;(); for (AnalyzeResponse.AnalyzeToken token : tokens) &#123; // 排序数字类型 &amp; 小于2个字符的分词结果 if ("&lt;NUM&gt;".equals(token.getType()) || token.getTerm().length() &lt; 2) &#123; continue; &#125; HouseSuggest suggest = new HouseSuggest(); suggest.setInput(token.getTerm()); suggests.add(suggest); &#125; // 定制化小区自动补全 HouseSuggest suggest = new HouseSuggest(); suggest.setInput(indexTemplate.getDistrict()); suggests.add(suggest); indexTemplate.setSuggest(suggests); return true;&#125; 排除数字类型的词（token）对每个合适的词构建自定义的suggest，并设置权重（默认10）将suggest数组添加到es返回类中 如果想添加一些不用分词的keyword类型，直接包装成suggest放到suggest数组中 补全逻辑：调用search语法查询suggest1234567891011121314151617181920212223242526@Overridepublic ServiceResult&lt;List&lt;String&gt;&gt; suggest(String prefix) &#123; CompletionSuggestionBuilder suggestion = SuggestBuilders.completionSuggestion("suggest").prefix(prefix).size(5); SuggestBuilder suggestBuilder = new SuggestBuilder(); suggestBuilder.addSuggestion("autocomplete", suggestion); SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .suggest(suggestBuilder); logger.debug(requestBuilder.toString()); SearchResponse response = requestBuilder.get(); Suggest suggest = response.getSuggest(); if (suggest == null) &#123; return ServiceResult.of(new ArrayList&lt;&gt;()); &#125; Suggest.Suggestion result = suggest.getSuggestion("autocomplete"); int maxSuggest = 0; Set&lt;String&gt; suggestSet = new HashSet&lt;&gt;(); // 去重... List&lt;String&gt; suggests = Lists.newArrayList(suggestSet.toArray(new String[]&#123;&#125;)); return ServiceResult.of(suggests);&#125; 照理说不应该用house生成用户搜索的关键词，建立索引 用户输入存入自动补全索引表123456789101112&#123; "mappings": &#123; "bar": &#123; "properties": &#123; "body": &#123; "type": "completion", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125;&#125; 异步添加词、句子 一个小区有多少套房 数据聚合统计对小区名进行聚集controller12ServiceResult&lt;Long&gt; aggResult = searchService.aggregateDistrictHouse(city.getEnName(), region.getEnName(), houseDTO.getDistrict()); model.addAttribute("houseCountInDistrict", aggResult.getResult()); 聚合语法123456789101112131415161718192021222324252627282930@Overridepublic ServiceResult&lt;Long&gt; aggregateDistrictHouse(String cityEnName, String regionEnName, String district) &#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery() .filter(QueryBuilders.termQuery(HouseIndexKey.CITY_EN_NAME, cityEnName)) .filter(QueryBuilders.termQuery(HouseIndexKey.REGION_EN_NAME, regionEnName)) .filter(QueryBuilders.termQuery(HouseIndexKey.DISTRICT, district)); SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addAggregation( AggregationBuilders.terms(HouseIndexKey.AGG_DISTRICT) .field(HouseIndexKey.DISTRICT) ).setSize(0); logger.debug(requestBuilder.toString()); SearchResponse response = requestBuilder.get(); if (response.status() == RestStatus.OK) &#123; Terms terms = response.getAggregations().get(HouseIndexKey.AGG_DISTRICT); if (terms.getBuckets() != null &amp;&amp; !terms.getBuckets().isEmpty()) &#123; return ServiceResult.of(terms.getBucketByKey(district).getDocCount()); &#125; &#125; else &#123; logger.warn("Failed to Aggregate for " + HouseIndexKey.AGG_DISTRICT); &#125; return ServiceResult.of(0L);&#125; es查询调优_search?explain=true对标题字段改权重123boolQuery.must( QueryBuilders.matchQuery(HouseIndexKey.TITLE, rentSearch.getKeywords()).boost(2.0f)); 还可以把must改成should 查询条件返回的是整个es文档，只返回需要的字段12345678910SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addSort( HouseSort.getSortKey(rentSearch.getOrderBy()), SortOrder.fromString(rentSearch.getOrderDirection()) ) .setFrom(rentSearch.getStart()) .setSize(rentSearch.getSize()) .setFetchSource(HouseIndexKey.HOUSE_ID, null); 8.百度地图 按地图找房创建两个应用，类别：服务端、浏览器端浏览器端的AK 复制到新建的rent-map页面，引入百度的css和js代码新建controller，利用session存一些东西查有多少个区域查数据库就ok，一共有多少房需要es聚合数据123public class HouseBucketDTO &#123; private String key; private long count; 1234567891011121314151617181920212223242526272829 @Overridepublic ServiceMultiResult&lt;HouseBucketDTO&gt; mapAggregate(String cityEnName) &#123; // 过滤城市 BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); boolQuery.filter(QueryBuilders.termQuery(HouseIndexKey.CITY_EN_NAME, cityEnName)); // 起名、根据enname字段聚合 AggregationBuilder aggBuilder = AggregationBuilders.terms(HouseIndexKey.AGG_REGION) .field(HouseIndexKey.REGION_EN_NAME); SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addAggregation(aggBuilder); logger.debug(requestBuilder.toString()); SearchResponse response = requestBuilder.get(); // 异常处理 List&lt;HouseBucketDTO&gt; buckets = new ArrayList&lt;&gt;(); if (response.status() != RestStatus.OK) &#123; logger.warn("Aggregate status is not ok for " + requestBuilder); return new ServiceMultiResult&lt;&gt;(0, buckets); &#125; // 根据刚起的名获取数据 Terms terms = response.getAggregations().get(HouseIndexKey.AGG_REGION); for (Terms.Bucket bucket : terms.getBuckets()) &#123; buckets.add(new HouseBucketDTO(bucket.getKeyAsString(), bucket.getDocCount())); &#125; return new ServiceMultiResult&lt;&gt;(response.getHits().getTotalHits(), buckets);&#125; 前端地图拿到数据12345678910// 声明一个区域 设置好id &lt;div id="allmap" class="wrapper"&gt;&lt;script type="text/javascript" th:inline="javascript"&gt; // 初始化加载地图数据 var city = [[$&#123;city&#125;]], regions = [[$&#123;regions&#125;]], aggData = [[$&#123;aggData&#125;]]; console.log(regions) load(city, regions, aggData);&lt;/script&gt; 画地图1234567891011121314function load(city, regions, aggData) &#123; // 百度地图API功能 // 创建实例。设置地图显示最大级别为城市(不能缩放成世界） var map = new BMap.Map("allmap", &#123;minZoom: 12&#125;); // 坐标拾取获取中心点 http://api.map.baidu.com/lbsapi/getpoint/index.html var point = new BMap.Point(city.baiduMapLongitude, city.baiduMapLatitude); // 初始化地图，设置中心点坐标及地图级别 map.centerAndZoom(point, 12); // 添加比例尺控件 map.addControl(new BMap.NavigationControl(&#123;enableGeolocation: true&#125;)); // 左上角 map.addControl(new BMap.ScaleControl(&#123;anchor: BMAP_ANCHOR_TOP_LEFT&#125;)); // 开启鼠标滚轮缩放 map.enableScrollWheelZoom(true); 给地图添加标签显示当前区域有多少套，从百度地图获取城市和区的经纬度，存在support_address表里 文档Label：http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a3b912setContent(content: String) none 设置文本标注的内容。支持HTMLsetStyle(styles: Object) none 设置文本标注样式，该样式将作用于文本标注的容器元素上。其中styles为JavaScript对象常量，比如： setStyle(&#123; color : &quot;red&quot;, fontSize : &quot;12px&quot; &#125;) 注意：如果css的属性名中包含连字符，需要将连字符去掉并将其后的字母进行大写处理，例如：背景色属性要写成：backgroundColor drawRegion(map, regions);123456789101112131415161718192021222324252627282930313233343536373839404142// 全局区域几套房数据var regionCountMap = &#123;&#125;function drawRegion(map, regionList) &#123; var boundary = new BMap.Boundary(); var polygonContext = &#123;&#125;; var regionPoint; var textLabel; for (var i = 0; i &lt; regionList.length; i++) &#123; regionPoint = new BMap.Point(regionList[i].baiduMapLongitude, regionList[i].baiduMapLatitude); // 从后端获取到的数据先保存成全局的了 var houseCount = 0; if (regionList[i].en_name in regionCountMap) &#123; houseCount = regionCountMap[regionList[i].en_name]; &#125; // 标签内容 var textContent = '&lt;p style="margin-top: 20px; pointer-events: none"&gt;' + regionList[i].cn_name + '&lt;/p&gt;' + '&lt;p style="pointer-events: none"&gt;' + houseCount + '套&lt;/p&gt;'; textLabel = new BMap.Label(textContent, &#123; // 标签位置 position: regionPoint, // 文本偏移量 offset: new BMap.Size(-40, 20) &#125;); // 添加style 变成原型 textLabel.setStyle(&#123; height: '78px', width: '78px', color: '#fff', backgroundColor: '#0054a5', border: '0px solid rgb(255, 0, 0)', borderRadius: "50%", fontWeight: 'bold', display: 'inline', lineHeight: 'normal', textAlign: 'center', opacity: '0.8', zIndex: 2, overflow: 'hidden' &#125;); // 将标签画在地图上 map.addOverlay(textLabel); pointer-events: none上面元素盖住下面地图，地图无法操作。 但是这个Label一放大就没了 添加区域覆盖 Polygon API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 记录行政区域覆盖物// 点集合polygonContext[textContent] = [];// 闭包传参(function (textContent) &#123; // 获取行政区域 boundary.get(city.cn_name + regionList[i].cn_name, function(rs) &#123; // 行政区域边界点集合长度 var count = rs.boundaries.length; console.log(rs.boundaries) if (count === 0) &#123; alert('未能获取当前输入行政区域') return; &#125; for (var j = 0; j &lt; count; j++) &#123; // 建立多边形覆盖物 var polygon = new BMap.Polygon( rs.boundaries[j], &#123; strokeWeight: 2, strokeColor:'#0054a5', fillOpacity: 0.3, fillColor: '#0054a5' &#125; ); // 添加覆盖物 map.addOverlay(polygon); polygonContext[textContent].push(polygon); // 初始化隐藏边界 polygon.hide(); &#125; &#125;)&#125;)(textContent);// 添加鼠标事件textLabel.addEventListener('mouseover', function (event) &#123; var label = event.target; console.log(event) var boundaries = polygonContext[label.getContent()]; label.setStyle(&#123;backgroundColor: '#1AA591'&#125;); for (var n = 0; n &lt; boundaries.length; n++) &#123; boundaries[n].show(); &#125;&#125;);textLabel.addEventListener('mouseout', function (event) &#123; var label = event.target; var boundaries = polygonContext[label.getContent()]; label.setStyle(&#123;backgroundColor: '#0054a5'&#125;); for (var n = 0; n &lt; boundaries.length; n++) &#123; boundaries[n].hide(); &#125;&#125;);textLabel.addEventListener('click', function (event) &#123; var label = event.target; var map = label.getMap(); map.zoomIn(); map.panTo(event.point);&#125;);&#125; 给es添加位置索引 es基于gps系统 百度地图是123"location": &#123; "type": "geo_point" &#125; 新建地理位置类12345public class BaiduMapLocation &#123; @JsonProperty("lon") private double longitude; @JsonProperty("lat") private double latitude; 在es显示对应类添加private BaiduMapLocation location; 在addressService里添加根据城市和地址 根据百度地图API找经纬度在新建索引时调用（template是用于保存mysql中查询到的数据，保存到es）123456789SupportAddress city = supportAddressRepository.findByEnNameAndLevel(house.getCityEnName(), SupportAddress.Level.CITY.getValue());SupportAddress region = supportAddressRepository.findByEnNameAndLevel(house.getRegionEnName(), SupportAddress.Level.REGION.getValue());String address = city.getCnName() + region.getCnName() + house.getStreet() + house.getDistrict() + detail.getDetailAddress();ServiceResult&lt;BaiduMapLocation&gt; location = addressService.getBaiduMapLocation(city.getCnName(), address);if (!location.isSuccess()) &#123; this.index(message.getHouseId(), message.getRetry() + 1); return;&#125;indexTemplate.setLocation(location.getResult()); addressService中的调用百度api包装成http格式（中文要用utf-8编码），HttpClient 拼接地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic ServiceResult&lt;BaiduMapLocation&gt; getBaiduMapLocation(String city, String address) &#123; String encodeAddress; String encodeCity; try &#123; encodeAddress = URLEncoder.encode(address, "UTF-8"); encodeCity = URLEncoder.encode(city, "UTF-8"); System.out.println(encodeAddress); System.out.println(encodeCity); &#125; catch (UnsupportedEncodingException e) &#123; logger.error("Error to encode house address", e); return new ServiceResult&lt;BaiduMapLocation&gt;(false, "Error to encode hosue address"); &#125; HttpClient httpClient = HttpClients.createDefault(); StringBuilder sb = new StringBuilder(BAIDU_MAP_GEOCONV_API); sb.append("address=").append(encodeAddress).append("&amp;") .append("city=").append(encodeCity).append("&amp;") .append("output=json&amp;") .append("ak=").append(BAIDU_MAP_KEY); // 执行 HttpGet get = new HttpGet(sb.toString()); try &#123; HttpResponse response = httpClient.execute(get); if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) &#123; return new ServiceResult&lt;BaiduMapLocation&gt;(false, "Can not get baidu map location"); &#125; // 拿结果 json String result = EntityUtils.toString(response.getEntity(), "UTF-8"); System.out.println("返回"+result); JsonNode jsonNode = objectMapper.readTree(result); int status = jsonNode.get("status").asInt(); if (status != 0) &#123; return new ServiceResult&lt;BaiduMapLocation&gt;(false, "Error to get map location for status: " + status); &#125; &#123; BaiduMapLocation location = new BaiduMapLocation(); JsonNode jsonLocation = jsonNode.get("result").get("location"); location.setLongitude(jsonLocation.get("lng").asDouble()); location.setLatitude(jsonLocation.get("lat").asDouble()); return ServiceResult.of(location); &#125; &#125; catch (IOException e) &#123; logger.error("Error to fetch baidumap api", e); return new ServiceResult&lt;BaiduMapLocation&gt;(false, "Error to fetch baidumap api"); &#125;&#125; 测试123456789101112@Testpublic void testGetMapLocation() &#123; String city = "北京"; String address = "北京市昌平区巩华家园1号楼2单元"; ServiceResult&lt;BaiduMapLocation&gt; serviceResult = addressService.getBaiduMapLocation(city, address); Assert.assertTrue(serviceResult.isSuccess()); Assert.assertTrue(serviceResult.getResult().getLongitude() &gt; 0 ); Assert.assertTrue(serviceResult.getResult().getLatitude() &gt; 0 );&#125; 地图找房，前端数据传递1234567891011121314151617181920212223public class MapSearch &#123; private String cityEnName; /** * 地图缩放级别 */ private int level = 12; private String orderBy = "lastUpdateTime"; private String orderDirection = "desc"; /** * 左上角 */ private Double leftLongitude; private Double leftLatitude; /** * 右下角 */ private Double rightLongitude; private Double rightLatitude; private int start = 0; private int size = 5; 接口12345678910111213141516171819@GetMapping("rent/house/map/houses")@ResponseBodypublic ApiResponse rentMapHouses(@ModelAttribute MapSearch mapSearch) &#123; System.out.println("找房参数"+mapSearch); if (mapSearch.getCityEnName() == null) &#123; return ApiResponse.ofMessage(HttpStatus.BAD_REQUEST.value(), "必须选择城市"); &#125; ServiceMultiResult&lt;HouseDTO&gt; serviceMultiResult; if (mapSearch.getLevel() &lt; 13) &#123; serviceMultiResult = houseService.wholeMapQuery(mapSearch); &#125; else &#123; // 小地图查询必须要传递地图边界参数 serviceMultiResult = houseService.boundMapQuery(mapSearch); &#125; ApiResponse response = ApiResponse.ofSuccess(serviceMultiResult.getResult()); response.setMore(serviceMultiResult.getTotal() &gt; (mapSearch.getStart() + mapSearch.getSize())); return response;&#125; es查找的参数城市、排序方式、数量1234567891011121314151617181920212223242526272829@Overridepublic ServiceMultiResult&lt;Long&gt; mapQuery(String cityEnName, String orderBy, String orderDirection, int start, int size) &#123; // 限定城市 BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); boolQuery.filter(QueryBuilders.termQuery(HouseIndexKey.CITY_EN_NAME, cityEnName)); // +排序 +分页 SearchRequestBuilder searchRequestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addSort(HouseSort.getSortKey(orderBy), SortOrder.fromString(orderDirection)) .setFrom(start) .setSize(size); List&lt;Long&gt; houseIds = new ArrayList&lt;&gt;(); SearchResponse response = searchRequestBuilder.get(); if (response.status() != RestStatus.OK) &#123; logger.warn("Search status is not ok for " + searchRequestBuilder); return new ServiceMultiResult&lt;&gt;(0, houseIds); &#125; // 从sorce获取数据obj-&gt;String-&gt;Long -&gt;List for (SearchHit hit : response.getHits()) &#123; houseIds.add(Longs.tryParse(String.valueOf(hit.getSource().get(HouseIndexKey.HOUSE_ID)))); &#125; return new ServiceMultiResult&lt;&gt;(response.getHits().getTotalHits(), houseIds);&#125; 安装kafka managersbthttps://github.com/sbt/sbt/releases geo查询 bound查询1234567891011121314151617181920212223242526272829303132@Overridepublic ServiceMultiResult&lt;Long&gt; mapQuery(MapSearch mapSearch) &#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); boolQuery.filter(QueryBuilders.termQuery(HouseIndexKey.CITY_EN_NAME, mapSearch.getCityEnName())); boolQuery.filter( QueryBuilders.geoBoundingBoxQuery("location") .setCorners( new GeoPoint(mapSearch.getLeftLatitude(), mapSearch.getLeftLongitude()), new GeoPoint(mapSearch.getRightLatitude(), mapSearch.getRightLongitude()) )); SearchRequestBuilder builder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addSort(HouseSort.getSortKey(mapSearch.getOrderBy()), SortOrder.fromString(mapSearch.getOrderDirection())) .setFrom(mapSearch.getStart()) .setSize(mapSearch.getSize()); List&lt;Long&gt; houseIds = new ArrayList&lt;&gt;(); SearchResponse response = builder.get(); if (RestStatus.OK != response.status()) &#123; logger.warn("Search status is not ok for " + builder); return new ServiceMultiResult&lt;&gt;(0, houseIds); &#125; for (SearchHit hit : response.getHits()) &#123; houseIds.add(Longs.tryParse(String.valueOf(hit.getSource().get(HouseIndexKey.HOUSE_ID)))); &#125; return new ServiceMultiResult&lt;&gt;(response.getHits().getTotalHits(), houseIds);&#125; 在地图上绘制各个房子的地点（麻点）lbs服务，将房源信息上传到lbs 创建数据（create poi）接口 post请求http://lbsyun.baidu.com/index.php?title=lbscloud/api/geodata用3：百度加密经纬度坐标示例 前端配置geotableId就可以直接放图层了http://lbsyun.baidu.com/jsdemo.htm#g0_4 9.会员管理 短信登陆1234567891011121314151617181920// 新增用户 更新用户表和权限表要加事务@Override@Transactionalpublic User addUserByPhone(String telephone) &#123; User user = new User(); user.setPhoneNumber(telephone); user.setName(telephone.substring(0, 3) + "****" + telephone.substring(7, telephone.length())); Date now = new Date(); user.setCreateTime(now); user.setLastLoginTime(now); user.setLastUpdateTime(now); user = userRepository.save(user); Role role = new Role(); role.setName("USER"); role.setUserId(user.getId()); roleRepository.save(role); user.setAuthorityList(Lists.newArrayList(new SimpleGrantedAuthority("ROLE_USER"))); return user;&#125; 添加filter12345678910111213141516171819202122232425262728293031323334public class AuthFilter extends UsernamePasswordAuthenticationFilter &#123; @Autowired private IUserService userService; @Autowired private ISmsService smsService; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; String name = obtainUsername(request); if (!Strings.isNullOrEmpty(name)) &#123; request.setAttribute("username", name); return super.attemptAuthentication(request, response); &#125; String telephone = request.getParameter("telephone"); if (Strings.isNullOrEmpty(telephone) || !LoginUserUtil.checkTelephone(telephone)) &#123; throw new BadCredentialsException("Wrong telephone number"); &#125; User user = userService.findUserByTelephone(telephone); String inputCode = request.getParameter("smsCode"); String sessionCode = smsService.getSmsCode(telephone); if (Objects.equals(inputCode, sessionCode)) &#123; if (user == null) &#123; // 如果用户第一次用手机登录 则自动注册该用户 user = userService.addUserByPhone(telephone); &#125; return new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities()); &#125; else &#123; throw new BadCredentialsException("smsCodeError"); &#125; &#125; 阿里云短信 security 通过手机号查数据库用户12345678910111213141516@Overridepublic User findUserByTelephone(String telephone) &#123; User user = userRepository.findUserByPhoneNumber(telephone); if (user == null) &#123; return null; &#125; List&lt;Role&gt; roles = roleRepository.findRolesByUserId(user.getId()); if (roles == null || roles.isEmpty()) &#123; throw new DisabledException("权限非法"); &#125; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); roles.forEach(role -&gt; authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()))); user.setAuthorityList(authorities); return user;&#125; 创建用户，生成用户名 要写role表和user表 需要事务没有密码12345678910111213141516171819@Override@Transactionalpublic User addUserByPhone(String telephone) &#123; User user = new User(); user.setPhoneNumber(telephone); user.setName(telephone.substring(0, 3) + "****" + telephone.substring(7, telephone.length())); Date now = new Date(); user.setCreateTime(now); user.setLastLoginTime(now); user.setLastUpdateTime(now); user = userRepository.save(user); Role role = new Role(); role.setName("USER"); role.setUserId(user.getId()); roleRepository.save(role); user.setAuthorityList(Lists.newArrayList(new SimpleGrantedAuthority("ROLE_USER"))); return user;&#125; 调用读数据库，比较用户输入验证码12345678910111213141516171819202122232425262728293031323334353637public class AuthFilter extends UsernamePasswordAuthenticationFilter &#123; @Autowired private IUserService userService; @Autowired private ISmsService smsService; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; System.out.println("登陆请求"+request.getRequestedSessionId()); String name = obtainUsername(request); if (!Strings.isNullOrEmpty(name)) &#123; request.setAttribute("username", name); return super.attemptAuthentication(request, response); &#125; String telephone = request.getParameter("telephone"); if (Strings.isNullOrEmpty(telephone) || !LoginUserUtil.checkTelephone(telephone)) &#123; throw new BadCredentialsException("Wrong telephone number"); &#125; User user = userService.findUserByTelephone(telephone); String inputCode = request.getParameter("smsCode"); String sessionCode = smsService.getSmsCode(telephone); if (Objects.equals(inputCode, sessionCode)) &#123; if (user == null) &#123; // 如果用户第一次用手机登录 则自动注册该用户 user = userService.addUserByPhone(telephone); &#125; return new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities()); &#125; else &#123; throw new BadCredentialsException("smsCodeError"); &#125; &#125;&#125; 配置到security12345678910public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * HTTP权限控制 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(authFilter(), UsernamePasswordAuthenticationFilter.class);&#125; 注册manager和失败的bean1234567891011121314151617@Beanpublic AuthenticationManager authenticationManager() &#123; AuthenticationManager authenticationManager = null; try &#123; authenticationManager = super.authenticationManager(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return authenticationManager;&#125;@Beanpublic AuthFilter authFilter() &#123; AuthFilter authFilter = new AuthFilter(); authFilter.setAuthenticationManager(authenticationManager()); authFilter.setAuthenticationFailureHandler(authFailHandler()); return authFilter;&#125; 短信验证码发送验证码接口12345678910111213@GetMapping(value = "sms/code")@ResponseBodypublic ApiResponse smsCode(@RequestParam("telephone") String telephone) &#123; if (!LoginUserUtil.checkTelephone(telephone)) &#123; return ApiResponse.ofMessage(HttpStatus.BAD_REQUEST.value(), "请输入正确的手机号"); &#125; ServiceResult&lt;String&gt; result = smsService.sendSms(telephone); if (result.isSuccess()) &#123; return ApiResponse.ofSuccess(""); &#125; else &#123; return ApiResponse.ofMessage(HttpStatus.BAD_REQUEST.value(), result.getMessage()); &#125;&#125; 添加初始化方法，在bean初始化的时候装配好client坑：阿里云的gson版本，把自己引入的gson删掉就行了 任何对数据库有更改的接口都要加事务 用户名、密码修改接口 房屋预约功能12345678910111213141516171819202122232425262728293031323334@Table(name = "house_subscribe")public class HouseSubscribe &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "house_id") private Long houseId; @Column(name = "user_id") private Long userId; @Column(name = "admin_id") private Long adminId; // 预约状态 1-加入待看清单 2-已预约看房时间 3-看房完成 private int status; @Column(name = "create_time") private Date createTime; @Column(name = "last_update_time") private Date lastUpdateTime; @Column(name = "order_time") private Date orderTime; private String telephone; /** * 踩坑 desc为MySQL保留字段 需要加转义 */ @Column(name = "`desc`") private String desc; 经纪人看房记录，管理人联系用户经纪人后台list，操作看房完成标记 api接口security拦截1234567891011121314public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; String uri = request.getRequestURI(); if (uri.startsWith(API_FREFIX)) &#123; response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.setContentType(CONTENT_TYPE); PrintWriter pw = response.getWriter(); pw.write(API_CODE_403); pw.close(); &#125; else &#123; super.commence(request, response, authException); &#125;&#125; 客服聊天系统 美洽 监控12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; management.security.enabled=false 用jconsole查看maxBean PS Scavenge 25次 262ms 新生代 吞吐量优先收集器复制算法，并行多线程PS MarkSweep（Parallel Old） 9次 2073ms 多线程压缩收集 预约功能和会员中心 desc字段需要转义 必须变成12@Column(name = "`desc`")private String desc; 123456789101112131415161718public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; User findByName(String userName); User findUserByPhoneNumber(String telephone); @Modifying @Query("update User as user set user.name = :name where id = :id") void updateUsername(@Param(value = "id") Long id, @Param(value = "name") String name); @Modifying @Query("update User as user set user.email = :email where id = :id") void updateEmail(@Param(value = "id") Long id, @Param(value = "email") String email); @Modifying @Query("update User as user set user.password = :password where id = :id") void updatePassword(@Param(value = "id") Long id, @Param(value = "password") String password);&#125; es调优索引读写优化index.store.type:&quot;niofsdynamic=strict关闭all字段，防止全部字段用于全文索引6.0已经没了&quot;_all&quot;:{ &quot;enabled&quot;:flase} 延迟恢复分片&quot;index.unassigned.node_left.delayed_timeout&quot;:&quot;5m&quot; 配置成指挥节点和数据节点，数据节点的http功能可以关闭，只做tcp数据交互负载均衡节点master和data都是false，一般都是用nginx 不会用es节点堆内存空间 指针压缩 小于32G内存才会用批量操作 bulk nginx./configure --with-stream用stream模块 开启慢查询日志1234567891011mysql&gt; show variables like &apos;%slow_query_log%&apos;;+---------------------+-----------------------------------+| Variable_name | Value |+---------------------+-----------------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/localhost-slow.log |+---------------------+-----------------------------------+2 rows in set (0.00 sec)mysql&gt; set global slow_query_log=1;Query OK, 0 rows affected (0.01 sec) tcp反向代理1234./configure --with-streammake install./nginx -s reload 日志路径12[root@localhost logs]# lsaccess.log error.log nginx.pid nginx 坑访问首页没问题，但是在登录跳转重定向时域名被修改成upstream的名字一定要加！！！！Host 在HTTP/1.1中，Host请求头部必须存在,否则会返回400 Bad Request curl 用法 nginx access 日志110.1.18.87 - - [25/Jun/2019:19:08:50 +0800] "GET /static/lib/layer/2.4/layer.js HTTP/1.1" 200 19843 "http://10.1.18.27/" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36" "-" 日志采集Logstash123456789101112input&#123; file&#123; path =&gt; ["/usr/local/nginx/logs/access.log"] type =&gt; "nginx_access" start_position =&gt; "beginning" &#125;&#125;output&#123; stdout&#123; codec =&gt;rubydebug &#125;&#125; 启动1root@localhost logstash-5.5.2]# ./bin/logstash -f config/logstash.conf 提取了日志和时间戳12345678&#123; "path" =&gt; "/usr/local/nginx/logs/access.log", "@timestamp" =&gt; 2019-06-25T11:32:52.787Z, "@version" =&gt; "1", "host" =&gt; "localhost.localdomain", "message" =&gt; "10.1.18.87 - - [25/Jun/2019:19:26:44 +0800] \"GET /static/lib/layer/2.4/skin/layer.css HTTP/1.1\" 200 14048 \"http://10.1.18.27/\" \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\" \"-\"", "type" =&gt; "nginx_access"&#125;]]></content>
      <categories>
        <category>项目流程</category>
      </categories>
      <tags>
        <tag>项目流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试卡片]]></title>
    <url>%2F2018%2F12%2F25%2Finterview-recite%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/jackfrued/article/details/44921941https://github.com/randian666/algorithm-studyhttps://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.mdhttp://www.linya.pub/ https://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2 https://www.nowcoder.com/discuss/111311 架构扫盲https://github.com/doocs/advanced-java 1.数据库SQL生命周期：应用服务器与数据库服务器建立一个连接数据库进程拿到请求sql解析并生成执行计划，执行读取数据到内存并进行逻辑处理通过步骤一的连接，发送结果到客户端关掉连接，释放资源 数据库连接池1.数据库更适合长连接，复用连接，维护连接对象、分配、管理、释放，也可以避免创建大量的连接对DB引发的各种问题2.通过请求排队缓解对db的冲击 mysql 的其他引擎设计数据库表 1.数据库里的乐观锁和悲观锁共享锁、排他锁 悲观锁：select ... for update; 主键明确&amp;有结果行锁，无结果集（查空）无锁。 查询无主键或者不走索引where id&lt;&gt;&#39;66&#39; like，表索 。乐观锁：数据库version字段 2.索引什么时候会失效：模糊匹配、类型隐转、最左匹配1）有or or中的每个列都要有索引2）like 以%开头用覆盖索引index_all 只访问索引的查询using index &amp; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据例如联合索引a,b一般不能单独用b的索引，但是count就能用 3）如果where=字符串 一定要加引号4)如果数据太少还是全表扫描快就不用，如果查询的列太多，数据太多，会直接走主键全表扫描5）is null或者is not null 3.Mysql 有哪些索引数据结构：B+，hash，全文索引，R-Tree 物理存储：聚集索引、非聚集索引 逻辑角度：主键、单列索引、多列索引、空间索引、覆盖索引（？） 4.数据库隔离界别5.mybatis和jdbc比有什么好处1)动态sql 持久层框架 6.防止sql注入如何实现#{} 会被替换成sql中的？调用PreparedStatement set进参数${} 是替换值 字段名不一样，定义resultMap，id标签映射主键并设置column，其他列用result标签 写模糊查询不要写在sql，用#{}传入 7.分页原理：物理分页：limit offset逻辑分页 8.数据库索引INNDB的好处事务，主键索引，外键自增长列必须是主键，索引的第一个列，而且因为不是表锁要考虑并发增长。innodb其实不是根据每个记录产生行锁的，根据页加锁，而且用位图。 意向锁。锁定对象分为几个层次，支持行锁、表锁同时存在。 一致性非锁定读：读快照 多版本并发控制：read committed是最新快照，重复读是事务开始时的快照。通过undo完成的。 redo 保证事务的一致性、持久性。undo 保证事务的一致性（回滚）和MVCC多版本并发控制。 不走索引表锁。 myisam 缓冲池之缓存索引文件，不缓存数据。 索引和数据分文件。 脏读脏页是最终一致性的，数据库实例内存和磁盘异步造成的。脏（数据）读违反了隔离性。 9.mysql日志文件（不是引擎）binlog(逻辑日志，是sql）记录了数据库更改的所有操作。有3种格式 Statement：sql语句。 row：记录行的更改情况，很占空间，而且对复制的网络开销也增加。mixed。用于point-in-time恢复、主从复制只有事务提交时写磁盘一次。 慢查询、查询、错误 数据完整性：记录每个页的更改物理情况redo重做日志缓存，按一定频率写到重做日志文件 是innodb的。事务进行中，缓存每秒写入一次文件。内部xa事务事务提交先写binlog再写reodlog也写入磁盘。 doublewrite：内存中的2M buffer，磁盘上共享表空间的128个页（2M）在应用重做日志之前，需要通过副本还原页。页刷新都首先要放入doublewrite。 因为只有一个主键并且建了B+树，所以其他辅助索引的插入是离散的，所以，有insert buffer mysql为什么可重复读不可重复读重点在于update和delete，而幻读的重点在于insert。幻读：虽然可重复读对第一次读到的数据加锁，但是插入还是可以的，就多了一行。 因为binlog的Statement以commit顺序可重复读会对读取到的数据进行加锁（行锁），保证其他事务无法修改这些已经读过的数据， MVCC实现可重复读只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度每个数据行会添加两个额外的隐藏列，分别记录这行数据何时被创建以及何时被删除，这里的时间用版本号控制 所有的SELECT操作无需加锁，因为即使所读的数据在下一次读之前被其他事务更新了 行锁会用gap锁锁住一个区间，阻止多个事务插入到同一范围内。是为了解决幻读问题。一个事务select * from t where a&gt;2 for update;对[2+)加锁，另一个事务插入5失败。 mysql主从复制主节点创建线程发送binlog，读取binlog时会加锁。mysql在事务提交前，记录binlog。主库通过发送信号告知从库有新事件。从节点I/O线程接受binlog，保存在relaylog中继log。从节点SQL线程读取relaylog，并执行sql。完成数据一致性。也可以开启放到自身的二进制日志中。在主库上并发的操作变成串行的。 主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。 复制一个库，先dump一个快照，得到当前快照时对应binlog中的偏移量：日志文件坐标 mysql的两种复制方式：语句复制：只记录修改数据的查询。更新是串行的，需要很多锁基于行的复制：实际数据记录在binlog。 但是例如全表更新的操作 行数据让会binlog很大。 10.数据库最左匹配原理11.jdbc数据库过程12345678910111213141516//1加载驱动//用调用者的类加载器 加载类并初始化（静态变量赋值和静态代码块）Class.forName("com.mysql.jdbc.Driver");//2.获取数据库连接// Connection conn = DriverManger.getConnection(DB_URL,USER,PASS);//3.创建StatementStatement stmt = conn.createStatement();//4.执行sqlResultSet rs = stmt.executeQuery(SQL);//5遍历结果while(rs.next())&#123; rs.getString(列名);&#125;//6，异常cache//7.finally关闭连接 Spring jdbcTemplate可以将查询结果用RowMapper返回成一个对象list 2.网络 web服务器1.一个端口的连接数太多Linux中，一个端口能够接受tcp链接数量的理论上限是？无上限client端的情况下，最大tcp连接数为65535 server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。 server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万 是没问题的 有一个接口一下子快一下子慢1）用户怎么排查2）开发者怎么排查如果是一个数据库接口 2.反爬虫1）单个IP、session统计 对header user-agent、referer检测 3.7层模型是哪7层表示层：数据格式变化，加密解密，压缩和恢复 会被放到应用层和会话层会话层：建立连接，有序传输数据。建立、管理、终止会话。使用校验点，使会话失效时从同步点/校验点恢复通信。（传文件）ADSP ASP传输层：第一个端到端通信。根据端口分报文到不同的进程。 4.http如果输入163.com跳转到www.163301 重定向 206 客户端发送range，服务端有accept-range 响应码nginx会检查的405 Not Allowed 必须是GET/POST等指定的方法，header不合法，有下划线等414 Request URI too Large 请求行太长，超过buffer400 Bad request 单个header超过单个buffer大小413 Request Entity Too Large 浏览器发送的Content-Length 超过服务器的包体大小。 502 的原因是由于上游服务器的故障，比如停机，进程被杀死，上游服务 reset 了连接，进程僵死等各种原因。在 nginx 的日志中我们能够发现 502 错误的具体原因，分别为：104: Connection reset by peer，113: Host is unreachable，111: Connection refused。 504 的原因比较简单，一般都是上游服务的执行时间超过了 nginx 的等待时间 QUIC协议已经标准化为Http3协议。基于UDP，但提供了可靠性和流量控制。可以避免Http2的前序包阻塞 HTTP2以frame 分帧发送只建立一个连接 并发发送服务端推送 重定向的响应头为302，并且必须要有Location响应头；服务器通过response响应，重定向的url放在response的什么地方？后端在header里的设置的Location url重定向可以用于均衡负载 5.nginx10w以上的并发连接 Nginx是如何工作的？是如何配置的？工作模式：进程模式：一个master进程管理worker进程，监听连接请求。worker进程处理业务请求，每个worker可以并行处理数千个并发连接和请求。事件模式：网络、信号、定时器惊群现象1)事件驱动、全异步网络I/O 极少进程切换2）sendfile系统调用 硬盘-&gt;网络3）可靠性：多进程独立 epoll：通过内核与用户空间mmap同一块内存实现的 tomcat nginx apache 区别Apache和nginx是 Http静态服务器tomcat 是 Servlet 的容器，处理动态资源。 cookie跨域问题web1想要拿到web2的cookie KV并且让path变成/web1发ajax，type：get，dataType：jsonp。jsonp利用回调函数，服务端response的outputstream返回document.cookie=&quot;k=v;path=/web1&quot;（返回可执行的js代码，回调函数自动执行js） nginx nginx的负载均衡策略1.轮询round robin 按配置文件中的顺序分发2.最少连接 活动连接数量最少的服务器3.IP地址哈希 方便session保存1234567http &#123; upstream myapp1 &#123; //ip_hash, least_conn; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; 4.基于权重的均衡负载 nginx限流是漏桶法 6.正向代理和反向代理的区别正向代理：隐藏了真实的请求客户端，服务端不知道真实的客户端是谁。需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回。 反向代理：接收外网请求，转发给内网上游服务器，并将结果返回给外网客户端。先接受完请求的1G文件，缓存客户端请求，建立转发，降低上游服务器负载（占用服务器的连接时间会非常短）。 其他web服务器有哪些 7.nodejs为什么快？用户态异步实现单进程，非阻塞异步IO，通过回调高度用户 事件驱动 超过5w主进程现在只要专心处理一些与I/O无关的逻辑处理 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈 8.为什么是三次握手三次握手的过程：https://juejin.im/post/5a0444d45188255ea95b66bc客户端 端口+SYN=1+序号a SYN_SENT，服务端 SYN=1，ACK=1,序号b，ack=序号a+1, 客户端ESTABLISHED客户端 ACK = 1，序号=a+1,ack=b+1,服务端ESTABLISHED 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 三次通信是理论上的最小值。 1）初始化序号 （来解决网络包乱序（reordering）问题），互相通知自己的序号。 2）为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。如果A发送2个建立链接给B，第一个没丢只是滞留了，如果不第三次握手只要B同意连接就建立了。如果B以为连接已经建立了，就一直等A。所以需要A再确认。 首次握手隐患：服务器收到ACK 发送SYN-ACK之后没有回执，会重发SYN-ACK。产生SYN flood。用tcp_syncookies 参数 SYN 洪水攻击：服务端收到客户端SYN后发送SYN和ACK后，客户端不回复，导致服务端大量SYN_RCVD设置syn ack retry参数加快半连接回收速度。 或者调大syn backlog 9.拥塞控制4种算法拥塞控制：慢启动、拥塞避免、快重传、快速恢复4个算法cwind：发送方维护 拥塞窗口，发送窗口可能小于拥塞窗口 cwind初始值可以设置为10MSSssthresh：慢启动门限 (接收缓冲区rwndnet.ipv4.tcp_rmem) 慢启动：cwind 报文数 指数增长拥塞避免：cwind到 慢启动的门限ssthresh线性增长 一旦造成网络拥塞，发生超时重传时 cwind重新【慢启动】，ssthresh为cwind/2快重传：接收到失序报文 立刻发出重复确认（而不是稍带确认），发送方收到3个重复确认立即重传对方没收到的报文，不用等待重传计时器。快恢复：当收到3个重复确认（快重传，能收到ack说明没有拥塞）ssthresh为cwind/2，cwind/=2【拥塞避免】 TCP滑动窗口window size 16bit位 可靠性+流量控制+拥塞控制流量控制：本质是 动态缓冲区。接收端动态调整窗口大小放在ACK的header中。 window 接收端告诉发送端自己还有多少缓冲区可以接收数据rwndoption中还有一个窗口扩大因子 10.快重传当发送方连续收到了3个重复的确认响应的时候，就判断为传输失败，报文丢失，这个时候就利用快重传算法立即进行信息的重传。拥塞控制主要通过【慢开始，快重传，快恢复和避免拥塞】来实现的。快恢复 与快重传配合使用，当发送方接收到连续三个重复确认请求，为了避免网络拥塞，执行拥塞避免算法 11.可靠传输的方法 可靠性ARQ自动重传请求协议，确认和重传机制，为提高信道利用率，连续ARQ发送方维护滑动窗口，接收端累计确认。1.序号 确认应答 超时重传2.连接管理 数据校验3.数据合理分片和排序 UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报. TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。4、流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。5、拥塞控制：当网络拥塞时，减少数据的发送。 12.为什么四次分手1)TCP半关闭。于TCP连接是全双工的，因此每个方向都必须单独进行关闭。 当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。 收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 13.为什么要TIME_WAIT等2MSL 最大报文寿命 Maximum Segment LifetimeTCP报文段是以IP数据报在网络中传输，IP数据报有TTL字段。IP数据报对TTL的限制是跳数，不是定时器。 主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。【rst】是一种关闭连接的方式。 1）可靠地实现TCP全双工连接终止。等最后一个ACK到达。如果没收到ACK，则被动方重发FIN，再ACK正好是两个MSL。 2)让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。为什么是2MSL是让某个方向上最多存活MSL被丢弃，另一个方向上的应答最多存活MSL被丢弃。 14.TIME_WAIT 和 CLOSE_WAIT1）发送FIN变成FIN_WAIT1，然后收到对方ACK+FIN，发完ACK2）FIN_WAIT1 收到ACK之后到FIN_WAIT2，然后收到FIN，发送ACK。如果最后一个ACK失败，重发FIN但是对方已关闭会得到RST，发送FIN方会报错。这个状态等2MSL后就CLOSED作用：让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。 HTTP长连接主动关闭的是server，TIME_WAIT可以修改参数解决。net.ipv4.tcp_tw_recycle = 1可以快速回收TIME-WAIT CLOSE_WAIT 被动关闭后没有释放连接，一般是代码写的有问题。 TCP连接状态书上一共11种 15.和UDP区别1）无连接 不可靠 无序2）广播3）速度快 报头只有8字节 TCP是【字节流】 20字节（1行32位4字节)，数据分段TCP是无边界的，UDP面向【报文】，保留了边界。 16.ping命令原理https://juejin.im/post/5ba0bb05e51d450e6f2e38a0输入 ping IP 后敲回车，发包前会发生什么？如果是域名先要差dns解析ip 1.根据目的IP和路由表决定走哪个【网卡】2.根据【网卡的子网掩码】地址判断目的IP是否在【子网】内。 同一网段：3.不在则会通过【arp缓存】查询IP的网卡地址4.不存在的话会通过[arp广播]询问目的IP的mac地址5.同一个网段的Ping：A得到mac地址后，把B的MAC地址封装到ICMP包中，向主机B发送一个回显请求不同网段：3.发送arp找网关MAC4.把目的MAC是网关，目的IP是主机C的ICMP包5.路由器去掉原来ICMP的MAC头，MAC源地址改成自己的MAC出地址，目的是查询到C的MAC6.主机C直接ICMP回显 ICMP回显应答时要输出 序号、TTL、往返时间，目的主机IP地址。 type:回显询问ICMP_ECHO 和回答ICMP_ECHOREPLYcode 总是 0 在ICMP报文的标识符字段设为发送的进程ID。即使多个ping程序也可以识别出返回信息。序号，用于查看是否有分组 丢失、失序、重复。 输入主机名，ping会用DNS确定主机对应的IP地址。 第一个RTT会比较长，因为会发送一个ARP报文。 发送ICMP请求报文（类型8）一定会从host或者getway返回一个ICMP 响应报文(类型0)发送一个32字节的测试数据，TTL经过一个路由器就-1. ping 127.0.0.1 TTL是128. 17.输入URL之后经历什么DNS解析1）查DNS，浏览器缓存，操作系统先查hosts，查本地DNS缓存，路由器缓存，向DNS服务器发UDP包2）IP包到网关需要知道网关的MAC地址，用ARP3）DNS服务器会去查根据名服务器得到注册的域名服务器TCP建立连接4）得到IP给浏览器，浏览器，发TCP建立连接HTTP请求/响应5）接到重定向到Https， 18.HTTP 长连接怎么实现HTTP管道是什么，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 19.http httpsHTTP+ 加密 + 认证 + 完整性保护 =HTTPS总共有3个随机数，客户端随机数，服务端随机数，预主密钥,对2个随机数和预主密钥生成主密钥用于之后数据加密 https的过程： 握手过程1.客户端client hello发送 随机数+支持的套件2.服务端server hello返回2个包，1）随机数+选择套件，2）证书（身份认证）3.握手完成，客户端返回用服务端公钥加密的预主密钥 完成后两边都有预主密钥+2个随机数，用约定的hash算法，生成主密钥进行数据传输 http先和ssl通信，再ssl和tcp通信。在交换密钥环节使用【公开密钥】加密方式，之后的建立通信交换报文阶段则使用【共享密钥】加密方式。 对称和非对称 随机码用来？ 随机码用服务端的公钥加密， http 有9种方法 RSA:两种方式：1）全密文：用对方公钥加密，对方用私钥解密2）明文+印章（防抵赖）：用自己私钥签名，对方用公钥验签使用AOP实现 20.网络编程的一般步骤21.Nagel和ACK延迟ACK延迟 将ACK和数据包一起发送 有定时器20字节IP首部，20字节TCP一起用会出现延迟40ms超时后才能回复ACK包 3.操作系统1.三态转换2.进程间通信套接字，管道，命名管道、邮件槽、远程过程调用、消息队列，共享内存，信号量,信号。 使用场景：进程间数据共享：共享内存 进程间数据交换：socket、消息队列。 信号：异步的通知机制，用来提醒进程一个事件已经发生 信号是在软件层次上对中断机制的一种模拟。 trap -ltrap &quot;&quot; INT 表明忽略SIGINT信号，按Ctrl+C也不能使脚本退出 https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/IPC.md 管道只能两个进程消息队列能多个进程 管道 【随进程持续】：管道的本质是内核维护了一块缓冲区与管道文件相关联。1）单向 半双工：把一个程序的输出直接连接到另一个程序的输入2）除非读端已经存在，否则写端的打开管道操作会一直阻塞3）只能父子进程、兄弟进程4）无格式字节流，需要事先约定数据格式。 匿名管道：内存文件描述符（内核）。1）pipe(2)系统调用时，这个函数会让系统构建一个匿名管道2）这样在进程中就打开了两个新的，打开的文件描述符：父进程关闭管道读端，子进程关闭管道写端。3）一般再fork一个子进程，然后通过管道实现父子进程间的通信。4）通过只在【内存】（内核）中的文件描述符fd[0]表示读 fd[1]表示写。（父子进程分别关闭一端组合成父进程-&gt;子进程/子进程-&gt;父进程的管道） 命名管道FIFO文件：提供一个路径名与之关联，以FIFO文件形式存在于【文件系统】mkfifo()可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接。1)读管道程序 mkfifo创建管道文件，死循环read2)写程序 打开管道文件写。 借助了文件系统的file结构和VFS的索引节点inode。过将两个file 结构指向同一个临时的VFS 索引节点，而这个VFS引节点又指向一个物理页面 管道和命名管道都是随进程持续的，而消息队列还有后面的信号量、共享内存都是随内核持续的 消息队列（链表） msgget（同一台机器） 系统内核： （一种逐渐被淘汰的方式）msgid = msgget((key_t)1234, 0666 | IPC_CREAT);msgget()msgrcv()1）异步：消息队列本身是【异步】的，消息队列独立于进程存在。它允许接收者在消息发送很长时间后再取回消息2）消息必须以long int 开头 , 接收程序可以通过消息类型有选择地接收数据。3）可以同时通过发送消息，避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。 4）轮询：收者必须轮询消息队列，才能收到最近的消息。5）优先级6）与管道相比，消息队列提供了有格式的数据 【读写双方都需要msgget建立消息队列】7）和信号相比，消息队列能够传递更多的信息 共享内存shmget 最快但是无法解决同步1）shmget创建一个 结构体大小的共享内存，有权限2）shmat 映射到进程的地址空间。3）读写的时候要用written标志防止两个进程同时读写 而且要把written变成原子操作4）shmdt可以分离共享内存1234struct shared_use_st&#123; int written; char text[2048];&#125;; 同一个Linux机器的两个进程访问同一块共享内存，他们访问共享内存中的同一个对象的时候，指针相同吗？可能相同也可能不同 信号量semget 有权限不是线程同步的posix信号量，是SYSTEM V信号量信号量能解决 共享内存同步问题 3.进程调度方式 CFS 调度周期 计算运行时间vruntimeLinux CFS 完全公平调度器：1.设定一个【调度周期】（sched_latency_ns），目标是让每个进程在这个周期内至少有机会运行一次。每个进程等待CPU的时间最长不超过这个调度周期。2.进程的数量，大家平分这个调度周期内的CPU使用权，由于进程的优先级即nice值不同，分割调度周期的时候要加权；3.每个进程的【累计运行时间】保存在自己的vruntime字段里，哪个进程的vruntime最小就获得本轮运行的权利。 细节问题1：新进程fork之后的子进程优先于父进程每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，防止一直fork获得时间片，新进程一般要设置比min_vruntime大。 问题2：休眠进程唤醒抢占特性被唤醒时当新进程重新设置vruntime 问题3：频繁抢占CFS设定了进程占用CPU最小时间，如果进程太多，调度周期会根据最小时间x进程数 问题4：进程切换CPU为保持相对公平，vruntime要减去当前CPU的min，在加到CPU2的min上 红黑树而不用最小堆每个核用红黑树选区vruntime最小的进程进程调度有很多遍历操作，需要完全排序红黑树插入最多两次旋转，删除最多3次旋转，染色Logn 进程的上下文切换：切换会保存寄存器、栈，需要用户态切换到内核态 4.内存分页与swap内存屏障 指令乱序 分支预测 CPU亲和性affinity Netfilter和iptables 5. 死锁原因：资源不足、进程运行推进顺序不合理、资源分配不当、占用资源的程序崩溃 5.1死锁条件死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 5.2死锁处理策略1）预防死锁 前面4个条件 2）避免死锁 银行家算法 3）死锁检测再解除互斥条件：SPOOLing 技术，将打印机变成共享设备，加一个队列。不剥夺条件：得不到就放弃自己的 或者直接抢请求和保持条件：静态分配（进程运行前一次性分配全部资源）循环等待条件：顺序资源分配法 对资源加编号 同类资源一次性分配完 4.java基础1.Java 类加载的过程将编译好的类文件中的字节码文件加载到内存中，放在方法区内并创建Class对象。双亲委派原则：每个加载器对应不同的加载目录。先检查这个类是否加载过，不然调用父加载器的loadClass，如果父加载器（在搜索范围内没这个类）抛出异常，调用自己的findClass()。 好处：避免类的重复加载，避免核心API被纂改。无论哪个类加载器要加载。都委派给启动类加载器，类随类加载器有层级关系，Objet都是同一个类。 类加载的过程包括了【加载、链接（验证、准备、解析）、初始化】五个阶段加载：1）获取二进制字节流2）静态存储结构（字面量和符号引用）放到【运行时数据区】。堆中生成3）Class对象，作为方法区类数据的访问入口，hotspot放在方法区里。验证：文件格式、元数据、字节码（数据流、控制流）、符号引用 验证准备：分配内存，设初始值解析：符号引用-&gt;直接引用初始化：如果父类没有初始化，会先初始化父类 解析可能在初始化之后。初始化阶段有且只有5种主动加载的情况：1）new,静态方法、静态字段（被final放到常量池的静态字段除外）2）反射Class.forName3）作为父类，子类被初始化4）调用main5）MethodHandle 每个类都会使用 当前类加载器（自己的类加载器）加载依赖的其它对象线程类加载器：继承父线程的上下文类加载器，运行初始线程上下文类加载器是Applicatonmysql的Connection接口是JDK内置的rt.jar，由bootstrap类加载器加载的，但是厂商的实现是applicaton类加载器加载的，双亲委托模型 2.java8的新特性3.Object有哪些方法还有getClass() 和finalizewait 方法必须在synchronized内用 4.JVM分哪几个区 - JVM内存模型虚拟机运行时数据区、类加载器、执行引擎、本地方法库线程独占：1）程序计数器-多线程轮流切换并分配处理器执行时间，多线程切换后恢复到正确的执行位置。2）虚拟机栈3）本地方法栈线程共享：堆、方法区（永久代、metaspace） 介绍JVM堆和栈，有什么用虚拟机栈：生命周期与线程相同。Java 方法执行的内存模型，局部变量表、返回地址、操作数栈、动态链接（？） JVM结构新生代有什么算法4大算法：引用计数，复制，标记清除，标记压缩7个垃圾收集器串行收集器适合单核CPU或者非常小堆。ES默认使用CMS收集器 5.Java内存分配策略Java对象的内存分配主要是指在堆上分配（也有经过JIT编译后被拆散为标量类型并间接地在栈上分配的情况），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，则将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。 怎么把对象分配到老年代上 6.泛型的好处泛型：向不同对象发送同一个消息，不同的对象在接收到时会产生不同的行为（即方法）；也就是说，每个对象可以用自己的方式去响应共同的消息。消息就是调用函数，不同的行为是指不同的实现（执行不同的函数）。用同一个调用形式，既能调用派生类又能调用基类的同名函数。 7.方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 为什么不能根据返回类型来区分重载?因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 虚函数是实现多态 “动态编联”的基础，C++中如果用基类的指针来析构子类对象，基类的析构要加virtual，不然不会调用子类的析构，会内存泄漏。 8.虚拟机如何实现多态解析调用：方法是一个常量池中的符号引用。静态方法（类型绑定），私有方法（外部不可访问）在类加载【解析】阶段把所有符号引用变为可确定的直接引用。分派调用：重载：静态分派，编译期间依赖静态类型（左边）定位方法版本。应用：重载。变异期间选择重载版本。静态多分派，动态单分派。重写：动态分派，虚拟机根据实际类型分派，invokevirtual指令 调用虚方法。运行期在操作数栈顶找到对象的实际类型（运行时确定方法的接收者类型），将常量池中的方法符号引用解析到不同的直接引用上。每个类在方法区中有 虚方法表，子类重写方法，子类放发表里换替换为子类实现的版本地址。相同签名的方法，在父类、子类需方发表都应有一样的序号。链接阶段进行初始化方法表（？） 9.除了基本类型还有那些类能表示数字包装类，高精度BigDecimal，原子类Atomic内部用native方法，使用了硬件支持的CAS 1.8新加的原子类LongAdder 分离热点把value变成一个数组，变成hash计数，计数结果就是累加结果。 10. java修饰符访问修饰符：可以对 类、变量、方法、构造方法访问控制private不能修饰外部类protected不能修饰外部类非访问修饰符：static final abstract synchronized volatile 11.线程调度方式时间片轮转调度，优先级调度，多级反馈队列调度，高响应比优先调度 vmstat 看cs 是context switch 线程上下文切换次数pidstat -w cswch/s 主动上下文修换 nvcswch/s 被动上下文切换上下文切换还包括系统调用。us 用户CPU时间sy 系统CPU时间 协同式线程调度（协程，每个线程执行时间由线程本身控制）java：抢占式线程调度（操作系统分配时间）java线程是映射到操作系统原生线程上的。 12.String StringBuilder StringBufferString 存在JVM哪里1）一旦有一个用引号的字符串就会放到字符串常量池。2）拼接创建的只在堆里。3）堆里面创建新的字符串，用intern可以放【引用】到常量池（jdk1.7之前只只能放一个副本放到常量池）方法区，方法区是JVM的一种规范。元空间MetaSpace和永久代PermGen都是方法区的实现。原来在永久代里的字符串常量池移到了堆中。而且元空间替代了永久代。本来永久代使用的是JVM内存，而元空间使用的是本地内存，字符串常量不会有性能问题（intern）和内存溢出。 5.分布式使用过zookpeeper吗1.使用场景 2.解决的问题 3.特点 4.和其他同类型的框架的比较 全局唯一idmysql实现123456789101112create table `tic`( `id` bigint(20) unsigned not null auto_increment, `stub` char(1) not null default '', primary key (`id`), unique key `stub` (`stub`) )engine = myisam; start transaction;replace into tic(stub) values('a');select last_insert_id();commit; 1.zookeeper的应用场景分布式协调 节点注册监听分布式锁 2.XA事务 分布式事务事务管理器（Mysql客户端）和资源管理器（Mysql数据库）之间用两阶段提交，等所有参与全局事务的都能提交再提交用JAVA JTA API 6.数据结构1.二叉平衡树的应用 红黑树原理关键性质：红黑树确保没有一条从根到叶子的路径会比其他从根到叶子的路径长出两倍1）根、叶子节点、红色节点的两个儿子都是黑色2）任一节点到其每个叶子节点的所有简单路径 包含相同数目的黑色节点AVL树是严格的平衡二叉树如果应用场景中对插入删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。windows对进程地址空间的管理用到了AVL树 2.排序 希尔排序复杂度当步长为1时，算法变为普通插入排序已知最好n(log^2)n 3.最小生成树的两种算法Prim算法，标记已选点，选标记点可达的最近点标记，直到标记完所有点。贪心选择与当前顶点集合中距离最短的顶点。把点划分为3类：不可达（不可选），可选，已选维护一个数组：dis，作用为已用点到未用点的最短距离。 证明：对于任意一个顶点v，连接到该顶点的所有边中的一条最短边(v, vj)必然属于最小生成树（即任意一个属于最小生成树的连通子图，从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树） 复杂度：O（n^2) n为图中顶点数。适合稠密图。邻接矩阵O(v^2) 邻接表O(elog2v) Kruskal算法，存在相同权值的边。O(mlogm) m为边树，与顶点数无关扩展边，每次贪心选择剩余边中最小权重的边。从权值最小的边开始遍历，直到图的点全部在一个连通分量中。复杂度： 4.Hash碰撞的方法1）开放地址法（Nginx的散列表） 开放地址法分： 线性探测法（会聚集）、平方探测、双散列2）链地址法 不成功平均查找长度，要按照冲突解决方法查找到当前位置为空位置。最后/散列函数的mod（hash函数的分类个数） 7.框架1.Spring容器初始化过程ioc aop原理 2.ioc怎么实现3.Springboot的启动流程4.SpringMVC工作原理1）servlet一共三个层次HttpServletBean:直接继承java的HttpServlet，将Servlet中的配置参数设置到相应的属性。 FrameworkServlet：初始化WebApplicationContext 抽象类静态方法 将不同类型请求合并到一个方法统一处理。还发布了一个事件。 DispatcherServlet:初始化9大组件 doService方法保存redirect转发的参数和include的request快照。 调用的doDispatch方法4步 1）根据request找到handler（@RequestMapping） 2）用mapper根据handler找到handlerAdapter 处理不同参数（不只是request和response） 3）handlerAdapter处理，先执行拦截器。Last-Modified 4）processDispatchResult处理View 8.并发1.协程 轻量化 用户态调度 切换代价比线程上下文切换低非抢占式用户态线程与进程和线程的区别：通过抢占式调度内核态异步编程：内核线程（轻量级进程LWP，用户可操作的内核态线程）大量内核态县城会干扰内核调度 影响其他应用go的调度器分为：内核线程M，P内核处理器，G goroutine 协程 用户态线程通过P，把无限多的G均分到有限的M上。 Java 第三方协程框架 2.currentHashMaphttps://blog.csdn.net/qq_33256688/article/details/799388861.7之前是头插，1.8之后是尾插hashmap为了避免尾部遍历，链表插入使用头插，不然rehash要每次都遍历到链表尾。头插会死循环，因为如果2个线程在rehash，线程1:原来[3]-&gt;3-&gt;7，保存的next是7.挂起线程2已经rehash好了变成[3]-&gt;7-&gt;3线程1恢复，开始rehash，变成new[3]-&gt;3 next = 7 继续变成[3]-&gt;7-&gt;3。并且线程2已经把7-&gt;3连好了，现在next还是3，变成[3]-&gt;3-&gt;7-&gt;3 3.next还是7死循环 问题在于，本来从链表头部拿，next一定会拿到null，但是另外一个线程使next倒置，导致线程1先rehash好了后面的节点，然后原链表继续next实际上已经在新链表里了。 不能为null hashmap也是尾插 保留了顺序，不会死循环。 currentHashMap原理：1.7分段锁，降低锁定程度，1.8CAS自旋锁 3.CAS算法原理？优缺点？CAS 流程：线程在读取数据时不进行加锁，在写回数据时，比较原值是否修改，如果未被其它线程修改，则写回，不然重新读取。乐观认为并发操作不是总会发生。通过操作系统原语实现，保证操作过程中不会被中断。https://juejin.im/post/5ba66a7ef265da0abb1435ae非阻塞算法：一个线程的失败或者挂起不会导致其他线程也失败或者挂起。无锁算法：算法的每个步骤，都存在某个线程能执行下去。多个线程竞争CAS总有一个线程胜出并继续执行。 CAS 是实现非阻塞同步的计算机指令，它有三个操作数，内存位置，旧的预期值，新值，对于多个状态变量的场景，通过AtomicReference包装这个对象，每次更新先获取旧值，再创建新值，用这两个值进行CAS原子更新。 CAS 实现原子操作的三大问题1) ABA问题 解决：用AtomicStampedReference 不可变对象pair2）循环CPU开销 JVM pause指令 Unsafe.park()遇到线程中断不会抛异常，会立刻返回再次运行，CPU可能飙升，一直是RUNNABLE。3）多个共享变量 解决：用AtomicReference 线程安全的链表每个node有锁，保存链表尾指针 AQS利用CAS原子操作维护自身的状态，结合LockSupport对线程进行阻塞和唤醒从而实现更为灵活的同步操作。 MCS自旋锁 基于链表 公平自旋锁 在本地属性变量上自旋CLH自旋锁 基于链表 公平自旋锁 在前驱结点上自旋有N个线程 L个锁 空间需要O(L+N) 4.AQSAQS：队列同步器AQS的核心思想是基于volatile int state这样的一个标志位1表示有线程占用，其它线程需要进入同步队列同步队列是一个双向链表，当获得锁的线程等待条件，进入等待队列（可以有多个），满足后重新进入同步队列，获取锁竞争Unsafe类提供CAS方法同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。private volatile int state;ReentrantLock用来表示所有者重复获取该锁的次数Semaphore表示剩余许可数量FutureTask用于表示任务状态(现在FutureTask不用AQS了)但也是state 当线程尝试更改AQS状态操作获得失败时，会将Thread对象抽象成Node对象 形成CLH队列，LIFO规则。 5.线程池的运行流程，使用参数以及方法策略https://juejin.im/entry/59b232ee6fb9a0248d25139a#%E6%80%BB%E7%BB%93线程池中的线程包装成工作线程Worker放在HashSet中，Worder继承AQS实现了不可重入锁，Worker的run方法是for循环一直take队列中的runable对象执行 运行流程：1）如果运行的线程小于corePollsize，则创建核心线程，即使其他是空闲的。2）当线程池中线程数量&gt;corePollsize，判断缓冲队列是否满，没满放入队列，等待线程空闲执行。如果队列满了，判断是否达到最大线程数，没达到创建新线程，如果达到了，执行拒绝策略。 只有当workQueue满才去创建新线程处理任务 ！！先判断队列再判断最大线程数3）如果没有空闲，任务封装成Work对象放到等待队列4) 如果队列满了，用handler指定的策略 （5种）ctl 状态值（高3位）和有效线程数（29位） 线程池的状态：RUNNING： 能接受提交SHUTDOWN: 不能提交，但是能处理。STOP： 不接受提交也不处理TIDYING： 所有任务都已经终止 有效线程数为0TERMINATED： 标识 一共有5种线程池：1）fixed 无界队列缓冲队列，适用于任务数量不均匀，内存压力不敏感，系统负载敏感。只要线程个数比核心线程个数多并且当前空闲则回收2）cached 核心0，最大INT_MAX,缓冲队列：synchronousQueue只要没有空闲线程就会新建（没有队列缓冲）不限制线程数，低延迟短期任务。处理大量短时间工作任务 长期闲置的时候不会消耗资源3）sigle 1个线程，异步执行，保证顺序执行多个任务4）scheduled 定时、周期工作调度最大线程数是Integer.MAX_VALUE，空闲工作线程生存时间是0，阻塞队列是DelayedWorkQueue，是堆 按延迟时间获取任务的优先级ScheduledFutureTask实现了Comparable接口，是按照任务执行的时间来倒叙排序的 5）newWrokStealingPoll 工作窃取，固定并行度的多任务队列，适合任务执行时长不均匀 6.如何优化线程池参数1.核心线程数 2.最大线程数3.4 线程的空闲时间（可以通过allowcorethreadtimeout方法允许核心线程回收）5 缓冲队列ArrayBlockingQueue 有界队列 LinkedBlockingQueue 无界队列 SynchronousQueue 同步队列没有缓冲区6.线程工厂方法，用于定制线程的属性 例如线程的group，线程名 优先级7.线程池满时的拒绝策略4种Abourt异常（默认） Discard 抛弃 callerruns 提交者执行 discardoldest 丢弃最早 怎么配置参数 7.线程同步的方法1.CAS 2.synchronize 3.Lock synchronize 可重入对象头 Monitor(管程) 分三块：entry set，owner,wait sethttps://blog.csdn.net/javazejian/article/details/72828483正确说法：给调用该方法的【对象】加锁。在一个方法调用结束之前，其他线程无法得到这个对象的控制权。方法同步通过ACC_SYNCHRONIZED代码块同步通过monitorenter monitorexit 缺点：只能实现方法级别的排他性，不能保证业务层面（多个方法）。 Synchronized的锁优化机制JVM提供了3种Monitor实现：偏向锁、轻量级锁、重量级锁偏向锁（默认）：优先同一线程获取锁，JVM在对象头上Mark word设置线程ID，用CAS操作。轻量级锁:有另外线程试图锁定已经偏向锁的对象，JVMrevoke撤销偏向锁。如果失败，短暂自旋。轻量级锁用CAS试图获得锁操作Mark Work，如果成功就轻量级锁，如果失败重量级锁。 notify和waitnotify方法调用后不会释放锁！放置在sychronized作用域中，wait会释放synchronized关联的锁阻塞，实现存库为1的生产者消费者。 wait和sleep的不同1.wait是object类，sleep是thread类2.wait会释放对象锁，sleep不会3.wait需要在同步块中使用，sleep可以在任何地方使用4.sleep要捕获异常，wait不需要 join 方法join(long millis)获取t2的对象锁，判断t2是否alive，放弃对t2的锁,将当前t3放入t2的【等待池】中，等待t2notify，一个线程结束后会调用notifyAll，被notify后会进入t2的锁池等待竞争锁 wait(0)是一直等待123456789101112Thread t3 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 引用t2线程，等待t2线程执行完 t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("t3"); &#125; &#125;); 如果没有判断isAlive,join的线程根本没启动会永远等待下去 10.1信号量 Semaphore ： 管理多线程竞争例子：100个线程抢10个数据库连接。 10.2 Condition ： 线程通信 多个阻塞队列线程间通信目的：Condition 可以在多线程中创建多个阻塞队列。例子1：实现 【仓库数量&gt;1】 的生产者消费者：将生产者和消费者放入不同的阻塞队列，精准控制。生产者判断full满就阻塞，加入商品后唤醒所有阻塞empty的消费者线程。 Condition1）由Lock对象生成2）await 会释放锁，阻塞。 signal能唤醒。 wait和notify只能建立一个阻塞队列。 10.3锁 LockReentreantLock1）可中断 2）可定时轮询 3）锁分段，每个链表节点用一个独立的锁，多线程能对链表的不同部分操作。4）公平性/非公平性5）tryLock，得不到锁立即返回 读写锁 适合读并发多写并发少，读不用互斥另一个方法是copyonwriteSync继承AQS，公平锁新来的线程有没有可能比同步队列中等待的线程更早获得锁。 5）可重入Thread.currentThread()可重入是如何实现的？ 6)业务锁同一个账户的存钱、取钱业务应该先完整完成一次后才释放锁。Lock可以跨方法锁对象：登录加锁，登出释放。tryLock如果获取锁失败会立刻返回 false，不会阻塞。 读写锁 降级：获得写入锁能不能不释放获得读取锁。 升级：一般不支持，因为两个读线程同时升级为写入锁，会死锁。 非公平锁（默认）：写线程降级为读线程可以，不能从读线程升级为写。 公平锁:如果读线程持有，写线程请求，其他读线程都不能去锁，直到写完。用处：包装map、linkedhashmap等，在put前后上写锁，get上读锁。 StampedLock 使用CLH的乐观锁 防止写饥饿1.8新加。是单独的类型，不可重入，锁不是持有线程为单位的。问题：读写锁使得读和读可以完全并发，但是读锁会完全阻塞写锁。思路：试着先修改，然后通过validate方法确认是否进入了写模式，如果进入，则尝试获取读锁。读操作不需要等写操作完。StampedLock 是乐观锁，写锁long stamp = .writeLock，.unlockWrite读锁long stamp = .tryOptimisticRead() ， .validate(stamp) .unlockRead(stamp 还可以强行时候悲观读 实现：基于CLH锁：自旋锁，维护一个等待队列，保证没有饥饿并且FIFO。用一个volatile long表示写锁、当前正在读取的线程数量。 8.JMM java内存模型线程工作内存，保存主内存副本拷贝。线程对变量的所有读取、赋值都必须在工作内存完成，不能直接读写主内存变量。处理并发过程中的**原子性、可见性、有序性。 volatile变量定义了8种操作顺序的规则，能保证代码执行的顺序与程序顺序相同。保证long和double不被拆分。定义了8个happen before原则1）单线程控制流程序次序 2）管程 3）volatile 4）线程启动、5终止、6中断 7）对象finalize 8）传递性 为什么要paddingcache伪共享：多个线程读写同一个缓存行，volitale变量无关但是多个线程之间仍然要同步。把热点数据隔离在不同的缓存行 8个原子操作主内存变量线程独占：1）lock 线程独占，同个线程可以lock多次，会清空工作内存中这个变量的值执行引擎use前要load assign2）unlock 释放，之前会同步回主存 主内存-&gt;工作内存：3）read 从主内存读入工作内存4）load 将read的变量存入工作内存的变量副本 工作变量和执行引擎：5）use 工作内存变量传递给执行引擎6）assign 执行引擎赋值给工作变量 工作内存-&gt;主内存7）store 工作内存传入主内存8）write 将store的值放入主内存 9.快速失败fail-fast 和 安全失败 fail-safe快速失败：迭代器遍历过程中，集合对象修改会改modCount，和expected不一样，报错。java.util包下的集合类都是 快速失败的。 安全失败：遍历是先拷贝在遍历。遍历过程中的修改不会影响迭代器，不会报错。java.util.concurrent包下都是安全失败。 ThreadLocal 使用弱引用的Map保存变量 线程数据隔离LinkedBlockingQueue 直接交接队列SynchronousQueue不使用缓存，没有空闲线程就开线程，需要限定好线程池最大数量。atomic 9.redis1.redis高性能的原因1）内存2）单线程3）网络请求io单进程多路复用“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 2.redis持久化持久化方式：1）快照 Mysql Dump和Redis RDB 2）写日志 Mysql Binlog Hbase Hlog Redis AOF RDB是保存数据库中的键值对，AOF保存redis执行的命令。 RDBRDB是压缩过的二进制文件,会生成临时文件，把老的RDB文件替换掉。BGSAVE不会阻塞服务器进程，会创建子进程创建RBD文件。copy-on-write策略，但是父进程写入还会做副本 内存开销大。触发机制：从节点全量复制主节点会生成RDB文件。 debug reload 、 shutdown。缺点磁盘性能，宕机没快照的丢了。但是恢复速度快。 AOFAOF更新频率通常比RDB高。写【命令】先从redis 写到硬盘缓冲区 再根据3种策略（everysec每秒，always，no（操作系统自己刷)）fsync到硬盘AOF文件。AOF会开子进程重写。 redis主从复制数据是单向的。可以通过slaveof 或者配置方式slave-read-only yes实现。进入redis用info replication可以查看主从状态 老版本当从节点slaveof之后发送PSYNC，并发送自己的ID主节点bgsave向从节点发送rdb文件，设置offset，将偏移量之后的数据存在定长有界队列【积压缓冲区1M】中，一个字节一个offset。从节点发送offset给主节点继续从缓冲区同步。之后命令传播。主从复制（副本）集群是为了解决多请求，读写分离，高可用，分布式是为了解决一个请求的多个步骤。 redis主从同步的问题 master挂了，从节点全部得全量复制，复制风暴 redis集群一致性hash如何解决分布不均匀 全量复制1）第一次是全量复制full resync master会BGSAVE。2）从节点的数据全部清除Flushing old data，通过网络接受RDB文件，加载RDB文件到内存。info server |grep run3）在同步期间master的写命令会单独记录，rdb同步完后通过偏移同步给slave。可以看到redis实例的run_id。如果从复制的主节点的id发生变化，则需要全量复制。 部分复制info replication 可以看到master的偏移量master_repl_offset和slave的偏移量slave_repl_offset，主节点可以看到各个从节点的偏移量。偏移量主比从大表示主写入了数据还没同步到从。如果主从连接断了，先重连，从服务器发送runid和offset，主服务器发送buffer中的部分数据。 redis 高可用 sentinelredis写失败怎么办更新数据库，缓存删除失败方法1：将需要删除的key发送到消息队列，发送给自己，继续消费，重新向redis删除。 方法2：订阅数据库binlog（2）数据库会将操作信息写入binlog日志当中（3）订阅程序提取出所需要的数据以及key（4）另起一段非业务代码，获得该信息（5）尝试删除缓存操作，发现删除失败（6）将这些信息发送至消息队列（7）重新从消息队列中获得该数据，重试操作。mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能 软工和测试白盒测试是什么怎么评价一个软件系统的好坏 java的进程通信管道 Java中没有命名管道12345678// 启动子进程ProcessBuilder pb = new ProcessBuilder("java", "com.test.process.T3"); Process p = pb.start(); // 或者Runtime rt = Runtime.getRuntime(); Process process = rt.exec("java com.test.process.T3"); // 子进程的输出BufferedInputStream in = new BufferedInputStream(p.getInputStream()); 共享内存nio有内存映射文件mmaphttps://cloud.tencent.com/developer/article/103186012345RandomAccessFile raf = new RandomAccessFile("D:/a.txt", "rw"); FileChannel fc = raf.getChannel(); // 核心 系统调用mmapMappedByteBuffer mbb = fc.map(MapMode.READ_WRITE, 0, 1024); FileLock fl = fc.lock();//文件锁 mmap和共享文件的区别操作系统划分出一块内存来共多个进程共享使用mmap需要把内容写回到文件，所以还需要与文件打交道；而SM则是完全的内存操作，不涉及文件IO，效率上可能会好很多。还有就是SM使用的系统调用是shmget和shmctl。 FileChannel 是将共享内存和磁盘文件建立联系的文件通道类。 信号123456789OperateSignal operateSignalHandler = new OperateSignal(); Signal sig = new Signal("SEGV");//SEGV 这个linux和window不同 Signal.handle(sig, operateSignalHandler); public class OperateSignal implements SignalHandler&#123; @Override public void handle(Signal arg0) &#123; System.out.println("信号接收"); &#125; &#125; 线程池 参数，常用的callable 11.C++虚函数作用及底层实现虚函数是使用虚函数表和虚函数表指针实现的。虚函数表：一个类 的 虚函数 的 地址表：用于索引类本身及其父类的虚函数地址，如果子类重写，则会替换成子类虚函数地址。虚函数表指针： 存在于每个对象中，指向对象所在类的虚函数表的地址。多继承：存在多个虚函数表指针。 12.千万数据的表怎么优化表设计：SQL优化：1）超过500w要分表分表方案：水平分表（时间、id、hash）、垂直分表 数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分 水平切分的实现： Merge存储引擎允许将一组使用MyISAM存储引擎的并且表结构相同（即每张表的字段顺序、字段名称、字段类型、索引定义的顺序及其定义的方式必须相同）的数据表合并为一个表，方便了数据的查询。123456CREATE TABLE log_merge( dt DATETIME NOT NULL, info VARCHAR(100) NOT NULL, INDEX(dt) ) ENGINE = MERGE UNION = (log_2004, log_2005, log_2006, log_2007) INSERT_METHOD = LAST; 2）Explain索引设置3）减少查询列应用层优化4）减少返回的行 limit5）拆分大的delete和insert，不然会一次锁住很多数据 sql优化 计算两点距离100公里以内的餐馆，不要查询圆，查询方形两个between，如果第一列是范围查询，无法索引后面的列，所以只能索引第一个列。 13.15.基于比较的算法的最优时间复杂度是O(nlog(n))因为n个数字全排列是n! 一次比较之后，两个元素顺序确定，排列数为 n!/2!总的复杂度是O(log(n!)) 根据斯特林公式就等于O(nlog(n)) 18 没有中序没办法确定二叉树前序 根左右后序 左右根找不到左右的边界 19 redis动态字符串sds的优缺点结构：1）len 2）free 3）buf数组优点1）以\0结尾，可以复用c string的库函数。2）O(1)复杂度获取长度3) 杜绝缓冲区溢出 （c如果没分配够空间就直接覆盖了)4) 减少内存重分配（空间预分配和惰性空间释放）5）二进制安全（可以存图片等特殊格式），c字符串中不能包含空字符。 20 数据库三范式目的：减少冗余、插入删除更新异常第一范式：列不可拆分 目的：列原子性第二范式：每个属性要【完全依赖】于主键，如果主键有多个候选键，属性第三范式：非主键关键字段之间不能存在依赖关系，避免更新、插入、删除异常。每一列都要与主键直接相关。【消除传递依赖】。 例子： 各种信息只在一个地方存储，不出现在多张表中。 如果成员表已经有部门编号，不应该有部门表中的部门名称。BCNF：表的部分主键依赖于非主键部分 应该拆分。第四范式：两个均是1：N的关系，当出现在一张表的时候，会出现大量的冗余。所以就我们需要分解它，减少冗余。 20 数据库 5约束主键约束PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。唯一约束UNIQUE 默认值约束DEFAULT 非空约束NOT NULL 外键约束FOREIGN KEY CHECK （CHECK (P_Id&gt;0)） 20 自然连接 NATURAL JOINcolumns with the same name of associate tables will appear once only.自然连接是指关系R和S在所有公共属性(common attribute)上的等接(Equijoin). 但在得到的结果中公共属性只保留一次, 其余删除. 控制文件：Oracle服务器在启动期间用来标识物理文件和数据库结构的二进制文件 21 内存溢出OOM和内存泄漏memory leakjstat 22 四种引用类型强引用，软引用，弱引用，虚引用软引用：内存不够二次回收弱引用：回收弱引用应用：优惠券 WeakHashMap&lt;Coupan, &lt;List&lt;WeakReference &lt;User&gt;&gt;&gt; weakCoupanHM.put(coupan1,weakUserList);当某个优惠券（假设对应于coupan2对象）失效时，我们可以从coupanList里去除该对象，coupan2上就没有强引用了，只有weakCoupanHM对该对象还有个弱引用，这样coupan2对象能在下次垃圾回收时被回收，从而weakCoupanHM里就看不到了。 当某个用户（假设user1）注销账号时，它会被从List类型的userList对象中被移除。 虚引用：要和引用队列一起使用，用于跟踪垃圾回收的过程 23 Java线程状态6种New， Runnable， Timed Waiting， Waiting，Blocked，Terminated创建线程 new状态调用start方法后j进入Runnable状态，不能马上运行，要先进入就绪状态等待线程调度（Ready），获取到CPU后到Running状态如果运行中获取锁失败Blocked状态，获取到后再变成就绪状态调用Thread.join 或者LockSupport.park方法会进入Waiting可以通过notify或者unpark回到就绪状态。 24 生产者消费者问题（消费的是同一个东西） 1个互斥2个同步P表示-1，V表示+1事件关系：1）互斥：缓冲区是临界资源，需要互斥访问2）同步：缓冲区满，生产者等待消费者取 （先后顺序）3）同步：缓冲区空，消费者等生产者生产 （先后） 信号量机制：一个关系一个信号量1）互斥信号量初始化为12）缓冲区同步的信号量根据系统资源初始值设定 1）生产者：空闲缓冲区数量 信号量初始值empty = n 2）消费者：缓冲区产品数量 初始值full = 0互斥信号量是在同一个进程之间操作的。一前一后同步关系 ，两个信号量的PV操作在不同的进程 生产者：123456789101112131415161718product()&#123; while(1)&#123; P(empty) P(mutex) //放入缓冲区 V(mutex) V(full) &#125;&#125;custom()&#123; while(1)&#123; P(full) P(mutex) // 取出 V(mutex) V(empty) &#125;&#125; 注意点：1）对于P操作 一定要先操作同步信号量再操作互斥信号量，不然互斥加锁然后同步阻塞 循环等待 就死锁了。 V操作顺序无所谓2）生产和使用操作不要放到PV操作（临界区）里面，时间太多 25 多生产者 多消费者 （一个临界区，但是生产者和消费者有特定类型）例子：只有一个盘子，父亲-儿子之间生产-消费 苹果，母亲-女儿之间生产-消费 橘子 关系：1）互斥：盘子2）同步：父亲儿子 消费-生产3）同步：母亲女儿 消费-生产4）同步：盘子空（事件） 之后 放入水果 事件信号量：1）互斥12）盘子中的苹果 03) 盘子中的橘子 04）盘子中的剩余空间 1 注意：1）如果盘子资源为1，不用加互斥，剩余空间就可以用来互斥了2）如果盘子资源为2以上，不加互斥会数据覆盖 26 读者-写者问题 count计数器1）允许多个读2）只许一个写3）完成写之前不允许读/写4）写之前要没有读/写操作 关系：1）互斥：写-写2）互斥：写-读（第一个读进程要对文件加锁）(最后一个进程解锁) 信号量：1）互斥 是否有进程在访问文件 semaphore rw = 12) 当前有几个读进程在访问 int count = 03）互斥count：隐藏3 mutex = 1 因为判断是不是第一个和计数不原子，所以判断+增加要加锁 问题：实际上是读优先。读进程太多会导致写进程饿死改进：用信号量semaphore w = 1;123456789101112131415161718192021222324252627282930313233semaphore rw = 1 // 文件互斥int count = 0 // 读进程计数semaphore mutex = 1 // count计数互斥semaphore w = 1 // 写进程优先writer()&#123; while(1)&#123; P(w) P(rw) // 写文件 V(rw) V(w) &#125;&#125;reader()&#123; while(1)&#123; // 如果前一个读执行到释放w后， // w会被写抢走，下一个读会等待写完成 P(w) // 用于count互斥访问 P(mutex) if(count == 0) P(rw) count++ V(mutex) // 写会抢走 V(w) P(mutex) count-- if(count == 0) V(rw) V(mutex) &#125;&#125; 不是疯狂写优先。是读写公平的。先来先服务的。 27 哲学家问题 两个临界资源 防止死锁5个哲学家 5个筷子 拿起左然后右吃饭方法1：只允许4个人吃饭(初始值为4的信号量)方法2：奇数号的先拿左边，偶数号的先拿右边方法3：用一个信号量同时对拿左边拿右边加锁 28 银行家算法（避免死锁） 安全序列 不会死锁手里有100亿钱，A要最多借70，B最多借40，C最多借50，借完了就会全部还回来。现在已经分别借了ABC一些，ABC其中一个再发起了一个请求，应不应该借？银行家算法：每次分配资源之前，判断是否会进入不安全状态（可能会产生死锁（没钱借又拿不会钱）找安全序列：用剩余资源 遍历所有进程 还需资源，如果可以分配，则分配+拿回全部资源+加入安全序列+从遍历中移除，再从头遍历所有进程。 31 页面置换算法OPT：知道后面会访问什么。向之后看，之后最后出现/没出现的的先删除缺页中断页面置换（满了才换）缺页率：缺页次数/请求次数FIFO：Belady异常。LRU：如果满了，将内存块中的数值向前找，最早出现的那个删除。CLOCK：时钟置换算法，NRU最近未用算法。 循环队列。 访问位。 问题LRU：出现一次冷数据批量查询，误淘汰大量热点数据LFU：起始频率值低，导致最近新加入的数据总会很容易被剔除FIFO：特殊领域：作业调度、消息队列 33 ajax的四个步骤1)创建xhr对象2)open方法参数：method，url，同步或异步3)send4)注册一个监听器onreadystatechange readyState=4和status200 获得响应.responseText 34 XSS攻击，跨站脚本攻击网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些恶意的脚本代码（HTML、JavaScript）到Web页面中去，使别的用户访问都会执行相应的嵌入代码。解决方法：1）cookie设置成http Only 不让前端document.cookie拿到2）对输入多做一些检查 对 html危险字符转义 CSRF 盗取用户cookie或者session伪造请求1)每次提交加随机数token2）检查referer 35 防止表单重复提交1）submit方法最后把按钮disable掉2）用token3）重定向 38 IO模型阻塞和非阻塞：阻塞IO：等待数据（收到一个完整的TCP包）和系统内核拷贝到用户内核都阻塞了。非阻塞IO：内核数据没准备好直接返回错误，需要轮询。非阻塞IO需要和IO通知机制一起使用。I/O通知机制：1） I/O复用函数【向内核注册一组事件】，内核通过I/O复用函数把就绪事件通知给应用程序。 I/O复用函数本身是阻塞的，可以同时监听多个I/O事件。2）SIGIO信号。 accept()为什么会阻塞？即使用多线程，serverSocket.accept()询问操作系统的客户端连接accept()还是单线程的，系统级别的【同步】网络I/O模型。阻塞，非阻塞是程序级别的，同步非同步时操作系统级别的。 多路复用IO模型：操作系统在一个端口上同时接受多个客户端I/O事件。事件驱动IO。select阻塞轮询所有socket，可以同时处理多个连接，（连接数不高的话不一定比多线程阻塞IO好）优势不在于单个连接处理更快，在于能处理更多的连接。而且单线程执行，事件探测和事件响应在一起。以上三个都属于同步IO，都会阻塞进程。select/poll/epoll都需要等待读写时间就绪后读写，异步IO会把数据从内核拷贝到用户。epoll是根据每个fd上面的callback函数实现的。而且有mmap内核空间和用户空间同处一块内存空间。 如何理解 nio是同步非阻塞边缘触发和水平触发边缘触发：只能处理非阻塞套接字，如果没有处理完缓冲区，这个套接字没有心事件，无法再次从epoll_wait调用中再次获取这个事件。 如果没有彻底将缓冲区数据处理完，会导致缓冲区中的用户请求得不到相应。水平触发：可以处理非阻塞和阻塞的套接字，一个事件的缓冲区还有数据，就可以epoll_wait获取这个事件。 https://www.jianshu.com/p/7835726dc78bET边缘触发：即使有数据可读,但是没有新的IO活动到来,epoll也不会立即返回.epoll默认是LT水平触发 Level信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发 Epoll事件分派接口可以表现为边沿前触发 (ET)和 水平触发(LT).这两个机制之间的区别可以描述如下。ET模式只有在被监控文件描述符发生变化时才递交事件 同步和异步事件处理模式Reactor模式实现同步I/O，处理I/O操作的依旧是产生I/O的程序异步I/O 订阅-通知：立即返回，内核完成数据准备+拷贝数据之后发送给用户进程一个信号。Proactor实现异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。 39异常 Error 和 Exception的区别1）Error是JVM负责的2）RuntimeException 是程序负责的3）checked Exception 是编译器负责的 异常处理机制：在堆上创建异常 try catch中有return之前都会先执行finally的return java进程间通信java 线程通信：wait notify，共享变量的synchronize，Lock同步机制全局变量2个线程之间的单向数据连接 NIO pipe 写sink 读source。java线程同步的方法 41 什么时候对象会被回收？如果互相引用http://blog.jobbole.com/109170/强引用=null引用计数算法 无法解决互相引用的情况。 所以用的是 可达性分析算法：判断对象的引用链是否可达。如果循环引用，没有人指向这个环也会被回收。从GC root（栈中的本地变量表中的对象、类（方法区）常量、静态属性保存的是对象……） JIT编译时会在安全点记录下很多OopMap(一个对象内 偏移量：类型数据)压缩在内存中。GC的时候扫描对应偏移量 类回收：ClassLoader已经被回收，Class对象没有引用，所有实例被回收。 资源管理，如果数据库连接对象被收回，但是没有调用close，数据库连接的资源不会释放，数据库连接就少一个了，要放在try()里。 full GC1）System.gc()方法的调用2）老年代空间3）Minor GC后超过老年代可用空间 45 布隆过滤器黑名单如果数据量有8G，hash冗余要保证16G构造：使用16/8 = 2G 可以表示16G个bit位。set：用8个随机函数，得到0-16G中8个随机数，并将这8位设置为1。get：同样用这8个随机函数，查看这8位是否都为1。 46 精确的接口限流。/禁止重复提交：用户提交之后按钮置灰，禁止重复提交如果做到精确5秒里只能访问10次 漏桶法 流量整形个固定容量的漏桶，按照常量固定速率流出水滴 令牌桶（对业务的峰值有一定容忍度）固定容量令牌的桶，按照固定速率往桶里添加令牌 前端做还是后台做 大数据相关的 47 linux 怎么查询一个端口48 操作系统 进程通信进程和线程的区别1）地址空间 线程的内存描述符 将直接指向 父进程的内存描述符 ，打开的资源2）通信，全局变量：线程通信要加锁3）调度和切换：切换快。4）进程不是可执行的实体 文件是进程创建的信息逻辑单元每个进程有专用的线程表跟踪进程中的线程。和内核中的进程表类似。 进程结构：代码段、数据段、堆栈段代码段：多个进程运行同一个程序，可以使用同一个代码段。数据段：全局变量、常量、静态变量。栈：用于存放 【函数调用】，存放函数的 【参数】，函数内部的【局部变量】PCB位于核心堆栈的底部。进程组ID是一个进程的必备属性。 子进程：当调用fork时，子进程完全复制了父进程地址空间的内容，包括：堆、栈、数据段，并和父进程共享代码段，因为代码段是只读的，不会被修改。在Linux上，对于多进程，子进程继承了父进程的下列哪些？A 进程地址空间B 共享内存C 信号掩码D 已打开的文件描述符E 以上都不是 子进程对数据段和堆、栈段的修改不会影响父进程。“写时复制”：现在fork不会立刻复制，当子进程要修改的时候才会分配进程空间 并复制。 创建一个守护进程java守护线程JVM的垃圾回收、内存管理等线程都是守护线程。Main退出，前台线程执行完毕，后台线程也直接结束了。生命周期 终端：系统与用户交互的界面，运行进程的终端被称为 【控制终端】。控制终端关闭时，进程都会关闭，除了守护进程。1）fork()一个子进程并退出父进程。子进程拷贝了父进程的【会话期、进程组、控制终端、工作目录、父进程的权限掩码、打开的文件描述符】。 2）在子进程中创建会话setid()让进程摆脱1）原会话2）进程组3）控制终端 的控制。 3）工作目录换成根目录chdir(&quot;/&quot;)4）文件权限掩码设置成0 umask(0)5）关闭所有打开的文件描述符 僵尸进程子进程退出，父进程没有调用wait，子进程的进程描述符仍然在系统中。父进程应该调用wait取得子进程的终止状态。如果父进程退出，僵尸进程变成孤儿进程给init（1）进程，init会周期性调用wait清除僵尸进程。 49 线程之间什么是共享的1）地址空间2）全局变量3）打开文件4）子进程5）即将发生的定时器6）信号与信号处理程序6）账户信息线程试图实现：共享同一组资源的多个线程的执行能力 50 栈为什么要线程独立一个栈帧只有最下方的可以被读写，处于工作状态，为了实现多线程，必须绕开栈的限制。每个线程创建一个新栈。多个栈用空白区域隔开，以备增长。每个线程的栈有一帧，供各个被调用但是还没有从中返回的过程使用。该栈帧存放了相应过程的局部变量、方法参数、过程调用完成后的返回地址，线程私有不共享。例如X调用Y，Y调用Z， 执行Z时，X和Y和X使用的栈帧会全部保存在堆栈中。每个线程有一个各自不同的执行历史。 栈内存分配运算内置于处理器的指令集中，效率很高 运行时在模块入口时，数据区需求是确定的。栈是编译器可以管理创建和释放的内容，堆需要GC栈很少有碎片 静态全局变量、静态局部变量https://blog.csdn.net/hushpe/article/details/45396059static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。 1.全局变量：源程序作用域。所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问extern 2.静态全局变量：文件作用域。如果加了static，就会对其它源文件隐藏。不能用extern导出。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心【命名冲突】。全局变量、静态全局变量存储在静态数据区。只有程序刚开始运行时唯一一次初始化。 3.静态局部变量：static局部变量只被初始化一次，下一次依据上一次结果值。！！！ 单例模式！！！ 作用域：作用域（可见性）仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。12345678910111213class Singleton&#123;private: Singleton()&#123;&#125; Singleton(const Singleton &amp;s); Singleton &amp; operator = (const Singleton &amp;s);public: static Singleton * GetInstance() &#123; static Singleton instance; //局部静态变量 return &amp;instance; &#125;&#125;; 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。局部变量改变为静态变量后是改变了它的存储方式即改变了它的【生存期】。把全局变量改变为静态变量后是改变了它的【作用域】，限制了它的使用范围。 4.static函数作用域只在本文件从原来的栈中存放改为【静态存储区】。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件. 静态存储区：内存在程序编译的时候就已经分配好已经初始化过的全局变量在.data段，而未初始化的全局变量在.bss段。.bss段不占用可执行文件的大小，而是在加载程序的时候由操作系统自动分配并初始化为0 目标文件用于二进制文件、可执行文件、目标代码、共享库和核心转储 的标准文件格式。分为3种：1）可重定位的目标文件 .o文件 .a静态库文件 未链接 可以经过链接生成可执行的目标文件和可被共享的目标文件。没有程序进入点。2）可执行的目标文件 链接处理之后的3）可【共享】的目标文件 .so。 动态库文件。 java staticstatic方法不能被覆盖override：因为方法覆盖是运行时动态绑定的，static是编译时静态绑定的。 Hashtable 和 HashMap的区别Hashtable不允许键或者值是nullhashMap线程不安全，遍历的时候会有环死循环Hashtable 不能支持符合操作：若不存在则添加、若存在则删除，即使单个方法加锁，符合方法也线程不安全。currentHashMap cas无锁，不涉及上下文切换效率高。1.7版本分为16个segment分段锁，允许16个线程同时读写操作不同的段。 ArrayList每次扩容1.5倍int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);线程不安全，扩容的时候会发生数组越界 LinkedListLinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用. Comparable和Comparator接口 区别Comparable 是该类支持排序 实例具有内在的排序关系 不能跨越不同类型的对象比较Comparator 是外部比较器，需要一个非标准的排序关系。有多个域，按不同的域排序。加了很多default方法。 Enumeration接口和Iterator接口 的区别Enumeration快Iterator允许调用者删除底层集合里面的元素 finalize 方法JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 任何对象的finalize只会被调用一次 final finally finalize的区别Exception和Error的区别事务是什么数据库并发控制的基本单位。一个类里面有两个方法A和B，方法A有@Transaction，B没有，但B调用了A，外界调用B会不会触发事务？ 51ThreadPoolExecutor 怎么实现的1）线程池状态 ExecutorService 源码 52 Java多继承https://juejin.im/post/5a903ef96fb9a063435ef0c8#heading-1内部类:每个内部类都能独立地继承自一个（接口的）实现，内部类允许继承多个非接口类型. socket编程 mq有几种模式Binding:Exchange和Queue的虚拟连接 接口和抽象类的区别抽象类里面能不能有非抽象方法 能不能被重写 String不能被继承重写和重载的区别 53 sb依赖注入控制反转。IOC:控制反转控制：Java Bean的生命周期（创建、销毁）反转：容器管理依赖关系。IOC是一种设计模式。将对象-对象关系解耦和对象-IOC容器-对象关系。容器管理依赖关系。依赖对象的获得被反转了。调用者不用创建被调用的实例，容器管理单例对象。 IOC的实现方式：1)设置注入/属性注入setter方法元素2）构造器注入3）工厂方法注入 依赖注入DI方式:把底层类作为参数传递给上层类，实现上层对下层的“控制”。setter、接口、构造函数。组件之间依赖关系由容器在运行期决定。SpringBoot Autowired是自动注入，自动从spring的上下文找到合适的bean来注入 IOC容器初始化1）Resource定位2）载入：把定义的Bean表示成IOC的数据结构（不包括Bean依赖注入）3）注册到容器的HashMap中 IOC容器通过和注解配置(Controller)1）IOC容器就是ApplicationContext 可以通过web.xml或者加载xml或者文件用application-context.xml初始化。2）定义bean 然后getBean()就获取了对象可以调用方法了bean的作用域6种 默认是单例，多次getBean是同一个。prototype每次都是新的。bean有创建和销毁的回调函数。3）如果要用两个类的组合，一个类里需要new另一个类，这样那个类的构造参数都需要在这个类里面改，这样强耦合。所以这个外部对象应该用构造函数（强依赖）/setter（可选依赖（可配置的（颜色）））等方法注入。 通过配置文件的方法，注入依赖的参数。 Springboot的启动流程tomcat的启动流程Spring 怎么解决循环引用构造器循环依赖：通过使用bean创建时的标识值setter循环依赖：通过引入objectfactory解决 Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。12345678/** Cache of singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);/** Cache of singleton factories: bean name --&gt; ObjectFactory */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);/** Cache of early singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); singletonFactories ： 单例对象工厂的cacheearlySingletonObjects ：提前暴光的单例对象的CachesingletonObjects：单例对象的cache AOP 面向切面编程 关注点分离，抽离业务逻辑知识图谱 之间的关系 和结构存储neo4jvue的特点和react的比较 54 前后端跨域怎么实现浏览器的同源策略导致了跨域。1)JSONP 但是只能直接发get请求&lt;script src=&quot;http://127.0.0.1:8897&quot;&gt;&lt;script&gt;2)Access-Control-Allow-Origin&#39;:&#39;*&#39;3)nginx反向代理 XSS 跨站脚本攻击：篡改网页，注入恶意html脚本。CSRF 跨站请求伪造（利用用户登陆态）Cookie的 SameSite属性strict http缓存响应：Expires是日期Cache-Control 的no-cache每次都要验证（ctrl+F5强制刷新）mag-age是给浏览器，s-max-age是给代理Etag不是秒，一秒修改很多次的情况，比较版本号条件式：过期了会带条件询问请求if-modified-since- 响应Last-modified 304 用户的cookie无法缓存，post和put都不缓存 Vary 加上对应的头信息，匹配才使用缓存 55 cookies1) 存储 浏览器的cookie数据库中2）服务器产生3）会威胁客户隐私4）用于跟踪用户访问和状态 cookie有两种:会话cookie（退出浏览器删除， 没设置discard或者expires 或者max-age） 持久cookiecookie的实现cookie加密 原本需要由web服务器创建会话的过程转交给Spring-Session进行创建，本来创建的会话保存在Web服务器内存中，通过Spring-Session创建的会话信息可以保存第三方的服务中，如：redis,mysql等 redis stringredis redis常用数据结构string, hash,set,sorted set,list12345678910redis&gt; GEOADD Sicily 13.361389 38.115556 "Palermo" 15.087269 37.502669 "Catania"(integer) 2redis&gt; GEODIST Sicily Palermo Catania"166274.1516"redis&gt; GEORADIUS Sicily 15 37 100 km1) "Catania"redis&gt; GEORADIUS Sicily 15 37 200 km1) "Palermo"2) "Catania"redis&gt; redis 有序集合skiplist和dict会共享元素的成员和分值。zset中的dict创建了一个从成员到分值的映射，程序可用O(1)的时间查找到【分值】(zscore)。跳跃表实现zrank,zrange 还有查找全是logN 如果一个千万条数据的表怎么优化数据库分片：1）分片ID2）无需分片的表 61 linux shell 如何传文件 scp 如何查进程ps -ef |grep如何在文件找查一个字符串grep &#39;abc&#39; abc.txtgrep &#39;abc&#39; abc* 从abc开头的文件查找参数-o只输出正则匹配的部分参数-v输出不含正则的内容 遍历文件夹查找所有文件中的一个字符串的所有行grep -r &quot;要查找的内容&quot; ./ 文件夹大小：du -sh . 如果grep不带文件就等输入 echo不支持标准输入 如何查找一个文件 find默认是递归查找的find ~ -name &quot;abc.java sed 替换awk 切片统计 终端 /dev/tty当前终端 vi： ZZ：命令模式下保存当前文件所做的修改后退出vi； 怎么调整top多久刷新，top间隔默认是多少 默认3秒 top -d 任务队列 和 CPU Load netstat列出所有tcp端口 netstat -at显示pid和进程名netstat -p可以查看所有套接字的连接情况 top 可以查看到哪些指标1： CPU 平均负载1min，5min,15min在一段时间内CPU正在处理以及等待CPU处理的 【进程数】 之和。CPU使用队列的长度的统计信息。2：进程、cpu状态、内存状态（系统内核控制的内存数） 打开的文件lsof 序列化的性能短链接特征模型归并排序多线程归并排序线程上下文类加载器JNDI服务，使用线程上下文加载器，父类加载器请求子类加载器完成类加载。 OSGi自定义加载器，程序模块和它的类加载器一起替换掉。 运行时字节码生成 动态代理动态代理：原始类和接口还未知的时候就确定了代理类的代理行为。代理类与原始类脱离直接联系后，可以用于不同的应用场景。 jvm以byte数组为单位拼接出 传入接口的每个方法的实现，并且调用外部传入this的invoke方法，的字节码文件。 RCU机制http://blog.jobbole.com/107958/ 分布式锁1）互斥性：保证不同节点的线程之间互斥2）同一个节点同一个线程可重入3）支持超时防死锁for update悲观锁 大并发不建议数据库是各个服务进程的临界资源。如果已经下订单了还没减库存，但是没加锁就会脏读。 乐观锁：因为查询加行锁开销比较大，用版本号，查询出版本号之后update或者delete的时候需要判断当前的版本号和刚才读的是否一致，这样就不用for update ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。 redis分布式锁流程1）setnx(key,currenttime+timeout)2)expire(key)3)业务执行完后del(key)其他tomcat获取不到锁返回0流程1）get(key)判断当前时间和value的时间，2)如果key超时了可以先get再setgetset(key,currenttime+timeout) 如果get的值是null或者和之前的锁一样（？）继续expire(key)走加锁流程… 面向对象和面向过程的区别封装：隐藏内部代码继承：复用现有代码多态：改写对象行为 面向过程是结构化开发方法，面向数据流的开发方法，用数据流图建立系统的功能模型。自顶向下，逐层分解，适合数据处理领域，难以适应需求变化。每个模块确定输入输出。结构化方法包括了：结构化分析SA，结构化设计SD（转换成软件体系结构图），结构化程序设计SPD结构化设计包括：体系结构设计、数据设计、接口设计（内部和外部接口）、过程设计 面向对象：UML是标准建模语言。面向对象分析，面向对象设计、面向对象实现，界限不明显。面向对象= 对象+分类+继承+消息通信需求经常变化，但是客观世界的对象和对象与对象间的关系比较稳定，所以OO的结果也相对稳定。 完整表述现实世界的数据结构，表达数据间的嵌套、递归联系。封装性和继承性提高了软件可重用性。面向过程会导致结构体里出现不是本模块的成员 对象的产生方式有1）原型对象(prototype 原型链)为基础的 （所有对象都是实例）2）基于类（Java)的对象模型。 分布式文件系统HDFS1）每个文件拆分成很多小块128M（并行处理和负载均衡）.2）文件以多副本存储（副本因子），高可用。3）有一个节点存储着存储信息 1个Master，NameNode。N个Slave DataNode。 NameNode：1）处理客户端请求 文件系统的读写操作 2）元素据DataNode：1）块的存储和操作 2）定期心跳 分布式文件系统一致性HDFS 文件只能写1次 除了 append和truncate 而且不能多并发写。 节点失效为什么本地文件系统不使用hash 2.25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？5轮找出各组第一；5组第一跑一次，得出第一，只有前3的组可能是前3；最后一次A2, A3, B1, B2, C1参赛得出第二第三名。 13.100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？topK问题1.找出N个数中最小的K个数 大小为K的【大根堆】。好处，不用全部读入内存。时间复杂度NlogK2.从N个有序数组/队列找到最小的K个值 用每个队列最小的元素组成一个N个元素的【小根堆】，获取堆顶，将堆顶这个元素的队列的下一个元素放入堆，重复，直到堆有K个数。 算法复杂度是（N+K-1）*logK 分布式1）均衡负载技术均衡负载的算法有：随机 round roubin 一致性hash2）容灾设计3）高可用系统 rpc通信jsonrpc没法区分int和long 通信开销加密和压缩 秒杀项目相关https://mp.weixin.qq.com/s/ktq2UOvi5qI1FymWIgp8jw秒杀项目的请求流程需求：秒杀地址隐藏，记录订单，减库存 1.下订单和减库存如何保持一致？ACID强一致性，利用关系型数据库的强一致性，【订单表和库存表】放在一个关系型数据库事务，实时一致性。高并发场景提高关系型数据库吞吐量和存储，应该吧库存和订单放入同一个数据库分片。主从复制只能提高数据库读。BASE思想：分布式事务拆分，每个步骤都记录状态，使用【写前日志】或者数据库来记住任务的执行状态，一般通过行级锁实现比写前日志更快。 2.缓存与数据库一致性读请求和写请求串行化，串到一个内存队列里去。串行化就不会不一致。先更新数据库再删除缓存。 缓存更新的时候加锁 防止大量请求直接访问数据库雪崩或者缓存不一致 常用的缓存使用模式 Cache Aside同时更新缓存和数据库，！先更新数据库，【删除缓存】，下次使用会添加到缓存 这种模式不保证 数据库和cache的一致性！数据库中的数据可以随时被外部进程修改，但是cache不会变。 如果数据库是有备份的，经常同步问题会很严重。 出问题的场景只有并发读和写，读在写之前读到数据库，在写返回删除缓存之后，读请求返回写旧缓存。基本不可能发生。可以通过2PC或者PAXOS保证一致性，实际操作还是设置过期时间。（并发操作包装成一个事务？） 数据库被外部进程修改的场景：mysql读写分离：如果先删除缓存，请求B从从库查询，但是还没完成主从同步，旧值写入缓存。解决方案是 异步延迟删除，保证读请求完了再删除。 如果删除缓存失败！！cache中是旧数据。1.失效时间 2.mq重试3.二次删除效率低 解决方案还是binlog 各个应用实例一定要用同样的分布式缓存。 适用场景：数据是不变的，可以启动时预加载的 Read/Write Through：先更新缓存，缓存负责同步更新数据库读：Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。 写:当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作） 1 每次写缓存都更新2 写缓冲，下一次写强制刷新 Write Behind Cacheing：linux文件系统的page cache只更新缓存，缓存定期异步更新数据库write-behind 缓存中，数据的读取和更新通过缓存进行，与 write-through 缓存不同，更新的数据并不会立即传到数据库。相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到数据库中。 缓存会合并这些脏记录。只保证最后一次更新。 会出现一瞬间cpu负载变高 redis怎么保证缓存一致性更新cache成功，更新数据库失败怎么办？强一致性，你需要使用“两阶段提交协议 3.更新数据库的同时为什么不是马上更新缓存而是删除缓存更新数据库后更新缓存可能会因为多线程下导致写入脏数据（比如线程A先更新数据库成功，接下来要取更新缓存，接着线程B更新数据库，但B又更新了缓存，接着B的时间片用完了，线程A更新了缓存） （？） 4.缓存穿透：数据库中没这个数据，缓存中也没有，数据库被大量查询有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。 哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。 1）查询结果为空的也缓存(命中不高 但是频繁更新的数据)2）对可能为空的key统一存放（命中不高 更新不频繁）3）如果后面插入了新数据要删除相应缓存（或者设置较短超时时间） 缓存击穿热点数据key过期，大量访问数据库1）用分布式锁，保证只有一个线程从数据库拉取数据2）后台异步脚本更新key过期时间 缓存雪崩缓存不可用（宕机） 大量缓存key失效多级缓存、随机超时、提高可用性 5.数据库乐观锁减库存先查库存，在减库存的时候判断当前库存是否与读到的库存一样乐观锁适用冲突少的情况，会导致大量回滚 死循环 cpu占用高 6.读写锁能不能用在大并发场景7.为什么要把页面放到redis中？页面缓存，将整个页面手动渲染，加上所有vo，设定有效期1分钟，让用户1看到的是1分钟前的页面详情页应该不能放（？）库存更新怎么办（？）只是把页面商品信息放到了redis中 8.秒杀地址 + 接口限流如果有很多手机账号，公不公平？按收货地址（？） 9.如果订单表和库存表不在同一个数据库除了分布式锁更轻量级的做法？消息队列-异步处理 10.为什么秒杀系统需要mq 秒杀排队系统多redis扣库存一旦缓存丢失需要考虑恢复方案。比如抽奖系统扣奖品库存的时候，初始库存=总的库存数-已经发放的奖励数，但是如果是异步发奖，需要等到MQ消息消费完了才能重启redis初始化库存，否则也存在库存不一致的问题。需要一个分布式锁来控制只能有一个服务去初始化库存 11.为什么秒杀系统需要mq 秒杀排队系统https://www.infoq.cn/article/yhd-11-11-queuing-system-design1）削峰:减少瞬间流量。处理失败的消息退回队列，接收的下一条还是这个消息，这是因为消息传递不仅要保证一次且仅一次，还要保证顺序。2）限流保证数据库不会挂掉，不然会影响其他服务。主要还是为了减少数据库访问 透这么多请求来数据库没有意义,会有大量锁冲突导致读请求会发生大量的超时。如果均成功再放下一批.3）持久化:就算库存系统出现故障,消息队列也能保证消息的可靠投递confirm模式将状态写入消息db(mysql),不会导致消息丢失。定时将状态失败的任务重新执行。4）订单和库存解耦.1234567#从队列里每次取几个spring.rabbitmq.listener.simple.prefetch= 1# 消费失败会重新压入队列spring.rabbitmq.listener.simple.default-requeue-rejected= true#spring.rabbitmq.publisher-confirms= truespring.rabbitmq.publisher-returns= true 异步下单：异步下单的前提是确保进入队列的购买请求一定能处理成功。Redis天然是单线程的，其INCR/DECR操作可以保证线程安全。而且入队之前要对用户user+goodsId判重。假设处理一个秒杀订单需要1s，而将秒杀请求（或意向订单/预订单）加入队列（或消息系统等）可能只需要1ms。异步化将用户请求和业务处理解耦 其他消息中间件 如何用redis list实现mq 12.消息中间件的作用1）解耦 基于数据的接口层2）冗余（持久化）3）扩展性 解耦了 处理过程4）削峰5）降低进程耦合度6）顺序消费7）缓冲8）异步通信 rabbitMQ 的confirm通知是否持久化成功，ack或者nack方法，等到有千条消息再一次性刷新到磁盘确保持久化：1.放到redis ， DB，消息状态：发送中2.投递消息，ack后删除消息3.定时任务获取redis中的 发送中消息，补偿性投递，补偿次数&gt;3 失败，由人工排查补偿方案要设计幂等性乐观锁：操作库存的时候带上商品version 13.mq集群模式Master-Slave模式NetWork模式 两组Master-Slave模式 14.mq怎么实现的https://tech.meituan.com/2016/07/01/mq-design.htmlAMQP协议: 虚拟主机（virtual host），交换机（exchange），队列（queue）和绑定（binding）。一个虚拟主机持有一组交换机、队列和绑定.broker(消息队列服务端)1）数据流：例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。2）RPC:两次RPC发送者把消息投递到服务端（broker），服务端再将消息转发一手到接收端，消费端最终做消费确认的情况是三次RPC。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。3）消息堆积:存储消息，在合适的时机投递消息。4）广播：我维护消费关系，可以利用zk/config server等保存消费关系。 生产者和消费者是完全解耦.？因为保证可靠消费？这样redis预减的库存就真的减少到mysql里了？不用再同步回来（？持久化？消息队列时需要考虑到的问题，如RPC、高可用、顺序和重复消息、可靠投递、消费关系解析等直接模式 15. mq的持久化交换机持久化、队列持久化、消息持久化持久化包括：队列索引和消息存储，队列索引维护队列中落盘的消息（消息的存储地点，是否已给消费者，是否已被消费者ack）队列中的消息有4种状态：alpha 消息和索引都在内存beta：消息内容在磁盘，索引在内存gamma：内容在磁盘，索引在磁盘和内存（持久化消息）delta：内容、索引都在磁盘内部存储分为5个子队列，经历从内存到磁盘再到内存，消费者从Q4读取。 默认：队列中消息尽可能存在内存中，即使持久化消息，被写入磁盘的同时，内存中也有备份，当需要释放内存时，换页到磁盘会阻塞队列操作。惰性队列：目标：支持更长队列，更多消息存储，消息存入磁盘，消费者消费到再加载到内存。 流量控制存储成一个完整的流控链，Connection处理进程，Channel处理进程，队列处理进程，消息持久化进程 ES倒排索引，倒排列表中每个节点存储document地址、文中出现位置、用TF-IDF计算的分数倒排索引压缩编码]]></content>
      <tags>
        <tag>面试卡片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单选题记录]]></title>
    <url>%2F2018%2F12%2F25%2Fchoice%2F</url>
    <content type="text"><![CDATA[1.类加载父类的静态成员初始化&gt;父类的静态代码块&gt;子类的静态成员初始化&gt;子类的静态代码块&gt;父类的代码块&gt;父类的构造方法&gt;子类的代码块&gt;子类的构造方法 12345678910111213public class Test &#123; public static void main(String[] args) &#123; System.out.println(Test2.a); &#125;&#125;class Test2&#123; public static final String a=new String("JD"); static &#123; System.out.print("OK"); &#125;&#125;答案：输出OKJD 123456789101112public class Test &#123; public static void main(String[] args) &#123; System.out.println(Test2.a); &#125;&#125;class Test2&#123; public static final String a="JD"; static &#123; System.out.print("OK"); &#125;&#125;答案：输出 JD 《java虚拟机》p213B中的常量，编译时通过【常量传播优化】直接存储到了Test类的常量池里，Test和B类的关系没有了。1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; System.out.print(B.c); &#125;&#125;class A &#123; static &#123; System.out.print("A"); &#125;&#125;class B extends A&#123; static &#123; System.out.print("B"); &#125; public final static String c = "C";&#125;答案 C 《java虚拟机》P212静态字段c，只有直接定义这个字段的类才会被初始化。通过子类来引用父类中定义的静态字段，只会触发父类初始化，不会触发子类。1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; System.out.print(B.c); &#125;&#125;class A &#123; public static String c = "C"; static &#123; System.out.print("A"); &#125;&#125;class B extends A&#123; static &#123; System.out.print("B"); &#125;&#125;答案 AC 2.多线程下面哪个行为被打断不会导致InterruptedException：（ ）？A Thread.joinB Thread.sleepC Object.waitD CyclicBarrier.awaitE Thread.suspend他的回答： A (错误)正确答案： E 如果抛出 InterruptedException 意味着一个方法是阻塞方法 如何在多线程中避免发生死锁？ 正确答案 : ABCD您的答案 : BCDA允许进程同时访问某些资源。B允许进程强行从占有者那里夺取某些资源。C进程在运行前一次性地向系统申请它所需要的全部资源。D把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。 下列关于线程调度的叙述中,错误的是( ) 正确答案 : C您的答案 : BA调用线程的sleep()方法,可以使比当前线程优先级低的线程获得运行机会B调用线程的yeild()方法,只会使与当前线程相同优先级的线程获得运行机会C具有相同优先级的多个线程的调度一定是分时的D分时调度模型是让所有线程轮流获得CPU使用权 下列关于线程调度的叙述中，错误的是（）。A调用线程的sleep()方法，可以使比当前线程优先级低的线程获得运行机会B调用线程的yeild()方法，只会使与当前线程相同优先级的线程获得运行机会C当有比当前线程的优先级高的线程出现时，高优先级线程将抢占CPU并运行D一个线程由于某些原因进入阻塞状态，会放弃CPUE具有相同优先级的多个线程的调度一定是分时的F分时调度模型是让所有线程轮流获得CPU使用权 正确答案：B C E3. 进程线程以下关于进程和线程的描述中，正确的一项是（ ）A 一个进程就是一个独立的程序B 进程间是互相独立的，同一进程的各线程间也是独立的，不能共享所属进程拥有的资源C 每个线程都有自己的执行堆线和程序计数器为执行上下文D 进程的特征包括动态性、并发性、独立性、同步性 他的回答： A (错误)正确答案： C 资源某系统中有4个并发进程，多需要同类资源5个，试问该系统无论怎样都不会发生死锁的最少资源数是 4. 字符串123456789public class Main &#123; public static void main(String[] args) &#123; String s1 = "abc"; String s2 = "abc"; System.out.println(s1 == s2); String s3 = new String("abc"); System.out.println(s1 == s3); &#125;&#125; 答案 true false 123456String str1 = "cityu";String str2 = new String("cityu");String str3 = "city"+new String("u");System.out.println(str1==str2);System.out.println(str1==str3);System.out.println(str2==str3); 答案 false false false str2是引用，在栈，引用的内容先在常量池，再复制到堆，str2的引用是堆的地址。str1是对常量池的引用 123456String str1 = "cityu";String str2 = new String("cityu");String str3 = "city"+new String("u");System.out.println(str1==str2.intern());System.out.println(str1==str3.intern());System.out.println(str2==str3.intern()); 答案 true true true intern会去查找常量池 12final String b = "b";//变成了常量String b1=b+"1";//编译期确定 =&gt;String b2="b1" ==b1 12345678private static String getString()&#123;//方法在运行期才能确定 return "c";&#125;main&#123;final String c= getString();//加不加final都false 方法一定在运行期确定String c1=c+1;String c2="c1";System.out.println(c1==c2);//不等&#125; jdk1.812345678910111213// "a"只要出现了就放到常量池String s = new String("a");// 已经放不进常量池了s.intern();String s2 = "a";//falseSystem.out.println(s==s2);String s3 = new String("a")+new String("a");// 放的是引用s3.intern();String s4 = "aa";//trueSystem.out.println(s3==s4); 5.设计模式Java数据库连接库JDBC用到哪种设计模式?A 生成器B 桥接模式C 抽象工厂D 单例模式他的回答： C (错误)正确答案： B 桥接模式：通过组合建立两个类之间的联系 ，而不是继承抽象与实现分离，可以独立变化，而且各自可以继承扩展。应用场景一个类存在两个或多个独立变化的维度，需要独立进行扩展,防止类爆炸。多个银行多种账户 12Bank icbcBank = new ICBCBank(new DepositAccount());Account icbcAccount = icbcBank.openAccount(); JDBC:DriverManager 和 具体的Driver 之前是桥接。所谓的抽象部分(JDBC API)与它的实现部分(JDBC Driver)分离Driver 和其mysql等数据库实现是 实现类。DriverInfo 里注入(registerDriver)了Driver Driver 中的静态块在调用Class.forName会调用Manager的静态方法register将Driver包装成DriverInfo注入。 JDBC通过 DriverManager 对外提供数据库的统一getConnection接口,返回的Connection也有不同的数据库实现类。registerDriver会找到真正的实现类。 抽象工厂：数据库连接的Connection、Statement接口. 用于获取同一类的产品族。mybatis的SqlSessionFactory构建session对象。 6.try catch12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; System.out.print(fun1()); &#125; public static String fun1() &#123; try &#123; System.out.print("A"); return fun2(); &#125; finally &#123; System.out.print("B"); &#125; &#125; public static String fun2() &#123; System.out.print("C"); return "D"; &#125;&#125;执行以上程序后，输出结果正确的是？正确答案 : C您的答案 : AA ABCDB ACDBC ACBDD 不确定 能单独和 finally 语句一起使用的块是A tryB throwsC throwD catch他的回答： C (错误)正确答案： A throw 要用在try catch中7. 复杂度下面一段代码的时间复杂度是12345678910if ( A &gt; B ) &#123; for ( i=0; i&lt;N; i++ ) for ( j=N*N; j&gt;i; j-- ) A += B;&#125;else &#123; for ( i=0; i&lt;N*2; i++ ) for ( j=N*2; j&gt;i; j-- ) A += B;&#125; A O(n)B O(n的2次方)C O(n的3次方)D O(nlog2n).他的回答： B (错误)正确答案： C 关于递归法的说法不正确的是（ ） 正确答案 : D您的答案 : CA程序结构更简洁B占用CPU的处理时间更多C要消耗大量的内存空间，程序执行慢，甚至无法执行D递归法比递推法的执行效率更高 8. 算法若串S=”UP！UP！JD”，则其子串的数目33373935 答案B 若字符串的长度为n,则子串的个数就是[n*(n+1)/2]+1个，重复的子串也考虑 包含1个字符的子串共n个； 包含2个字符的子串共n-1个； 包含3个字符的子串共n-2个； 包含4个字符的子串共n-3个； 包含n个字符的子串共1个； 空串1个； 子串个数共：1+2+3+……+n+1=n(n+1)/2+1； 子集数，串只能是相邻字符组成 如果不考虑重复字符串:去掉长度为1的重复字符串一共 U P ! 都出现了2次 -3去掉长度为2的重复字符串一共 UP P! 都出现了2次 -2去掉长度为3的重复字符串一共 UP! 都出现了2次 -1 12345678910111213141516public class Test &#123; static int cnt = 0; public static void main(String[] args) &#123; fib(7); System.out.println(cnt); &#125; static int fib(int n) &#123; cnt++; if (n == 0) return 1; else if (n == 1) return 2; else return fib(n - 1) + fib(n - 2); &#125;&#125; cnt(n)=cnt(n-1)+cnt(n-2)+1f(0) 1次 f(1) 1次f(2)=f(0)+f(1)+1=3f(3)=f(1)+f(2)=1+1+3=5f(4)=f(2)+f(3)=1+3+5=9f(5)=f(4)+f(3)=1+9+5=15f(6)=f(5)+f(4)=1+15+9=25f(7)=f(6)+f(5)=25+15+1=41 数据结构广义表(((a,b,c),d,e,f))的长度是1长度：去掉一层括号剩下的是几部分。深度：去掉几层括号可以到最后一部分. 以下序列中不可能是一棵二叉查找树的后序遍历结构的是:A 1,2,3,4,5B 3,5,1,4,2C 1,2,5,4,3D 5,4,3,2,1 B 无法找到一个合理的划分点，来组成二叉查找树 一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足? 正确答案 : C您的答案 : DA所有的结点均无左孩子B所有的结点均无右孩子C只有一个叶子结点D是一棵满二叉树 具有7个顶点的【有向图】至少应有多少条边才可能成为一个强连通图? 正确答案 : B您的答案 : AA 6 B 7 C 8 D 12有向图强连通：从任何一点出发都可以回到原处，每个节点至少要一条出路(单节点除外)至少有n条边，正好可以组成一个环最多n(n-1) 最少n 8.网络nagle 算法设置tcp的哪个socket参数会影响了 nagle算法？正确答案: DTCP_MAXSEGTCP_KEEPALIVETCP_SYNCNTTCP_NODELAY TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据。Nagle算法就是为了尽可能发送大块数据,避免网络中充斥着许多小数据块. 一个提供NAT服务的路由器在转发一个源IP地址为10.0.0.1、目的IP地址为131.12.1.1的IP分组时，可能重写的IP分组首部字段是Ⅰ.TTLⅡ.片偏移量Ⅲ.源IP地址Ⅳ.目的IP地址 答案1，2，3在路由器的分组转发过程中，间接转发时，源IP地址随着路由器的变化在不停变化，生存时间（TTL）每跳过一个路由器减1，片偏移量和偏移标志、首部检验和也可能发生变化。但目的IP地址始终不会变化。 查看系统内存如下： [@server ~]# free -g total used free shared buffers cached Mem: 15 5 9 0 0 2 -/+ buffers/cache: 3 12 Swap: 0 0 0那么程序实际可使用内存有多少 HTTP中的POST和GET在下列哪些方面有区别?( ) 正确答案 : ABCDE您的答案 : ADEA数据位置B明文密文C数据安全D长度限度E应用场景 9.数据库 SQLsql中，可以用来替换DISTINCT的语句是（ ） mysql数据库中一张user表中,其中包含字段A,B,C,字段类型如下:A:int,B:int,C:int根据字段A,B,C按照ABC顺序建立复合索引idx_A_B_C,以下查询语句中使用到索引idx_A_B_C的语句有哪些？ 正确答案 : ABD您的答案 : ABAselect from user where A=1 and B=1Bselect from user where 1=1 and A=1 and B=1Cselect from user where B=1 and C=1Dselect from user where A=1 and C=1 对于满足SQL92标准的SQL语句:123select foo,count(foo)from pokes where foo&gt;10 group by foo having count (*)&gt;5 order by foo 其执行顺序应该是? 正确答案 : A您的答案 : BA FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BYB FROM-&gt;GROUP BY-&gt;WHERE-&gt;HAVING-&gt;SELECT-&gt;ORDER BYC FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;ORDER BY-&gt;SELECTD FROM-&gt;WHERE-&gt;ORDER BY-&gt;GROUP BY-&gt;HAVING-&gt;SELECT 10. shellShell 脚本（shell script），是一种为 shell 编写的脚本程序。现有一个test.sh文件，且有可执行权限，文件中内容为：12#!/bin/bashaa='Hello World !' 请问下面选项中哪个能正常显示Hello World !sh test.sh &gt;/dev/null 1 &amp;&amp; echo $aa./test.sh &gt;/dev/null 1 &amp;&amp; echo $aabash test.sh &gt;/dev/null 1 &amp;&amp; echo $aa. ./test.sh &gt;/dev/null 1 &amp;&amp; echo $aa / source test.sh &gt;/dev/null 1 &amp;&amp; echo $aa答案DABC都是开子shell，不影响当前环境中的变量. ./test.sh等于source ./test.sh直接影响当前环境下的变量 在linux系统中,有一个文件夹里面有若干文件,通常用哪个命令可以获取这个文件夹的大小: 正确答案 : B您的答案 : BAls -h Bdu -sh Cdf -h Dfdish -h 11. 操作系统下列有关软连接描述正确的是 正确答案 : C您的答案 : DA与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块B不能对目录创建软链接C保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径D不可以对不存在的文件创建软链接 软链接有自己的文件属性及权限等；-可对不存在的文件或目录创建软链接；-软链接可交叉文件系统；-软链接可对文件或目录创建；-创建软链接时，链接计数 i_nlink 不会增加；-删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接） 下列关于链接描述，错误的是正确答案: B 你的答案: A (错误)A硬链接就是让链接文件的i节点号指向被链接文件的i节点B硬链接和符号连接都是产生一个新的i节点C链接分为硬链接和符号链接D硬连接不能链接目录文件 硬链接是有着相同 inode 号仅文件名不同的文件 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。 以下关于linux操作系统中硬链接和软链接的描述,正确的是? 正确答案 : B您的答案 : DA硬链接和软链接指向的inode的编号是一样的B可以建立一个空文件的软链接Clinux操作系统可以对目录进行硬链接D硬链接指向inode节点 12. linuxLinux文件权限一共10位长度(例如drwxrwxrwx)，分成四段，第三段表示的内容是:正确答案: C 你的答案: B (错误)A文件类型B文件所有者的权限C文件所有者所在组的权限D其他用户的权限 -rw-r--r--10位权限 （r4 w2 x1 读写执行权限 -没有权限 rwx7r-x5r-x5）设计成2的幂次因为不会歧义rw-u所有者权限r--g所属组r--其他人 13. 引用下面有关值类型和引用类型描述正确的是（）？ 正确答案 : ABC您的答案 : ABCDA值类型的变量赋值只是进行数据复制，创建一个同值的新对象，而引用类型变量赋值，仅仅是把对象的引用的指针赋值给变量，使它们共用一个内存地址。B值类型数据是在栈上分配内存空间，它的变量直接包含变量的实例，使用效率相对较高。而引用类型数据是分配在堆上，引用类型的变量通常包含一个指向实例的指针，变量通过指针来引用实例。C引用类型一般都具有继承性，但是值类型一般都是封装的，因此值类型不能作为其他任何类型的基类。D值类型变量的作用域主要是在栈上分配内存空间内，而引用类型变量作用域主要在分配的堆上。 跟作用域没关系 14. 泛型JVM p251123456789101112public class Test &#123; public static void main(String[] args) &#123; Test t = new Test(); t.method(null); &#125; public void method(Object o)&#123; System.out.println("Object"); &#125; public void method(String s)&#123; System.out.println("String"); &#125;&#125; 答案： String方法重载，编译期间静态分派 如果输入一个char去匹配1）先安全转型char-&gt;int&gt;long&gt;float-&gt;double不会匹配到byte和short 因为转型不安全2）在自动装箱Character，不会转成Integer3）然后转型成父类如果有多个父类，按继承关系，从下往上。如果实现了多个接口，优先级是一样的，不写明编译器报错。4）可变长参数(char… arg)的优先级最低，而且不会转型成int了 注意重载时是通过静态类型（左边）而不是实际类型（右边）为依据，并且静态类型在编译期可知。 cpp以下代码输出什么?12int a =1,b =32 ;printf("%d,%d",a&lt;&lt;b,1&lt;&lt;32); 执行a&lt;&lt;b时，编译器会先将b与31进行and操作，以限制左移的次数小于等于31。b&amp;31=0，则a&lt;&lt;b=1执行1&lt;&lt;32时，编译器直接执行算术左移的操作。 具有相同类型的指针类型变量p与数组a,不能进行的操作是: 正确答案 : D您的答案 : CA p=a;B *p=a[0];C p=&amp;a[0];D p=&amp;a; A C是一样的 C++中构造函数和析构函数可以抛出异常吗? 正确答案 : C您的答案 : BA都不行B都可以C只有构造函数可以D只有析构函数可以 开发C代码时,经常见到如下类型的结构体定义:12345typedef struct list_t&#123;struct list_t *next;struct list_t *prev;char data[0];&#125;list_t; 最后一行char data[0];的作用是? 正确答案 : AB您的答案 : BA方便管理内存缓冲区B减少内存碎片化C标识结构体结束D没有作用 很容易构造出变成结构体，如缓冲区，数据包等等构造缓冲区就是方便管理内存缓冲区,减少内存碎片化,它的作用不是标志结构体结束,而是扩展 行测 数学由A地到B地,中间有一段扶梯,总路程和扶梯长度是固定的,为赶时间全程都在行走(包含扶梯上),中途发现鞋带松了,需要停下来绑鞋带.请问在扶梯上绑鞋带和在路上绑鞋带两种方式比较( ) 正确答案 : B您的答案 : CA路上绑鞋带,全程用时短B扶梯上绑鞋带,全程用时短C用时一样D和扶梯长度,绑鞋带具体用时有关 将7723810的各位数字打乱排序,可组成的不同的7位自然数的个数是? 正确答案 : B您的答案 : BA1080B2160C3240D4320E5040 共有7的阶乘（5040）种排列，然后0在首位的排列有6的阶乘（720）种，数字中有两个7，所以结果在除以2，（5040-720）/2=2160.]]></content>
      <tags>
        <tag>面试卡片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo微服务框架]]></title>
    <url>%2F2018%2F12%2F25%2Fdubbo%2F</url>
    <content type="text"><![CDATA[SOA：从一个大系统拆分成 权限系统、用户系统，系统之间通过WebService消息组件交互（通过接口）微服务：1）是一种将业务系统进一步拆分的架构风格WBS 工作任务分解2）每个单一业务 独立运行（一个业务模块一个JVM） 资源拆分 资源独立 业务独立3）通过更轻量的协议4）服务环境不关心 api网关：为服务系统中的Facade1）身份验证 安全2）审查和监测（统计） 拦截器 获得边缘数据3）动态路由4）压力测试5）负载均衡6）静态数据处理 guns-rest JWTJWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 cookie 不能跨域的问题。]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactlearn]]></title>
    <url>%2F2018%2F12%2F14%2Freactlearn%2F</url>
    <content type="text"><![CDATA[mongodb react前端12345cnpm install -g create-react-appyarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sassnpm config set sass-binary-site http://npm.taobao.org/mirrors/node-sassyarn create react-app reactlearncnpm install redux --save 1cnpm install express --save 新建server文件夹新建server.js123456789101112const app = express()app.get('/',function (req,res) &#123; res.send('&lt;hi&gt;Hello word&lt;/hi&gt;') &#125;)app.get('/data',function (req,res) &#123; res.json(&#123;name:'小明'&#125;)&#125;)app.listen(9093,function () &#123; console.log("输入正确")&#125;) 运行：node server.js访问9093成功 node 热加载12npm install -g nodemon`nodemon server.js mongodb1234567891011121314sudo yum install -y mongodb-orgwhereis mongodservice mongod start&gt;use admin&gt;db.createUser( &#123; user: "root", //用户名 pwd: "123456", //密码 roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] //设置权限 &#125;)vi /etc/mongod.conf service mongod restartmongo -u root -p 123456 node mongodb1cnpm install mongoose --save 暂时先关掉auth service123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongoose = require('mongoose')// 连接数据库const DB_URL = 'mongodb://10.1.18.20:27017/reactlearn'mongoose.connect(DB_URL)mongoose.connection.on('connected',function () &#123; console.log("成功连接mongodb")&#125;)// 定义文档模型const User = mongoose.model('user',new mongoose.Schema(&#123; name: &#123;type:String,requier:true&#125;, age: &#123;type:Number,requier:true&#125;&#125;))// 添加数据User.create(&#123; name:'wangwu', age:18&#125;,function (err,doc) &#123; if(!err)&#123; console.log(doc) &#125;else&#123; console.log(err) &#125;&#125;)// 删除数据User.remove(&#123;age:18&#125;,function (err,doc) &#123; if(!err)&#123; console.log(doc) User.find(&#123;&#125;,function (e,d) &#123; console.log(d) &#125;) &#125;&#125;)// 更新User.update(&#123;'name':'zhangsan'&#125;,&#123;'$set':&#123;age:26&#125;&#125;,function (err, doc) &#123; console.log(doc)&#125;)const app = express() // 查询app.get('/data',function (req,res) &#123; User.find(&#123;"age":26&#125;,function (err,doc) &#123; res.json(doc) &#125;)&#125;) antd 和组件1234cnpm install antd-mobile# 按需加载yarn ejectnpm install babel-plugin-import --save-dev 在 package.json babel加上123"plugins": [ ["import", &#123; "libraryName": "antd-mobile", "style": "css" &#125;] ] 可以删掉import css 报错1cnpm install react-dev-utils --save-dev 坑：react里class名字要大写，小写tag会被当成html标签123456789101112131415161718192021222324252627282930313233class One extends Component&#123; constructor(props)&#123; super(props) this.state = &#123; arr:["a","b","c"] &#125; // this.additem = this.additem.bind(this) &#125;// additem = () =&gt;&#123; additem()&#123; this.setState( &#123; arr:[...this.state.arr,"aaa"+Math.random()] &#125; ) &#125; render()&#123; const boss2 = "boss1" return ( &lt;div&gt; &lt;ul&gt; &#123;this.state.arr.map(v=&gt;&#123; return &lt;li key=&#123;v&#125;&gt;&#123;v&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;h2&gt;boss1:,&#123;this.props.boss1&#125;&lt;/h2&gt; &lt;button onClick=&#123;()=&gt;this.additem()&#125;&gt;add users&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; &lt;button onClick={this.additem}&gt;add users&lt;/button&gt; 方法不能带小括号方法的this绑定在构造函数里,或者用箭头函数&lt;button onClick={()=&gt;this.additem()}&gt;add users&lt;/button&gt; redux和异步redux123456789101112131415161718192021// index.redux.jsconst ADD = "add"const REMOVE ="remove"export function counter(state=0,action) &#123; switch (action.type)&#123; case ADD: return state+1 case REMOVE: return state-1 default: return 10 &#125;&#125;export function add() &#123; return &#123;type:ADD&#125;&#125;export function remove() &#123; return &#123;type:REMOVE&#125;&#125; 12345678910//index.jsimport &#123;counter,add,remove&#125; from "./index.redux";const store = createStore(counter)function render() &#123; ReactDOM.render(&lt;App store=&#123;store&#125; add=&#123;add&#125; remove=&#123;remove&#125;/&gt;, document.getElementById('root'));&#125;render()store.subscribe(render) 12345678910111213141516//App.jsclass App extends Component &#123; render() &#123; const store = this.props.store const num = store.getState() const add = this.props.add const remove = this.props.remove return ( &lt;div&gt; &lt;h1&gt;现在state是&#123;num&#125;&lt;/h1&gt; &lt;Button onClick=&#123;()=&gt;store.dispatch(add())&#125;&gt;添加&lt;/Button&gt; &lt;Button onClick=&#123;()=&gt;store.dispatch(remove())&#125;&gt;删除&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125; thunk中间件1cnpm install redux-thunk --save 1234567//index.jsimport &#123; createStore,applyMiddleware&#125; from 'redux'import thunk from 'redux-thunk'const store = createStore(counter,applyMiddleware(thunk))function render() &#123; ReactDOM.render(&lt;App store=&#123;store&#125; add=&#123;add&#125; addAsync=&#123;addAsync&#125; remove=&#123;remove&#125;/&gt;, document.getElementById('root'));&#125; 12345678// index.redux.jsexport function addAsync()&#123; return dispatch=&gt;&#123; setTimeout(()=&gt;&#123; dispatch(add()) &#125;,2000) &#125;&#125; 12const addAsync = this.props.addAsync &lt;Button onClick=&#123;()=&gt;store.dispatch(addAsync())&#125;&gt;异步&lt;/Button&gt; 目录结构1234567891011121314151617/app - /app/js - /app/js/class - /app/js/class/test.js - /app/js/index.ejs - /app/css - /app/views - /app/views/error.ejs - /app/views/index.ejs/server/tasks - /tasks/util - /tasks/util/args.js - /tasks/scripts.jspackage.json.babelrcgulpfile.babel.js 搭建server123npm install express-generator -g\server&gt;express -e .npm install 构建工具文件合并，脚本编译，模板自动更新创建命令行工具 生成依赖文件package.jsonnpm init bebal配置1.babelrc gulp 配置文件1gulpfile.babel.js args.js1234567891011121314151617181920212223242526272829303132333435// 命令行参数包import yargs from 'yargs';// 区分开发环境和线上环境const args = yargs .option('production',&#123; boolean:true, default:false, describe: 'min all scripts' &#125;)// 开发环境自动编译 .option('watch',&#123; boolean:true, default:false, describe: 'watch all files' &#125;)// 命令行输出详细日志 .option('verbose',&#123; boolean:true, default:false, describe: 'log' &#125;)// source map .option("sourcemaps",&#123; describe:'force the creation of sroucemaps' &#125;) // 服务器端口 .option("port",&#123; string:true, default:8080, describe:'server port' &#125;) // 以字符串解析 .argv gulp打包脚本]]></content>
      <categories>
        <category>项目练习</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark scala]]></title>
    <url>%2F2018%2F11%2F17%2Fspark%2F</url>
    <content type="text"><![CDATA[Esri GeojsonMlib数据格式1.本地向量Vector.dense(1.0,2.0,3.0) 还有位置的稀疏向量2.监督学习xy对LabeledPoint(1.0,Vector.dense(1.0,2.0,3.0))3.本地矩阵 是按列存储的 Matrices.dense(3,3,Array(1,0,0,1,0,0,0,1)稀疏矩阵比较复杂4.分布式矩阵RDD 弹性分布式数据集 RDD:弹性分布式数据集 n行1列的表 行是string 没有列的概念 MLib使用Dataset:类似csv 有列了 ml 使用DataFrame：有列，行被封装成Row对象 spark 配置spark-env.shhttps://spark.apache.org/docs/latest/configuration.html 12Shell:397 - Failed to locate the winutils binary in the hadoop binary pathjava.io.IOException: Could not locate executable 添加System.setProperty(&quot;hadoop.home.dir&quot;, &quot;C:\\winutils&quot;) Wordcount1.map,拆分出单词2.reduce合并并计数单词 12345678object WordCount &#123; def main(args: Array[String]): Unit = &#123; System.setProperty("hadoop.home.dir", "C:\\winutils") var sc = new SparkContext("local","wordcount") val file = sc.textFile("D:\\sparkLearn\\src\\LICENSE") file.flatMap(_.split(" ")).map((_,1)).reduceByKey((a,b)=&gt; a+b).foreach(println(_)) &#125;&#125; 打包Artifacts- Jar - From Modules - Main class选择WordCount因为要发布到spark集群中运行，所以 删除所有scala的jar包 只保留工程的compile output提交后生成META-INF-MANIFEST.MFBuild-Build Artifacts -Buildout里可以看到编译完的jar包 spark-submit D:\sparkLearn\out\artifacts\sparkLearn_jar\sparkLearn.jar 数据可视化 echartshttp://echarts.baidu.com/examples/ 基础统计模块 相关性 假设检验文档https://spark.apache.org/docs/2.3.0/mllib-statistics.html北京历年降水量1234567891011scala&gt; val txt = sc.textFile("D:/sparkLearn/src/beijingdata.txt")txt: org.apache.spark.rdd.RDD[String] = D:/sparkLearn/src/beijingdata.txt MapPartitionsRDD[6] at textFile at &lt;console&gt;:28scala&gt; txt.take(10)res30: Array[String] = Array(0.4806,0.4839,0.318,0.4107,0.4835,0.4445,0.3704,0.3389,0.3711,0.2669,0.7317,0.4309,0.7009,0.5725,0.8132,0.5067,0.5415,0.7479,0.6973,0.4422,0.6733,0.6839,0.6653,0.721,0.4888,0.4899,0.5444,0.3932,0.3807,0.7184,0.6648,0.779,0.684,0.3928,0.4747,0.6982,0.3742,0.5112,0.597,0.9132,0.3867,0.5934,0.5279,0.2618,0.8177,0.7756,0.3669,0.5998,0.5271,1.406,0.6919,0.4868,1.1157,0.9332,0.9614,0.6577,0.5573,0.4816,0.9109,0.921)scala&gt; val data = txt.flatMap(_.split(",")).map(value =&gt; Vectors.dense(value.toDouble))data: org.apache.spark.rdd.RDD[org.apache.spark.mllib.linalg.Vector] = MapPartitionsRDD[8] at map at &lt;console&gt;:29scala&gt; data.take(10)res31: Array[org.apache.spark.mllib.linalg.Vector] = Array([0.4806], [0.4839], [0.318], [0.4107], [0.4835], [0.4445], [0.3704], [0.3389], [0.3711], [0.2669]) 统计12345678910scala&gt; import org.apache.spark.mllib.&#123;stat,linalg&#125;import org.apache.spark.mllib.&#123;stat, linalg&#125;scala&gt; stat.Statistics.colStats(data)res39: org.apache.spark.mllib.stat.MultivariateStatisticalSummary = org.apache.spark.mllib.stat.MultivariateOnlineSummarizer@75d753acscala&gt; res39.count max mean min normL1 normL2 numNonzeros variancescala&gt; res39.maxres40: org.apache.spark.mllib.linalg.Vector = [1.406] 相关系数 年份和降水量的关系 矩阵和向量文档https://spark.apache.org/docs/latest/mllib-data-types.html 向量 应该使用123456scala&gt; val v2 = breeze.linalg.DenseVector(1,2,3,4)v2: breeze.linalg.DenseVector[Int] = DenseVector(1, 2, 3, 4)scala&gt; v2.% /= :== ^^= dot iterator reduceRight unary_-%:% :!= :&gt; active equals keySet repr unsafeUpdate..... 12345val v1 = Vectors.dense(1,2,3,4)v1: org.apache.spark.mllib.linalg.Vector = [1.0,2.0,3.0,4.0]scala&gt; v1.apply asML copy foreachActive numActives size toDense toSparseargmax compressed equals hashCode numNonzeros toArray toJson 矩阵1234scala&gt; val m1 = org.apache.spark.mllib.linalg.Matrices.dense(2,3,Array(1,2,3,4,5,6))m1: org.apache.spark.mllib.linalg.Matrix =1.0 3.0 5.02.0 4.0 6.0 1234scala&gt; val m2 = breeze.linalg.DenseMatrix(Array(1,2,3),Array(4,5,6))m2: breeze.linalg.DenseMatrix[Int] =1 2 34 5 6 123456scala&gt; val m3 = breeze.linalg.DenseMatrix(Array(1,2,3,4,5,6))m3: breeze.linalg.DenseMatrix[Int] = 1 2 3 4 5 6scala&gt; m3.reshape(2,3)res6: breeze.linalg.DenseMatrix[Int] =1 3 52 4 6 currying 函数 两个变量的函数变成两个分次传入12def sum2(a:Int)(b:Int) = a+bprintln(sum2(3)(5)) //8 scala 多行字符串1234567// 多行字符串var b =s"""|多行字符串|$name""".stripMarginprintln(b) Scala 模式匹配match case匹配类型12345678matchType(Map("name" -&gt; "PK"))def matchType(obj:Any): Unit =&#123; obj match&#123; case x:Int =&gt; println("Int") case s:String =&gt; println("String") case m:Map[_,_] =&gt; m.foreach(println) &#125;&#125; Scala的apply 伴生对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647object ApplyApp &#123; def main(args: Array[String]): Unit = &#123; /* out： 调用伴生对象 1 */ ApplyTest.incr println(ApplyTest.count)// out: 伴生对象 调用了aply方法// 调用了类 val applyObj = ApplyTest() /** out: * 调用了类 * com.start.ApplyTest@4e9ba398 */ val applyClass = new ApplyTest() println(applyClass) // out:伴生类 调用类的apply方法 applyClass() &#125; &#125;// 同名 class和objectclass ApplyTest&#123; println("调用了类") def apply() = &#123; println("伴生类") &#125;&#125;// 单例对象object ApplyTest&#123; println("调用伴生对象") var count = 0 def incr = &#123; count = count + 1 &#125; // 最佳实践：在object的apply中new Class def apply(): ApplyTest = &#123; println("伴生对象") new ApplyTest &#125;&#125; caseClass123456object CaseClass &#123; def main(args: Array[String]): Unit = &#123; println(Dog("namename").name) &#125;&#125;case class Dog(name:String) trait第一个用extends 后面用with]]></content>
  </entry>
  <entry>
    <title><![CDATA[ICSOC NASAC 会议记录]]></title>
    <url>%2F2018%2F11%2F14%2Fconference%2F</url>
    <content type="text"><![CDATA[需求、设计与演化质量特约报告 移动Web软件系统体验质量解析与优化 数据集http://www.ntu.edu.sg/home/gaocong/datacode.htm 《eTOUR: A Two-Layer Framework for Tour Recommendation with Super-POIs》https://link.springer.com/chapter/10.1007/978-3-030-03596-9_55#Sec3大景点（large-scale POI）：例如 外滩 有多个出口，里面包含了很多小景点的情况。希望对小景点内也有路径，而不是直接经过它。 先把大景点当一个，然后内景点的路径动态适应外路径。。Outer ModelLocal searchGRASP .Greedy Randomized Adaptive Search Procedure[3]内景点DFS 剪枝：剩余时间/重复节点 数据集 爬百度地图的北京和杭州的 可用的参考文献：《Personalized multi-period tour recommendations》：foursquare的数据集分成了6类 66个小类多天的行程规划 每个POI有时间窗。用taba search和启发式的算法。评价的时候用了Transport time/Service time/Waiting time 《E-Tourism: Mobile Dynamic Trip Planner》]]></content>
      <tags>
        <tag>会议记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财项目-用到RPC和加密]]></title>
    <url>%2F2018%2F11%2F10%2Fjava-financial-project%2F</url>
    <content type="text"><![CDATA[主要的业务流程 查询和购买 用到的技术： 1.模块化开发 高内聚，低耦合模块划分业务模块 公共模块 - 项目模块 - 管理端/销售端 按业务层次划分，将dao层和service层单独划分成模块（Entity、Api） 功能划分：管理和销售模块（可以独立部署的，算一个应用） 重复使用的模块：Util，Quartz，Swagger 构建工具 Gradle模块：jar/war可以独立部署创建gradle java项目 使用本地gradle修改 构建脚本 添加单独文件专门用来依赖管理dependencies.gradle123456789101112131415161718192021222324252627282930313233343536373839ext &#123; versions = [ springBootVersion: '2.0.0.RELEASE' ] libs = [ common : [ "org.springframework.boot:spring-boot-starter-web:$&#123;versions.springBootVersion&#125;", "org.springframework.boot:spring-boot-starter-data-jpa:$&#123;versions.springBootVersion&#125;", "org.apache.commons:commons-lang3:3.5" , "com.h2database:h2:1.4.195" ], findbugs: [ "com.google.code.findbugs:jsr305:1.3.9" ], mysql : [ "mysql:mysql-connector-java:5.1.29" ], jsonrpc:[ "com.github.briandilley.jsonrpc4j:jsonrpc4j:1.5.1" ], swagger: [ "io.springfox:springfox-swagger2:2.7.0", "io.springfox:springfox-swagger-ui:2.7.0" ], hazelcast:[ 'com.hazelcast:hazelcast:3.8.6', 'com.hazelcast:hazelcast-spring:3.8.6', ], activemq:[ "org.springframework.boot:spring-boot-starter-activemq:$&#123;versions.springBootVersion&#125;", ], rsa:[ 'commons-codec:commons-codec:1.8' ], test : [ "org.springframework.boot:spring-boot-starter-test:$&#123;versions.springBootVersion&#125;" ] ]&#125; 修改build.gradle 引入依赖文件1234567891011121314151617181920212223group 'finalLearn'version '1.0-SNAPSHOT'apply from: "$rootDir/dependencies.gradle"subprojects &#123; apply plugin: 'java' apply plugin: 'war' sourceCompatibility = 1.8 targetCompatibility = 1.8 repositories &#123; mavenLocal() mavenCentral() &#125; dependencies &#123; compile libs.common testCompile libs.test &#125; [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'&#125; 新建模块1.在工程上新建Module util，2.将util的build.gradle清空因为根项目的build.gradle 的 subprojects定义过了所有模块。3.新建其他api,entity,manager,quartz,swagger,saller模块。4.删除根目录下的src 2数据库设计创建 manager 数据库 和 saller数据库 管理端：产品表 datetime 保存的时间更广，timestamp有时区信息（读取的时候会根据客户端时区转换成对应时区） 编号varchar50、名称varchar50、收益率decimal5,3、锁定期smallint、状态varchar20、起投金额decimal 15,3、投资步长decimal 15,3、备注创建时间datetime、创建者varchar20、更新时间datetime、更新者varchar201234567891011121314151617use managerDROP TABLE IF EXISTS `product`;CREATE TABLE `product` ( `Id` varchar(50) NOT NULL DEFAULT '' COMMENT '产品编号', `name` varchar(50) NOT NULL DEFAULT '' COMMENT '产品名称', `threshold_amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '起投金额', `step_amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '投资补偿', `lock_term` smallint(6) NOT NULL DEFAULT '0' COMMENT '锁定期', `reward_rate` decimal(5,3) NOT NULL DEFAULT '0.000' COMMENT '收益率', `status` varchar(20) CHARACTER SET latin1 NOT NULL DEFAULT '' COMMENT 'audining审核中', `memo` varchar(200) DEFAULT NULL, `create_at` datetime DEFAULT NULL COMMENT '创建时间', `create_user` varchar(20) DEFAULT NULL, `update_at` datetime DEFAULT NULL, `update_user` varchar(20) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 销售端： 订单表order_t (order是关键字)订单编号varchar50 渠道编号varchar50 产品编号varchar50 用户编号varchar50 外部订单编号varchar50 类型varchar50 状态varchar50 金额decimal15,3 备注varchar200 创建时间datetime 更新时间datetime1234567891011121314151617create database seller;use seller;DROP TABLE IF EXISTS `oreder_t`;CREATE TABLE `oreder_t` ( `order_id` varchar(50) NOT NULL DEFAULT '', `ch_id` varchar(50) NOT NULL DEFAULT '' COMMENT '渠道编号', `product_id` varchar(50) NOT NULL DEFAULT '' COMMENT '产品编号', `chan_user_id` varchar(50) NOT NULL DEFAULT '', `order_type` varchar(50) NOT NULL DEFAULT '' COMMENT '状态购买赎回', `order_status` varchar(50) NOT NULL DEFAULT '' COMMENT '状态初始化处理中成功失败', `outer_order_id` varchar(50) NOT NULL DEFAULT '' COMMENT '外部订单编号', `amount` decimal(15,3) NOT NULL DEFAULT '0.000' COMMENT '金额', `memo` varchar(200) DEFAULT NULL COMMENT '备注', `create_at` datetime DEFAULT NULL COMMENT '创建时间', `update_at` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`order_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; entity产品类 Productentity的java里新建包entity新建Product和Order类12345678910111213141516@Entitypublic class Product &#123; @Id private String id; private String name; private String status; private BigDecimal thresholdAmount; private BigDecimal stepAmount; private Integer lockTerm; private BigDecimal rewardRate; private String memo; private Date createAt; private Date updateAt; private String createUser; private String updateUser;&#125; 可以用工具类重写toString（apache.commons）用反射(?)123@Overridepublic String toString() &#123; return ReflectionToStringBuilder.toString(this, ToStringStyle.SIMPLE_STYLE); 产品status的枚举类 新建enums包12345678910public enum ProductStatus &#123; AUDITING("审核中"), IN_SELL("销售中"), LOCKED("暂停销售"), FINISHED("已结束"); ProductStatus(String desc) &#123; this.desc = desc; &#125; private String desc;&#125; 在Product类中添加说明1234/*** @see entity.enums.ProductStatus*/private String status; 订单对象 Order类1234567891011121314@Entity(name = "order_t")public class Order &#123; @Id private String orderId; private String chanId; private String chanUserId; private String orderType; private String orderStatus; private String outerOrderId; private BigDecimal amount; private String memo; private Date createAt; private Date updateAt;&#125; 订单状态和订单种类的枚举类1234567891011public enum OrderType &#123; APPLY("申购"), REDEEM("赎回"); private String desc; OrderType(String desc) &#123; this.desc = desc; &#125; public String getDesc() &#123; return desc; &#125;&#125; 添加doc12345678/** * @see entity.enums.OrderType */private String orderType;/** * @see entity.enums.OrderStatus */private String orderStatus; 123456789101112131415public enum OrderStatus &#123; INIT("初始化"), PROCESS("处理中"), SUCCESS("成功"), FAIL("失败"); private String desc; OrderStatus(String desc) &#123; this.desc = desc; &#125; public String getDesc() &#123; return desc; &#125;&#125; 3.管理端Spring Data 用JPA 操作数据库接口设计 添加产品、查询单个产品、条件查询产品 1.新建启动类在manager模块 新建mannager-ManagerApp.java 启动类entity不在manager里要手动添加扫描路径1234567@SpringBootApplication@EntityScan(basePackages = &#123;"entity"&#125;)public class ManagerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ManagerApp.class); &#125;&#125; 2.配置数据库连接地址：在resources添加jpa配置文件123456789spring: datasource: url: jdbc:mysql://192.168.3.109:3306/manager?user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=utf-8 jpa: show-sql: trueserver: servlet: context-path: /manager port: 8081 3.新建controller，repository,service包 4.创建接口dao层repository - ProductRepository继承 简单查询和复杂查询12public interface ProductRepository extends JpaRepository&lt;Product,String&gt;,JpaSpecificationExecutor&lt;Product&gt;&#123;&#125; 在当前模块的build.gradle 添加entity依赖123456dependencies&#123; compile project(":entity") compile project(":util") compile project(":api") compile libs.mysql&#125; 添加产品5.service添加产品 参数校验+设置默认值不应该在实体类有默认值int会有默认值 Integer不会有默认值判断整数的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Servicepublic class ProductService &#123; private static Logger LOG = LoggerFactory.getLogger(ProductService.class); @Autowired private ProductRepository repository; public Product addProduct(Product product)&#123; LOG.debug("创建产品，参数：&#123;&#125;",product); //数据校验 checkProduct(product); setDefault(product); Product rst = repository.save(product); LOG.debug("创建产品，结果:&#123;&#125;",rst); return rst; &#125; /** * 产品：编号不可空 步长整数 收益率0-30 校验 * @param product */ private void checkProduct(Product product) &#123; Assert.notNull(product.getId(), "编号不可为空"); Assert.isTrue(BigDecimal.ZERO.compareTo(product.getRewardRate())&lt;0&amp;&amp;BigDecimal.valueOf(30).compareTo(product.getRewardRate())&gt;=0,"收益率范围错误" ); Assert.isTrue(BigDecimal.valueOf(product.getStepAmount().longValue()).compareTo(product.getStepAmount())==0, "投资步长需为整数"); &#125; /** * 产品默认值：创建更新时间，步长，状态，锁定期 * @param product */ public void setDefault(Product product) &#123; if(product.getCreateAt()==null)&#123; product.setCreateAt(new Date()); &#125; if(product.getUpdateAt()==null)&#123; product.setUpdateAt(new Date()); &#125; if(product.getStepAmount()==null)&#123; product.setStepAmount(BigDecimal.ZERO); &#125; if(product.getLockTerm()== null)&#123; product.setLockTerm(0); &#125; if(product.getStatus()==null)&#123; product.setStatus(ProductStatus.AUDITING.name()); &#125; &#125;&#125; 6.controller info级别的log123456789101112131415@RestController@RequestMapping("/products")public class ProductController &#123; private static Logger LOG = LoggerFactory.getLogger(ProductController.class); @Autowired private ProductService service; @RequestMapping(value = "",method= RequestMethod.POST) public Product addProduct(@RequestBody Product product)&#123; LOG.info("创建产品，参数:&#123;&#125;",product); Product rst = service.addProduct(product); LOG.info("创建产品，参数:&#123;&#125;",product); return rst; &#125;&#125; 查询产品单个产品7.service1234567public Product findOne(String id)&#123; Assert.notNull(id,"需要产编号参数"); LOG.debug("查询单个产品,id=&#123;&#125;",id); Product product = repository.findById(id).orElse(null); LOG.debug("查询单个产品,结果=&#123;&#125;",product); return product;&#125; 8.controller从URL里获得产品id@PathVariable1234567@RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.GET)public Product findOne(@PathVariable String id)&#123; LOG.info("查询单个产品，id:&#123;&#125;",id); Product product = service.findOne(id); LOG.info("查询单个产品，结果:&#123;&#125;",product); return product;&#125; 复杂查询 分页查询9.service1).多个编号查询List&lt;String&gt; idList2).收益率范围查询BigDecimal minRewardRate, BigDecimal maxRewardRate3).多个状态查询List&lt;String&gt; statusList4).分页查询Pageable pageable 分页参数 定义Specification12345678910111213141516171819202122232425262728293031323334353637public Page&lt;Product&gt; query(List&lt;String&gt; idList, BigDecimal minRewardRate, BigDecimal maxRewardRate, List&lt;String&gt; statusList, Pageable pageable)&#123; LOG.debug("查询产品,idList=&#123;&#125;,min=&#123;&#125;,max:&#123;&#125;,status=&#123;&#125;,pageable=&#123;&#125;",idList,minRewardRate,maxRewardRate,statusList,pageable); Specification&lt;Product&gt; specification = new Specification&lt;Product&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Product&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //获得编号、收益率、状态列 Expression&lt;String&gt; idCol = root.get("id"); Expression&lt;BigDecimal&gt; rewardRateCol = root.get("rewardRate"); Expression&lt;String&gt; statusCol = root.get("status"); //断言列表 List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if(idList!=null &amp;&amp;idList.size()&gt;0)&#123; predicates.add(idCol.in(idList)); &#125; if(minRewardRate!=null&amp;&amp;BigDecimal.ZERO.compareTo(minRewardRate)&lt;0)&#123; predicates.add(cb.ge(rewardRateCol,minRewardRate)); &#125; if(maxRewardRate!=null&amp;&amp;BigDecimal.ZERO.compareTo(maxRewardRate)&lt;0)&#123; predicates.add(cb.le(rewardRateCol,maxRewardRate)); &#125; if(statusList!=null&amp;&amp;statusList.size()&gt;0)&#123; predicates.add(statusCol.in(statusList)); &#125; // 查询 列表-&gt;数组? query.where(predicates.toArray(new Predicate[0])); return null; &#125; &#125;; Page&lt;Product&gt; page = repository.findAll(specification, pageable); LOG.debug("查询产品，结果=&#123;&#125;",page); return page;&#125; 10.controllerpageNum 哪页 pageSize 每页多少12345678910111213141516@RequestMapping(value = "",method = RequestMethod.GET) public Page&lt;Product&gt; query(String ids, BigDecimal minRewardRate,BigDecimal maxRewardRate,String status,@RequestParam(defaultValue = "0") int pageNum,@RequestParam(defaultValue = "10")int pageSize)&#123; LOG.info("查询产品,ids=&#123;&#125;,min=&#123;&#125;,max=&#123;&#125;,status=&#123;&#125;,pagenum =&#123;&#125;,pagesize=&#123;&#125;", ids,minRewardRate,maxRewardRate,status,pageNum,pageSize); List&lt;String&gt; idList = null,statusList = null; if(!StringUtils.isEmpty(ids))&#123; idList = Arrays.asList(ids.split(",")); &#125; if(!StringUtils.isEmpty(status))&#123; statusList = Arrays.asList(status.split(",")); &#125; Pageable pageable = new PageRequest(pageNum,pageSize); Page&lt;Product&gt; page = service.query(idList, minRewardRate, maxRewardRate, statusList, pageable); LOG.info("=&#123;&#125;",page ); return page; &#125; API测试启动MangerAPP1234567891011121314151617var data = &#123; "id":"001", "name":"金融1号", "thresholdAmount":10, "stepAmount":1, "lockTerm":0, "rewardRate":3.86, "status":"AUDITING"&#125;fetch("http://localhost:8081/manager/products",&#123; // post请求 method:"POST", headers: &#123; "Content-Type": "application/json" &#125;, body:JSON.stringify(data)&#125;).then(res =&gt; console.log(res.json())) .catch(e=&gt;console.log("something went wrong: " + e)) 查看数据库 OK 查询get：http://localhost:8081/manager/products/001 搜索功能：get:http://localhost:8081/manager/products?minRewardRate=3&amp;maxRewardRate=5&amp;status=AUDITING&amp;pageNum=0&amp;pageSize=10 jackson时间格式化 好像并不用1234spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 post：http://localhost:8081/manager/products/12345678&#123; "name":"金融1号", "thresholdAmount":10, "stepAmount":1, "lockTerm":0, "rewardRate":3.86, "status":"AUDITING"&#125; 返回1234567&#123; "timestamp": "2018-08-29 19:38:21", "status": 500, "error": "Internal Server Error", "message": "编号不可为空", "path": "/manager/products/"&#125; 4.统一错误处理https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-error-handlingspring boot提供了默认的/error全局错误处理对于machine clients(程序，jar包，http client ,ajax发起的), it produces a JSON response 包括HTTP status, the exception message.对于浏览器（browser clients会自动添加accept: text/html到报文头）发起的请求renders the same data in HTML format 如果用postman加上Accept:text/html就返回html通过实现ErrorController接口注册到容器中或者添加一个ErrorAttributesbean还可以用@ControllerAdvice拦截controller的错误 源码：变成html的实现方法BasicErrorController123@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController 错误页面的拦截所以可以通过修改server.error.path修改默认配置123456789101112@RequestMapping(produces = "text/html")public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); // 自定义的error视图 ModelAndView modelAndView = resolveErrorView(request, response, status, model); //如果没有视图，用error视图 return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);&#125; 普通机器客户端的拦截12345678@RequestMapping@ResponseBodypublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;&gt;(body, status);&#125; 都是用getErrorAttributes获取响应数据，用getStatus 获取状态码 BasicErrorController的注册过程 右键Find Usages1234567@Bean//条件表达式，如果没有则新建@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers);&#125; html错误形式1234567891011121314151617181920212223242526272829@Configuration@ConditionalOnProperty(prefix = "server.error.whitelabel", name = "enabled", matchIfMissing = true)@Conditional(ErrorTemplateMissingCondition.class)protected static class WhitelabelErrorViewConfiguration &#123; private final SpelView defaultErrorView = new SpelView( "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;" + "&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;" + "&lt;div id='created'&gt;$&#123;timestamp&#125;&lt;/div&gt;" + "&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;" + "&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"); //注册了一个View名字叫error @Bean(name = "error") @ConditionalOnMissingBean(name = "error") public View defaultErrorView() &#123; return this.defaultErrorView; &#125; // If the user adds @EnableWebMvc then the bean name view resolver from // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment. @Bean @ConditionalOnMissingBean(BeanNameViewResolver.class) public BeanNameViewResolver beanNameViewResolver() &#123; BeanNameViewResolver resolver = new BeanNameViewResolver(); resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; &#125;&#125; 自定义错误处理新建错误页面123456789src/ +- main/ +- java/ | + &lt;source code&gt; +- resources/ +- public/ +- error/ | +- 404.html +- &lt;other public assets&gt; 方法1 拦截5xx错误 新建resources-static.error-5xx.html 方法2新建error包 新建类1.继承BasicErrorController重写返回错误的方法，去掉不要的信息123456789101112131415public class MyErrorController extends BasicErrorController&#123; public MyErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties, List&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; super(errorAttributes, errorProperties, errorViewResolvers); &#125; @Override protected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(request, includeStackTrace); errorAttributes.remove("timestamp"); errorAttributes.remove("error"); errorAttributes.remove("path"); return errorAttributes; &#125;&#125; 2.添加配置类注册bean 参考BasicError的注册类ErrorMvcAutoConfiguration 将Controller注册到容器中123456789@Configurationpublic class ErrorConfiguration &#123; @Bean public MyErrorController basicErrorController(ErrorAttributes errorAttributes, ServerProperties serverProperties, ObjectProvider&lt;List&lt;ErrorViewResolver&gt;&gt; errorViewResolversProvider) &#123; return new MyErrorController(errorAttributes, serverProperties.getError(),errorViewResolversProvider.getIfAvailable()); &#125;&#125; 效果：123&#123; "message": "编号不可空",&#125; 3.添加错误枚举类(注意 枚举类中的类方法)1234567891011121314151617181920public enum ErrorEnum &#123; ID_NOT_NULL("F001","编号不可空",false), UNKNOWN("999","未知异常",false); private String code; private String message; private boolean canRetry; ErrorEnum(String code, String message, boolean canRetry) &#123; this.code = code; this.message = message; this.canRetry = canRetry; &#125; public static ErrorEnum getByCode(String code)&#123; for(ErrorEnum errorEnum:ErrorEnum.values())&#123; if(errorEnum.code.equals(code))&#123; return errorEnum; &#125; &#125; return UNKNOWN; &#125; 修改ProductService中的check抛出的不是message而是自己定义的错误code12private void checkProduct(Product product) &#123;Assert.notNull(product.getId(), ErrorEnum.ID_NOT_NULL.getCode());&#125; 修改MyErrorController,添加errorcode和retry12345678910111213141516 @Overrideprotected Map&lt;String, Object&gt; getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(request, includeStackTrace); errorAttributes.remove("timestamp"); errorAttributes.remove("error"); errorAttributes.remove("path"); String message = (String)errorAttributes.get("message"); errorAttributes.remove("message"); // 获取错误种类 ErrorEnum errorEnum = ErrorEnum.getByCode(message); errorAttributes.put("message",errorEnum.getMessage() ); errorAttributes.put("code",errorEnum.getCode() ); errorAttributes.put("canRetry",errorEnum.isCanRetry() ); return errorAttributes;&#125; 输出12345&#123; "message": "编号不可空", "code": "F001", "canRetry": false&#125; 方法3：@ControllerAdvice优先级比方法2高，controller异常后直接这个然后返回response扫描制定的package123456789101112131415161718@ControllerAdvice(basePackages = &#123;"manager.controller"&#125;)public class ErrorControllerAdvice &#123; @ExceptionHandler(Exception.class) @ResponseBody public ResponseEntity handleException(Exception e)&#123; Map&lt;String, Object&gt; errorAttributes = new HashMap&lt;&gt;(); String errorcode = e.getMessage(); ErrorEnum errorEnum = ErrorEnum.getByCode(errorcode); errorAttributes.put("message",errorEnum.getMessage() ); errorAttributes.put("code",errorEnum.getCode() ); errorAttributes.put("canRetry",errorEnum.isCanRetry() ); //这里再抛一个异常就到basicerror里了 Assert.isNull(errorAttributes,"advice" ); errorAttributes.put("type","advice"); return new ResponseEntity(errorAttributes, HttpStatus.INTERNAL_SERVER_ERROR); &#125; 比方法二更优先拦截，在ErrorControllerAdvice里的错误会到BasicErrorController 123456&#123; "message": "编号不可空", "code": "F001", "canRetry": false, "type": advice&#125; 5.自动化测试 不是写细到方法的单元测试 而是直接功能测试http请求1.添加依赖 会自动导入JUnit包123test : [ "org.springframework.boot:spring-boot-starter-test:$&#123;versions.springBootVersion&#125;" ] 新建测试类test-manager.controller-ProductControllerTest测试创建产品 POST请求工具类为方便发送POST请求的工具类 放在util模块，并把util模块添加到manager1compile project(":util") 1.JsonUtil:Object-&gt;Json 用于log输出12345678910111213141516public class JsonUtil &#123; private static final Logger LOG = LoggerFactory.getLogger(JsonUtil.class); private final static ObjectMapper mapper = new ObjectMapper(); public static String toJson(Object obj) &#123; try &#123; return mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; LOG.error("to json exception.", e); throw new JSONException("把对象转换为JSON时出错了", e); &#125; &#125;&#125;final class JSONException extends RuntimeException &#123; public JSONException(final String message) &#123;super(message);&#125; public JSONException(final String message, final Throwable cause) &#123;super(message, cause);&#125;&#125; 2.RestUtil用RestTemplate发送Http请求用的是ClientHttpRequest12345678910111213141516171819public class RestUtil &#123; static Logger log = LoggerFactory.getLogger(RestUtil.class); public static HttpEntity&lt;String&gt; makePostJSONEntiry(Object param) &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON_UTF8); headers.add("Accept", MediaType.APPLICATION_JSON_VALUE); HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;( JsonUtil.toJson(param), headers); log.info("rest-post-json-请求参数:&#123;&#125;", formEntity.toString()); return formEntity; &#125; public static &lt;T&gt; T postJSON(RestTemplate restTemplate, String url, Object param, Class&lt;T&gt; responseType) &#123; HttpEntity&lt;String&gt; formEntity = makePostJSONEntiry(param); T result = restTemplate.postForObject(url, formEntity, responseType); log.info("rest-post-json 响应信息:&#123;&#125;", JsonUtil.toJson(result)); return result; &#125;&#125; 添加产品测试正常数据的测试123456789101112131415161718192021222324252627282930313233343536@RunWith(SpringRunner.class)//随机端口@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class ProductControllerTest &#123; private static RestTemplate rest =new RestTemplate(); @Value("http://localhost:$&#123;local.server.port&#125;/manager") private String baseUrl; //正常的测试用例 private static List&lt;Product&gt; normals = new ArrayList&lt;&gt;(); //异常测试用例 private static List&lt;Product&gt; exceptions = new ArrayList&lt;&gt;(); // 只执行一次 @BeforeClass public static void init()&#123; Product p1 = new Product("T011", "灵活宝1号", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(1), BigDecimal.valueOf(3.42)); Product p2 = new Product("T012", "活期盈-金色人生", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(0), BigDecimal.valueOf(3.28)); Product p3 = new Product("T013", "朝朝盈-聚财", ProductStatus.AUDITING.name(), BigDecimal.valueOf(100), BigDecimal.valueOf(10), BigDecimal.valueOf(3.86)); normals.add(p1); normals.add(p2); normals.add(p3); // 如果有插入时间则插入成功 @Test public void create()&#123; normals.forEach(product -&gt; &#123; Product rst = RestUtil.postJSON(rest, baseUrl + "/products", product, Product.class); Assert.notNull(rst.getCreateAt(),"插入失败" ); &#125;); &#125;&#125; 异常数据的测试 返回500 是RestUtil报错返回5001234567891011121314151617Product e1 = new Product(null, "编号空", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(1), BigDecimal.valueOf(3.42));Product e2 = new Product("E002", "收益&gt;30", ProductStatus.AUDITING.name(), BigDecimal.valueOf(10), BigDecimal.valueOf(0), BigDecimal.valueOf(31));Product e3 = new Product("E003", "投资步长是小数", ProductStatus.AUDITING.name(), BigDecimal.valueOf(100), BigDecimal.valueOf(1.01), BigDecimal.valueOf(3.86));exceptions.add(e1);exceptions.add(e2);exceptions.add(e3);@Testpublic void createError()&#123; exceptions.forEach(product -&gt; &#123; Product rst = RestUtil.postJSON(rest, baseUrl + "/products", product, Product.class); Assert.notNull(rst.getCreateAt(),"插入失败" ); &#125;);&#125; init对错误的测试用例添加异常捕获1234567891011ResponseErrorHandler errorHandler = new ResponseErrorHandler() &#123; @Override public boolean hasError(ClientHttpResponse response) throws IOException &#123; return false; &#125; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; &#125;&#125;;rest.setErrorHandler(errorHandler); 12345678@Test public void createError()&#123; exceptions.forEach(product -&gt; &#123; Map rst = RestUtil.postJSON(rest, baseUrl + "/products", product, HashMap.class); System.out.println(rst); &#125;); &#125; out：{canRetry=false, code=F001, message=编号不可空, type=advice} 查询产品测试]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组划分 前缀和 滑动窗口 子数组、序列问题]]></title>
    <url>%2F2018%2F10%2F28%2Falgsubarrr%2F</url>
    <content type="text"><![CDATA[689!!!高频题 找到三个长度为k互不重叠的子数组的最大和 Input: [1,2,1,2,6,7,5,1], 2不重叠窗口为2的数组的和 [1, 2], [2, 6], [7, 5]返回 起始索引为 [0, 3, 5]。也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。 https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/ 53!!!最大subarray sumInput: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Kadane 14ms 19%12345678public int maxSubArray(int[] nums)&#123; int sum = nums[0],rst = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; sum = Math.max(nums[i],sum+nums[i]); rst = Math.max(rst,sum); &#125; return rst;&#125; greedy: !!337 不可以抢父节点抢过的房子不可以抢父节点抢过的房子 ，注意不是层输入: [2,1,3,null,4]12345 2 / \ 1 3 / \ null 4 输出: 7解释: 小偷一晚能够盗取的最高金额 = 3 + 4 = 7. 思路：每个node保存偷/不偷的最大值。如果这个点不偷，最大值是左偷/不偷最大值+右偷/不偷最大值。如果这个点偷，是这个点+左右不偷的最大值。 1ms 99%12345678910111213141516public int rob(TreeNode root) &#123; int[] res = robSub(root); return Math.max(res[0], res[1]);&#125;private int[] robSub(TreeNode root) &#123; if (root == null) return new int[2]; int[] left = robSub(root.left); int[] right = robSub(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res;&#125; 加上Map&lt;TreeNode,Integer&gt; 12ms 36%123456789101112public int rob(TreeNode root) &#123; if(root == null )return 0; int sum = root.val; if(root.left!= null) sum += rob(root.left.left) + rob(root.left.right); if(root.right!= null) sum += rob(root.right.left) + rob(root.right.right); return Math.max(sum, rob(root.left) + rob(root.right));&#125; ！309 只能卖掉再买，卖掉股票之后的一天不能买Input: [1,2,3,0,2]Output: 3Explanation: transactions = [buy, sell, cooldown, buy, sell] You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) 意思是可以不买不卖。思路：一共有3买，卖，不动种操作，记录每天以这三个状态结尾的最大值。 12345678910111213141516171819public int maxProfit(int[] prices) &#123; if(prices == null ||prices.length &lt;1)return 0; int n = prices.length; int[] buy = new int[n]; int[] rest = new int[n]; int[] sell = new int[n]; buy[0] = - prices[0]; rest[0] = 0; sell[0] = 0; for(int i =1;i&lt;n;i++)&#123; // 不操作 或者 已经休息了1次了再买 buy[i] = Math.max(buy[i-1],rest[i-1] - prices[i]); // 只能前一次是卖 rest[i] = sell[i-1]; // 前一次是买 或者不操作 sell[i] = Math.max(sell[i-1],buy[i-1] + prices[i]); &#125; return sell[n-1];&#125; lt 45 最大子数组差 给出数组[1, 2, -3, 1]，返回 6找出两个不重叠的子数组A和B，使两个子数组和的差的绝对值|SUM(A) - SUM(B)|最大 724 最小划分 数字分成2组 和的差最小 给出nums = [1, 6, 11, 5]，返回1// Subset1 = [1, 5, 6]，和是12// Subset2 = [11]，和是11// abs(11 - 12) = 1 dp：dp[n+1][sum+1] 用1~n前n个数字能得到sum 递归思路：两种情况 用这个数字和不用，终止条件:所有数字都选择过了。超时1234567891011121314151617Map&lt;String,Integer&gt; difmemo;public int findMindfs(int[] arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length ; i++) &#123; sum += arr[i]; &#125; difmemo = new HashMap&lt;&gt;(); return dfs(arr, 0, 0, sum);&#125;private int dfs(int[] arr,int idx,int sum,int target)&#123; if(idx == arr.length) return Math.abs(target - 2* sum); if(difmemo.containsKey(idx+" "+sum))return difmemo.get(idx+" "+sum); difmemo.put(idx+" "+sum, Math.min(dfs(arr, idx+1, sum+arr[idx], target), dfs(arr, idx+1, sum, target))) ; return difmemo.get(idx+" "+sum);&#125; 813 数组A分成K个相邻的非空子数组，子数组平均和和最大多少 输入:A = [9,1,2,3,9]K = 3输出: 20解释:A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.我们也可以把 A 分成[9, 1], [2], [3, 9].这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值. 805 数组分成2个平均值相等的部分!!!698 将数组分成sum相等的k份 不用连续 Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. //todo DPhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/ 1.计算出数组的sum看能不能整除k，同时得到了每组的subsum2.如果数组中有一个元素&gt;subsum则不可能。最大的几个==subsum，自己分成一组。3.对前面都比subsum小的元素回溯将数字放入group数组。变成 Combination tum target12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean canPartitionKSubsets(int[] nums, int k) &#123; // 1. 求每组应该的平均值 int sum = 0; for(int num : nums)&#123; sum += num; &#125; if(sum % k != 0)&#123; return false; &#125; int subsum = sum/k; // 2. 等于平均值的单独分成一组 Arrays.sort(nums); int n = nums.length; int idx = n-1; if(nums[n-1] &gt; subsum)return false; for(int i = n-1;i &gt;= 0;i--)&#123; if(nums[i] &lt; subsum)break; if(nums[i] == subsum)&#123; k--; idx--; &#125; &#125; // 3. 回溯分组 int[] group = new int[k]; return back(group,idx,subsum,nums);&#125;private boolean back(int[] group,int idx,int target,int[] nums)&#123; // 全部都分组好了 if(idx &lt; 0)&#123; return true; &#125; // 试着放到每一组 for(int i = 0;i &lt; group.length;i++)&#123; if(group[i] + nums[idx] &gt; target)&#123; continue; &#125; group[i] += nums[idx]; if(back(group,idx-1,target,nums))&#123; return true; &#125; group[i] -= nums[idx]; // 重要剪枝30%-&gt;100% // 如果这个桶已经装过了，减到0了，用其他数字装这个桶的结果其实已经在别的桶实现过了 // 一个桶肯定有一个数字，减到没有数字其他桶也没可能了，直接退出 if (group[i] == 0) break; &#125; return false;&#125; 最大值为k的不重叠子数组的长度和？??https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/ Input : arr[] = {2, 1, 4, 9, 2, 3, 8, 3, 4} k = 4Output : 5{2, 1, 4} =&gt; Length = 3{3, 4} =&gt; Length = 2So, 3 + 2 = 5 is the answer 123456789101112131415161718public int lensum(int[] arr,int k)&#123; int n = arr.length; int ans = 0; for (int i = 0; i &lt; n ; i++) &#123; int cnt=0; int flag = 0; while (i&lt;n&amp;&amp;arr[i]&lt;=k)&#123; cnt++; if(arr[i] == k)flag = 1; i++; &#125; //？？？ if(flag == 1) ans+=cnt; while (i&lt;n&amp;&amp;arr[i]&gt;k)i++; &#125; return ans;&#125; 198 不能偷相邻房屋 最大利润 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 122 可以买卖多次 买股票的利润 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 123 最多买卖2次的 买股票利润 考到 输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 188 最多k次买卖的 买卖股票利润 输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 重复元素很多的数组排序https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/ AVL or Red-Black to sort in O(n Log m) time where m is number of distinct elements.//todo 77combinations C(n,k)=C(n-1,k-1)+C(n-1,k)C(n-1,k-1)表示选这个数，C(n-1,k)表示不选这个数88%的写法：1234567891011121314public List&lt;List&lt;Integer&gt;&gt; combineFast(int n,int k) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(k&gt;n||k&lt;0)return result; if(k==0)&#123; result.add(new ArrayList&lt;&gt;()); return result; &#125; result = combine(n-1,k-1 ); for(List&lt;Integer&gt; list:result)&#123; list.add(n); &#125; result.addAll(combine(n-1,k )); return result;&#125; 1234567891011121314// math 8% C(n,k)=C(n-1,k-1)+C(n-1,k)public List&lt;List&lt;Integer&gt;&gt; combineMath(int n,int k)&#123; if(k==n||k==0)&#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;=k ; i++) &#123; row.add(i); &#125; return new ArrayList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combineMath(n-1,k-1 ); result.forEach(e-&gt;e.add(n)); result.addAll(this.combineMath(n-1,k )); return result;&#125; 896有正负的数列判断单调用首尾判断up/down，中间相邻遍历判断up/down和之前不符return false20ms12345678910public boolean isMonotonic(int[] A) &#123; if (A.length==1) return true; int n=A.length; //关键 boolean up= (A[n-1]-A[0])&gt;0; for (int i=0; i&lt;n-1; i++) if (A[i+1]!=A[i] &amp;&amp; (A[i+1]-A[i]&gt;0)!=up) return false; return true;&#125; 753 输出能包含所有密码可能性的最短串 Input: n = 2, k = 2Output: “00110” 包含了00,01,10,11 官方解de Bruijn Card Trick 方法1每个点1次写出n个数的组合(11,12,22,21) 并找出哈密尔顿路径 方法2每条边1次写出(n-1)个数的组合(1,2) 的完全图，找出欧拉环路(circuit)。de Bruijn 序列的数量为欧拉环的数量。用k个数字，长度有n的组合有$k^n$种，但是因为可以首尾相连，总共de Bruijn的数量是$\frac{k! k^{n-1}}{k^n}$ 方法3 用不重复的最小字典序Lyndon Word例子：1.列出所有长度为4的组合1111,1112…以及能被4整除的长度(1,2)的组合1,2,11,22.2.所有按字典序排序3.去除所有旋转之后相同的组合，只保留字典序最小的：01和10只保留01 n = 6, k = 20 000001 000011 000101 000111 001 001011 001101 001111 01 010111 011 011111 1 连起来就是最小的de Bruijin sequence !!!152 最大子数组乘积 保留当前值之前的最大积和最小积 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 维护前缀乘积的min/max，每次当前数组元素必须参与运算。注意：更新min/max的时候考虑放弃前缀，只考虑本身，所以变成子数组。注意：子数组所以min/max是前一个index的结果 负数的最小积有潜力变成最大积当前max是 nums[i]*max,nums[i]*min,nums[i] 三者的最大者当前min是 nums[i]*max,nums[i]*min,nums[i] 三者最小值更新全局max4ms 11.99%1234567891011public int maxProduct(int[] nums) &#123; int sum = nums[0],min = nums[0],max = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int nextmax = nums[i]*max; int nextmin = nums[i]*min; max = Math.max(Math.max(nextmax,nextmin),nums[i]); min = Math.min(Math.min(nextmax,nextmin),nums[i]); sum = Math.max(max,sum); &#125; return sum;&#125; 合唱团 背包(只能向前找k个物品)+数组最大子数组(差d的子数组)???乘积 从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大输入37 4 72 50输出49 更新当前结尾最大子数组和 需要试min/max取前d个数之内(可以跳过前d-1个)的全部结果 12345678910111213141516171819202122public static long maxability(int n,long[]arr,int k,int d)&#123; long[][] fmax = new long[k+1][n]; long[][] fmin = new long[k+1][n]; long res = Integer.MIN_VALUE; fmax[1] = arr.clone(); fmin[1] = arr.clone(); //选2-k个人 for (int j = 2; j &lt;=k ; j++) &#123; for (int i = 0; i &lt;n ; i++) &#123; // 遍历上次层结果的[i-d,i) for (int l = i-1; l&gt;=0&amp;&amp;l&gt;=i-d ; l--) &#123; // 前面以l结尾的最大和最小 fmax[j][i] = Math.max(fmax[j][i],Math.max(fmax[j-1][l]*arr[i],fmin[j-1][l]*arr[i]) ); fmin[j][i] = Math.min(fmin[j][i],Math.min(fmax[j-1][l]*arr[i],fmin[j-1][l]*arr[i]) ); &#125; &#125; &#125; for (int i = 0; i &lt;n ; i++) &#123; res = Math.max(res, fmax[k][i]); &#125; return res; &#125; 769 !!!!!最多能排序的块 0-n的排列切割，块排序后连接是排序的原数组 输入: arr = [1,0,2,3,4]输出: 4解释:我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。 注意条件：arr that is a permutation of [0, 1, ..., arr.length - 1]思路1:当前的index==当前的最大值，左边一共有index-1个数字，比index小的都在左边了，可以切分。1234idx:0 1 2 3 4arr:1 0 2 3 4max:0 1 2 3 4当前index&lt;当前max 表示可以划分成一组，==max表示要换下一组 12345678public int maxChunksToSorted(int[] arr) &#123; int res = 0; for(int i =0,max = 0;i&lt;arr.length;i++)&#123; if(i==(max=Math.max(max,arr[i]))) res++; &#125; return res;&#125; 思路2：维护一个leftmax和minright数组，当leftmax&lt;=rightmin则可以划分 915 Max(left)&lt;=Min(right)画折线图，当前A[i]&lt;left 则把切分线抬到globalMax7ms 60%12345678910111213public int partitionDisjoint(int[] A) &#123; int n = A.length; int leftMax = A[0]; int global = leftMax; int parti = 0; for(int i = 1;i&lt;n;i++)&#123; if(leftMax&gt;A[i])&#123; leftMax = global; parti = i; &#125;else global = Math.max(global,A[i]); &#125; return parti+1;&#125; 768 最多能排序的块 重复元素 输入: arr = [2,1,3,4,4]输出: 4解释:我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。arr的长度在[1, 2000]之间。arr[i]的大小在[0, 10**8]之间。 最快的100%： 只构造后缀min数组,线性扫描更新max,保证leftMax&lt;Rmin的划分 12345678910111213141516public int maxChunksToSorted100(int[] arr) &#123; int n = arr.length; int[] minOfRight = new int[n]; minOfRight[n - 1] = arr[n - 1]; for (int i = n - 2; i &gt;= 0; i--) &#123; minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]); &#125; int res = 0; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n - 1; i++) &#123; max = Math.max(max,arr[i]); // 等于 重复元素 去掉=就是第一题 68% if (max &lt;= minOfRight[i + 1]) res++; &#125; return res + 1;&#125; 56%：前缀max数组 后缀min数组left[2,1] right[3,4,4]leftMax&lt;rightMin的时候12345arr [2, 1, 3, 4, 4]比较切分位置0~n-1：[0:i][i+1:n-1]leftMax [2, !2, !3, !4, 4] rightMin[1, 1, !3, !4, !4] 123456789101112131415161718192021public int maxChunksToSorted(int[] arr) &#123; int n = arr.length; int[] maxLeft = new int[n]; int[] minRight = new int[n]; maxLeft[0] = arr[0]; for (int i = 1; i &lt; n; i++) &#123; maxLeft[i] = Math.max(maxLeft[i-1],arr[i]); &#125; minRight[n-1] = arr[n-1]; for (int i = n-2; i &gt;= 0 ; i--) &#123; minRight[i] = Math.min(minRight[i+1],arr[i]); &#125; int res = 0; for (int i = 0; i &lt; n-1; i++) &#123; if(maxLeft[i] &lt;= minRight[i+1])&#123; res++; &#125; &#125; return res+1;&#125; 44%拷贝一个数组排序，做累加,相等则可以划分[2,1 |,3 |,4 |,4][1,2 |,3 |,4 |,4]12345678910public int maxChunksToSorted(int[] arr) &#123; int sum1 =0,sum2 =0,res = 0; int[] copy = arr.clone(); for(int i =0;i&lt;arr.length;i++)&#123; sum1 += copy[i]; sum2 += arr[i]; if(sum1 == sum2)ans++; &#125; return ans;&#125; 581 需要排序的最小子串，整个串都被排序了 递增40大于35，只排序到右边遍历过来第一个n&lt;n-1是不够的要找到[30~31]中的min和max1234567891011public static int fid(int[]A)&#123; //1,3,2,2,2 int n = A.length, beg = -1, end = -2, min = A[n-1], max = A[0]; for (int i=1;i&lt;n;i++) &#123; max = Math.max(max, A[i]);//从前往后，找到最大值max=3 min = Math.min(min, A[n-1-i]);//从后往前找到最小值min=2 if (A[i] &lt; max) end = i; //a=2&lt;3 end = 2-&gt;3-&gt;4 直到找到a[i]&gt;max if (A[n-1-i] &gt; min) beg = n-1-i;//begin =1 直到找到a[i]&lt;min &#125; return end - beg + 1; &#125; 697 ？？保留数组中最高频出现数字频数的最短数组长度 Input: [1,2,2,3,1,4,2]最小连续子数组，使得子数组的度与原数组的度相同。返回子数组的长度Output: 6 最高频是2-&gt;【2,2,3,1,4,2】 用3个hashmap扫一遍记录每个数字出现的cnt,left,right最后cnt最大的right-left+1合并成一个hashmap&lt;Integer,int[3]&gt; ！！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。12345678910111213141516public boolean canPartition(int[] nums)&#123; int sum = 0; for(int n : nums)&#123; sum+=n; &#125; if(sum%2!=0)return false; int[] dp = new int[sum+1]; dp[0] = 1; for(int n : nums)&#123; for(int v = sum;v&gt;=0;v--)&#123; if(dp[v]==1)dp[v+n]=1; &#125; if(dp[sum/2]==1)return true; &#125; return false;&#125; !594 最长max min相差1的子序列(不是连续的数组)数组 hashmap 计数模板]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F10%2F23%2FjavaDesignPattern%2F</url>
    <content type="text"><![CDATA[依赖关系 虚线，指向被使用的 （参数关系、返回值） 关联关系 实线 一般是一个类中有另一个类的对象 继承关系 空心三角，指向父类（父类不知道子类） 组合关系，实心菱形 可以有基数 聚合关系 空心菱形 has a 独立生命周期 整体局部（大雁菱形-箭头大雁） 实现关系 简单工厂模式：不依赖具体的类，根据参数传入工厂返回具体类，并用泛型接收。例子 jdbc根据参数不一样创建不同的驱动 工厂方法：用泛型工厂调用具体的类的工厂至少添加类的时候不用改工厂]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广度优先用于无权图的最短路径]]></title>
    <url>%2F2018%2F10%2F21%2Falgbfs%2F</url>
    <content type="text"><![CDATA[有权图的最短路径要用DijKstra lc310 树的中心12345678910Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 Output: [3, 4] 关键：中心（到所有叶节点路径最小）只可能有1个或者2个 一层一层的褪去叶节点，最后剩下的一个或两个节点就是我们要求的最小高度树的根节点所有只有一个连接边的节点(叶节点)都存入到一个队列queue中，然后我们遍历每一个叶节点，通过图来找到和其相连的节点，并且在其相连节点的集合中将该叶节点删去，如果删完后此节点也也变成一个叶节点了，加入队列中，再下一轮删除。当节点数小于等于2时候停止，此时剩下的一个或两个节点就是我们要求的最小高度树的根节点啦 [0]- leaf[1]- leaf[2]- leaf[3]-&lt;0,1,2,4&gt;[4]-&lt;3,5&gt;[5]- leaf-&gt;[3]-[4]- 279完美平方数距离场距离场的题不适合用dfs，递归全部完成才建立好距离场。 lt 803 建筑物之间的最短距离123456789盖房子，在最短的距离内到达所有的建筑物。给定三个建筑物(0,0),(0,4),(2,2)和障碍物(0,2): 1 - 0 - 2 - 0 - 1 | | | | | 0 - 0 - 0! - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0点(1,2)是建造房屋理想的空地，因为3+3+1=7的总行程距离最小。所以返回7。 思路：1.BFS可以求每个0到这个建筑物的距离。BFS保证每个可达的格子只访问1次肯定是最短距离。2.用一个矩阵累加空地到所有建筑物的距离。并且计数这是累加了几个建筑物的。3.遍历累加距离矩阵中累加了和1相等的数量的格子中最小的那个。 int[n][m][2] 每个位置(2,1)表示从一个建筑物出发，走两步到达这个格子。从另一个建筑物出发，叠加距离变成(4,2)表示第二个建筑物走两步到达这个格子。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;public int shortestDistance(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; int[][][] res = new int[n][m][2]; // 城市的数量 int count = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(grid[i][j] == 1) &#123; count++; bfs(grid, i, j, res); &#125;// System.out.println(); &#125; &#125; int min = Integer.MAX_VALUE; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(res[i][j][1] == count) min = Math.min(min, res[i][j][0]); return min;&#125;void bfs(int[][] grid, int i, int j, int[][][] res) &#123; int n = grid.length; int m = grid[0].length; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]&#123;i, j&#125;); boolean[][] v = new boolean[n][m]; int step = 1; while(!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0)&#123; int[] cur = q.poll(); for(int[] dir : dirs) &#123; int x = cur[0] + dir[0]; int y = cur[1] + dir[1]; // 四个方向继续找空地 if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] != 0 || v[x][y]) continue; q.offer(new int[]&#123;x, y&#125;); res[x][y][0] += step; res[x][y][1] += 1; v[x][y] = true; &#125; &#125;// System.out.println(Arrays.deepToString(res)); step++; &#125;&#125; lt573 邮局建立同上展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public int shortestDistance(int[][] grid) &#123; int n = grid.length; int m = grid[0].length; int cnt = 0; int[][][] res = new int[n][m][2]; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0;j&lt;m;j++)&#123; if(grid[i][j] == 1)&#123; cnt ++; bfs(grid,i,j,res); &#125; &#125; &#125; int min = Integer.MAX_VALUE; for(int i =0;i&lt;n;i++)&#123; for(int j = 0;j&lt;m;j++)&#123; if(res[i][j][1] == cnt) min = Math.min(min,res[i][j][0]); &#125; &#125; return min == Integer.MAX_VALUE? -1:min;&#125;int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;;private void bfs(int[][] grid,int cx,int cy,int[][][] res)&#123; int n = grid.length; int m = grid[0].length; boolean[][] visited = new boolean[n][m]; visited[cx][cy] = true; Queue&lt;int[]&gt; que = new ArrayDeque&lt;&gt;(); que.add(new int[]&#123;cx,cy&#125;); int step = 0; while(!que.isEmpty())&#123; int size = que.size(); while(size-- &gt;0)&#123; int[] cur = que.poll(); int x = cur[0]; int y = cur[1]; for(int i =0;i&lt;dirs.length;i++)&#123; int nx = x + dirs[i][0]; int ny = y + dirs[i][1]; if(nx &gt;=0 &amp;&amp; ny &gt;=0 &amp;&amp; ny&lt;m &amp;&amp; nx &lt;n &amp;&amp; grid[nx][ny] == 0 &amp;&amp; !visited[nx][ny])&#123; res[nx][ny][0] += (step+1); res[nx][ny][1] += 1; que.add(new int[]&#123;nx,ny&#125;); visited[nx][ny] = true; &#125; &#125; &#125; step ++; &#125;&#125; 542 01矩阵 变成离0距离的矩阵12345670 0 00 1 01 1 10 0 00 1 01 2 1 还可以dp todo 还可以dfs todo 1.把0都放入队列，非零格子最大化2.如果bfs到这个格子的距离比格子的值小就更新。1234567891011121314151617181920212223242526272829303132int[][] ori = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;public int[][] updateMatrix(int[][] matrix) &#123; int n = matrix.length; int m = matrix[0].length; Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == 0) &#123; que.add(new int[]&#123;i, j&#125;); &#125;else&#123; matrix[i][j] = Integer.MAX_VALUE; &#125; &#125; &#125; while (!que.isEmpty()) &#123; int[] top = que.poll(); int curx = top[0]; int cury = top[1]; for (int i = 0; i &lt; ori.length; i++) &#123; int newx = curx + ori[i][0]; int newy = cury + ori[i][1]; if (newx &lt; 0 || newx &gt;= n || newy &lt; 0 || newy &gt;= m || matrix[newx][newy] &lt;= matrix[curx][cury] +1) continue; matrix[newx][newy] = matrix[curx][cury] + 1; que.add(new int[]&#123;newx, newy&#125;); &#125; &#125; return matrix;&#125; lt 663 墙和门您将获得一个使用这三个可能值初始化的 m×n 2D 网格。-1 - 墙壁或障碍物。0 - 门。INF - Infinity是一个空房间。我们使用值 2 ^ 31 - 1 = 2147483647 来表示INF，您可以假设到门的距离小于 2147483647 在代表每个空房间的网格中填入到距离最近门的距离。如果不可能到达门口，则应填入 INF。 给定 2D 网格：1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF 返回结果：12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 dfs 1415 ms12345678910111213141516171819202122int[][] dirs = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;public void wallsAndGates(int[][] rooms) &#123; int n = rooms.length; int m = rooms[0].length; for(int i = 0;i&lt;n;i++)&#123; for(int j = 0;j&lt;m;j++)&#123; if(rooms[i][j] == 0) dfs(rooms,i,j,0,m,n);&#125;&#125;&#125;private void dfs(int[][] rooms,int x,int y,int d,int m,int n)&#123; if(rooms[x][y] &gt; d || d == 0)&#123; rooms[x][y] = d; for(int i = 0;i&lt; dirs.length ;i++)&#123; int newx = x + dirs[i][0]; int newy = y + dirs[i][1]; if(newx&gt;=n || newy&gt;=m ||newx&lt;0||newy&lt;0 ||rooms[newx][newy] ==-1)continue; dfs(rooms,newx,newy,d+1,m,n); &#125;&#125; return;&#125; BFS方法同上展开代码 123456789101112131415161718192021222324252627int[][] dirs = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;public void wallsAndGates(int[][] rooms) &#123; int n = rooms.length; int m = rooms[0].length; Queue&lt;int[]&gt; que = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (rooms[i][j] == 0) &#123; que.add(new int[]&#123;i, j&#125;); &#125;&#125;&#125; while (!que.isEmpty()) &#123; int[] cur = que.poll(); int curx = cur[0]; int cury = cur[1]; for (int i = 0; i &lt; dirs.length; i++) &#123; int newx = curx + dirs[i][0]; int newy = cury + dirs[i][1]; if (newx &lt; 0 || newx &gt;= n || newy &lt; 0 || newy &gt;= m || rooms[newx][newy] == -1 || rooms[newx][newy] &lt; rooms[curx][cury] + 1) &#123; continue; &#125; rooms[newx][newy] = rooms[curx][cury] + 1; que.add(new int[]&#123;newx,newy&#125;); &#125;&#125;&#125; !!126 word Ladder 返回所有可能的路径 记录宽搜搜索路径！77% 117ms1.先bfs，在bfs的过程中，构建有向图邻接表map。完成一个最长路径为k的图。2.在构建完的图中dfs，回溯找完到end的路径tmp添加到rst中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; HashSet&lt;String&gt; words = new HashSet&lt;&gt;(wordList); words.add(beginWord); List&lt;List&lt;String&gt;&gt; rst = new ArrayList&lt;&gt;(); HashMap&lt;String,List&lt;String&gt;&gt; graph = new HashMap&lt;&gt;(); // pair &lt;node,step&gt; HashMap&lt;String,Integer&gt; pairs = new HashMap&lt;&gt;(); ArrayList&lt;String&gt; tmp = new ArrayList&lt;&gt;(); bfs(beginWord,endWord,words,graph,pairs); dfs(beginWord,endWord,words,graph,pairs,tmp,rst); return rst; &#125; // 从set 中筛选出 步长差1的String private List&lt;String&gt; getNeib(String top,Set&lt;String&gt; words)&#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); char[] chs = top.toCharArray(); // 这两个循环如果反一下 慢30ms （数量小的循环要写外面？） for(char ch = 'a'; ch &lt;= 'z' ; ch++ )&#123; for (int i = 0; i &lt;chs.length ; i++) &#123; if(chs[i] == ch)continue; char old = chs[i]; chs[i] = ch; if(words.contains(String.valueOf(chs)))&#123; rst.add(String.valueOf(chs)); &#125; chs[i] = old; &#125; &#125; return rst; &#125; // bfs可以找到所有 k步可达的顶点，并建立起链接， k是到达end的最少步数 private void bfs(String start,String end,Set&lt;String&gt; words,HashMap&lt;String,List&lt;String&gt;&gt; graph,HashMap&lt;String,Integer&gt; pairs)&#123; for(String word : words)&#123; graph.put(word, new ArrayList&lt;&gt;()); &#125; // 队列只放node 或者结构体把step也带着 Deque&lt;String&gt; que = new ArrayDeque&lt;&gt;(); que.add(start); pairs.put(start, 0); while (!que.isEmpty())&#123; // 这一层 int count = que.size(); boolean found = false; for (int i = 0; i &lt; count ; i++) &#123; String top = que.poll(); int step = pairs.get(top); List&lt;String&gt; neib = getNeib(top, words); for(String next : neib)&#123; // 构建有向图 graph.get(top).add(next); // 记录访问过了并且当前访问的步长 不用了visit set if(!pairs.containsKey(next))&#123; // 注意找到了也需要先把pair放进去 pairs.put(next, step+1); // 如果找到了 if(end.equals(next))&#123; found = true; &#125;else&#123; que.add(next); &#125; &#125; &#125; if(found)break; &#125; &#125; &#125; private void dfs(String start,String end,Set&lt;String&gt; words,Map&lt;String,List&lt;String&gt;&gt; graph,Map&lt;String,Integer&gt; pairs,List&lt;String&gt; tmp,List&lt;List&lt;String&gt;&gt; res)&#123; tmp.add(start); if(end.equals(start)) &#123; res.add(new ArrayList&lt;&gt;(tmp)); &#125;else &#123; // 从start dfs找这个最长只有k步的图， dfs的条件是1 是邻边表示差1步，2是pair中记录这个邻边是下一个step for(String next : graph.get(start))&#123; if(pairs.get(next) == pairs.get(start) + 1)&#123; dfs(next,end,words,graph,pairs,tmp,res); &#125; &#125; &#125; //如果这条路走不通或者走完了，一段一段删回来 tmp.remove(tmp.size()-1); &#125; 队列中的结构&lt;顶点，前驱，步数&gt; !!127 word Ladder bfs最短单词转换路径todo 为什么复杂度差那么多 //todo双向bfs 注意marked和dfs的不同，单纯bfs访问wordlist里每个单词1.79% 1097ms//list.size()*cur.length()展开代码 12345678910111213141516171819202122232425262728293031323334private boolean dif(String difword,String cur)&#123; int cnt=0; for(int i =0;i&lt;difword.length();i++)&#123; if(difword.charAt(i)!=cur.charAt(i))&#123; cnt++; if(cnt&gt;1)return false; &#125; &#125; return true;&#125;public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int cnt = 0; HashSet&lt;String&gt; words = new HashSet&lt;&gt;(); for(String word:wordList)&#123; words.add(word); &#125; Set&lt;String&gt; marked = new HashSet&lt;&gt;(); Deque&lt;String&gt; que = new ArrayDeque&lt;&gt;(); que.add(beginWord); marked.add(beginWord); while(!que.isEmpty())&#123; cnt++; int size = que.size(); while(size&gt;0)&#123; size--; String cur = que.poll(); for(String difword:words)&#123; if(dif(difword,cur))&#123; if(difword.equals(endWord))return cnt+1; if(!marked.contains(difword))&#123; que.add(difword); marked.add(difword);&#125;&#125;&#125;&#125;&#125; return 0;&#125; 构建图，用map 邻接表，两层for遍历wordList(包括start) ,如果两个字符串只差一个字符，则加到双方邻接表(map)中。将start放进队列&lt;顶点,步数&gt;，宽搜,搜到返回步数。需要markedSet，因为一个点的父节点有多个，将一个点的邻接点放进队列，有的点早被别的父节点就放进队列过了。 AC 17.88% 570ms展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Pair&#123; String word; int step; public Pair(String word, int step) &#123; this.word = word; this.step = step; &#125;&#125; private boolean dif(String difword,String cur)&#123; int cnt=0; for(int i =0;i&lt;difword.length();i++)&#123; if(difword.charAt(i)!=cur.charAt(i))&#123; cnt++; if(cnt&gt;1)return false; &#125; &#125; return true;&#125;public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); List&lt;String&gt; words = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(wordList)); words.add(beginWord); if(!words.contains(endWord))&#123; return 0; &#125; // graph build for(int i = 0;i&lt;words.size();i++)&#123; String word1 = words.get(i); List&lt;String&gt; word1List = map.getOrDefault(word1, new ArrayList&lt;&gt;()); for (int j = i+1; j &lt;words.size() ; j++) &#123; String word2 = words.get(j); if(dif(word1,word2 ))&#123; List&lt;String&gt; word2List = map.getOrDefault(word2, new ArrayList&lt;&gt;()); word2List.add(word1); map.put(word2,word2List); word1List.add(word2); &#125; map.put(word1,word1List ); &#125; &#125; // bfs Deque&lt;Pair&gt; que = new ArrayDeque&lt;&gt;(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); que.add(new Pair(beginWord,1)); visited.add(beginWord); while (!que.isEmpty())&#123; Pair top = que.poll(); int step = top.step; List&lt;String&gt; neib = map.get(top.word); for(String next : neib)&#123; if(!visited.contains(next))&#123; if(next.equals(endWord))&#123; return step + 1; &#125; que.add(new Pair(next,step+1)); visited.add(next); &#125; &#125; &#125; return 0;&#125; 先改变单词cur.length()*25再查表47% 97ms展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int cnt = 0; HashSet&lt;String&gt; words = new HashSet&lt;&gt;(); for(String word:wordList)&#123; words.add(word); &#125; Set&lt;String&gt; marked = new HashSet&lt;&gt;(); Deque&lt;String&gt; que = new ArrayDeque&lt;&gt;(); que.add(beginWord); marked.add(beginWord); while(!que.isEmpty())&#123; cnt++; int size = que.size(); while(size&gt;0)&#123; size--; String cur = que.poll(); //System.out.println(cur); char[] curr = cur.toCharArray(); for(int i =0;i&lt;curr.length;i++)&#123; char ori = curr[i]; for(char c='a';c&lt;='z';c++)&#123; if(curr[i]!=c)&#123; curr[i]=c; String next = new String(curr); if(words.contains(next))&#123; if(next.equals(endWord))return cnt+1; if(!marked.contains(next))&#123; que.add(next); marked.add(next); &#125; &#125; &#125; &#125; curr[i] = ori; &#125; &#125; &#125; return 0; &#125; 倒水问题 BFS ax + by = m 最大公约数 的倍数都行有无限的水源,一个5L无刻度桶和一个7L无刻度桶,则只利用这两个无刻度桶,将不能获得()L水正确答案: F 你的答案: E (错误)A2B3C6D8E11F以上均能获得 365 容量x,y的两个杯子能否量出z Input: x = 3, y = 5, z = 4Output: TrueInput: x = 2, y = 6, z = 5Output: False bfs 4种情况123456789101112131415161718192021222324252627public boolean canMeasureWater(int x, int y, int z) &#123; if(z == 0)return true; if(x + y &lt; z)return false; int total = x+y; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty())&#123; int n = q.poll(); if(n + x &lt;= total &amp;&amp; set.add(n + x))&#123; q.offer(n + x); &#125; if(n + y &lt;= total &amp;&amp; set.add(n + y))&#123; q.offer(n + y); &#125; if(n - x &gt;=0 &amp;&amp; set.add(n -x))&#123; q.offer(n-x); &#125; if(n -y &gt;=0 &amp;&amp;set.add(n - y))&#123; q.offer(n - y); &#125; if(set.contains(z))&#123; return true; &#125; &#125; return false;&#125; -2*3 + 2*5 = 4倒掉3的容器2次倒满5的容器2次1.装满5，倒给3 -&gt; (0,2)2.装满5，倒给3 -&gt; (4,3) 只要z是x,y的最大公约数的倍数就True 裴蜀定理:ax + by = m有整数解，当且仅当 m是d = gcd(a,b)的倍数 d 是最小的 可以写成ax+by形式的正整数。ax+by = 1有整数解 当且仅当 a,b互质 123456789101112131415public boolean canMeasureWater(int x, int y, int z) &#123; if(z == 0)return true; if(x == 0 &amp;&amp; y != z)return false; if(y == 0 &amp;&amp; x != z)return false; if(x + y &lt; z)return false; if(z % gcd(x,y) == 0)&#123; return true; &#125;else&#123; return false; &#125;&#125;public static long gcd(long a, long b) &#123; return (b == 0) ? a : gcd(b, a % b);&#125; hdu 1495 容量S 用N和M的平分 S:可乐体积 N杯子1 M杯子2 N+M=S 三个容器可以互相倒 能不能2人平分7 4 34 1 3out： 最少次数NO3 ax+by = (a+b)/2第一个瓶子倒入x次第二个倒出y次倒进倒出都是大瓶子，倒进1次之后继续用还要把小瓶子倒回大瓶子，倒出同理。但是最后 一定是放在两个小瓶子里不用倒回大瓶子 所以操作数=(a+b)/gcd(a,b)-1 poj 3414 Pots 容量A,B的容器 量出C升水http://poj.org/problem?id=3414 输入：3 5 4输出容量A3 B5 获得4升水的最短序列6FILL(2)POUR(2,1)DROP(1)POUR(2,1)FILL(2)POUR(2,1) Accepted 3128K 1125MS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class pathNode&#123; int a,b; int t; public pathNode(int a, int b, int t) &#123; this.a = a; this.b = b; this.t = t; &#125;&#125;class Cell&#123; int a,b; public Cell(int a, int b) &#123; this.a = a; this.b = b; &#125;&#125;void Bfs(int A,int B,int C)&#123; int cnt = 0; int[][] marked = new int[A+1][B+1]; pathNode[] pathNodes = new pathNode[A+B+5]; int[][] pre = new int[A+1][B+1]; Deque&lt;Cell&gt; que = new ArrayDeque&lt;Cell&gt;(); //初始状态 2个空桶 que.add(new Cell(0,0)); marked[0][0] = 1; while (!que.isEmpty())&#123; Cell cell = que.poll(); int a = cell.a,b = cell.b; //6种操作 满，空，互相倒 x2 for (int d = 0; d &lt;6 ; d++) &#123; int na=0,nb=0; //装满A if(d==0)&#123;na=A;nb=b;&#125; else if(d==1)&#123;na= a;nb=B;&#125; else if(d==2)&#123;na=0;nb=b;&#125; else if(d==3)&#123;na=a; nb=0;&#125; //A-&gt;B else if(d==4)&#123; int all = a+b; na = all&gt;=B?all-B:0; nb = all&gt;=B?B:all; &#125; //B-&gt;A else if(d==5)&#123; int all = a+b; na = all&gt;=A?A:all; nb = all&gt;=A?all-A:0; &#125; //这个桶状态没试过 if(marked[na][nb]==0)&#123; marked[na][nb] =1; //关键：记录当前操作序号cnt是在node(a,b)是做d操作得来的 pathNodes[cnt] = new pathNode(a,b,d); //可以查到对上一个的操作 pre[na][nb] = cnt; cnt++; if(na == C||nb==C)&#123; Deque&lt;Integer&gt; op = new ArrayDeque&lt;Integer&gt;(); int enda = na,endb = nb; while (enda!=0||endb!=0)&#123; int p = pre[enda][endb]; op.push(pathNodes[p].t); enda = pathNodes[p].a; endb = pathNodes[p].b; &#125; System.out.println(op.size()); while (!op.isEmpty())&#123; int x = op.poll(); if(x==0||x==1) System.out.printf("FILL(%d)\n",x+1); else if(x==2||x==3)System.out.printf("DROP(%d)\n",x-1); else if(x==4) System.out.printf("POUR(1,2)\n"); else if(x==5)System.out.printf("POUR(2,1)\n"); &#125; return; &#125; que.add(new Cell(na,nb)); &#125; &#125;// System.out.println("下一层"); &#125; System.out.println("impossible");&#125; poj 1606]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵基本操作和相关题]]></title>
    <url>%2F2018%2F10%2F21%2FalgMatrix%2F</url>
    <content type="text"><![CDATA[Spiral Matrix II 生成旋转矩阵贪吃蛇法 ac12345678910111213141516171819202122232425262728public int[][] generateMatrix(int n) &#123; int[][] rst = new int[n][n]; int[] loc = &#123;0,0&#125;; int num = 1; rst[loc[0]][loc[1]] = num++; while(true)&#123; int lx = loc[0]; int ly = loc[1]; while(loc[1]+1 &lt; n &amp;&amp; rst[loc[0]][loc[1]+1] == 0)&#123; loc[1]+=1; rst[loc[0]][loc[1]] = num++; &#125; while(loc[0]+1 &lt; n &amp;&amp; rst[loc[0]+1][loc[1]] == 0)&#123; loc[0]+=1; rst[loc[0]][loc[1]] = num++; &#125; while(loc[1]-1 &gt;= 0 &amp;&amp; rst[loc[0]][loc[1]-1] == 0)&#123; loc[1]-=1; rst[loc[0]][loc[1]] = num++; &#125; while(loc[0]-1 &gt;= 0 &amp;&amp; rst[loc[0]-1][loc[1]] == 0)&#123; loc[0]-=1; rst[loc[0]][loc[1]] = num++; &#125; if(lx == loc[0] &amp;&amp;ly==loc[1])break; &#125; return rst;&#125; 48 Rotate Image展开代码 逆时针：第一步交换主对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。 如果是顺时针， 第一步交换对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。12345678910111213141516171819public void rotate(int[][] matrix) &#123; int n = matrix.length; for(int i = 0;i&lt;n;i++)&#123; for(int j = i+1;j&lt;n;j++)&#123; if(i!=j)&#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125; &#125; for(int i =0;i&lt;n;i++)&#123; for(int j = 0;j&lt;n/2;j++)&#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][n-1-j]; matrix[i][n-1-j] = tmp; &#125; &#125;&#125; 快速幂给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。12345678910111213141516171819202122public double Power(double base, int ex) &#123; double rst = 1; while(ex &gt;0)&#123; if((ex&amp;1) != 0)&#123; rst = rst*base; &#125; base = base*base; ex&gt;&gt;=1; &#125; // 2，-3 if(ex &lt;0)&#123; ex = -ex; &#125; while(ex &gt;0)&#123; if((ex&amp;1) != 0)&#123; rst = rst/base; &#125; base = base*base; ex&gt;&gt;=1; &#125; return rst;&#125; 矩阵链乘法O(n^3)的dp最大子矩阵和https://www.youtube.com/watch?v=yCQN096CwWMtime O(col x col x row) 54旋转矩阵 顺时针打印矩阵1 贪吃蛇法8% 3ms，从这一行到边界，然后掉头，外层访问过的都mark掉12345678910111213141516171819202122232425262728public List&lt;Integer&gt; spiralOrder(int[][] mat) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); int n = mat.length; if(n == 0)return rst; int m = mat[0].length; // int[] rst = new int[n*m]; boolean[][] seen = new boolean[n][m]; int[][] dirs = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; int r = 0,c = 0,di = 0; for (int i = 0; i &lt;n*m ; i++) &#123; rst.add(mat[r][c]); seen[r][c] = true; // rst[i] = mat[r][c]; int cr = r+dirs[di][0]; int cc = c+dirs[di][1]; if(0 &lt;= cr &amp;&amp; cr &lt; n&amp;&amp;0 &lt;= cc&amp;&amp;cc &lt; m &amp;&amp; !seen[cr][cc])&#123; r = cr; c = cc; &#125;else &#123; di = (di+1)%4; r += dirs[di][0]; c += dirs[di][1]; &#125; &#125; return rst;&#125; top=0,bot=3,left=0,right = 3n是矩阵大小n&gt;1的时候继续，每一圈，矩阵大小-=2将2赋值给8：[top+i][right]=[top][left+i]i=3:3赋值给12每个i要赋值4遍，上下左右外层完了之后子问题是top++,left++,right–,bot–,n-=2 方法2：翻转？ 59 生成nxn的旋转矩阵顺时针旋转矩阵矩阵乘法相关题目：http://www.matrix67.com/blog/archives/276 poj3734790 L型，XX型骨牌覆盖2xN的board Input: 3Output: 5Explanation:The five different ways are listed below, different letters indicates different tiles:XYZ XXZ XYY XXY XYYXYZ YYZ XZZ XYY XXY 1.如果只XX骨牌dp[i] 表示N = i的时候有多少种解其实是费fib数列 poj 2411http://poj.org/problem?id=2411输入：大矩阵的h高，和w宽输出:用宽2，高1的骨牌一共有多少种拼法 图中长度为k的路径计数https://www.nowcoder.com/acm/contest/185/B 求出从 1 号点 到 n 号点长度为k的路径的数目. 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;import java.util.Scanner;public class Main &#123; //AC// final static int M = 10000; public static long[][] mul(long[][] A,long[][] B)&#123; long[][] rst = new long[A.length][B[0].length]; for (int i = 0; i &lt;A.length ; i++) &#123; for (int k = 0; k &lt;B.length ; k++) &#123; for (int j = 0; j &lt;B[0].length ; j++) &#123; rst[i][j] = (rst[i][j]+A[i][k]*B[k][j]); &#125; &#125; &#125; return rst; &#125; public static long[][] pow(long[][] A,int n)&#123; long[][] rst =new long[A.length][A.length]; for (int i = 0; i &lt;A.length ; i++) &#123; rst[i][i] = 1; &#125; while (n&gt;0)&#123; if((n&amp;1)!=0)&#123; rst = mul(rst,A ); &#125; A = mul(A, A); n&gt;&gt;=1; &#125; return rst; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = sc.nextInt(); long[][] graph = new long[n][n]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;n ; j++) &#123; graph[i][j] = sc.nextInt(); &#125; &#125; long[][] Gn = pow(graph, k); System.out.println(Gn[0][n-1]); &#125;&#125; 有向图 从A点走K步到达B(边可重复)的方案数G[u][v]表示u到v 长度为k的路径数量k=1 1条边可达的点 G1是图的邻接矩阵 快速幂logN完成幂运算carmichael number12//this^exponent mod mpublic BigInteger modPow(BigInteger exponent, BigInteger m) 递推公式实际上求m项地推公式的第n项 可以用初项线性表示，通过快速幂O(m^2logn) fibo递推公式特征方程1.二阶递推公式的特征方程递推公式Xn = aXn-1 - bXn-2特征方程x^2-ax+b =0解得x1,x2则存在F(n) = Ax1+Bx2带入F(0),F(1) 可得通项 2.矩阵解法二阶递推式存在2x2矩阵A 矩阵乘法：123456789101112final int M = 10000;public int[][] mul(int[][] A,int[][] B)&#123; int[][] rst = new int[A.length][B[0].length]; for (int i = 0; i &lt;A.length ; i++) &#123; for (int k = 0; k &lt;B.length ; k++) &#123; for (int j = 0; j &lt;B[0].length ; j++) &#123; rst[i][j] = (rst[i][j]+A[i][k]*B[k][j])%M; &#125; &#125; &#125; return rst;&#125; 快速幂，将n用二进制表示，5-&gt;101表示A^5 = A^4+A^1,A每次翻倍，n一直右移，n最右为1的时候加上当前A翻倍的结果。矩阵的幂1234567891011121314public int[][] pow(int[][] A,int n)&#123; int[][] rst =new int[A.length][A.length]; for (int i = 0; i &lt;A.length ; i++) &#123; rst[i][i] = 1; &#125; //for(;n&gt;0;n&gt;&gt;=1) while (n&gt;0)&#123; //快速幂 if((n&amp;1)!=0)rst = mul(rst,A ); A = mul(A, A); n&gt;&gt;=1; &#125; return rst;&#125; 解fibo：123int[][] A = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;int[][] rst = sl.pow(A, n);System.out.println(rst[1][0]); 867 矩阵转置1234567891011public int[][] transpose(int[][] A) &#123; int m = A.length; int n = A[0].length; int [][] rst = new int[n][m]; for(int r =0;r &lt; m; r++)&#123; for(int c =0; c &lt; n;c++)&#123; rst[c][r] = A[r][c]; &#125; &#125; return rst;&#125; 566 矩阵reshape12345678910111213141516public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int[][] rst = new int[r][c]; int m = nums.length; int n = nums[0].length; if(r*c != n*m)&#123; return nums; &#125; for(int i = 0;i &lt; m;i++)&#123; for(int j = 0;j &lt; n;j++)&#123; int row = (i*n+j) / c; int col = (i*n+j) % c; rst[row][col] = nums[i][j]; &#125; &#125; return rst;&#125; concise：12345678public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int n = nums.length, m = nums[0].length; if (r*c != n*m) return nums; int[][] res = new int[r][c]; for (int i=0;i&lt;r*c;i++) res[i/c][i%c] = nums[i/m][i%m]; return res;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学、概率问题]]></title>
    <url>%2F2018%2F10%2F18%2Falgprobability%2F</url>
    <content type="text"><![CDATA[&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 活字印刷输入：”AAB”输出：8解释：可能的序列为 “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”。 方法212345678910111213141516171819202122public int numTilePossibilities(String tiles) &#123; int rst = 0; int[] cnt = new int[26]; for(char c:tiles.toCharArray())&#123; cnt[c-'A']++; &#125; return back(cnt); &#125;private int back(int[] cnt)&#123; int sum = 0; // 长度为1的 a,b // 长度为2的 aa,ab,ba // 长度为3的 aab,aba,baa for(int i =0;i&lt;26;i++)&#123; if(cnt[i]==0)continue; sum++; cnt[i]--; sum+=back(cnt); cnt[i]++; &#125; return sum;&#125; 方法1If we have a string of size n with i unique characters, and each character repeats m[i] times, the number of unique permutations is: n! / (m[1]! m[2]! .. * m[i]!)要计算出所有组合的排列数的累加 =======称硬币的最少次数http://sighsmile.github.io/2017-08-02-weighing-puzzle/相当于把硬币分为三份：天平两侧各一份，其余硬币为一份。如果天平是平衡的，则假币在其余硬币那一份中；如果不平衡，则假币在天平某一侧的一份中，若假币更轻，则假币在更轻的一份中，否则在更重的一份中。因此，容易想到基于三进制的编号来解决这道问题。 refs/remotes/origin/hexo-edit !!172 Factorial Trailing Zeroes 阶乘后面后几个0Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 2一定比5多，算一下这些数一共有多少个5. 12345678public int trailingZeroes(int n) &#123; int rst = 0; while(n != 0)&#123; rst += n/5; n/=5; &#125; return rst;&#125; 343 Integer Break 和固定的数字的最大乘积Input: 10Output: 36Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. 对f(x)=x^(x/n) 求导f(x)’，得到x=e的时候最大最接近的是3，然后取2….? 反正&gt;4的用3.. 12345678910public int integerBreak(int n) &#123; int[] dp = new int[n + 1]; dp[1] = 1; for(int i = 2; i &lt;= n; i ++) &#123; for(int j = 1; j &lt; i; j ++) &#123; dp[i] = Math.max(dp[i], (Math.max(j,dp[j])) * (Math.max(i - j, dp[i - j]))); &#125; &#125; return dp[n];&#125; 43 Multiply Strings 大数相乘Input: num1 = “2”, num2 = “3”Output: “6” 两个关键位置i+j,i+j+1。并且记住右边那个是取模，左边那个是累加。1234567891011121314151617181920public String multiply(String num1, String num2) &#123; int n = num1.length(); int m = num2.length(); StringBuilder sb = new StringBuilder(); int[] rst = new int[m+n]; for(int i = n-1;i&gt;=0;i--)&#123; for(int j = m-1;j&gt;=0;j--)&#123; int mul = (num1.charAt(i)-'0')*(num2.charAt(j)-'0'); int p1 = i+j,p2 = i+j+1; mul += rst[p2]; rst[p2] = mul%10; rst[p1] += mul/10; &#125; &#125; for(int num:rst)&#123; if(sb.length()==0 &amp;&amp; num == 0)continue; sb.append(num); &#125; return sb.length()==0?"0":sb.toString();&#125; 233 Number of Digit One [1,n]中数字带1的个数Input: 13Output: 6Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. 不会https://leetcode.com/problems/number-of-digit-one/discuss/64381/4%2B-lines-O(log-n)-C%2B%2BJavaPython 123456public int countDigitOne(int n) &#123; int ones = 0; for (long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0); return ones;&#125; m个芒果n个人https://www.geeksforgeeks.org/count-ways-to-distribute-m-items-among-n-people/1）m个芒果，n个人，如果物品和人都是相同的用n个人划分芒果，需要n-1个划分。 所有芒果的排列和划分的排列一共是(m+n-1)!种排列。因为芒果是相同的，而且人也是相同的，所以把相同的分法去掉就是(m+n-1)!/((n-1)!*(m)!) 二项式系数(组合数）：C(N,K) = factorial(N)/factorial(K)*factorial(N-K)m芒果n个人就是二项式系数C(N-1+M) = F() 19本书，编号1-19，取5本，任意两本不相邻的取法有：14本书15个空，插空放5本书C(15,5) 9宫格连线密码一共有389112方案数。一根木棍截成三段，组成三角形的概率是多少？棍长a，设边长x,y,a-x-y.得到可行域x+y&lt;a.用3个两边之和&gt;第三边得到3个不等式，得到小三角形。是大三角形的1/4 两个人轮流掷（6面）骰子，先掷出6的人获胜，先手者获胜的概率是多少？决出胜负：1-5/6*5/6先手胜:1/6p(先手|决出胜负) = 1/6 / 11/36 = 6/11 有6个洞 编号9个球，求球入洞的方案数隔板法： 划分6个洞需要5个隔板，用1~9填充隔板的空间。变成5个隔板和9个球的全排列。 5个隔板是相同的，P（14,5,1,1,1,1,1,1,1,1,1,1) = 14!/5! 另一种方法： 1号球可以放6个位置 1号球等于把空间又划分成了1前和1后，2球有5+2种可能 同理 3号球有7-1+2 =8个可能… 6乘到14 = 14!/5! 12本书按 4:4:4平均分给3个人，有多少种分法 C(12,4)C(8,4)C(4,4) 12本书按 3:3:2:2:2分给 ABCDE 5个人A(5,5)C(12,3)C(9,3)C(6,2)C(4,2)C(2,2)/(A(3,3)A(2,2)) 10个小朋友做游戏，分成四组，每组人数分别为2，2，3，3，请问有几种分组方法C(10,2)C(8,2)C(6,3)C(3,3)/A(2,2)*A(2,2) 52张牌分发给4个人，每人13张，问每人有一张A的概率有多少？10.55% 52张牌分发给4个人，每人13张的方法数为52！/(13!)^4 。每人发一张A的方法数为4！* 48！/(12!)^4 . 4个相同的桔子和6个不同的苹果放到5个不同的盒子中，问每个盒子里有2个水果的概率有多大？7.4% 把4个相同桔子放入5个不同盒子的放法数为C(5,4),把6个不同苹果放入5个不同盒子的放法数为5^6 .因此总的分配方法数为C(5,4)*5^6 . 每个盒子有2个水果，有如下三种情况：1234561、（AA)(AA)(AA)(OO)(OO)C(5,2)*6!/2!/2!/2!2、AA)(AA)(OA)(OA)(OO)C(5,1)\*C(4,2)\*6!/2!/2!3.（AA)(OA)(OA)(OA)(OA)C(5,4)*6!/2! 将n个不同的球放入编号为1,2,…,k的k个盒子中，试求： 第一个盒子是空盒的概率: 第一个盒子是空盒的方案数为(k－1) n 。 设k≥n,求n个球落入n个不同盒子的概率: n个球落入n个不同盒子的方案数为C(k,n)n!。 第一盒或第二盒两盒中至少一个是空盒的概率。该方案数为第一个盒子是空盒的方案数加上第二个盒子是空盒的方案数，再减去两个盒子都是空盒的方案数。 随机地将15名插班生分配到三个班级，每班各5名。设15名插班生中有3为女生。试求：将15名插班生分配到三个班级，每班各5名的方案数为C(15,5)C(10,5)C(5,5)=15!/(5!5!5!)。 每一个班级分到一名女生的概率:3!*12!/(4!4!4!) 三名女生分到同一班的概率: 3*12!/(5!5!2!) 歌单：3个红球3个白球，红球2分，白球3分，问总分5分的拿法有多少种？ 有4副相同的牌,每副牌有4张不同的牌.先从这16张牌中,随机选4张出来.然后,在这4张牌中随机选择一张牌,然后把抽出的一张放回3张中,再随机选择一张牌.与上次选出的牌一样的概率是()正确答案: C 你的答案: F (错误)1/41/32/51/22/33/4 某体校选择校服,每套校服都包括短袖运动衫,长袖运动衫,厚外套,运动长裤和运动短裤组成.每种运动服有3个备选方案.老师请了部分学生来挑选自己喜欢的校服.结果发现任意3个学生都至少在一种运动服上选择互不相同,那么老师最多邀请了()名学生参加挑选.正确答案: B 你的答案: E (错误)789101112 任意3个学生都至少在一种运动服上选择互不相同翻译过来就是说对于每种不同的选择，最多有2个人选择。 有100个金币，分给10个人.第一个金币等概率地分给10个人之一.之后的每一个金币分配给第K个人的概率正比于这个人已经持有的金币数+1.在这样的分配机制下，关于每个人最终的金币个数的分布的说法错误的是()正确答案: B 你的答案: B (正确)A每个人得到的金币的个数的期望是相等的B每个人的金币个数接近均匀分布C第一个金币给哪个人,哪个人的最终金币个数的期望就会更大D在中间的某个阶段金币个数越多的人，未来获得金币的可能性越大 21点21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J, Q, K 都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？() (1) 93.7% 或 93.8% 或 93.7 或 93.8 十字交叉法 平均数 总体平均数三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？38a+24b = 30(a+b)24b+42c = 34(b+c)a:b:c = 3:4:5(38x3+24x4+42x5)/12 = 35 https://blog.csdn.net/MrChen11/article/details/47114877 最大似然估计、最大后验估计、贝叶斯估计 最小二乘https://blog.csdn.net/yangliuy/article/details/8296481进行20次投硬币的伯努利实验，出现正面12次，反面8次，请分别用最大似然估计、最大后验估计、贝叶斯估计估计三种方法来估计“正面出现”的概率p. [注：n次伯努利实验服从二项分布 B(n, p)] 最大似然估计MLP：似然函数：$p(X|\theta)$用似然函数取最大值的参数作为估计值。参数是p 每次正面的概率。 12/20。 最大后验估计MAP：后验概率：$p(\theta|X)$贝叶斯公式中的先验概率根据经验0.5用到了beta分布 要设置beta分布的超参数a,b，让先验分布在0.5取最大值。 贝叶斯估计：不是直接求参数，而是求参数的分布 LSE 硬币相关问题p112 3.39 连续仍硬币，A正反胜，B反反胜，A赢的概率?3/4 A赢： 先正后反， B赢 连续两次反面：A胜的概率 3/4 B 赢概率是1/2*1/2 = 1/4 http://www.raychase.net/3144正正反 甲赢 正反反 乙赢 Penney’s game 使用长度为3字节的序列，玩家B相对玩家A有优势。这是因为这个游戏是一个非传递博弈，所以无论如何选定第一个序列，总会有一个序列有更大的获胜概率。 反反正:正反反 = 1：3因为只要出现一次正，想得到反反正的人就必输了，他肯定得先看到两次反，我就得到正反反了。两个硬币4种情况有3种有正 正正反：反正正 = 1：3只要出现一次反，反正正就赢了。 正反反HTT：正正反HHT = 1:2反正正thh:反反正tth = 1：2 https://en.wikipedia.org/wiki/Penney%27s_game对于二号玩家：1-2-3 -&gt; (not-2)-1-2第一个字节与1号玩家的第二个字节相反，第二个字节与1号玩家的第一个字节相同，第三个字节与1号玩家的第二个字节相同。 http://www.matrix67.com/blog/archives/3638 所有 1 都不相邻的 k 位 01 串有 Fk+2 个 Fi 表示 Fibonacci 数列中的第 i 项 抛掷第 k 次才出现连续两个正面”的意思就是， k 位 01 串的末三位是 011，并且前面 k – 3 位中的数字 1 都不相邻。 k-3位的01不相邻的串有F(k-1)个 平均需要抛掷多少次硬币，才会首次出现连续的 n 个正面？ 答案是 2^(n+1) – 2神奇的模式概率与“鞅”//todohttp://www.math-engineering.uestc.edu.cn/模式的平均等待时间：模式 HHHHHH 的平均等待时间 126 扔硬币直到连续两次出现正面，求扔的期望次数 6• 扔到的是反面，那么还期望抛 E 次，因为抛到反面完全没用，总数就期望抛 E+1，所以是0.5*(1 + E)• 扔到的是正面，如果下一次是反面，那么相当于重头来过，总数就期望抛，则是0.25*(2 + E)• 扔到两次，都是正面，总数是 2，则是0.25*2所以递归来看E = 0.5*(1 + E) + 0.25*(2 + E) + 0.25*2，解得E = 6 反复投掷一个均匀的硬币直到正面向上为止，则期望投掷次数为 2当xxx长度为n时，期望为$2^{n+1} - 2$ 快手发了10个月饼，已知月神一天至少吃一个月饼；请问，月神在3天内将10个月饼全部吃完的概率为：10个月饼，分割，9个空。总的可能性是2^9. 第一天是C(9,0),第二天C（9，1）第三天C（9,3) 期望（均值）随机变量平均下来会取怎样的值 如果5局3胜，两人出100赌本，赢的人得200甲已2胜，乙1胜，继续两局的可能是甲甲、甲乙、乙乙、乙甲甲的期望获得的收益是：200 x 3/4 +0 x 1/4 =150乙期望是200 x 1/4 +0 x3/4 = 50 离散型随机变量出现的概率就是取值的权重。所以加权算术平均数(p1 x a1 + p2 x a2) /(p1 + p2) = (p1 x a1 + p2 x a2) 绝对收敛 =&gt; 黎曼定理 =&gt; 交换律可以用随机试验结果次序是任意的，所以按任意次序算期望应该是一样的。所以无穷项 随机变量 的期望 级数是绝对收敛的。 连续型是 xp(x) 从-∞到+∞的广义积分 也是绝对收敛。 01分布 两点分布二项分布 期望nphttps://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83在n重伯努利试验中，事件A恰好发生k次的概率为在伯努利试验序列中，事件A在第 k 次试验中才首次发生的概率为 泊松分布 期望λ12from scipy.stats import poissonrv = poisson(mu=5) https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83当二项分布的n很大而p很小时，泊松分布可作为二项分布的近似，其中λ为np。每天中午12点 等待地铁的人数 均匀分布 期望(a+b)/2指数分布泊松过程中，第k次随机事件与第k+1次随机事件出现的时间间隔服从指数分布。果T是某一元件的寿命，已知元件使用了t小时，它总共使用至少s+t小时的条件概率，与从开始使用时算起它使用至少s小时的概率相等。 正态分布 随机变量的函数的期望Y=g(x)假设x的分布已知Y的期望就是g(x)的期望 矩https://baike.baidu.com/item/%E5%8E%9F%E7%82%B9%E7%9F%A9一阶原点距是期望二阶中心距是方差1234567891011121314from scipy.stats import binomrv = binom(10,0.2) # n = 10 p = .2## 期望 10 x 0.2 print(rv.mean())## 方差 10 x 0.2 x 0.8print(rv.var())## 一阶原点矩 就是期望print(rv.moment(1))## 二阶矩print(rv.moment(2))## 方差= (2阶距- 1阶矩^2 )print(rv.moment(2) - rv.moment(1)**2)## 期望 方差 偏度 峰度print(rv.stats(moments='mvsk')) 方差公式： 参数估计矩估计 中心矩 x和中心ex的差的k次方的期望 样本矩点估计 有分配对象的排列组合问题https://zhuanlan.zhihu.com/p/27017390分组分配问题http://blog.sina.com.cn/s/blog_50a269f00100haxo.html 概率生成函数 概率母函数1.x的系数是a1,a2,…an 的单个组合的全体。2.x^2的系数是a1,a2,…a2的两个组合的全体。………n. x^n的系数是a1,a2,….an的n个组合的全体（只有1个）。 有1克、2克、3克、4克的砝码各一枚，能称出哪几种重量？每种重量各有几种可能方案？ 设x表示砝码，x的指数表示砝码的重量1个1克的砝码可以用函数1+1*x^1表示，1个2克的砝码可以用函数1+1*x^2表示，1个3克的砝码可以用函数1+1*x^3表示，1个4克的砝码可以用函数1+1*x^4表示， 1表示数量0个例如1个2克的砝码：1+x^21其实应该写为：1*x^0,即1代表重量为2的砝码数量为0个。 系数表示状态数（方案数）1+x^2，也就是1x^0 + 1x^2，不取2克砝码，有1种状态；或者取2克砝码，也有1种状态。 123(1+x)(1+x^2)(1+x^3)(1+x^4)=(1+x+x^2+x^4)(1+x^3+^4+x^7)=1 + x + x^2 + 2*x^3 + 2*x^4 + 2*x^5 + 2*x^6 + 2*x^7 + x^8 + x^9 + x^10 从上面的函数知道：可称出从1克到10克，系数便是方案数。有2*x^5 项，即称出5克的方案有2种：5=3+2=4+1； 求用1分、2分、3分的邮票贴出不同数值的方案数：每种是无限的。 分配问题及应用 排列村长带着 4 对父子参加爸爸去哪儿第三季第二站某村庄的拍摄。村里为了保护小孩不被拐走有个前年的规矩，那就是吃饭的时候小孩左右只能是其他小孩或者自己的父母。那么 4 对父子在圆桌上共有___种坐法。 （旋转一下，每个人面对的方向变更后算是一种新的坐法） Little定律系统中物体的平均数量等于物体到达系统的平均速率和物体在系统中停留的平均时间的乘积 如果一个博物馆参观者到达的速率是每分钟 20 人，平均每个人在馆内停留20分钟，那么该博物馆至少需要容纳__人才行？400 鸽策略鹰策略多重排列：pingpang中有重复2个p 2个n 2个g12341. 标记为p1p2n1n2g1g2ia 全排列个数是8!2. p的重复度 为p1p2的全排列 2!3. P(N,r1,r2...rt) 标记为P(8;2,2,2,1,1)4. P(8;2,2,2,1,1)\*2!\*2!\*2! = 8! 理解二项式定理(a+b)^n通项是a^k b^(n-k) 前面的系数表示 n个数的可重排列，a有k个，b有n-k个 不仅是二项式通项是a1^(r1) a2^(r2) at^(rt)(x1+x2+…+xm)^n 展开式的项数等于C(n+m-1,n).]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java秒杀]]></title>
    <url>%2F2018%2F10%2F16%2Fmiaosha%2F</url>
    <content type="text"><![CDATA[nginx 负载均衡策略：轮询、权重、ip hash、 url hash (第三方)、fair (第三方)用权重把有定时任务的服务器配置权重低一些 Shedule定时关单写库存1查找订单、加库存、关订单订单表要有创建时间、订单状态1)数据库查找创建时间在当前时间前1小时的所有订单2)对每个订单的商品查找其库存，并且加锁。3)新创建一个product，只赋值商品id和库存，更新数据库4)update数据库中订单状态为012345678910111213141516171819202122232425@Overridepublic void closeOrder(int hour) &#123; Date closeDateTime = DateUtils.addHours(new Date(),-hour); List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(),DateTimeUtil.dateToStr(closeDateTime)); for(Order order : orderList)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo()); for(OrderItem orderItem : orderItemList)&#123; //一定要用主键where条件，防止锁表。同时必须是支持MySQL的InnoDB。 Integer stock = productMapper.selectStockByProductId(orderItem.getProductId()); //考虑到已生成的订单里的商品，被删除的情况 if(stock == null)&#123; continue; &#125; Product product = new Product(); product.setId(orderItem.getProductId()); product.setStock(stock+orderItem.getQuantity()); productMapper.updateByPrimaryKeySelective(product); &#125; orderMapper.closeOrderByOrderId(order.getId()); log.info("关闭订单OrderNo：&#123;&#125;",order.getOrderNo()); &#125;&#125; 定时任务 还可以使用quartz定时任务框架12345678910111213@Component@Slf4jpublic class CloseOrderTask &#123; @Autowired private IOrderService iOrderService; @Scheduled(cron="0 */1 * * * ?")//每1分钟(每个1分钟的整数倍) public void closeOrderTaskV1()&#123; log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour","2")); iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); &#125;&#125; 在Main上添加@EnableScheduling 解決多实例部署问题其他优化点http://massivetechinterview.blogspot.com/2016/01/blog-post_48.html数据库的分片，主从复制（可能会id冲突，要应用自己生成id）其他缓存框架hazelcast 1.前后台json格式实现效果，在Controller调用静态方法： 成功：Result.success(data); 成功时只返回数据 异常：Result.error(CodeMsg); 包括code和msg123456789101112131415161718192021222324252627282930313233class Result&lt;T&gt; &#123; private int code; private String msg; private T data; /** * 成功时候的调用 * */ public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123; return new Result&lt;T&gt;(data); &#125; /** * 失败时候的调用 * */ public static &lt;T&gt; Result&lt;T&gt; error(CodeMsg cm)&#123; return new Result&lt;T&gt;(cm); &#125; // 构造函数private 不被外部调用，外部只能使用2个静态方法 // 失败构造 private Result(CodeMsg cm) &#123; if(cm == null) &#123; return; &#125; this.code = cm.getCode(); this.msg = cm.getMsg(); &#125; //成功构造 private Result(T data) &#123; this.code = 0; this.msg = "success"; this.data = data; &#125;&#125; controller中测试：12345678910111213141516@Controller//@RequestMapping("/demo")public class DemoController &#123; @RequestMapping("/hello") @ResponseBody public Result&lt;String&gt; hello() &#123; return Result.success("hello"); // return new Result(0, "success", "hello"); &#125; @RequestMapping("/helloError") @ResponseBody public Result&lt;String&gt; helloError() &#123; return Result.error(CodeMsg.SERVER_ERROR); //return new Result(500102, "XXX"); &#125;&#125; 封装错误信息类，用于生成各种各样的错误信息（枚举类？）//后面很难改 不要用枚举//外部只能调用静态变量123456789101112131415161718192021public class CodeMsg &#123; private int code; private String msg; //通用异常 public static CodeMsg SUCCESS = new CodeMsg(0, "success"); public static CodeMsg SERVER_ERROR = new CodeMsg(500100, "服务端异常"); //登录模块 5002XX //商品模块 5003XX //订单模块 5004XX //秒杀模块 5005XX //私有 private CodeMsg(int code, String msg) &#123; this.code = code; this.msg = msg; &#125;&#125; 展开代码 12345678910111213141516public enum CodeMsg &#123; SUCCESS(0,"success"), SERVER_ERROR(500100,"服务端异常"); private final int code; private final String msg; private CodeMsg( int code,String msg ) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125;&#125; 测试：访问http://localhost:8080/hello{&quot;code&quot;:0,&quot;msg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;hello,imooc&quot;}访问：http://localhost:8080/helloError{&quot;code&quot;:500100,&quot;msg&quot;:&quot;服务端异常&quot;,&quot;data&quot;:null} 2.添加页面模板 配置文件配置项https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties/resources/aplication.properties1234567spring.thymeleaf.cache=falsespring.thymeleaf.content-type=text/htmlspring.thymeleaf.enabled=truespring.thymeleaf.encoding=UTF-8spring.thymeleaf.mode=HTML5spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.html controller返回页面1234567@RequestMapping("/hel")public String thymeleaf(Model model) &#123; //写入model的属性可以在页面中取到 model.addAttribute("name", "名字"); //找的是prefix+hello+sufix -&gt;/templates/hello.html return "hello";&#125; /resources/templates/hello.html12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text="'hello:'+$&#123;name&#125;" &gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3. Mybatishttp://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 1234567mybatis.type-aliases-package=package.model#下划线转驼峰mybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=3000# 配置文件扫描 接口类和xmlmybatis.mapperLocations = classpath:package/dao/*.xml 数据源druid1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819# druidspring.datasource.url=jdbc:mysql://10.1.18.133:3306/maiosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.filters=statspring.datasource.maxActive=2spring.datasource.initialSize=1spring.datasource.maxWait=60000spring.datasource.minIdle=1spring.datasource.timeBetweenEvictionRunsMillis=60000spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=select &apos;x&apos;spring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=falsespring.datasource.poolPreparedStatements=truespring.datasource.maxOpenPreparedStatements=20 新建数据库并添加user表ID:int(11) name:varchar(255)添加数据 1 小明新建/domain/User对象12345public class User &#123; private int id; private String name; //get/set&#125; 新建/dao/UserDao层interface UserDao12345@Mapperpublic interface UserDao &#123; @Select("select * from user where id = #&#123;id&#125;") public User getById(@Param("id")int id );&#125; 写service12345678@Servicepublic class UserService &#123; @Autowired UserDao userDao; public User getById(int id) &#123; return userDao.getById(id);&#125; 添加到controller123456789101112@Controller@RequestMapping("/demo")public class SampleController &#123; @Autowired UserService userService; @RequestMapping("/db/get") @ResponseBody public Result&lt;User&gt; dbGet() &#123; User user = userService.getById(1); return Result.success(user); &#125;&#125; 访问： http://localhost:8080/demo/db/get返回： {“code”:0,”msg”:”success”,”data”:{“id”:1,”name”:”小明”}} 测试事务：数据库中已经有id=1的数据，连插入id=2，id=1的数据，如果能回滚就行dao:12345678910@Mapperpublic interface UserDao &#123; @Select("select * from user where id = #&#123;id&#125;") public User getById(@Param("id") int id); //添加Insert方法 @Insert("insert into user(id, name)values(#&#123;id&#125;, #&#123;name&#125;)") public int insert(User user); &#125; service:123456789101112131415//注解注释掉 报错但插入了id=2@Transactionalpublic boolean tx() &#123; //整体在一块（一个事务） User u1= new User(); u1.setId(2); u1.setName("2222"); userDao.insert(u1); // 这条失败上面也不会插入 User u2= new User(); u2.setId(1); u2.setName("11111"); userDao.insert(u2); return true;&#125; controller:123456@RequestMapping("/db/tx")@ResponseBodypublic Result&lt;Boolean&gt; dbTx() &#123; userService.tx(); return Result.success(true);&#125; 测试：访问：http://localhost:8080/demo/db/tx数据完整性错误，但是2没有被插入123456Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Tue Oct 16 22:27:57 CST 2018There was an unexpected error (type=Internal Server Error, status=500).### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos; ### The error may involve com.cloud.miaosha.dao.UserDao.insert-Inline ### The error occurred while setting parameters ### SQL: insert into user(id, name)values(?, ?) ### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos; ; SQL []; Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos; 4.集成Redishttps://github.com/xetorthio/jedis12345678910&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.38&lt;/version&gt;&lt;/dependency&gt; 配置：1234567redis.host=10.1.18.133redis.port=6379redis.timeout=3redis.password=123456redis.poolMaxTotal=10redis.poolMaxIdle=10spring.redis.pool.max-wait=3 新建redis包配置类RedisConfig123456789101112@Component//获取配置文件 配置里的前缀 @ConfigurationProperties(prefix="redis")public class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; Service通过service提供Redis的get/set1234567891011121314151617181920@Servicepublic class RedisService&#123; @Autowired JedisPool jedisPool; public&lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = jedisPool.getResource(); &#125; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 查看源码找JedisPool中的timeout是什么单位redis 默认6个库从0开始123456789101112JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0);//JedisPool.javapublic JedisPool(final GenericObjectPoolConfig poolConfig, final String host, int port,int timeout, final String password, final int database) &#123; this(poolConfig, host, port, timeout, password, database, null);&#125;//thispublic JedisPool(final GenericObjectPoolConfig poolConfig, final String host, int port,final int connectionTimeout, final int soTimeout, final String password, final int database, final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(poolConfig, new JedisFactory(host, port, connectionTimeout, soTimeout, password, database, clientName, ssl, sslSocketFactory, sslParameters, hostnameVerifier));&#125; JedisFactory12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public JedisFactory(final String host, final int port, final int connectionTimeout, final int soTimeout, final String password, final int database, final String clientName, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;this.hostAndPort.set(new HostAndPort(host, port));//找用到connect time的地方this.connectionTimeout = connectionTimeout;this.soTimeout = soTimeout;this.password = password;this.database = database;this.clientName = clientName;this.ssl = ssl;this.sslSocketFactory = sslSocketFactory;this.sslParameters = sslParameters;this.hostnameVerifier = hostnameVerifier;&#125;//connectionTimeout用的地方PooledObject类final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout, soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);//Jedis.javapublic Jedis(final String host, final int port, final int connectionTimeout, final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, connectionTimeout, soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super BinaryJedis.javapublic BinaryJedis(final String host, final int port, final int connectionTimeout, final int soTimeout, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;client = new Client(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);//timeout的地方是Clientclient.setConnectionTimeout(connectionTimeout);client.setSoTimeout(soTimeout);&#125;//Connection.javasocket.connect(new InetSocketAddress(host, port), connectionTimeout);socket.setSoTimeout(soTimeout);//Socket.java//!!!毫秒@param timeout the specified timeout, in milliseconds.public synchronized void setSoTimeout(int timeout) throws SocketException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (timeout &lt; 0) throw new IllegalArgumentException("timeout can't be negative"); getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));&#125; 所以回到最开始redis.timeout=3是秒1JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); //Client.java展开代码 1234567891011121314151617181920212223//Client.javapublic Client(final String host, final int port, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super-&gt;BinaryClient.javapublic BinaryClient(final String host, final int port, final boolean ssl, final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier) &#123;super(host, port, ssl, sslSocketFactory, sslParameters, hostnameVerifier);&#125;//super-&gt;Connection.javapublic Connection(final String host, final int port, final boolean ssl, SSLSocketFactory sslSocketFactory, SSLParameters sslParameters, HostnameVerifier hostnameVerifier) &#123;this.host = host;this.port = port;this.ssl = ssl;this.sslSocketFactory = sslSocketFactory;this.sslParameters = sslParameters;this.hostnameVerifier = hostnameVerifier;&#125; 修改上面Service 加上释放连接池的代码查看Jedis的close方法源码123456789101112public void close() &#123;if (dataSource != null) &#123; if (client.isBroken()) &#123; //不关掉 返回到连接池 this.dataSource.returnBrokenResource(this); &#125; else &#123; this.dataSource.returnResource(this); &#125;&#125; else &#123; client.close();&#125;&#125; set方法BeanToStrnig用fastjson将bean对象变成string123456789101112public &lt;T&gt; boolean set(String key,T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String str = beanToString(value); if(str == null||str.length()&lt;=0)return false; jedis.set(key,str); return true; &#125;finally&#123; returnToPool(jedis); &#125;&#125; 1234567891011121314151617//任意类型转化成字符串import com.alibaba.fastjson.JSON;private &lt;T&gt; String beanToString(T value)&#123; //2. 添加空判断 if(value == null)return null; //3. 如果是数字，字符串，Long Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125;&#125; get方法 StringToBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class RedisService&#123; @Autowired JedisPool jedisPool; @SuppressWarnings("unchecked")//屏蔽警告 private &lt;T&gt; T stringToBean(String str,Class&lt;T&gt; clazz)&#123; //1. 参数校验 if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //2 如果是int，string，Long if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; //fastJson 只支持了bean类型 其他List类型要再写 return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; public&lt;T&gt; T get(String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jdeis = jedisPool.getResource(); //2.get的逻辑：get是String类型，需要的是T类型 String value = jedis.get(key); T t = stringToBean(value,clazz); return t; //1. 添加关闭代码 &#125;finally&#123; returnToPool(jedis); &#125; &#125; private void returnToPool(Jedis jedis)&#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; controller get测试:127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; set key1 1OK123456789@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;String&gt; redisGet() &#123; String name = redisService.get("key1", String.class); return Result.success(name);&#125; 报错：jedispoll循环引用 空指针 [redis.clients.jedis.JedisPool]: Circular reference involving containing bean ‘redisService’ - consider declaring the factory method as static for independence from its containing instance. Factory method ‘JedisFactory’ threw exception; nested exception is java.lang.NullPointerException 因为Service里注入了pool12@AutowiredJedisPool jedisPool; 但是 JedisPool是实例方法 创建这个Bean需要RedisSevice12@Beanpublic JedisPool JedisFactory() 所以独立出JedisPool1234567891011121314@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisFactory()&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); //redis默认16个库，从0库开始 JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp;&#125; controller set测试:123456789@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; redisSet() &#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set("key3",user);//UserKey:id1 return Result.success(true);&#125; 127.0.0.1:6379&gt; get key3“{\”id\”:1,\”name\”:\”1111\”}” 模板模式[接口&lt;-抽象类&lt;-实现类]：封装缓存key，加上前缀模板方法模式：算法骨架，允许子类为一个或多个步骤提供实现子类不改变算法结构的情况下，重定义算法的某些步骤。1）一次性实现算法不变的部分，并将可变的留给子类实现。2）子类中的公共行为提取到一个公共父类，避免代码重复。可以实现钩子方法。例子：AbstractList、HttpServlet子类重写部分的doGet/Post等方法Mybatis：BaseExecutor中的doUpdate方法 有各种实现（batchExecutor等)类覆盖 优化：将key加上Prefix，按业务模块区分缓存的keyKeyPrefix 接口 BasePrefix 抽象类 UserKey OrderKey等模块实现类效果：在不同的controllor模块调用service时传入模块IDcontroller使用:classname+prefix+keyredis效果：7) &quot;UserKey:id1&quot;UserKey.getById1234567891011121314151617@RequestMapping("/redis/get") @ResponseBody public Result&lt;User&gt; redisGet() &#123; User user = redisService.get(UserKey.getById, "1", User.class); return Result.success(user); &#125; @RequestMapping("/redis/set") @ResponseBody public Result&lt;Boolean&gt; redisSet() &#123; User user = new User(); user.setId(1); user.setName("1111"); //UserKey:id1 redisService.set(UserKey.getById,"1",user); return Result.success(true); &#125; 接口：123456public interface KeyPrefix()&#123; //有效期 public int expireSeconds(); //前缀 public String getPrefix(); &#125; 实现的抽象类 防止被创建12345678910111213141516public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //0表示永不过期 public BasePrefix(String prefix) &#123;//0代表永不过期 this(0, prefix); &#125; public int expireSeconds()&#123; return expireSeconds; &#125; //用类名当前缀 public String getPrefix()&#123; String className = getClass().getSimpleName(); return className+":"+perfix; &#125;&#125; 实现类：用户key123456public class UserKey extends BasePrefix&#123; //私有 防实例化 private UserKey(String prefix)&#123;super(prefix);&#125; public static UserKey getById = new UserKey("id"); public static UserKey getByName = new UserKey("name");&#125; 实现类：订单key1public class OrderKey extends BasePrefix 修改Service中的get和set 12345678910111213141516/** * 获取单个对象 */public&lt;T&gt; T get(Prefix prefix,String key,Class&lt;T&gt; clazz)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); //真正写到数据库的key String prefixKey = prefix.getPrefix()+key; String value = jedis.get(prefixKey); T t = stringToBean(value,clazz); return t; &#125;finally&#123; returnToPool(jedis); &#125;&#125; 添加失效时间127.0.0.1:6379&gt; expire key1 3(integer) 11234567891011121314151617181920public &lt;T&gt; boolean set(KeyPrefix prefix,String key,T value)&#123; Jedis jedis = null; try&#123; jedis = jedisPool.getResource(); String str = beanToString(value); if(str == null||str.length()&lt;=0)return false; String prefixKey = prefix.getPrefix()+key; int expire = prefix.expireSeconds(); //永不过期 if(expire&lt;=0)&#123; jedis.set(prefixKey,str); &#125;else&#123; jedis.setex(prefixKey,expire,str); &#125; return true; &#125;finally&#123; returnToPool(jedis); &#125;&#125; setex:等于set+expire命令12345public String setex(final String key, final int seconds, final String value) &#123; checkIsInMultiOrPipeline(); client.setex(key, seconds, value); return client.getStatusCodeReply(); &#125; 添加其他API:127.0.0.1:6379&gt; exists key1(integer) 1123456789public &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); String prefixKey = prefix.getPrefix()+key; return jedis.exists(prefixKey); &#125;finally &#123; returnToPool(jedis); &#125; 127.0.0.1:6379&gt; incr key1(integer) 2127.0.0.1:6379&gt; incr key1(integer) 3127.0.0.1:6379&gt; set key222 fdafdaOK127.0.0.1:6379&gt; incr key222(error) ERR value is not an integer or out of range incr1234567891011public &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 127.0.0.1:6379&gt; incr key1(integer) 5127.0.0.1:6379&gt; decr key1(integer) 4 decr1234567891011public &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.实现登陆 数据库设计 2次MD5 JSR303参数校验 全局异常 分布式session数据库设计1234567891011create table `miaosha_user`( `id` bigint(20) not null comment '用户ID，手机号', `nickname` varchar(256) not null, `password` varchar(32) default null comment 'MD5(md5+salt)+salt', `salt` varchar(10) default null, `head` varchar(128) default null comment '头像', `register_date` datetime default null comment '注册时间', `last_login_date` datetime default null comment '上次登录时间', `login_count` int(11) default '0' comment '登陆次数', primary key (`id`))ENGINE=InnoDB DEFAULT CHARSET=utf8; 用户端先MD5(明文+固定salt)服务端存再一次md5(明文+随机salt)123456789&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt;&lt;/dependency&gt; 新建util包使用apacheMD5加密前端第一次salt是可以看到的 隐藏只能activeX控件之类的123456789101112131415161718192021222324252627import org.apache.commons.codec.digest.DigestUtils;public static String md5(String src)&#123; return DigestUtils.md5Hex(src);&#125;//添加一个salt//前端form表单提交上来的密码//一次加密"123456"-&gt; 26718c17fe0b7862a27dd7dc1b532f29public static String inputPassFormPass(String inputPass)&#123; String passsalt = salt.charAt(0)+salt.charAt(2)+inputPass+salt.charAt(5); return md5(passsalt);&#125;//第二次加密，放入数据库public static String formPassToDBPass(String formPass, String salt) &#123; String toDB = ""+salt.charAt(0)+salt.charAt(2) + formPass +salt.charAt(5) + salt.charAt(4); return md5(toDB);&#125;//两次合并成1次public static String inputPassToDbPass(String inputPass, String saltDB) &#123; String formPass = inputPassToFormPass(inputPass); String dbPass = formPassToDBPass(formPass, saltDB); return dbPass;&#125;public static void main(String[] args) &#123; //c996054adec06904c675b89aa68de2ec System.out.println(inputPassToFormPass("123456")); //bef054e9b1abb70963943f32b41a3f6d System.out.println(formPassToDBPass(inputPassToFormPass("123456"), "secondsalt")); 在controller添加path12345678910@Controller@RequestMapping("/login")public class LoginController &#123; private static Logger log = LoggerFactory.getLogger(LoginController.class);@RequestMapping("/login") public String toLogin() &#123; return "login"; &#125;&#125; 登陆页面 用bootstrap的css，jq的表单验证，layer的弹窗，md5加密登陆html页面引入：12345678910111213141516171819&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;!-- jquery --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/jquery.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- bootstrap --&gt; &lt;link rel="stylesheet" type="text/css" th:href="@&#123;/bootstrap/css/bootstrap.min.css&#125;" /&gt; &lt;script type="text/javascript" th:src="@&#123;/bootstrap/js/bootstrap.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- jquery-validator --&gt; &lt;script type="text/javascript" th:src="@&#123;/jquery-validation/jquery.validate.min.js&#125;"&gt;&lt;/script&gt; &lt;script type="text/javascript" th:src="@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- layer --&gt; &lt;script type="text/javascript" th:src="@&#123;/layer/layer.js&#125;"&gt;&lt;/script&gt; &lt;!-- md5.js --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/md5.min.js&#125;"&gt;&lt;/script&gt; &lt;!-- common.js --&gt; &lt;script type="text/javascript" th:src="@&#123;/js/common.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt; bootstrap+jquery验证:展开代码 1234567891011121314151617181920212223242526272829303132&lt;!-- 50%宽度 居中 margin: 0 auto --&gt;&lt;form name="loginForm" id="loginForm" method="post" style="width:50%; margin:0 auto"&gt; &lt;h2 style="text-align:center; margin-bottom: 20px"&gt;用户登录&lt;/h2&gt; &lt;div class="form-group"&gt; &lt;div class="row"&gt; &lt;label class="form-label col-md-4"&gt;请输入手机号码&lt;/label&gt; &lt;div class="col-md-5"&gt; &lt;input id="mobile" name = "mobile" class="form-control" type="text" placeholder="手机号码" required="true" minlength="11" maxlength="11" /&gt; &lt;/div&gt; &lt;div class="col-md-1"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="row"&gt; &lt;label class="form-label col-md-4"&gt;请输入密码&lt;/label&gt; &lt;div class="col-md-5"&gt; &lt;input id="password" name="password" class="form-control" type="password" placeholder="密码" required="true" minlength="6" maxlength="16" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-5"&gt; &lt;button class="btn btn-primary btn-block" type="reset" onclick="reset()"&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;div class="col-md-5"&gt; &lt;button class="btn btn-primary btn-block" type="submit" onclick="login()"&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; jquery validate:http://www.runoob.com/jquery/jquery-plugin-validate.html12345678function login()&#123; // 在键盘按下并释放及提交后验证提交表单 $("#loginForm").validate(&#123; submitHandler:function(form)&#123; //如果成功 异步提交表单 doLogin() &#125; &#125;) 使用ajax异步提交1234567891011121314151617181920212223242526272829303132333435function doLogin()&#123; //每次提交loading框 g_showLoading() //md5加密密码 与后台规则一样 var inputpwd = $("#password").val() var str = salt.charAt(0)+salt.charAt(2)+inputpwd+salt.charAt(5) //123456-&gt;c996054adec06904c675b89aa68de2ec var password = md5(str) $.ajax(&#123; url:"/login/do_login", type:"POST", data:&#123; mobile:$("#mobile").val(), password:password &#125;, success:function(data)&#123; //无论成功失败都关闭框 layer.closeAll(); console.log("login") console.log(password) /* &#123;code: 0, msg: null, data: "登录成功"&#125; */ if(data.code==0)&#123; layer.msg("成功") console.log(data) &#125;else&#123; console.log("打印后端返回的错误信息") layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.closeAll() &#125; &#125;)&#125; layer.js弹窗http://layer.layui.com/common.js1234function g_showLoading()&#123; var idx = layer.msg('处理中...', &#123;icon: 16,shade: [0.5, '#f5f5f5'],scrollbar: false,offset: '0px', time:100000&#125;) ; return idx;&#125; 在js中设置salt1var g_passsword_salt="abcd1234" 参数校验在controller 验证手机号之后再调用Service 用手机号查询dao数据库里面的密码，与前端传的密码做比较。页面参数用vo封装。 后台添加vo接收前端数据的类：1234public class LoginVo &#123; private String mobile; private String password;&#125; 添加controller：添加errormessageCodeMsg.java12345678910//登录模块 5002XXpublic static CodeMsg SESSION_ERROR = new CodeMsg(500210,"Session不存在或者已经失效");public static CodeMsg PASSWORD_ERROR = new CodeMsg(500211,"登陆密码不能为空");public static CodeMsg MOBILE_EMPTY = new CodeMsg(500212,"手机号不能为空");public static CodeMsg SESSION_ERROR = new CodeMsg(500210,"Session不存在或者已经失效");public static CodeMsg PASSWORD_EMPTY = new CodeMsg(500211,"登陆密码不能为空");public static CodeMsg MOBILE_EMPTY = new CodeMsg(500212,"手机号不能为空");public static CodeMsg MOBILE_ERROR = new CodeMsg(500213,"手机号格式错误");public static CodeMsg MOBILE_NOT_EXIST = new CodeMsg(500214,"手机号不存在");public static CodeMsg PASSWORD_ERROR = new CodeMsg(500215,"密码错误"); 1234567891011121314151617181920//添加log 可以查看前端传过来的form数据是什么import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static Logger log = LoggerFactory.getLogger(LoginController.class);@RequestMapping("/do_login")@ResponseBodypublic Result&lt;Boolean&gt; doLogin(LoginVo loginVo) &#123; log.info(loginVo.toString()); //参数校验 String password = loginVo.getPassword(); String mobile = loginVo.getMobile(); if(StringUtils.isEmpty(mobile))&#123; return Result.error(CodeMsg.MOBILE_EMPTY); &#125; if(StringUtils.isEmpty(password))&#123; return Result.error(CodeMsg.PASSWORD_EMPTY); &#125; if(!ValidatorUtil.isMobile(mobile)) return Result.error(CodeMsg.MOBILE_ERROR); &#125; 正则手机号手机号验证类ValidatorUtil.java12345678910111213141516171819import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.commons.lang3.StringUtils;public class ValidatorUtil &#123; private static final Pattern mobile_pattern = Pattern.compile("^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$"); public static boolean isMobile(String str)&#123; if(StringUtils.isEmpty(str))&#123; return false; &#125; Matcher m = mobile_pattern.matcher(str); return m.matches(); &#125; public static void main(String[] args) &#123; //true System.out.println(isMobile("18912341234")); //false System.out.println(isMobile("12345678900")); &#125;&#125; 新建与数据库关联的domain对象1234567891011public class MiaoshaUser &#123; //bigint private Long id; private String nickname; private String password; private String salt; private String head; private Date registerDate; private Date lastLoginDate; private Integer loginCount;&#125; 新建dao,通过id找用户12345678@Mapperpublic interface MiaoshaUserDao&#123; @Select（"select * from miaosha user where id = #&#123;id&#125;") public MiaoshaUser getById(@Param("id") long id); @Insert("insert into user(id, name)values(#&#123;id&#125;, #&#123;name&#125;)") public int insert(User user);&#125; service获取用户及登陆:123456789101112131415161718192021222324252627282930@Servicepublic class MiaoshaUserService&#123; @Autowired MiaoshaUserDao miaoshaUserDao; public MiaoshaUser getById(long id) &#123; return miaoshaUserDao.getById(id); &#125; public CodeMsg login(LoginVo loginVo)&#123; if(loginVo == null) &#123; throw CodeMsg.SERVER_ERROR; &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); //数据库查询手机号 MiaoshaUser user = getById(Long.parseLong(mobile)); if(user == null) &#123; //用户/手机号不存在 throw new CodeMsg.MOBILE_NOT_EXIST; &#125; //数据库中的密码,salt String dbPass = user.getPassword(); String saltDB = user.getSalt(); //用前端密码+数据库salt是否等于数据库密码 String gassDBpass = MD5Util.formPassToDBPass(formPass, saltDB); if(!calcPass.equals(dbPass)) &#123; throw CodeMsg.PASSWORD_ERROR; &#125; return CodeMsg.SUCCESS; &#125;&#125; 在controller中注入1234567891011@AutowiredMiaoshaUserService userService;@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(LoginVo loginVo) &#123; //..参数校验 //登录 CodeMsg code = userService.login(loginVo); if(code.getCode()==0)return Result.success("登录成功"); else return Result.error(code); 6.JSR303参数校验+全局异常不是每个controller的方法里都要写参数校验，而是把参数校验放到vo类上，在controller只要打注解 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在controller要校验的实体前打@Valid1public Result&lt;String&gt; doLogin(@Valid LoginVo loginVo) 在实体类加注解1234public class LoginVo &#123;@NotNull@Length(min=32)private String password; 自定义注解对手机号添加自定义验证注解新建validator包,新建IsMobile.java参考java.validation.constrains里的NotNull,必须的，添加来自Constraint.java的注释：1234Each constraint annotation must host the following attributes: String message() default [...]; which should default to an error message key made of the fully-qualified class name of the constraint followed by .message. For example "&#123;com.acme.constraints.NotSafe.message&#125;" Class&lt;?&gt;[] groups() default &#123;&#125;; for user to customize the targeted groups Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; for extensibility purposes 123456789101112131415@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)@Retention(RUNTIME)@Documented// 注解实现类@Constraint(validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile&#123; //不能为空 boolean required() default true; //默认信息 String message() default "手机号码格式错误"; Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;&#125; 注解实现类新建类IsMobileValidator并在@interface里添加@Constraint(validatedBy = {IsMobileValidator.class}) 123public @interface Constraint &#123; Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();&#125; 创建类&lt;注解,检测的类型&gt;，用上之前创建的ValidatorUtil12345678910111213141516171819202122public class MobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; //成员变量，接收注解定义 private boolean required = false; @Override public void initialize(IsMobile constraintAnnotation) &#123; //初始化方法里可以获取注解对象 required = constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if(required)&#123; //初始化获取注解 传的值 如果是必须的，判断是否合法 return ValidatorUtil.isMobile(value); &#125;else//如果不是必须的 if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125;&#125; 在LoginVo上加上123@NotNull@Mobile(required = true,message = "手机号错")private String mobile; 返回controller的doLogin可以删掉之前的非空检验参数校验123456789@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(@Valid LoginVo loginVo) &#123; log.info(loginVo.toString()); // 登录 CodeMsg code = userService.login(loginVo); // 如果有异常会给异常controller处理 return Result.success("登录成功");&#125; 可以得到完整错误信息 绑定异常 异常处理错误处理新建exception包添加@ControllerAdvice 和controller是一样的1234567891011121314151617181920@ControllerAdvice@ResponseBodypublic class BindExceptionHandler &#123; // 拦截所有异常 @ExceptionHandler(Exception.class) public Result&lt;String&gt; bindexp(HttpServletRequest request,Exception e)&#123; // 刚刚手机号错报的绑定异常 if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError objectError = errors.get(0); String defaultMessage = objectError.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(defaultMessage)); &#125;else&#123; //通用异常 return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 定义传参的错误信息可传递参数的错误信息，原来定义的枚举类不能new 所以不用枚举了CodeMsg.BIND_ERROR.fillArgs(msg)123456789101112131415161718192021222324252627public class CodeMsg &#123; private int code; private String msg; private CodeMsg( int code,String msg ) &#123; this.code = code; this.msg = msg; &#125; //通用的错误码 public static CodeMsg SUCCESS = new CodeMsg(0, "success"); public static CodeMsg SERVER_ERROR = new CodeMsg(500100, "服务端异常"); // 绑定异常 public static CodeMsg BIND_ERROR = new CodeMsg(500101, "参数校验异常：%s"); //登录模块 5002XX public static CodeMsg SESSION_ERROR = new CodeMsg(500210, "Session不存在或者已经失效"); public static CodeMsg PASSWORD_EMPTY = new CodeMsg(500211, "登录密码不能为空"); public static CodeMsg MOBILE_EMPTY = new CodeMsg(500212, "手机号不能为空"); public static CodeMsg MOBILE_ERROR = new CodeMsg(500213, "手机号格式错误"); public static CodeMsg MOBILE_NOT_EXIST = new CodeMsg(500214, "手机号不存在"); public static CodeMsg PASSWORD_ERROR = new CodeMsg(500215, "密码错误"); //参数校验异常：%s public CodeMsg fillArgs(Object... args) &#123; int code = this.code; // this 关键 String message = String.format(this.msg,args); return new CodeMsg(code,message); &#125;&#125; 测试：200返回{&quot;code&quot;:500101,&quot;msg&quot;:&quot;参数校验异常：手机号错&quot;,&quot;data&quot;:null} 定义系统全局异常业务模块MiaoshaUserService中的public CodeMsg login(LoginVo loginVo)方法，不应该返回CodeMsg，应该定义系统全局异常(业务异常)1234567891011public class GlobalException extends RuntimeException&#123; private static final long serialVersionUID = 1L; private CodeMsg cm; public GlobalException(CodeMsg cm) &#123; super(cm.toString()); this.cm = cm; &#125;//get&#125; MiaoshaUserService.java修改业务代码直接抛异常而不是返回CodeMsg123456789101112131415161718192021222324// 返回业务含义的 登陆 true falsepublic boolean login(LoginVo loginVo)&#123; if(loginVo == null)&#123; throw new GlobalException( CodeMsg.SERVER_ERROR); &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); MiaoshaUser user = getById(Long.parseLong(mobile)); if(user == null) &#123; //用户/手机号不存在 throw new GlobalException( CodeMsg.MOBILE_NOT_EXIST); &#125; //数据库中的密码,salt String dbPass = user.getPassword(); String saltDB = user.getSalt();// 用前端密码+数据库salt是否等于数据库密码 String calcPass = MD5Util.formPassToDBPass(formPass, saltDB); log.info(calcPass); log.info(dbPass); if(!calcPass.equals(dbPass)) &#123; throw new GlobalException( CodeMsg.PASSWORD_ERROR); &#125; return true;&#125; 添加全局异常处理,注意合并成一个异常处理，不要覆盖// todo 应该先小异常还是先大异常1234567891011121314151617181920@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value=Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e)&#123; e.printStackTrace(); if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException)e; return Result.error(ex.getCm()); &#125;else if(e instanceof BindException) &#123; BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else &#123; return Result.error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125; 修改controllor中service的返回值，异常已经处理了，不用返回值12userService.login(loginVo);return Result.success("登录成功"); 7.分布式Session1.容器session同步 比较复杂2.登陆成功后生成token(sessionID)写到cookie传递给客户端，客户端每次访问上传cookie,服务器根据token找到user对象 新建生成ID的类用uuid，原生UUID带‘-’，去掉12345public class UUIDUtil &#123; public static String uuid() &#123; return UUID.randomUUID().toString().replace("-", ""); &#125;&#125; service中login比对密码正确后，生成token，并写到redis中 在service中引入redisService，设置cookie中的token name123456789101112131415161718192021222324252627282930313233343536// cookie keypublic static final String COOKI_NAME_TOKEN = "token";@AutowiredRedisService redisService;public boolean login( HttpServletResponse response,@Valid LoginVo loginVo) &#123; if(loginVo == null) &#123; System.out.println("loginvonull"); throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); //判断手机号是否存在 MiaoshaUser user = getById(Long.parseLong(mobile)); if(user == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //验证密码 String dbPass = user.getPassword(); String saltDB = user.getSalt(); String calcPass = MD5Util.formPassToDBPass(formPass, saltDB); if(!calcPass.equals(dbPass)) &#123; throw new GlobalException(CodeMsg.PASSWORD_ERROR); &#125; //生成cookie String token = UUIDUtil.uuid(); redisService.set(MiaoshaUserKey.token, token, user); Cookie cookie = new Cookie(COOKI_NAME_TOKEN,token); // 有效期 与redis中session有效期保持一致 cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds()); // 网站根目录 注意不是 ./ cookie.setPath("/"); //写到response要HttpResponse response.addCookie(cookie); return true;&#125; 在\redis\新建MiaoshaUserKey123456public class MiaoshaUserKey extends BasePrefix&#123; public MiaoshaUserKey(String prefix) &#123; super(prefix); &#125; public static tokenKey token = new tokenKey("tk");&#125; 修改login controller 里也要添加HttpServletResponse response1234567@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(HttpServletResponse response,@Valid LoginVo loginVo) &#123; log.info(loginVo.toString()); userService.login(response,loginVo); return Result.success("登录成功");&#125; 登录成功跳转页注意语法12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;商品列表&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p th:text="'hello:'+$&#123;user.nickname&#125;" &gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 创建新的controller类12345678@Controller@RequestMapping("/goods")public class GoodsController &#123; @RequestMapping("/to_list") public String list(Model model,MiaoshaUser user) &#123; return "goods_list"; &#125;&#125; login.html ajax成功后跳转1234567891011121314151617181920$.ajax(&#123; url: "/login/do_login", type: "POST", data:&#123; mobile:$("#mobile").val(), password: password &#125;, success:function(data)&#123; layer.closeAll(); if(data.code == 0)&#123; layer.msg("成功"); window.location.href="/goods/to_list"; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.closeAll(); &#125;&#125;); 测试：登录后可以显示:hello:null查看do_login的responseSet-Cookie: token=1701f466f2904a568aa364d6992828eb; Max-Age=0; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Path=./ 因为Max-Age=0所以to_list没有上传cookie给cookie设置默认有效期MiaoshaUserKey.java 12345678910public class MiaoshaUserKey extends BasePrefix&#123; public static final int TOKEN_EXPIRE = 3600*24 * 2; // 构造函数里加上过期时间 public MiaoshaUserKey(int expireSeconds,String prefix) &#123; super(expireSeconds,prefix); &#125; // 调用构造函数 public static MiaoshaUserKey token = new MiaoshaUserKey(TOKEN_EXPIRE,"tk"); 测试：do login的responseSet-Cookie: token=38407e1482e246519727d0041bbd781c; Max-Age=172800; Expires=Tue, 23-Oct-2018 11:07:50 GMT; Path=/tolist 里会带着Cookie: token=38407e1482e246519727d0041bbd781c public方法一定要做参数校验 实现用token从redis中得到MiaoshaUser123456public MiaoshaUser getByToken( String token) &#123; if(StringUtils.isEmpty(token)) &#123; return null; &#125; return redisService.get(MiaoshaUserKey.token, token, MiaoshaUser.class); &#125; controller：有的手机端会放到参数里传不在cookie里。设置优先级1234567891011121314151617@RequestMapping("/to_list")public String toLogin(Model model, @CookieValue(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = false)String cookieToken, @RequestParam(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = false)String paramToken) &#123; if(StringUtils.isEmpty(cookieToken)&amp;&amp; StringUtils.isEmpty(paramToken))&#123; System.out.println("没获取到"); return "login"; &#125; String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; System.out.println("获取到了token"); MiaoshaUser user = userService.getByToken(token); System.out.println("获取到了用户"); System.out.println(user); model.addAttribute("user",user); return "goods_list";&#125; session内登陆时延长有效期每次response里都有set-cookie 把生成cookie的代码独立成一个方法：1234567private void addCookie(HttpServletResponse response, String token,MiaoshaUser user) &#123; redisService.set(MiaoshaUserKey.token, token, user); Cookie cookie = new Cookie(COOKI_NAME_TOKEN, token); cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds()); cookie.setPath("/"); response.addCookie(cookie);&#125; 每次token-&gt;User的时候重新对response更新cookie 1234567891011public MiaoshaUser getByToken(HttpServletResponse response, String token) &#123; if(StringUtils.isEmpty(token)) &#123; return null; &#125; MiaoshaUser user = redisService.get(MiaoshaUserKey.token, token, MiaoshaUser.class);// 延长有效期 if(user != null) &#123; addCookie(response,token,user); &#125; return user;&#125; 在controller加response 判断登陆session的代码独立出来实现效果：每个Controller不用验证登陆，只需要注入一个User。相当于实现一个ArgumentResolver新建包configWebConfig.java参数通过框架回调WebMvcConfigurerAdapter的addArgumentResolvers addArgumentResolvers 是spring MVC里controller中可以带很多参数，都是框架回调这个方法给controller赋值的。所以只需要遍历方法的参数，如果有User这个参数，就赋值。 添加一个Resolver 赋值1234567891011@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolver userArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Servicepublic class UserArgumentResolver implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; public boolean supportsParameter(MethodParameter parameter) &#123; // 获取参数类型 是User类型才会做resolveArgument Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz==MiaoshaUser.class; &#125; public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; // 1. request 和 response HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); // 2. 浏览器不同 token可能在cookie里也可能在参数里 String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123;return null;&#125; // 3. 根据客户端token获取user String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; return userService.getByToken(response, token); &#125; /** * 遍历request里的所有cookie 找到对应那个的value * @param request * @param cookiName * @return */ private String getCookieValue(HttpServletRequest request, String cookiName) &#123; Cookie[] cookies = request.getCookies(); for(Cookie cookie : cookies) &#123; if(cookie.getName().equals(cookiName)) &#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; WebMvcConfigurerAdapter 已经被5弃用了（？）public void configureContentNegotiation(ContentNegotiationConfigurer configurer)内容协商：对象-&gt;Jsonpublic void addInterceptors(InterceptorRegistry registry) 拦截器public void addResourceHandlers(ResourceHandlerRegistry registry) 资源处理器public void addCorsMappings(CorsRegistry registry) 跨域 可以删掉controller里检测登陆的代码：12345@RequestMapping("/to_list")public String toLogin(Model model,MiaoshaUser user) &#123; model.addAttribute("user",user); return "goods_list";&#125; 完成分布式session 8.商品列表详情页 秒杀功能秒杀商品表、秒杀订单表 要独立，因为变化大新建数据库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950create table `goods`( `id` bigint(20) not null AUTO_INCREMENT comment '商品ID', `goods_name` varchar(16) not null comment '商品名称', `goods_title` varchar(64) default null comment '商品标题', `goods_img` varchar(64) default null comment'商品图片', `goods_detail` longtext comment '商品详情介绍', `goods_price` decimal(10,2) default '0.00' comment '商品单价', `goods_stock` int(11) default '0' comment '商品库存，-1表示没有限制', primary key (`id`))ENGINE=InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET=utf8;create table `miaosha_order`( `id` bigint(20) not null AUTO_INCREMENT , `user_id` BIGINT(20) not null comment '用户ID', `order_id` BIGINT(20) default null comment '订单ID', `goods_id` BIGINT(20) default null comment'商品ID', primary key (`id`))ENGINE=InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET=utf8;create table `miaosha_goods`( `id` bigint(20) not null AUTO_INCREMENT comment '秒杀商品表', `goods_id` BIGINT(20) DEFAULT null comment '商品id', `miaosha_price` DECIMAL(10,2) default '0.00' comment '秒杀', `stock_count` INT(11) default null comment'库存数量', `start_date` DATETIME DEFAULT NULL comment '秒杀开始时间', `end_date` DATETIME DEFAULT NULL comment '秒杀结束时间', primary key (`id`))ENGINE=InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET=utf8;create table `order_info`( `id` bigint(20) not null AUTO_INCREMENT , `user_id` BIGINT(20) not null comment '用户ID', `goods_id` BIGINT(20) default null comment '商品ID', `delivery_addr_id` BIGINT(20) default null comment'收获地址ID', `goods_name` VARCHAR(16) DEFAULT NULL comment '冗余商品名称', `goods_count` INT(11) DEFAULT '0' comment '商品数量', `goods_price` DECIMAL(10,2) DEFAULT '0.00' comment '商品单价', `order_channel` TINYINT(4) DEFAULT '0' comment '1pc,2android,3ios', `status` TINYINT(4) DEFAULT '0' comment '订单状态，0新建未支付，1已支付，3已收货，4已退款，5已完成', `create_date` DATETIME DEFAULT NULL comment '订单创建时间', `pay_date` DATETIME DEFAULT NULL comment '支付时间', primary key (`id`))ENGINE=InnoDB AUTO_INCREMENT = 12 DEFAULT CHARSET=utf8; 建立对应的domain对象1234567891011121314151617181920212223242526272829303132333435public class Goods &#123; private Long id; private String goodsName; private String goodsTitle; private String goodsImg; private String goodsDetail; private Double goodsPrice; private Integer goodsStock; &#125;public class MiaoshaGoods &#123; private Long id; private Long gooddsId; private Integer stockCount; private Date startDate; private Date endDate;&#125;public class OrderInfo &#123; private Long id; private Long userId; private Long goodsId; private Long deliveryAddrId; private String goodsName; private Integer goodsCount; private Double goodsPrice; private Integer orderChannel; private Integer status; private Date createDate; private Date payDate;&#125;public class MiaoshaOrder &#123; private Long id; private Long userId; private Long orderId; private Long goodsId;&#125; 创建GoodsService.java和对应的GoodsDao 查找商品希望同时查找到miaosha_goods中的秒杀信息建立vo12345public class GoodVo extends Goods&#123; private Double miaoshaPrice; private Integer stockCount; private Date startDate; private Date endDate; dao12345678@Mapperpublic interface GoodsDao &#123; /** * 查找商品信息和秒杀信息(库存和秒杀时间) */ @Select("select g.*,mg.miaosha_price,mg.stock_count,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id") public List&lt;GoodVo&gt; listGoodsVo();&#125; service: 显示商品列表123456789@Servicepublic class GoodsService &#123; @Autowired GoodsDao goodsDao; public List&lt;GoodVo&gt; listGoodsVo()&#123; return goodsDao.listGoodsVo(); &#125;&#125; controller 中添加到页面12345678910111213@AutowiredGoodsService goodsService;@RequestMapping("/to_list")public String toLogin(Model model,MiaoshaUser user) &#123; model.addAttribute("user",user); // 秒杀商品列表 List&lt;GoodVo&gt; goodVos = goodsService.listGoodsVo(); model.addAttribute("goodsList",goodVos); return "goods_list";&#125; 在goods_list.html 添加遍历 在static下放img/iphoneX.png 数据库img存img/iphoneX.png1234567891011121314&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品列表&lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt;&lt;td&gt;商品名称&lt;/td&gt;&lt;td&gt;商品图片&lt;/td&gt;&lt;td&gt;商品原价&lt;/td&gt;&lt;td&gt;秒杀价&lt;/td&gt;&lt;td&gt;库存数量&lt;/td&gt;&lt;td&gt;详情&lt;/td&gt;&lt;/tr&gt; &lt;tr th:each="goods,goodsStat : $&#123;goodsList&#125;"&gt; &lt;td th:text="$&#123;goods.goodsName&#125;"&gt;&lt;/td&gt; &lt;td &gt;&lt;img th:src="@&#123;$&#123;goods.goodsImg&#125;&#125;" width="100" height="100" /&gt;&lt;/td&gt; &lt;td th:text="$&#123;goods.goodsPrice&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;goods.miaoshaPrice&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;goods.stockCount&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;a th:href="'/goods/to_detail/'+$&#123;goods.id&#125;"&gt;详情&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 测试：http://localhost:8080/goods/to_list 可以看到表格 商品详情页 倒计时为了防止数据库中id连号被遍历，一般使用snowflake算法 html里/goods/to_detail/&#39;+${goods.id} 根据商品ID查询单个goodVO信息 并显示当前时间和秒杀时间的倒计时 （为什么不返回未来时间而要返回剩余时间？）controller:1234567891011121314151617181920212223242526272829@RequestMapping("/to_detail/&#123;goodsId&#125;")public String detail(Model model,MiaoshaUser user, @PathVariable("goodsId")long goodsId) &#123; model.addAttribute("user", user); GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute("goods", goods); long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); // 0：没开始 2：结束 1：进行中 int miaoshaStatus = 0; // 倒计时 int remainSeconds = 0; if(now &lt; startAt ) &#123;//秒杀还没开始，倒计时 miaoshaStatus = 0; remainSeconds = (int)((startAt - now )/1000); &#125;else if(now &gt; endAt)&#123;//秒杀已经结束 miaoshaStatus = 2; remainSeconds = -1; &#125;else &#123;//秒杀进行中 miaoshaStatus = 1; remainSeconds = 0; &#125; model.addAttribute("miaoshaStatus", miaoshaStatus); model.addAttribute("remainSeconds", remainSeconds); return "goods_detail";&#125; service 和dao 显示商品详情12345public GoodVo getGoodsVoByGoodsId(long goodsId) &#123; return goodsDao.getGoodsVoByGoodsId(goodsId); &#125;@Select("select g.*,mg.miaosha_price,mg.stock_count,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id where g.id = #&#123;goodId&#125;" )GoodVo getGoodsVoByGoodsId( long goodsId); 商品详情html：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品详情&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;span th:if="$&#123;user eq null&#125;"&gt; 您还没有登录，请登陆后再操作&lt;br/&gt;&lt;/span&gt; &lt;span&gt;没有收货地址的提示。。。&lt;/span&gt; &lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" th:text="$&#123;goods.goodsName&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="3"&gt;&lt;img th:src="@&#123;$&#123;goods.goodsImg&#125;&#125;" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀开始时间&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')&#125;"&gt;&lt;/td&gt; &lt;td id="miaoshaTip"&gt; &lt;input type="hidden" id="remainSeconds" th:value="$&#123;remainSeconds&#125;" /&gt; &lt;span th:if="$&#123;miaoshaStatus eq 0&#125;"&gt;秒杀倒计时：&lt;span id="countDown" th:text="$&#123;remainSeconds&#125;"&gt;&lt;/span&gt;秒&lt;/span&gt; &lt;span th:if="$&#123;miaoshaStatus eq 1&#125;"&gt;秒杀进行中&lt;/span&gt; &lt;span th:if="$&#123;miaoshaStatus eq 2&#125;"&gt;秒杀已结束&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;form id="miaoshaForm" method="post" action="/miaosha/do_miaosha"&gt; &lt;button class="btn btn-primary btn-block" type="submit" id="buyButton"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" th:value="$&#123;goods.id&#125;" /&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品原价&lt;/td&gt; &lt;td colspan="3" th:text="$&#123;goods.goodsPrice&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀价&lt;/td&gt; &lt;td colspan="3" th:text="$&#123;goods.miaoshaPrice&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;库存数量&lt;/td&gt; &lt;td colspan="3" th:text="$&#123;goods.stockCount&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 倒计时：&lt;span id=&quot;countDown&quot; th:text=&quot;${remainSeconds}&quot;&gt;&lt;/span&gt;秒&lt;/span&gt;设置隐藏域保留remainSeconds(controller添加的) 这样miaoshaStatus是1或者2 js也能取到时间12&lt;input type="hidden" id="remainSeconds" th:value="$&#123;remainSeconds&#125;" /&gt;&lt;span th:if="$&#123;miaoshaStatus eq 0&#125;"&gt;秒杀倒计时：&lt;span id="countDown" th:text="$&#123;remainSeconds&#125;"&gt;&lt;/span&gt;秒&lt;/span&gt; js判断remainSeconds 三种情况，设置标签颜色和倒计时12345678910111213141516171819202122232425$(function()&#123; countDown();&#125;);function countDown()&#123; var remainSeconds = $("#remainSeconds").val(); var timeout; if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时 $("#buyButton").attr("disabled", true); timeout = setTimeout(function()&#123; $("#countDown").text(remainSeconds - 1); $("#remainSeconds").val(remainSeconds - 1); countDown(); &#125;,1000); &#125;else if(remainSeconds == 0)&#123;//秒杀进行中 $("#buyButton").attr("disabled", false); if(timeout)&#123; clearTimeout(timeout); &#125; $("#miaoshaTip").html("秒杀进行中"); &#125;else&#123;//秒杀已经结束 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀已经结束"); &#125;&#125; 测试：http://localhost:8080/goods/to_detail/1 秒杀功能用表单提交 传递的参数是商品id1234&lt;form id="miaoshaForm" method="post" action="/miaosha/do_miaosha"&gt; &lt;button class="btn btn-primary btn-block" type="submit" id="buyButton"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" th:value="$&#123;goods.id&#125;" /&gt;&lt;/form&gt; 添加秒杀模块的Error Message12public static CodeMsg MIAO_SHA_OVER = new CodeMsg(500500, "无库存");public static CodeMsg REPEATE_MIAOSHA = new CodeMsg(500501, "不能重复秒杀"); 业务逻辑： 判断登陆 -&gt; 登陆页面 判断商品库存 -&gt; 秒杀失败 判断用户是否已经秒杀过该商品 -&gt;秒杀失败 //todo 如果可以买好几件？ 事务：减库存 下单 加入秒杀订单 -&gt; 订单详情页定义OrderService 用于查询用户订单是否已经买过这个商品 添加秒杀失败页面：12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;秒杀失败&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;秒杀失败：&lt;p th:text="$&#123;errmsg&#125;"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 新建MiaoshaController1234567891011121314151617181920212223242526272829303132333435363738394041@Controller@RequestMapping("/miaosha")public class MiaoshaController &#123; @Autowired GoodsService goodsService; @Autowired OrderService orderService; @Autowired MiaoshaService miaoshaService; @RequestMapping("/do_miaosha") public String list(Model model, MiaoshaUser user, @RequestParam("goodsId")long goodsId) &#123; model.addAttribute("user", user); // 没登陆 if(user == null) &#123; return "login"; &#125; //判断库存 GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if(stock &lt;= 0) &#123; model.addAttribute("errmsg", CodeMsg.MIAO_SHA_OVER.getMsg()); return "miaosha_fail"; &#125;// 从用户订单查询是否已经对这个物品下过单了 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId); if(order != null) &#123; model.addAttribute("errmsg", CodeMsg.REPEATE_MIAOSHA.getMsg()); return "miaosha_fail"; &#125; //1.减库存 2.下订单 3.写入秒杀订单 这三步是一个是事务 OrderInfo orderInfo = miaoshaService.miaosha(user, goods); model.addAttribute("orderInfo", orderInfo); model.addAttribute("goods", goods); return "order_detail"; &#125;&#125; 查订单 查询用户是否已经秒杀过该商品dao: 用 用户id和商品id 查询对应的订单123456@Mapperpublic interface OrderDao &#123; @Select("select * from miaosha_order where user_id=#&#123;userId&#125; and goods_id=#&#123;goodsId&#125;") public MiaoshaOrder getMiaoshaOrderByUserIdGoodsId(@Param("userId") long userId, @Param("goodsId") long goodsId); &#125; OrderService: controller 里判断是不是非null12345678910@Servicepublic class OrderService &#123; @Autowired OrderDao orderDao; // 根据用户ID和商品ID查找相应订单 public MiaoshaOrder getMiaoshaOrderByUserIdGoodsId(long userId, long goodsId) &#123; return orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId); &#125;&#125; 定义MiaoshaService 用于对1.减库存 2.下单 3.加入秒杀订单 包装成事务MiaoshaService的miaosha方法减库存update如果失败，后面补应该继续写入订单1234567891011121314151617181920@Servicepublic class MiaoshaService &#123; @Autowired GoodsService goodsService; @Autowired OrderService orderService; @Transactional public OrderInfo miaosha(MiaoshaUser user, GoodVo goods) &#123; //减库存 下订单 写入秒杀订单 boolean success = goodsService.reduceStock(goods); if(success)&#123; //order_info maiosha_order return orderService.createOrder(user, goods); &#125; return null; &#125;&#125; 减少库存：查找miaosha商品ID并更新数据库： 更新：通过GoodVo更新goods信息要通过GoodsDao更新数据库，一般不引入其他Service，所以引入GoodsService同理写订单不是调用OrderDao 而是 OrderService 减少库存的sql12@Update("update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;") public int reduceStock(MiaoshaGoods g); GoodsService:123456789101112131415161718192021@Servicepublic class GoodsService &#123; @Autowired GoodsDao goodsDao; // 商品列表 public List&lt;GoodVo&gt; listGoodsVo()&#123; return goodsDao.listGoodsVo(); &#125; // 商品详情 public GoodVo getGoodsVoByGoodsId(long goodsId) &#123; return goodsDao.getGoodsVoByGoodsId(goodsId); &#125; // 减库存 public boolean reduceStock(GoodVo goods) &#123; MiaoshaGoods g = new MiaoshaGoods(); g.setGooddsId(goods.getId()); int rst = goodsDao.reduceStock(g); return rst &gt; 0; &#125;&#125; 下单（生成订单）：生成订单InfoOrderServece根据User，GoodVo 拼成OrderInfo1234567891011121314151617181920212223242526272829303132333435Servicepublic class OrderService &#123; @Autowired OrderDao orderDao; // 根据用户ID和商品ID查找相应订单 public MiaoshaOrder getMiaoshaOrderByUserIdGoodsId(long userId, long goodsId) &#123; return orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId); &#125; // 根据用户和商品信息创建订单信息 @Transactional public OrderInfo createOrder(MiaoshaUser user, GoodVo goods) &#123; OrderInfo orderInfo = new OrderInfo(); orderInfo.setCreateDate(new Date()); orderInfo.setDeliveryAddrId(0L); orderInfo.setGoodsCount(1); orderInfo.setGoodsId(goods.getId()); orderInfo.setGoodsName(goods.getGoodsName()); orderInfo.setGoodsPrice(goods.getMiaoshaPrice()); orderInfo.setOrderChannel(1); orderInfo.setStatus(0); orderInfo.setUserId(user.getId()); // 数据库insert order表 mybatis成功之后会把id加到对象中 orderDao.insert(orderInfo); MiaoshaOrder miaoshaOrder = new MiaoshaOrder(); miaoshaOrder.setGoodsId(goods.getId()); miaoshaOrder.setOrderId(orderInfo.getId()); miaoshaOrder.setUserId(user.getId()); // 数据库 miaoshaOrder表 orderDao.insertMiaoshaOrder(miaoshaOrder); return orderInfo; &#125;&#125; Dao 插入两个订单并且有返回值123456789101112131415@Mapperpublic interface OrderDao &#123; // 用户id+商品id查找miaosha表订单信息 @Select("select * from miaosha_order where user_id=#&#123;userId&#125; and goods_id=#&#123;goodsId&#125;") public MiaoshaOrder getMiaoshaOrderByUserIdGoodsId(@Param("userId") long userId, @Param("goodsId") long goodsId); // 创建订单 @Insert("insert into order_info(user_id, goods_id, goods_name, goods_count, goods_price, order_channel, status, create_date)values(" + "#&#123;userId&#125;, #&#123;goodsId&#125;, #&#123;goodsName&#125;, #&#123;goodsCount&#125;, #&#123;goodsPrice&#125;, #&#123;orderChannel&#125;,#&#123;status&#125;,#&#123;createDate&#125; )") @SelectKey(keyColumn="id", keyProperty="id", resultType=long.class, before=false, statement="select last_insert_id()") public long insert(OrderInfo orderInfo); // 创建秒杀订单 @Insert("insert into miaosha_order (user_id, goods_id, order_id)values(#&#123;userId&#125;, #&#123;goodsId&#125;, #&#123;orderId&#125;)") public int insertMiaoshaOrder(MiaoshaOrder miaoshaOrder); &#125; 新建订单详情页：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀订单详情&lt;/div&gt; &lt;p th:text="$&#123;orderInfo.getId()&#125;"&gt;&lt;/p&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td th:text="$&#123;goods.goodsName&#125;" colspan="3"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="2"&gt;&lt;img th:src="@&#123;$&#123;goods.goodsImg&#125;&#125;" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;订单价格&lt;/td&gt; &lt;td colspan="2" th:text="$&#123;orderInfo.goodsPrice&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;下单时间&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(orderInfo.createDate, 'yyyy-MM-dd HH:mm:ss')&#125;" colspan="2"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;订单状态&lt;/td&gt; &lt;td &gt; &lt;span th:if="$&#123;orderInfo.status eq 0&#125;"&gt;未支付&lt;/span&gt; &lt;span th:if="$&#123;orderInfo.status eq 1&#125;"&gt;待发货&lt;/span&gt; &lt;span th:if="$&#123;orderInfo.status eq 2&#125;"&gt;已发货&lt;/span&gt; &lt;span th:if="$&#123;orderInfo.status eq 3&#125;"&gt;已收货&lt;/span&gt; &lt;span th:if="$&#123;orderInfo.status eq 4&#125;"&gt;已退款&lt;/span&gt; &lt;span th:if="$&#123;orderInfo.status eq 5&#125;"&gt;已完成&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-block" type="submit" id="payButton"&gt;立即支付&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;收货人&lt;/td&gt; &lt;td colspan="2"&gt;XXX 18812341234&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;收货地址&lt;/td&gt; &lt;td colspan="2"&gt;北京市昌平区回龙观龙博一区&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 访问：http://localhost:8080/goods/to_detail/1 会发送post带着goodId token里有用户http://localhost:8080/miaosha/do_miaosha 完成秒杀 10.JMeter测试QPS压测 打成war包放到tomcat服务器上https://jmeter.apache.org/1 压测商品列表页QPS说法：并发在1000的时候网站的QPS是1000或者500TPS 每秒钟完成了20笔订单D:\apache-jmeter-5.0\bin\jmeter.batTestPlan-右键-ADD-thread groupNumber of Thread ： 10 线程数Ramp-Up Period ： 10 用10秒把10个线程都启动起来 默认配置对线程组右键-add-Config Element -Http request default添加http和IP和端口 对线程组右键-add-sample-http请求不用填 http ip 端口方法get，path：/goods/to_list 对线程组右键-add-Listener-Aggregate Report也可以添加 Graph Results Average 平均花费时间 10msThroughput 可以当作qps 表示一秒能处理11.5个请求添加监听器 View Results in Table先把监听器都右键清空报错空指针 修改位置：UserArgumentResolver.java12345678910111213private String getCookieValue(HttpServletRequest request, String cookiName) &#123; Cookie[] cookies = request.getCookies(); // 添加空指针判断 if(cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for(Cookie cookie : cookies) &#123; if(cookie.getName().equals(cookiName)) &#123; return cookie.getValue(); &#125; &#125; return null; &#125; 线程数1000的情况下 只有 35每秒qps打开数据库服务器的top10000个线程 大概因为虚拟机所以压榨主机需要的更多 照理说应该load average会超过1多核cpu负载超过表示很多进程在等待 压测用户对象新建http requestpath：/user/info添加参数：token：ca5be550941349b7bb336f9451a41748 新建controller1234567891011@Controller@RequestMapping("/user")public class UserController &#123; private static Logger log = LoggerFactory.getLogger(GoodsController.class); @RequestMapping("/info") @ResponseBody public Result&lt;MiaoshaUser&gt; info(Model model,MiaoshaUser user)&#123; return Result.success(user); &#125;&#125; 报错消息：JedisException: Could not get a resource from the poolredis获取不到连接修改配置1234567891011# redisredis.timeout=10redis.password=123456redis.poolMaxTotal=1000redis.poolMaxIdle=500spring.redis.pool.max-wait=500# jdbcspring.datasource.maxActive=1000spring.datasource.initialSize=100spring.datasource.maxWait=60000spring.datasource.minIdle=500 不报错了 比商品列表的qps高很多，因为redis在内存 多用户token测试在Jmeter中添加CSV data set config在http请求里的参数是${userToken} 在服务器上测试jmeter1.在windows上录好jmx2.运行jmeter.sh -n -t xxx.jmx -l result.jtl3.把result.jtl导入jmeter redis压测：100个并发 100000个请求redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000123456789101112131415====== GET ====== 100000 requests completed in 2.55 seconds 100 parallel clients 3 bytes payload keep alive: 17.87% &lt;= 1 milliseconds72.82% &lt;= 2 milliseconds94.64% &lt;= 3 milliseconds97.13% &lt;= 4 milliseconds98.74% &lt;= 5 milliseconds99.65% &lt;= 6 milliseconds99.98% &lt;= 7 milliseconds100.00% &lt;= 7 milliseconds39277.30 requests per second 1秒能4w get123456[root@localhost ~]# redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100PING_INLINE: 41806.02 requests per secondPING_BULK: 41858.52 requests per secondSET: 39184.95 requests per secondGET: 41736.23 requests per secondINCR: 41876.05 requests per second 打war包1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!--编译时需要 运行时不需要--&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 修改启动类123456789101112@SpringBootApplicationpublic class MainApplication extends SpringBootServletInitializer&#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(MainApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(MainApplication.class); &#125;&#125; 命令行mvn clean package把war放到tomcat里D:\apache-tomcat-8.5.31\webapps 启动startup.bat访问http://localhost:8080/miaoshaLearn/login/to_login真实部署的时候放到ROOT下面就不需要tomcat路径了 为了方便还是打jar包war包插件改jar包的 注释掉tomcat的依赖1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 启动类还原123456@SpringBootApplicationpublic class MainApplication&#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(MainApplication.class, args); &#125;&#125; 命令行mvn clean package打开jar包 META-INF\META-INF1234Main-Class: org.springframework.boot.loader.JarLauncherStart-Class: com.cloud.miaosha.MainApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/ 上传jar包到linuxnohup java -jar miaosha.jar &amp;访问：http://10.1.18.133:8080/goods/to_list 上传jmeter和jmx文件到linux12chmod 777 jmeter.shchmod 777 jmeter 生成测试用户：用HttpURLConnection 发送post12345678910111213141516171819URL url = new URL(urlString);HttpURLConnection co = (HttpURLConnection)url.openConnection();co.setRequestMethod("POST");co.setDoOutput(true);OutputStream out = co.getOutputStream();String params = "mobile="+user.getId()+"&amp;password="+MD5Util.inputPassToFormPass("123456");out.write(params.getBytes());out.flush();InputStream inputStream = co.getInputStream();ByteArrayOutputStream bout = new ByteArrayOutputStream();byte buff[] = new byte[1024];int len = 0;while((len = inputStream.read(buff) &gt;=0))&#123; bout.write(buff,0,len);&#125;inputStream.close();bout.close();String response = new String(bout.toByteArray());//fast json解析并获取token 修改login返回token123456789@RequestMapping("/do_login")@ResponseBodypublic Result&lt;String&gt; doLogin(HttpServletResponse response,@Valid LoginVo loginVo) &#123; log.info(loginVo.toString());// 登录 String token = userService.login(response, loginVo); System.out.println("登陆成功"); return Result.success(token);&#125; dbutil123456789101112131415161718192021222324public class DBUtil &#123; private static Properties props;static &#123; try &#123; InputStream in = DBUtil.class.getClassLoader().getResourceAsStream("application.properties"); props = new Properties(); props.load(in); in.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125;&#125;public static Connection getConn() throws Exception&#123; String url = props.getProperty("spring.datasource.url"); String username = props.getProperty("spring.datasource.username"); String password = props.getProperty("spring.datasource.password"); String driver = props.getProperty("spring.datasource.driver-class-name"); Class.forName(driver); return DriverManager.getConnection(url,username, password);&#125;&#125; 删除数据库1delete from miaosha_user where nickname like 'user%'; userutil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class UserUtil &#123; private static void createUser(int count) throws Exception&#123; List&lt;MiaoshaUser&gt; users = new ArrayList&lt;MiaoshaUser&gt;(count); //生成用户 for(int i=0;i&lt;count;i++) &#123; MiaoshaUser user = new MiaoshaUser(); user.setId(13000000000L+i); user.setLoginCount(1); user.setNickname("user"+i); user.setRegisterDate(new Date()); user.setSalt("1a2b3c"); user.setPassword(MD5Util.inputPassToDbPass("123456", user.getSalt())); users.add(user); &#125; System.out.println("create user");// //插入数据库 Connection conn = DBUtil.getConn(); String sql = "insert into miaosha_user(login_count, nickname, register_date, salt, password, id)values(?,?,?,?,?,?)"; PreparedStatement pstmt = conn.prepareStatement(sql); for(int i=0;i&lt;users.size();i++) &#123; MiaoshaUser user = users.get(i); pstmt.setInt(1, user.getLoginCount()); pstmt.setString(2, user.getNickname()); pstmt.setTimestamp(3, new Timestamp(user.getRegisterDate().getTime())); pstmt.setString(4, user.getSalt()); pstmt.setString(5, user.getPassword()); pstmt.setLong(6, user.getId()); pstmt.addBatch(); &#125; pstmt.executeBatch(); pstmt.close(); conn.close(); System.out.println("insert to db"); //登录，生成token String urlString = "http://localhost:8080/login/do_login"; File file = new File("D:/miaoshaLearn/tokens.txt"); if(file.exists()) &#123; file.delete(); &#125; RandomAccessFile raf = new RandomAccessFile(file, "rw"); file.createNewFile(); raf.seek(0); for(int i=0;i&lt;users.size();i++) &#123; MiaoshaUser user = users.get(i); URL url = new URL(urlString); HttpURLConnection co = (HttpURLConnection)url.openConnection(); co.setRequestMethod("POST"); co.setDoOutput(true); OutputStream out = co.getOutputStream(); String params = "mobile="+user.getId()+"&amp;password="+MD5Util.inputPassToFormPass("123456"); out.write(params.getBytes()); out.flush(); InputStream inputStream = co.getInputStream(); ByteArrayOutputStream bout = new ByteArrayOutputStream(); byte buff[] = new byte[1024]; int len = 0; while((len = inputStream.read(buff)) &gt;= 0) &#123; bout.write(buff, 0 ,len); &#125; inputStream.close(); bout.close(); String response = new String(bout.toByteArray()); JSONObject jo = JSON.parseObject(response); String token = jo.getString("data"); System.out.println("create token : " + user.getId()); String row = user.getId()+","+token; raf.seek(raf.length()); raf.write(row.getBytes()); raf.write("\r\n".getBytes()); System.out.println("write to file : " + user.getId()); &#125; raf.close(); System.out.println("over"); &#125; public static void main(String[] args)throws Exception &#123; createUser(5000); &#125;&#125; // 1300 页面缓存 商品列表页是把html直接存在redis里,SB渲染返回页面静态化：前后端分离，通过ajax渲染页面浏览器会把html缓存在客户端，页面数据不需要重复下载，只下载动态数据 Redis 页面缓存key 一般页面缓存比较短，不然看不到页面变化1234567public class GoodsKey extends BasePrefix &#123; private GoodsKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static GoodsKey getGoodsList = new GoodsKey(60, "gl"); public static GoodsKey getGoodsDetail = new GoodsKey(60, "gd");&#125; 123456789101112131415161718192021222324252627282930@AutowiredThymeleafViewResolver thymeleafViewResolver;@AutowiredApplicationContext applicationContext;@RequestMapping(value = "/to_list",produces = "txt/html")@ResponseBodypublic String toLogin(HttpServletRequest request, HttpServletResponse response, Model model, MiaoshaUser user) &#123; model.addAttribute("user",user); // 取页面缓存 String html = redisService.get(GoodsKey.getGoodsList, "", String.class); if(!StringUtils.isEmpty(html)) &#123; return html; &#125; // 秒杀商品列表 List&lt;GoodVo&gt; goodVos = goodsService.listGoodsVo(); model.addAttribute("goodsList",goodVos); SpringWebContext ctx = new SpringWebContext(request,response, request.getServletContext(),request.getLocale(), model.asMap(), applicationContext ); //手动渲染 // 模板名称 context html = thymeleafViewResolver.getTemplateEngine().process("goods_list", ctx); // 缓存起来 if(!StringUtils.isEmpty(html)) &#123; redisService.set(GoodsKey.getGoodsList, "", html); &#125; return "goods_list";&#125; http://localhost:8080/goods/to_list连上redis 查看keys GoodsKey:gl URL缓存 详情页缓存和页面缓存一样，通过整个html用sb渲染返回，每个页面缓存时间60s12345678910111213141516171819202122232425262728293031323334353637383940414243@RequestMapping(value = "/to_detail/&#123;goodsId&#125;",produces="text/html")@ResponseBodypublic String detail(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user, @PathVariable("goodsId")long goodsId) &#123; model.addAttribute("user", user); //取缓存 String html = redisService.get(GoodsKey.getGoodsDetail, ""+goodsId, String.class); if(!StringUtils.isEmpty(html)) &#123; return html; &#125; // 读数据库的 保证刷新还是读到真实的库存 GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); model.addAttribute("goods", goods); long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); // 0：没开始 2：结束 1：进行中 int miaoshaStatus = 0; // 倒计时 int remainSeconds = 0; if(now &lt; startAt ) &#123;//秒杀还没开始，倒计时 miaoshaStatus = 0; remainSeconds = (int)((startAt - now )/1000); &#125;else if(now &gt; endAt)&#123;//秒杀已经结束 miaoshaStatus = 2; remainSeconds = -1; &#125;else &#123;//秒杀进行中 miaoshaStatus = 1; remainSeconds = 0; &#125; model.addAttribute("miaoshaStatus", miaoshaStatus); model.addAttribute("remainSeconds", remainSeconds);// return "goods_detail"; SpringWebContext ctx = new SpringWebContext(request,response, request.getServletContext(),request.getLocale(), model.asMap(), applicationContext ); html = thymeleafViewResolver.getTemplateEngine().process("goods_detail", ctx); if(!StringUtils.isEmpty(html)) &#123; redisService.set(GoodsKey.getGoodsDetail, ""+goodsId, html); &#125; return html;&#125; 对象缓存分布式session根据token从redis中拿User对象添加redis 用户id key12345678910public class MiaoshaUserKey extends BasePrefix&#123; public static final int TOKEN_EXPIRE = 3600*24 * 2; private MiaoshaUserKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static MiaoshaUserKey token = new MiaoshaUserKey(TOKEN_EXPIRE, "tk"); //永久有效 public static MiaoshaUserKey getById = new MiaoshaUserKey(0, "id");&#125; 登陆验证的时候不是从mysql按id取 而是从redis取12345678910111213public MiaoshaUser getById(long id) &#123; //取缓存 MiaoshaUser user = redisService.get(MiaoshaUserKey.getById, ""+id, MiaoshaUser.class); if(user != null) &#123; return user; &#125; //取数据库 user = miaoshaUserDao.getById(id); if(user != null) &#123; redisService.set(MiaoshaUserKey.getById, ""+id, user); &#125; return user;&#125; 修改密码： 更新数据库，再让缓存失效如果先删除缓存，数据库还没更新，又放了旧的数据在缓存里。 Cache Aside Pattern 更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching. 123456789101112131415161718public boolean updatePassword(String token, long id, String formPass) &#123; //取user MiaoshaUser user = getById(id); if(user == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //更新数据库 MiaoshaUser toBeUpdate = new MiaoshaUser(); toBeUpdate.setId(id); toBeUpdate.setPassword(MD5Util.formPassToDBPass(formPass, user.getSalt())); miaoshaUserDao.update(toBeUpdate); //以前的用户根据id取的缓存直接删掉 redisService.delete(MiaoshaUserKey.getById, ""+id); user.setPassword(toBeUpdate.getPassword()); // 为了登陆不掉，更新token，还是之前那个token redisService.set(MiaoshaUserKey.token, token, user); return true;&#125; user对象缓存应该删除。token缓存应该更新。 redisService 添加delete方法123456789101112public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125;&#125; 在dao层添加update123456789@Mapperpublic interface MiaoshaUserDao &#123; @Select("select * from miaosha_user where id = #&#123;id&#125;") public MiaoshaUser getById(@Param("id") long id); @Update("update miaosha_user set password = #&#123;password&#125; where id = #&#123;id&#125;") public void update(MiaoshaUser toBeUpdate);&#125; // to_list 接口qps 1267-&gt;2884 load 15-&gt;5 页面静态化(前后端分离)不用thymeleaf页面只有html，动态数据通过接口获取。 详情页将商品详情页包装成vo123456public class GoodsDetailVo &#123; private int miaoshaStatus = 0; private int remainSeconds = 0; private GoodsVo goods ; private MiaoshaUser user;&#125; 静态页面xhr获取后台数据&lt;a th:href=&quot;&#39;/goods_detail.htm?goodsId=&#39;+${goods.id}&quot;&gt;12345678910111213141516171819202122$(function()&#123; //countDown(); getDetail();&#125;);function getDetail()&#123; var goodsId = g_getQueryString("goodsId"); $.ajax(&#123; url:"/goods/detail/"+goodsId, type:"GET", success:function(data)&#123; if(data.code == 0)&#123; render(data.data); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; js获取url后面的参数name的值1234567// 获取url参数function g_getQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r != null) return unescape(r[2]); return null;&#125;; 成功之后的回调函数 渲染页面问题：时间不同步问题，应该定时和服务器同步一下，现在全靠自己刷新123456789101112131415161718function render(detail)&#123; var miaoshaStatus = detail.miaoshaStatus; var remainSeconds = detail.remainSeconds; var goods = detail.goods; var user = detail.user; if(user)&#123; $("#userTip").hide(); &#125; $("#goodsName").text(goods.goodsName); $("#goodsImg").attr("src", goods.goodsImg); $("#startTime").text(new Date(goods.startDate).format("yyyy-MM-dd hh:mm:ss")); $("#remainSeconds").val(remainSeconds); $("#goodsId").val(goods.id); $("#goodsPrice").text(goods.goodsPrice); $("#miaoshaPrice").text(goods.miaoshaPrice); $("#stockCount").text(goods.stockCount); countDown();&#125; 日期格式化123456789101112131415161718//设定时间格式化函数，使用new Date().format("yyyyMMddhhmmss"); Date.prototype.format = function (format) &#123; var args = &#123; "M+": this.getMonth() + 1, "d+": this.getDate(), "h+": this.getHours(), "m+": this.getMinutes(), "s+": this.getSeconds(), &#125;; if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var i in args) &#123; var n = args[i]; if (new RegExp("(" + i + ")").test(format)) format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? n : ("00" + n).substr(("" + n).length)); &#125; return format; &#125;; 页面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt;&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀商品详情&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;span id="userTip"&gt; 您还没有登录，请登陆后再操作&lt;br/&gt;&lt;/span&gt; &lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" id="goodsName"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="3"&gt;&lt;img id="goodsImg" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀开始时间&lt;/td&gt; &lt;td id="startTime"&gt;&lt;/td&gt; &lt;td &gt; &lt;input type="hidden" id="remainSeconds" /&gt; &lt;span id="miaoshaTip"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- &lt;form id="miaoshaForm" method="post" action="/miaosha/do_miaosha"&gt; &lt;button class="btn btn-primary btn-block" type="submit" id="buyButton"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" id="goodsId" /&gt; &lt;/form&gt;--&gt; &lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="doMiaosha()"&gt;立即秒杀&lt;/button&gt; &lt;input type="hidden" name="goodsId" id="goodsId" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品原价&lt;/td&gt; &lt;td colspan="3" id="goodsPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;秒杀价&lt;/td&gt; &lt;td colspan="3" id="miaoshaPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;库存数量&lt;/td&gt; &lt;td colspan="3" id="stockCount"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt; controller12345678910111213141516171819202122232425262728293031@RequestMapping(value = "/detail/&#123;goodsId&#125;")@ResponseBodypublic Result&lt;GoodsDetailVo&gt; detail(HttpServletRequest request, HttpServletResponse response, MiaoshaUser user, @PathVariable("goodsId")long goodsId) &#123; GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); long startAt = goods.getStartDate().getTime(); long endAt = goods.getEndDate().getTime(); long now = System.currentTimeMillis(); // 0：没开始 2：结束 1：进行中 int miaoshaStatus = 0; // 倒计时 int remainSeconds = 0; if(now &lt; startAt ) &#123;//秒杀还没开始，倒计时 miaoshaStatus = 0; remainSeconds = (int)((startAt - now )/1000); &#125;else if(now &gt; endAt)&#123;//秒杀已经结束 miaoshaStatus = 2; remainSeconds = -1; &#125;else &#123;//秒杀进行中 miaoshaStatus = 1; remainSeconds = 0; &#125; GoodsDetailVo vo = new GoodsDetailVo(); vo.setGoods(goods); vo.setUser(user); vo.setMiaoshaStatus(miaoshaStatus); vo.setRemainSeconds(remainSeconds); return Result.success(vo);&#125; 秒杀按钮&lt;button class=&quot;btn btn-primary btn-block&quot; type=&quot;button&quot; id=&quot;buyButton&quot;onclick=&quot;doMiaosha()&quot;&gt;立即秒杀&lt;/button&gt; 秒杀返回订单对后台数据有影响的要用post，put不能用get。因为搜索引擎遍历，执行/delete?等链接 1234567891011121314151617181920function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; window.location.href="/order_detail.htm?orderId="+data.data.id; &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 跳转到订单详情页12345678910111213141516171819202122232425262728293031323334353637@Controller@RequestMapping("/order")public class OrderController &#123; @Autowired MiaoshaUserService userService; @Autowired RedisService redisService; @Autowired OrderService orderService; @Autowired GoodsService goodsService; @RequestMapping("/detail") @ResponseBody public Result&lt;OrderDetailVo&gt; info(Model model, MiaoshaUser user, @RequestParam("orderId") long orderId) &#123; if(user == null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; OrderInfo order = orderService.getOrderById(orderId); if(order == null) &#123; return Result.error(CodeMsg.ORDER_NOT_EXIST); &#125; // 用订单的商品id 查商品信息 long goodsId = order.getGoodsId(); GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); OrderDetailVo vo = new OrderDetailVo(); vo.setOrder(order); vo.setGoods(goods); return Result.success(vo); &#125; &#125; 新建订单VO1234public class OrderDetailVo &#123; private GoodVo goods; private OrderInfo order;&#125; 新建订单页controller新的sql 用订单id查订单12345@Mapperpublic interface OrderDao &#123; @Select("select * from order_info where id = #&#123;orderId&#125;") public OrderInfo getOrderById(@Param("orderId")long orderId);&#125; 新的错误对象12//订单模块 5004XXpublic static CodeMsg ORDER_NOT_EXIST = new CodeMsg(500400, "订单不存在"); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;body&gt;&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt;秒杀订单详情&lt;/div&gt; &lt;table class="table" id="goodslist"&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td colspan="3" id="goodsName"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td colspan="2"&gt;&lt;img id="goodsImg" width="200" height="200" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;订单价格&lt;/td&gt; &lt;td colspan="2" id="orderPrice"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;下单时间&lt;/td&gt; &lt;td id="createDate" colspan="2"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;订单状态&lt;/td&gt; &lt;td id="orderStatus"&gt; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-block" type="submit" id="payButton"&gt;立即支付&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;收货人&lt;/td&gt; &lt;td colspan="2"&gt;XXX 18812341234&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;收货地址&lt;/td&gt; &lt;td colspan="2"&gt;北京市昌平区回龙观龙博一区&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;function render(detail)&#123; var goods = detail.goods; var order = detail.order; $("#goodsName").text(goods.goodsName); $("#goodsImg").attr("src", goods.goodsImg); $("#orderPrice").text(order.goodsPrice); $("#createDate").text(new Date(order.createDate).format("yyyy-MM-dd hh:mm:ss")); var status = ""; if(order.status == 0)&#123; status = "未支付" &#125;else if(order.status == 1)&#123; status = "待发货"; &#125; $("#orderStatus").text(status);&#125;$(function()&#123; getOrderDetail();&#125;)function getOrderDetail()&#123; var orderId = g_getQueryString("orderId"); $.ajax(&#123; url:"/order/detail", type:"GET", data:&#123; orderId:orderId &#125;, success:function(data)&#123; if(data.code == 0)&#123; render(data.data); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125;&lt;/script&gt; 静态化配置304是客户端（浏览器）向服务端自动加If-Modified-Since: Fri, 28 Dec 2018 11:48:23 GMT服务端会检查如果没发生变化就304.还是发生了一次交互。 让页面直接从浏览器取。Spring resources handling12345678#staticspring.resources.add-mappings=truespring.resources.cache-period= 3600spring.resources.chain.cache=true spring.resources.chain.enabled=truespring.resources.chain.gzipped=truespring.resources.chain.html-application-cache=truespring.resources.static-locations=classpath:/static/ response里200 （但其实是来自缓存）响应头里有，达到从浏览器读。Pragma是1.0的Expire带时区的（服务端）Cache-Control: max-age=3600 秒 bug1：秒杀并发库存到0以下and stock_count &gt;0code review1.判断库存2.判断用户订单3.秒杀123456789101112131415161718192021222324@RequestMapping(value = "/do_miaosha",method = RequestMethod.POST)@ResponseBodypublic Result&lt;OrderInfo&gt; list(MiaoshaUser user, @RequestParam("goodsId")long goodsId) &#123; // 没登陆 if(user == null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //判断库存 GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if(stock &lt;= 0) &#123; return Result.error(CodeMsg.MIAO_SHA_OVER); &#125;// 从用户订单查询是否已经对这个物品下过单了 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId); if(order != null) &#123; return Result.error(CodeMsg.REPEATE_MIAOSHA); &#125; //1.减库存 2.下订单 3.写入秒杀订单 这三步是一个是事务 OrderInfo orderInfo = miaoshaService.miaosha(user, goods); return Result.success(orderInfo);&#125; 减库存的sql12@Update("update miaosha_goods set stock_count = stock_count -1 where goods_id = #&#123;gooddsId&#125;")public int reduceStock(MiaoshaGoods g); 如果库存有1，两个线程同时调用这个sql就负数了 修改：只有库存&gt;0才减12@Update("update miaosha_goods set stock_count = stock_count -1 where goods_id = #&#123;gooddsId&#125; and stock_count &gt;0") public int reduceStock(MiaoshaGoods g); 因为数据库会加锁 不会两个线程同时更新 bug2：用户秒杀了多个商品:数据库唯一索引同一个用户多个请求，在没完成第一个订单之前都判断完了有库存，也没秒杀过。结果：多个线程都到减库存，下订单，生成新的秒杀订单。 数据库唯一索引，让一个用户只能有一个秒杀订单 优化：查询用户是否买过这个商品不走数据库建key1234567public class OrderKey extends BasePrefix &#123; public OrderKey( String prefix) &#123; super( prefix); &#125; public static OrderKey getMiaoshaOrderByUidGid = new OrderKey("moug");&#125; 12345// 根据用户ID和商品ID查找相应订单public MiaoshaOrder getMiaoshaOrderByUserIdGoodsId(long userId, long goodsId) &#123; return redisService.get(OrderKey.getMiaoshaOrderByUidGid,""+userId+"_"+goodsId , MiaoshaOrder.class);// return orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);&#125; 生成订单之后要写缓存12345678910// 根据用户和商品信息创建订单信息@Transactionalpublic OrderInfo createOrder(MiaoshaUser user, GoodVo goods) &#123; //... // 数据库 miaoshaOrder表 orderDao.insertMiaoshaOrder(miaoshaOrder); redisService.set(OrderKey.getMiaoshaOrderByUidGid,""+user.getId()+"_"+goods.getId(),miaoshaOrder); return orderInfo;&#125; 其他静态资源优化1.js/css压缩2.多个js/css组合成一个减少连接数3.CDN 接口优化1）redis预减库存减少数据库访问，减库存请求入消息队列，返回排队中。2）服务端：请求出队，生成订单，减库存。3）客户端轮询秒杀是否成功。 并发队列：Java的并发包提供了三个常用的并发队列实现，分别是：ConcurrentLinkedQueue 、 LinkedBlockingQueue 和 ArrayBlockingQueue。ArrayBlockingQueue是初始容量固定的阻塞队列，我们可以用来作为数据库模块成功竞拍的队列，比如有10个商品，那么我们就设定一个10大小的数组队列。ConcurrentLinkedQueue使用的是CAS原语无锁队列实现，是一个异步队列，入队的速度很快，出队进行了加锁，性能稍慢。LinkedBlockingQueue也是阻塞的队列，入队和出队都用了加锁，当队空的时候线程会暂时阻塞。由于我们的系统入队需求要远大于出队需求，一般不会出现队空的情况，所以我们可以选择ConcurrentLinkedQueue来作为我们的请求队列实现 安装 RabitMQ1.安装依赖yum install ncurses-devel2.安装erlangyum install erlang 执行erl表示安装成功3.安装rabbitmq解压xz -d rabbitmq-server-generic-unix-3.7.9.tar.xz解压tar xf rabbitmq-server-generic-unix-3.7.9.tar安装python安装yum install xmlto -y安装yum install python-simplejson -y12cd rabbitmq_server-3.7.9/cd sbin 启动然后报错yum remove掉erlang*相关的1234567tar -xf otp_src_21.0.tar.gz./configure --prefix=/usr/local/erlang20 --without-javacmake -j 8make installvim /etc/profileexport PATH=/usr/local/erlang21/bin:$PATH source /etc/profile 回到sbin启动./rabbitmq-server可以看log 端口是5672123[root@localhost sbin]# netstat -nap |grep 5672tcp 0 0 0.0.0.0:25672 0.0.0.0:* LISTEN 14205/beam.smp tcp6 0 0 :::5672 :::* LISTEN 14205/beam.smp 关闭用./rabbitmqctl stop12[root@localhost sbin]# netstat -nap |grep 5672tcp 0 0 127.0.0.1:43296 127.0.0.1:25672 TIME_WAIT - 安装lsof1234[root@localhost ebin]# lsof -i:5672COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEbeam.smp 17480 root 68u IPv6 176892 0t0 TCP *:amqp (LISTEN)beam.smp 17480 root 69u IPv6 176909 0t0 TCP localhost.localdomain:amqp-&gt;10.1.18.15:10893 (ESTABLISHED) SpringBoot 集成RabbitMQerlang有原生socket一样的延迟AMQP协议模型生产者：1.投递到server，2投递到virtual host，3投递到exchange RabbitMQ有一个消息确认机制来保证消息的不丢失：客户端从队列中取出消息之后，可能需要一段时间才能处理完成，如果在这个过程中，客户端出错了，异常退出了，而数据还没有处理完成，那么非常不幸，这段数据就丢失了，因为RabbitMQ默认会把此消息标记为已完成，然后从队列中移除，消息确认是客户端从RabbitMQ中取出消息，并处理完成之后，会发送一个ack告诉RabbitMQ，消息处理完成，当RabbitMQ收到客户端的获取消息请求之后，或标记为处理中，当再次收到ack之后，才会标记为已完成，然后从队列中删除。当RabbitMQ检测到客户端和自己断开链接之后，还没收到ack，则会重新将消息放回消息队列，交给下一个客户端处理，保证消息不丢失，也就是说，RabbitMQ给了客户端足够长的时间来做数据处理。 exchange 和 message queue 有绑定关系。 核心概念： Server：Broker。接受连接。 Connection:应用与Broker的网络连接。 Channel：网络信道，一个会话任务。一个客户端可以建立多个channel。 Message：消息结构由Properties（优先级，延迟）和Body组成。 Virtual host：逻辑隔离，消息路由，划分服务。一个host里可以有多个exchange和queue。同一个host不能有同名的exchange和queue。（相当于redis 16个db的逻辑概念） Exchange：交换机，接受消息，根据路由键转发消息到binding的队列。 Binding：Exchange和Queue的虚拟连接，可以有routing key。 Routing key：路由规则。host确定如何路由一个消息。 Queue:保存并转发给消费者。 核心配置文件位置：vi /usr/local/rabbitmq_server-3.7.9/ebin/rabbit.apploopback_users也在里面 可以修改成[guest] rabbitMQ插件 可视化管理12rabbitmq-plugins listrabbitmq-plugins enable rabbitmq_management 访问：http://10.1.18.20:15672/ 1 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 2 添加配置123456789101112131415161718192021#rabbitmqspring.rabbitmq.host=10.1.18.20spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#从队列里每次取几个spring.rabbitmq.listener.simple.prefetch= 1#消费者默认自动启动spring.rabbitmq.listener.simple.auto-startup=true# 消费失败会重新压入队列spring.rabbitmq.listener.simple.default-requeue-rejected= true#生产者重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000 spring.rabbitmq.template.retry.max-attempts=3spring.rabbitmq.template.retry.max-interval=10000spring.rabbitmq.template.retry.multiplier=1.0 新建rabbitmq包， 交换机的4种模式 Direct 模式配置类12345678910import org.springframework.amqp.core.Queue;@Configurationpublic class MQConfig &#123; public static final String QUEUE = "queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125;&#125; 新建发送者1234567891011@Servicepublic class MQSender &#123; @Autowired AmqpTemplate amqpTemplate; public void send(Object message)&#123; String msg = RedisService.beanToString(message); amqpTemplate.convertAndSend(MQConfig.QUEUE,msg); &#125;&#125; 重用redis中bean2String的方法123456789101112131415public static &lt;T&gt; String beanToString(T value)&#123; //2. 添加空判断 if(value == null)return null; //3. 如果是数字，字符串，Long Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125;&#125; String2Bean1234567891011121314151617public static &lt;T&gt; T stringToBean(String str,Class&lt;T&gt; clazz)&#123; //1. 参数校验 if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //2 如果是int，string，Long if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; //fastJson 其他List类型要再写 return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125;&#125; 消费者监听轮询12345678910111213@Servicepublic class MQSender &#123; private static Logger log = LoggerFactory.getLogger(MQSender.class); @Autowired AmqpTemplate amqpTemplate; public void send(Object message)&#123; String msg = RedisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQConfig.QUEUE,msg); &#125;&#125; 随便用一个controller测试一下123456@RequestMapping("/mq")@ResponseBodypublic Result&lt;String&gt; mq()&#123; sender.send("rabbitMQ消息测试"); return Result.success("rabbitMQ消息测试");&#125; 报错：1rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile. 因为guest用户默认不能远程连接 localhost是可以的https://www.rabbitmq.com/access-control.htmlit can only connect over a loopback interface (i.e. localhost). 用方法2修改rabbitmq.config在/usr/local/rabbitmq_server-3.7.9/etc/rabbitmq下创建rabbitmq.config添加[{rabbit, [{loopback_users, []}]}]. 重启12rabbitmqctl stoprabbitmq-server 访问http://localhost:8080/demo/mq 可以看到log Topic模式 可以发给多个queue1234567891011121314151617181920212223242526272829303132333435363738394041@Configurationpublic class MQConfig &#123; public static final String QUEUE = "queue"; public static final String TOPIC_QUEUE1 = "topic_queue1"; public static final String TOPIC_QUEUE2 = "topic_queue2"; public static final String TOPIC_EXCHANGE = "topic_queue2"; public static final String ROUTING_KEY1 = "topic.key1"; //* 表示一个单词。 #表示0个或者多个单词 public static final String ROUTING_KEY2 = "topic.#"; // 直接模式 @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; // topic模式 @Bean public Queue topicQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(ROUTING_KEY1); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(ROUTING_KEY2); &#125;&#125; 发送：12345678910111213141516171819202122@Servicepublic class MQSender &#123; private static Logger log = LoggerFactory.getLogger(MQSender.class); @Autowired AmqpTemplate amqpTemplate; public void send(Object message)&#123; String msg = RedisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQConfig.QUEUE,msg); &#125; public void sendTopic(Object message)&#123; String msg = RedisService.beanToString(message); log.info("send topic message"+msg); // queue1和2都能匹配上都能收到 amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,MQConfig.ROUTING_KEY1,msg+"1"); // 只有queue2能匹配上 amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE,MQConfig.ROUTING_KEY2,msg+"2"); &#125;&#125; 接收：1234567891011121314151617181920@Servicepublic class MQReceiver &#123; private static Logger log = LoggerFactory.getLogger(MQSender.class); @RabbitListener(queues = MQConfig.QUEUE) public void receive(String message)&#123; log.info("receive message:"+message); &#125; @RabbitListener(queues = MQConfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive q1 message:"+message); &#125; @RabbitListener(queues = MQConfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive q2 message:"+message); &#125;&#125; 1234567@RequestMapping("/mq/topic")@ResponseBodypublic Result&lt;String&gt; topic()&#123; // 发两条消息 sender.sendTopic("topic消息测试"); return Result.success("topic消息测试");&#125; 结果 Fanout模式 广播模式 不需要绑定key 12345678910111213// 广播模式 广播交换机@Beanpublic FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE);&#125;@Beanpublic Binding FanoutBinding1()&#123; return BindingBuilder.bind(topicQueue1()).to(fanoutExchange());&#125;@Beanpublic Binding FanoutBinding2()&#123; return BindingBuilder.bind(topicQueue2()).to(fanoutExchange());&#125; 123456public void sendFanout(Object message)&#123; String msg = RedisService.beanToString(message); log.info("send topic message"+msg); // queue1和2都能都能收到 amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE,"",msg+"1");&#125; 123456@RequestMapping("/mq/fanout")@ResponseBodypublic Result&lt;String&gt; fanout()&#123; sender.sendFanout("广播 消息测试"); return Result.success("广播消息测试");&#125; Header模式MQConfig123456789101112131415161718// Header模式@Beanpublic HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADER_EXCHANGE);&#125;@Beanpublic Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true);&#125;@Beanpublic Binding headerBinding()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("header1","value1" ); map.put("header2","value2" ); return BindingBuilder.bind(headerQueue()).to(headersExchange()).whereAll(map).match();&#125; sender123456789public void sendHeader(Object message)&#123; String msg = RedisService.beanToString(message); log.info("send header message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1" ); properties.setHeader("header2","value2" ); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQConfig.HEADER_EXCHANGE,obj);&#125; receiver1234@RabbitListener(queues = MQConfig.HEADER_QUEUE)public void receiveHeader(byte[] message)&#123; log.info("receive q2 message:"+ new String(message));&#125; controller测试123456@RequestMapping("/mq/header")@ResponseBodypublic Result&lt;String&gt; header()&#123; sender.sendHeader("header 消息测试"); return Result.success("header消息测试");&#125; 秒杀接口优化 同步下单-&gt;异步下单秒杀review：1234567891011121314151617181920212223242526@AutowiredMiaoshaService miaoshaService;@RequestMapping(value = "/do_miaosha",method = RequestMethod.POST)@ResponseBodypublic Result&lt;OrderInfo&gt; list(MiaoshaUser user, @RequestParam("goodsId")long goodsId) &#123; // 没登陆 if(user == null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //判断库存（读数据库） GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if(stock &lt;= 0) &#123; return Result.error(CodeMsg.MIAO_SHA_OVER); &#125;// （redis） 从用户订单查询是否已经对这个物品下过单了 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId); if(order != null) &#123; return Result.error(CodeMsg.REPEATE_MIAOSHA); &#125; //1.减库存 update 2.下订单 insert 3.写入秒杀订单 insert 这三步是一个是事务 OrderInfo orderInfo = miaoshaService.miaosha(user, goods); return Result.success(orderInfo);&#125; 判断库存要读数据库，下单减库存update生成订单两个insert，一共要3次数据库。思路：1)减少数据库访问，将系统初始化时，将库存数量加载到redis。2)redis预减库存，如果redis里库存没有直接返回。3)否则【异步下单】放到消息队列，返回排队中。4)请求出队，生成订单，减少库存。5)客户端轮询是否秒杀成功。 启动时将库存加载到redis：框架会回调，实现的方法。让Bean实现InitializingBean定义初始化逻辑，会被后置处理器在bean初始化之后执行1234567891011@Controller@RequestMapping("/miaosha")public class MiaoshaController implements InitializingBean&#123;// 系统初始化 读数据库库存，写到redis @Override public void afterPropertiesSet() throws Exception &#123; // 查询出所有商品数量 List&lt;GoodVo&gt; goodslist = goodsService.listGoodsVo(); if(goodslist!=null)&#123; for(GoodVo goods : goodslist)&#123; redisService.set(GoodsKey.getMiaoshaGoodsStock,""+goods.getId() ,goods.getStockCount() );&#125;&#125;&#125;&#125; 设置库存的rediskey123456789public class GoodsKey extends BasePrefix &#123; private GoodsKey(int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static GoodsKey getGoodsList = new GoodsKey(60, "gl"); public static GoodsKey getGoodsDetail = new GoodsKey(60, "gd"); // 添加 预加载库存key public static GoodsKey getMiaoshaGoodsStock= new GoodsKey(0, "gs");&#125; 队列中的消息格式：（秒杀）用户，商品idrabbitmq/MiaoshaMessage.java1234public class MiaoshaMessage &#123; private MiaoshaUser user; private long goodsId;&#125; 新的秒杀controller流程：12345678910111213141516171819202122232425262728293031@AutowiredRedisService redisService;@AutowiredMiaoshaSender sender;@AutowiredMiaoshaService miaoshaService;@RequestMapping(value = "/do_miaosha",method = RequestMethod.POST)@ResponseBodypublic Result&lt;Integer&gt; list(MiaoshaUser user, @RequestParam("goodsId")long goodsId) &#123; // 没登陆 if(user == null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; // redis中预减库存 Long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, "" + goodsId); if(stock &lt; 0)&#123; return Result.error(CodeMsg.MIAO_SHA_OVER); &#125;// 从用户订单查询是否已经对这个物品下过单了 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId); if(order != null) &#123; return Result.error(CodeMsg.REPEATE_MIAOSHA); &#125; // 入队 MiaoshaMessage msg = new MiaoshaMessage(); msg.setUser(user); msg.setGoodsId(goodsId); sender.sendMiaoshaMessage(msg); return Result.success(0);&#125; config12345678910@Configurationpublic class MiaoshaMQConfig &#123; public static final String MIAOSHA_QUEUE = "miaosha.queue"; // 直接模式 @Bean public Queue miaoshaQueue()&#123; return new Queue(MIAOSHA_QUEUE,true); &#125;&#125; sender：1234567891011121314@Servicepublic class MiaoshaSender &#123; private static Logger log = LoggerFactory.getLogger(MQSender.class); @Autowired AmqpTemplate amqpTemplate; public void sendMiaoshaMessage(MiaoshaMessage message) &#123; // direct模式 String msg = RedisService.beanToString(message); log.info("send message: "+msg); amqpTemplate.convertAndSend(MiaoshaMQConfig.MIAOSHA_QUEUE,msg); &#125;&#125; reveicer ：减库存 创建订单12345678910111213141516171819202122232425262728293031323334@Servicepublic class MiaoshaReceiver &#123; @Autowired GoodsService goodsService; @Autowired OrderService orderService; @Autowired MiaoshaService miaoshaService; private static Logger log = LoggerFactory.getLogger(MiaoshaMQConfig.class); @RabbitListener(queues = MQConfig.MIAOSHA_QUEUE) public void maishaReceive(String message)&#123; log.info("receive message:"+message); MiaoshaMessage msg = RedisService.stringToBean(message, MiaoshaMessage.class); long goodsId = msg.getGoodsId(); MiaoshaUser user = msg.getUser(); // 判断真的库存 GoodVo goods = goodsService.getGoodsVoByGoodsId(goodsId); int stock = goods.getStockCount(); if(stock &lt;= 0) &#123; return; &#125; // 判断秒杀过没有 MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId); if(order != null) &#123; return; &#125; //1.减库存 2.下订单 3.写入秒杀订单 这三步是一个是事务 OrderInfo orderInfo = miaoshaService.miaosha(user, goods); &#125;&#125; 客户端轮询后台添加轮询接口MiaoshaController12345678910111213141516// 客户端轮询接口 判断是否秒杀到/* orderID:成功 -1：秒杀失败 0：排队中 */@RequestMapping(value = "/result",method = RequestMethod.GET)@ResponseBodypublic Result&lt;Long&gt; miaoshaResult(Model model,MiaoshaUser user,@RequestParam("goodsId")long goodsId)&#123; model.addAttribute("user",user); if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; long rst = miaoshaService.getMiaoshaResult(user.getId(),goodsId); return Result.success(rst);&#125; 轮询方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Servicepublic class MiaoshaService &#123; @Autowired GoodsService goodsService; @Autowired OrderService orderService; @Autowired RedisService redisService; @Transactional public OrderInfo miaosha(MiaoshaUser user, GoodVo goods) &#123; //减库存 下订单 写入秒杀订单 boolean success = goodsService.reduceStock(goods); if(success)&#123; //order_info maiosha_order return orderService.createOrder(user, goods); &#125;else&#123; // 如果失败 说明秒杀失败 做标记 防止一直轮询 setGoodsOver(goods.getId()); return null; &#125; &#125; public long getMiaoshaResult(Long userid, long goodsId) &#123; MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(userid, goodsId); // 订单不空，秒杀成功 if(order != null)&#123; return order.getOrderId(); &#125;else&#123; // 判断是排队中还是失败了 boolean isOver = getGoodsOver(goodsId); if(isOver) &#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125; private void setGoodsOver(Long goodsId) &#123; redisService.set(MiaoshaKey.isGoodsOver, ""+goodsId, true); &#125; private boolean getGoodsOver(long goodsId) &#123; return redisService.exists(MiaoshaKey.isGoodsOver, ""+goodsId); &#125;&#125; 用redis添加秒杀完库存的标记，防止一直轮询，判断是排队中还是秒杀完了。123456public class MiaoshaKey extends BasePrefix&#123; private MiaoshaKey(String prefix) &#123; super(prefix); &#125; public static MiaoshaKey isGoodsOver = new MiaoshaKey("go"); 前端轮询：goods_detail.htm详情页中的秒杀按钮1&lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="doMiaosha()"&gt;立即秒杀&lt;/button&gt; 添加排队 并用get轮询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function doMiaosha()&#123; $.ajax(&#123; url:"/miaosha/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; // 成功 排队中 轮询 getMiaoshaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;); &#125;function getMiaoshaResult(goodsId) &#123; // 加载中的动画 g_showLoading(); $.ajax(&#123; url: "/miaosha/result", type: "GET", data: &#123; goodsId: $("#goodsId").val(), &#125;, success: function (data) &#123; //成功 if (data.code == 0) &#123; var result = data.data; // -1失败 if (result &lt; 0) &#123; layer.msg("对不起，秒杀失败"); &#125; //0排队继续轮询 else if (result == 0) &#123; setTimeout(function () &#123; getMiaoshaResult(goodsId); &#125;, 50); &#125; // 成功返回订单id else &#123; layer.confirm("恭喜你，秒杀成功！查看订单？", &#123;btn: ["确定", "取消"]&#125;, function () &#123; window.location.href = "/order_detail.htm?orderId=" + result; &#125;, function () &#123; layer.closeAll(); &#125;); &#125; &#125; else &#123; layer.msg(data.msg); &#125; &#125;, error: function () &#123;layer.msg("客户端请求有误");&#125; &#125;);&#125; 清理redis123redis-cliflushdbkeys * 测试秒杀ok 优化点 减少预减库存预减库存code review：12345// redis中预减库存Long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, "" + goodsId);if(stock &lt; 0)&#123; return Result.error(CodeMsg.MIAO_SHA_OVER);&#125; 如果库存本来有10个，有13个请求，库存减少成负的的操作都没必要访问redis。 内存标记，减少redis访问12345678910111213141516171819202122232425262728293031323334353637// 结束标记 &lt;商品ID,是否秒杀结束&gt;private Map&lt;Long,Boolean&gt; localOverMap = new HashMap&lt;Long, Boolean&gt;();// 系统初始化 读数据库库存，写到redis@Overridepublic void afterPropertiesSet() throws Exception &#123; List&lt;GoodVo&gt; goodslist = goodsService.listGoodsVo(); if(goodslist!=null)&#123; for(GoodVo goods : goodslist)&#123; redisService.set(GoodsKey.getMiaoshaGoodsStock,""+goods.getId() ,goods.getStockCount() ); // 初始化所有商品都没结束 localOverMap.put(goods.getId(), false); &#125; &#125;&#125;@AutowiredMiaoshaService miaoshaService;@RequestMapping(value = "/do_miaosha",method = RequestMethod.POST)@ResponseBodypublic Result&lt;Integer&gt; list(MiaoshaUser user, @RequestParam("goodsId")long goodsId) &#123; //... // 判断商品结束标记 Boolean over = localOverMap.get(goodsId); if(over)&#123; return Result.error(CodeMsg.MIAO_SHA_OVER); &#125; // redis中预减库存 Long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, "" + goodsId); if(stock &lt; 0)&#123; localOverMap.put(goodsId, true); return Result.error(CodeMsg.MIAO_SHA_OVER); &#125; //...&#125; 重置操作：123456789101112131415161718@RequestMapping(value="/reset", method=RequestMethod.GET)@ResponseBodypublic Result&lt;Boolean&gt; reset(Model model) &#123; List&lt;GoodVo&gt; goodsList = goodsService.listGoodsVo(); for(GoodVo goods : goodsList) &#123; // 库存还原成10个 goods.setStockCount(10); // redis中库存也变成10个 redisService.set(GoodsKey.getMiaoshaGoodsStock, ""+goods.getId(), 10); // 内存变量 所有商品重置成没结束 localOverMap.put(goods.getId(), false); &#125; // 删除用户订单和秒杀标记缓存 redisService.delete(OrderKey.getMiaoshaOrderByUidGid); redisService.delete(MiaoshaKey.isGoodsOver); miaoshaService.reset(goodsList); return Result.success(true);&#125; 根据前缀删除redis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125;public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; keys.addAll(result); &#125; //再处理cursor cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;&#125; mysql数据库中删除订单1234public void reset(List&lt;GoodVo&gt; goodsList) &#123; goodsService.resetStock(goodsList); orderService.deleteOrders();&#125; dao：12345@Delete("delete from order_info")public void deleteOrders();@Delete("delete from miaosha_order")public void deleteMiaoshaOrders(); 对/miaosha/do_miaosha压测5000个线程10次 一共5w个请求在服务器上测试jmeter1.在windows上录好jmx…2.运行jmeter.sh -n -t xxx.jmx -l result.jtl3.把result.jtl导入jmeter 压测QPS-&gt;2000 nginx 横向扩展（反向代理proxy_pass)配置多台服务器负载均衡 weightnginx 缓存https://linux.cn/article-5945-1.html1234proxy_cache_path /usr/local/nginx/proxy_cache levels=1:2 keys_zone=my_cache:200m inactive=1d max_size=20g;proxy_ignore_headers x-Accel-Expires Expires Cache-Control;proxy_hide_header Cache-Control;proxy_hide_header Pragma; LVS负载均衡 已经在linux内核里了浏览器-LVS-n个nginx-nn个tomcat 安全优化秒杀接口地址隐藏请求服务端秒杀地址，动态生成的方法：秒杀接口带上PathVariable，@RequestMapping(value = &quot;/{path}/do_miaosha&quot; 前端秒杀按钮获取地址1&lt;button class="btn btn-primary btn-block" type="button" id="buyButton"onclick="getmiaoshaPath()"&gt;立即秒杀&lt;/button&gt; 后台path接口：新建redis key保存随机path，并且设置有效期123456private MiaoshaKey( int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; public static MiaoshaKey isGoodsOver = new MiaoshaKey(0,"go"); public static MiaoshaKey getMiaoshaPath = new MiaoshaKey(60, "mp");&#125; 随机生成path，每个用户，每个商品地址不一样 保存到redis12345678910@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getMiaoShaPath(Model model,MiaoshaUser user,@RequestParam("goodsId")long goodsId)&#123; model.addAttribute("user",user); if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; String path = miaoshaService.createMiaoshaPath(user,goodsId); return Result.success(path);&#125; path生成service方法12345public String createMiaoshaPath(MiaoshaUser user,long goodsId) &#123; String str = MD5Util.md5(UUIDUtil.uuid()+"123456"); redisService.set(MiaoshaKey.getMiaoshaPath,"" +user.getId()+"_"+goodsId,str ); return str;&#125; 秒杀接口添加path变量添加非法请求key result/CodeMsg.java1public static CodeMsg REQUEST_ILLEGAL = new CodeMsg(500102, "请求非法"); 1234567891011121314151617@AutowiredMiaoshaService miaoshaService;@RequestMapping(value = "/&#123;path&#125;/do_miaosha",method = RequestMethod.POST)@ResponseBodypublic Result&lt;Integer&gt; list(MiaoshaUser user, @RequestParam("goodsId")long goodsId, @PathVariable("path")String path) &#123; // 没登陆 if(user == null) &#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; //验证path boolean check = miaoshaService.checkPath(user,goodsId,path); if(!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; 1234567public boolean checkPath(MiaoshaUser user, long goodsId, String path) &#123; if(user == null || path == null)&#123; return false; &#125; String pathRec = redisService.get(MiaoshaKey.getMiaoshaPath, "" + user.getId() + "_" + goodsId, String.class);ath return path.equals(pathRec);&#125; 前端的获取path的xhr方法，并且拼接后继续xhr doMiaosha()1234567891011121314151617181920212223242526272829303132333435363738394041function getMiaoshaPath()&#123; var goodsId=$("#goodsId").val(); // 加载中的动画 g_showLoading(); $.ajax(&#123; url: "/miaosha/path", type: "GET", data: &#123; goodsId: goodsId &#125;, success:function (data) &#123; if(data.code == 0)&#123; var path = data.data; doMiaosha(path) &#125;else &#123; layer.msg(data.msg); &#125; &#125;, error:function () &#123;layer.msg("客户端请求有误");&#125; &#125;);&#125;function doMiaosha(path)&#123; $.ajax(&#123; url:"/miaosha/"+path+"/do_miaosha", type:"POST", data:&#123; goodsId:$("#goodsId").val(), &#125;, success:function(data)&#123; if(data.code == 0)&#123; // 成功 排队中 轮询 getMiaoshaResult($("#goodsId").val()); &#125;else&#123; layer.msg(data.msg); &#125; &#125;, error:function()&#123; layer.msg("客户端请求有误"); &#125; &#125;);&#125; 完成动态获取秒杀path再秒杀 数学公式验证码点击秒杀之前先输入验证码ScriptEngine java中可以使用js v8 前端验证码：1234567&lt;div class="row"&gt; &lt;div class="form-inline"&gt; &lt;img id="verifyCodeImg" width="80" height="32" style="display:none" onclick="refreshVerifyCode()"/&gt; &lt;input id="verifyCode" class="form-control" style="display:none"/&gt; &lt;button class="btn btn-primary" type="button" id="buyButton"onclick="getMiaoshaPath()"&gt;立即秒杀&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 页面初始化渲染render完页面后，在countDown方法里，生成验证码123456789101112131415161718192021222324252627function countDown()&#123; var remainSeconds = $("#remainSeconds").val(); var timeout; if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀倒计时："+remainSeconds+"秒"); timeout = setTimeout(function()&#123; $("#countDown").text(remainSeconds - 1); $("#remainSeconds").val(remainSeconds - 1); countDown(); &#125;,1000); &#125;else if(remainSeconds == 0)&#123;//秒杀进行中 $("#buyButton").attr("disabled", false); if(timeout)&#123; clearTimeout(timeout); &#125; $("#miaoshaTip").html("秒杀进行中"); $("#verifyCodeImg").attr("src","/miaosha/verifyCode?goodsId="+$("#goodsId").val()); $("#verifyCodeImg").show(); $("#verifyCode").show(); &#125;else&#123;//秒杀已经结束 $("#buyButton").attr("disabled", true); $("#miaoshaTip").html("秒杀已经结束"); $("#verifyCodeImg").hide(); $("#verifyCode").hide(); &#125;&#125; 后台验证码接口 生成验证码后台验证码redis key1public static MiaoshaKey getMiaoshaVerifyCode = new MiaoshaKey(300, "vc"); 添加秒杀失败msg1public static CodeMsg MIAOSHA_FAIL = new CodeMsg(500502, "秒杀失败"); 验证码接口 直接写到output上123456789101112131415161718@RequestMapping(value = "/verifyCode",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getVerifyCode(HttpServletResponse response, MiaoshaUser user, @RequestParam("goodsId")long goodsId)&#123; if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; BufferedImage image = miaoshaService.createVerifyCode(user,goodsId); try&#123; OutputStream out = response.getOutputStream(); ImageIO.write(image, "JPEG", out); out.flush(); out.close(); return null; &#125; catch (Exception e) &#123; e.printStackTrace(); return Result.error(CodeMsg.SESSION_ERROR); &#125;&#125; service：用Graphics生成图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public BufferedImage createVerifyCode(MiaoshaUser user, long goodsId) &#123; if(user == null || goodsId &lt;=0)&#123; return null; &#125; int width = 80; int height = 32; //create the image BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); // set the background color g.setColor(new Color(0xDCDCDC)); g.fillRect(0, 0, width, height); // draw the border g.setColor(Color.black); g.drawRect(0, 0, width - 1, height - 1); // create a random instance to generate the codes Random rdm = new Random(); // make some confusion for (int i = 0; i &lt; 50; i++) &#123; int x = rdm.nextInt(width); int y = rdm.nextInt(height); g.drawOval(x, y, 0, 0); &#125; // 生成随机验证码 保存到key为用户,商品id用于用户输入的验证 String verifyCode = generateVerifyCode(rdm); g.setColor(new Color(0, 100, 0)); g.setFont(new Font("Candara", Font.BOLD, 24)); g.drawString(verifyCode, 8, 24); g.dispose(); //把验证码存到redis中 int rnd = calc(verifyCode); redisService.set(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+","+goodsId, rnd); //输出图片 return image;&#125;// 计算表达式的结果private static int calc(String exp) &#123; try&#123; ScriptEngineManager manger = new ScriptEngineManager(); ScriptEngine engine = manger.getEngineByName("JavaScript"); return (Integer)engine.eval(exp); &#125;catch (Exception e)&#123; e.printStackTrace(); return 0; &#125;&#125;private static char[] ops = new char[] &#123;'+', '-', '*'&#125;;// 加减乘的验证码private String generateVerifyCode(Random rdm) &#123; int num1 = rdm.nextInt(10); int num2 = rdm.nextInt(10); int num3 = rdm.nextInt(10); char op1 = ops[rdm.nextInt(3)]; char op2 = ops[rdm.nextInt(3)]; String exp = ""+ num1 + op1 + num2 + op2 + num3; return exp;&#125; 已经可以显示了 添加点击事件重新渲染验证码, 注意浏览器图片缓存1&lt;img id="verifyCodeImg" width="80" height="32" style="display:none" onclick="refreshVerifyCode()"/&gt; 123function refreshVerifyCode()&#123; $("#verifyCodeImg").attr("src", "/miaosha/verifyCode?goodsId="+$("#goodsId").val()+"&amp;timestamp="+new Date().getTime());&#125; 点击秒杀 获取秒杀地址之前校验验证码修改后台path接口，1234567891011121314151617@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getMiaoShaPath(Model model,MiaoshaUser user, @RequestParam("goodsId")long goodsId, @RequestParam("verifyCode")int verify)&#123; model.addAttribute("user",user); if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; boolean check = miaoshaService.checkVerifyCode(user,goodsId,verify); if(!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = miaoshaService.createMiaoshaPath(user,goodsId); return Result.success(path);&#125; service：123456789101112public boolean checkVerifyCode(MiaoshaUser user, long goodsId, int verify) &#123; if(user == null || goodsId &lt;=0)&#123; return false; &#125; Integer codeOld = redisService.get(MiaoshaKey.getMiaoshaVerifyCode, user.getId() + "," + goodsId, Integer.class); if(codeOld == null || codeOld - verify != 0)&#123; return false; &#125; // 从redis删除 否则还可以用 redisService.delete(MiaoshaKey.getMiaoshaVerifyCode, user.getId() + "," + goodsId); return true;&#125; 前端获取path的时候传入 输入的验证码1234567891011121314151617181920212223function getMiaoshaPath()&#123; var goodsId=$("#goodsId").val(); // 加载中的动画 g_showLoading(); $.ajax(&#123; url: "/miaosha/path", type: "GET", data: &#123; goodsId: goodsId, verifyCode: $("#verifyCode").val() &#125;, success:function (data) &#123; if(data.code == 0)&#123; var path = data.data; doMiaosha(path) &#125;else &#123; layer.msg(data.msg); &#125; &#125;, error:function () &#123;layer.msg("客户端请求有误");&#125; &#125;);&#125; 可以删除全部的Model了因为前后端分离了。 接口限流防止有用户写前端写for循环xhr用缓存的有效期,key是用户访问的地址+用户id新建限流key123456789public class AccessKey extends BasePrefix &#123; private AccessKey( int expireSeconds, String prefix) &#123; super(expireSeconds, prefix); &#125; // 比枚举好 因为可以new一个动态参数的 public static AccessKey withExpire(int expireSeconds) &#123; return new AccessKey(expireSeconds, "access"); &#125;&#125; request里的getURI/miaosha/path：the part of this request’s URL from the protocol name up to the query string in the first line of the HTTP request.getURLhttp://localhost:8022/miaosha/path：The returned URL contains a protocol, server name, port number, and server path, but it does not include query string parameters. 添加访问太频繁的错误1public static CodeMsg ACCESS_LIMIT_REACHED= new CodeMsg(500104, "访问太频繁！"); 12345678910111213141516171819202122232425262728@RequestMapping(value = "/path",method = RequestMethod.GET)@ResponseBodypublic Result&lt;String&gt; getMiaoShaPath(HttpServletRequest request,MiaoshaUser user, @RequestParam("goodsId")long goodsId, @RequestParam(value = "verifyCode",defaultValue = "0")int verify)&#123; if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; String uri = request.getRequestURI(); //限流 String acKey = uri + "_" + user.getId(); Integer count = redisService.get(AccessKey.withExpire(5), acKey, Integer.class); if(count == null)&#123; redisService.set(AccessKey.withExpire(5), acKey, 1); &#125;else if(count &lt; 5)&#123; redisService.incr(AccessKey.withExpire(5), acKey); &#125;else&#123; return Result.error(CodeMsg.ACCESS_LIMIT_REACHED); &#125; // 验证码 boolean check = miaoshaService.checkVerifyCode(user,goodsId,verify); if(!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = miaoshaService.createMiaoshaPath(user,goodsId); return Result.success(path);&#125; 使用拦截器（注解）抽取限流功能（因为不是业务代码）实现效果:5秒最多访问5次 需要登陆@AccessLimit(seconds=5, maxCount=5, needLogin=true) 新建access包新建注解1234567@Retention(RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 新建拦截器顺便解析用户保存到线程 并更新之前 ArgumentResolver参数解析器实现的登陆拦截器比参数解析先执行，一个请求接收到之后是一个线程在执行。拦截器实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Servicepublic class AccessIntercepter extends HandlerInterceptorAdapter&#123; @Autowired MiaoshaUserService userService; @Autowired RedisService redisService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(handler instanceof HandlerMethod)&#123; // 1. 取用户 MiaoshaUser user = getUser(request, response); // 2. 用户存到threadlocal UserContext.setUser(user); // 3. 获取注解参数 HandlerMethod hm = (HandlerMethod)handler; AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); if(accessLimit == null)&#123; return true; &#125; int second = accessLimit.seconds(); int maxcount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); // 限制访问的key String key = request.getRequestURI(); // 如果用户没登陆 if(needLogin)&#123; if(user == null)&#123; render(response, CodeMsg.SESSION_ERROR); return false; &#125; // 如果需要登陆 key + 用户id key += "_"+user.getId(); &#125; // else key就只有path AccessKey ak = AccessKey.withExpire(5); Integer count = redisService.get(ak, key, Integer.class); if(count == null)&#123; redisService.set(ak, key, 1); &#125;else if(count &lt; maxcount)&#123; redisService.incr(ak, key); &#125;else&#123; render(response, CodeMsg.ACCESS_LIMIT_REACHED); return false; &#125; &#125; return false; &#125; private void render(HttpServletResponse response, CodeMsg cm)throws Exception &#123; response.setContentType("application/json;charset=UTF-8"); OutputStream out = response.getOutputStream(); String str = JSON.toJSONString(Result.error(cm)); out.write(str.getBytes("UTF-8")); out.flush(); out.close(); &#125; private MiaoshaUser getUser(HttpServletRequest request, HttpServletResponse response) &#123; String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123; return null; &#125; String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken; return userService.getByToken(response, token); &#125; private String getCookieValue(HttpServletRequest request, String cookiName) &#123; Cookie[] cookies = request.getCookies(); if(cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for(Cookie cookie : cookies) &#123; if(cookie.getName().equals(cookiName)) &#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; WebConfig中注册拦截器：12345678910111213141516171819@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolver userArgumentResolver; @Autowired AccessIntercepter accessIntercepter; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(accessIntercepter); &#125; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 在拦截器里就解析用户并保存到线程：12345678910public class UserContext &#123; private static ThreadLocal&lt;MiaoshaUser&gt; userHolder = new ThreadLocal&lt;MiaoshaUser&gt;(); public static void setUser(MiaoshaUser user) &#123; userHolder.set(user); &#125; public static MiaoshaUser getUser() &#123; return userHolder.get(); &#125;&#125; 之前的参数解析器，直接从线程中获取12345678910111213141516@Servicepublic class UserArgumentResolver implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; public boolean supportsParameter(MethodParameter parameter) &#123; // 获取参数类型 是User类型才会做resolveArgument Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz==MiaoshaUser.class; &#125; public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; return UserContext.getUser(); &#125;&#125; 最后注解使用结果123456789101112131415161718192021@AccessLimit(seconds = 5,maxCount = 5,needLogin = true) @RequestMapping(value = "/path",method = RequestMethod.GET) @ResponseBody public Result&lt;String&gt; getMiaoShaPath(HttpServletRequest request, MiaoshaUser user, @RequestParam("goodsId")long goodsId, @RequestParam("verifyCode")int verify)&#123; if(user == null)&#123; return Result.error(CodeMsg.SESSION_ERROR); &#125; String uri = request.getRequestURI(); System.out.println("uri"+uri); System.out.println("url"+request.getRequestURL()); // 验证码 boolean check = miaoshaService.checkVerifyCode(user,goodsId,verify); if(!check)&#123; return Result.error(CodeMsg.REQUEST_ILLEGAL); &#125; String path = miaoshaService.createMiaoshaPath(user,goodsId); return Result.success(path); &#125;]]></content>
      <categories>
        <category>项目流程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基础二分查找例题]]></title>
    <url>%2F2018%2F10%2F11%2FalgBinarySearch%2F</url>
    <content type="text"><![CDATA[二分C12345while(lo &lt; hi)&#123; int mid = (lo + hi) &gt;&gt; 1; (e &lt; A[mid]) ? hi = mid :lo = mid + 1;&#125;return --lo; 好处:虽然不能命中及时返回，但是最坏情况变好。每一步迭代之需要比较1次有效区间宽度缩小到0才终止。正确性：A[0,lo)中元素&lt;=e,A[hi,n)中元素都&gt;e 658 K个最接近的元素从数组中找到最靠近 x（两数之差最小）的 k 个数结果按升序.如果有两个数与 x 的差值一样，优先选择数值较小的那个数。 输入: [1,2,3,4,5], k=4, x=-1输出: [1,2,3,4] 378 矩阵从左到右从上到下有序，找第k小的元素(唯品B 考到)2.二分： 1.26%全部放进k大的PriorityQueue,最后poll掉k-1个，return peek 28%123456789101112public int kthSmallest(int[][] matrix, int k) &#123; PriorityQueue&lt;Integer&gt; que = new PriorityQueue(k); for(int[] row:matrix)&#123; for(int x :row)&#123; que.add(x); &#125; &#125; for(int i = 0;i&lt;k-1;i++)&#123; que.poll(); &#125; return que.peek();&#125; 3.sort59% 14ms123456789101112public int kthSmallest(int[][] matrix, int k) &#123; int n = matrix.length; int[] a = new int[n*n]; int i = 0; for(int[] row :matrix)&#123; for(int x:row)&#123; a[i++] = x; &#125; &#125; Arrays.sort(a); return a[k-1];&#125; lt 848 数组插数 加油站之间的最小距离加油站位置中间插入k个之后最小的最大间距是多少。 stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9返回: 0.500000 如果每次都对最大的间隔二分，切三到会导致10-&gt;5,2.5,2.5，不如10/3 思路：找到间距mid，在k步之内可以让所有间距&lt;=mid 123456789101112131415161718192021public double minmaxGasDist(int[] stations, int k) &#123; double left = 0,right = 1e8; while (right - left &gt; 1e-6)&#123; double mid = left + (right - left)/2; if(helper(stations, k, mid))&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125; return right;&#125;private boolean helper(int[] stations, int k,double mid)&#123; int cnt = 0, n = stations.length; for (int i = 0; i &lt; n-1; i++) &#123; // 关键 如果这个是最小间距 ，这个间距需要切几刀 cnt += (stations[i + 1] - stations[i]) / mid; &#125; return cnt &lt;= k;&#125; 分田地 把田地分为16分，怎样分使16份中最小的一块田地最大https://www.nowcoder.com/questionTerminal/fe30a13b5fb84b339cb6cb3f70dca699 4 43332323333322323out: 2 暴力判断能不能切4刀 n^4 找最大的k，使切成16块&gt;=k 410 分割数组使Max(Sum(subarr))最小 Input:nums = [7,2,5,10,8]m = 2Output:18 [7,2,5] and [10,8], 复杂度： mn^2 有mn个子问题 每个子问题找最佳k dp[i][j] 长度为j的数组划分成i组的最大值1.dp[1][j]= sum(0,j)2.找分割点k，k左边划成i-1组的解和右边划分为1组 取max，在所有分割点k中取最小值dp[i][j] = min(max(dp[i-1][k],sum(k+1,j))递归：76ms 6% 二分：复杂度(log(sum(nums))*n) 空间O(1) ok //todo nextlower bound 数组中的最大元素max(nums)up bound 分成1组 sum(nums)12345678910111213141516171819202122232425262728293031323334public int splitArray(int[] nums, int m) &#123; int max = 0;long sum = 0; for(int num:nums)&#123; max = Math.max(num,max ); sum+=num; &#125; if(m==1)return (int)sum; long l = max,r = sum; while (l&lt;=r)&#123; long mid = (l+r)/2; //用这个最小值能不能划分成m组 可以更小一点 if(valid(mid,nums ,m ))&#123; r = mid-1; &#125; else&#123; l = mid+1; &#125; &#125;return (int)l;&#125;private boolean valid(long target,int[] nums,int m)&#123; int cnt =1; long total = 0; for(int num:nums)&#123; total += num; if(total&gt;target)&#123; total = num; //需要一个新的分组 cnt++; if(cnt&gt; m)return false; &#125; &#125; return true;&#125; 三步翻转法： 151 反转英语句子的单词顺序，不翻转单词lt 30 恢复 rotated array189 rotate array!!!4 两个排序数组的中位数 nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 考虑找第k大1.merge k个数就得到第k大O(k)2.比较两个数组的k/2如果A[k/2]&lt;B[k/2]则A[0..k/2]&lt;B[k/2] 88合并排序数组!!!33 rotate Sort Array 中查找！！ 没重复元素方法1 分成4种情况 左半上升 的左右 右半上升的左右 15%方法2 先找到最小值再在左or右二分如果有重复只能O(n) 81 有重复的rotated sorted array!!! lc162 find peak nums[i] ≠ nums[i+1]如果相邻元素可能相同则不能用二分 只能for循环一下如果mid比左边大，则比mid大的peak肯定在右边1234567891011public int findPeakElement(int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (nums[mid] &gt; nums[mid + 1]) r = mid; else l = mid + 1; &#125; return l;&#125; 用s+1&lt;e 就退出[0,1] s=0,e=1 数组中只有2个时候也退出最后要加一步两个数是哪个好处是：有些二分的题目s和e不能为mid +1或者 -1 1234567891011public int findPeakElement(int[] nums) &#123; int s = -1,e = nums.length-1; while(s+1&lt;e)&#123; int mid = (s+e)/2; int left = nums[mid]-nums[mid+1]; if(left&gt;0)&#123; e = mid; &#125;else s = mid; &#125; return e;&#125; 153 Roataed Sorted Array的最小值 二分logN右边的肯定比左边的大，最右肯定比左半小，e不断向左移1234567891011121314public int findMin(int[] nums) &#123; int s = 0,e = nums.length-1; while(s + 1 &lt; e)&#123; int mid = (e+s)/2; if(nums[mid] &gt;= nums[e])&#123; s = mid; &#125;else&#123; e = mid; &#125; &#125; //只剩下2个数之后 取个小的 if(nums[s]&lt;nums[e])return nums[s]; else return nums[e];&#125; 123456789101112public int findMin(int[] nums) &#123; if(nums.length==1)return nums[0]; return findMin(nums,0,nums.length-1);&#125;private int findMin(int[] nums,int low,int hi)&#123; //只有1个或者2个 if(low+1&gt;=hi)return Math.min(nums[low],nums[hi]); if(nums[low]&lt;nums[hi])return nums[low]; int mid = low+(hi-low)/2; //无缝 return Math.min(findMin(nums,low,mid-1),findMin(nums,mid ,hi));&#125; 154 有重复元素Roataed Sorted Array Input: [2,2,2,0,1]Output: 0 不能用二分了 不能Ologn 要O(N)//比遍历都慢1234567891011121314public int findMin(int[] nums) &#123; int s = 0, e = nums.length-1; while (s+1&lt;e)&#123; int mid = (s+e)/2; if(nums[mid]&gt;nums[e])&#123; s = mid; &#125;else if(nums[mid]&lt;nums[e])&#123; e = mid; //关键 &#125;else e--; &#125; return Math.min(nums[s],nums[e] );&#125; 去掉第二个递归条件。 跟遍历一个速度 80 数组每个元素只保留&lt;=2次cnt表示插入位置，i用于遍历12345678910public int removeDuplicates(int[] nums) &#123; if(nums.length &lt; 2)return nums.length; int cnt = 2; for(int i =2;i&lt;nums.length;i++)&#123; if(nums[cnt-2] != nums[i])&#123; nums[cnt++] = nums[i]; &#125; &#125; return cnt;&#125; 278 第一个错误的版本 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。可以调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错 123456789101112public int firstBadVersion(int n) &#123; int l = 1,h = n; while(l &lt; h)&#123; int mid = l+(h-l)/2; if(isBadVersion(mid))&#123; h = mid; &#125;else&#123; l = mid +1; &#125; &#125; return h;&#125; lc240 行列排序的2d矩阵二分查找 O(m+n)从左下角或者右上角开始找12345678910111213141516171819public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length &lt; 1 || matrix[0].length &lt;1) &#123; return false; &#125; int col = matrix[0].length-1; int row = 0; while(col &gt;= 0 &amp;&amp; row &lt;= matrix.length-1) &#123; if(target == matrix[row][col]) &#123; return true; //左 &#125; else if(target &lt; matrix[row][col]) &#123; col--; //往下 &#125; else if(target &gt; matrix[row][col]) &#123; row++; &#125; &#125; return false;&#125; 正确二分查找的写法 lc351.查找范围是 [0,len-1][0]：l=0,r=1-1，while(l==r)的时候应该继续123456789101112131415int l = 0,r=n-1;while(l&lt;=r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)&#123; return mid; &#125; else if(arr[mid]&lt;target)&#123; l=mid+1;// &#125; else&#123; r=mid-1; &#125;&#125;//如果l&gt;rreturn -1; 2.[0,len) 保持len取不到[0]:l=0,r=1,l++,while(l==r)的时候应该结束好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的1234567891011121314int l = 0,r = n;while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)return mid; if(arr[mid]&gt;target)&#123; //在左边，边界为取不到的数 r=mid;//[l,mid) &#125;else&#123; //左闭又开 l = mid+1;//[mid+1,r) &#125;&#125;//如果l==r [1,1)表示空的return -1; 3.(-1,len] from jpbook12345678910111213public int searchInsert(int[] a, int k) &#123; int l = -1,h = a.length; while (h-l&gt;1)&#123; int mid = (l+h)/2; if(a[mid]&gt;=k)&#123; h = mid; &#125;else&#123; l = mid; &#125; &#125; //l+1=h return h;&#125; poj2456 最大化最小值 最大化最近两头牛的距离 in:5 3 [1,2,8,4,9]out: 3 在1，4，9 分别放入这三头牛 12345678910111213141516171819202122232425private static boolean C(int d)&#123; int last = 0; for (int i = 1; i &lt;m ; i++) &#123; int crt = last + 1; //找到间隔&gt;d的房间 while (crt &lt; n &amp;&amp; room[crt] - room[last] &lt; d) &#123; crt++; &#125; if (crt == n) return false; last = crt; &#125; return true;&#125;public static int maxmin(int[] room,int m)&#123; Arrays.sort(room); // positions x1,...,xN (0 &lt;= xi &lt;= 1,000,000,000). int l = 0,h = 1000000+1; while (h-l&gt;1)&#123; int mid = (h+l)/2; if(C(mid))l = mid; else h = mid; &#125; //为什么这里是low return l;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[algInterval]]></title>
    <url>%2F2018%2F10%2F11%2FalgInterval%2F</url>
    <content type="text"><![CDATA[435 去掉最少区间使区间不重叠1Arrays.sort(intervals,(a,b)-&gt;&#123;a.end!=b.end?(a.end-b.end):(a.start-b.start)&#125;); 性能很慢44ms换 提升到2ms 打败了100%123456Arrays.sort(intervals,new Comparator&lt;Inteval&gt;()&#123; public int compare(Interval a,Interval b)&#123; if(a.start==b.start)return a.end-b.end; return a.start-b.start; &#125;&#125;) 算法：按start排序，如果重叠了，end更新成min(end1,end2) 539 时间diff Input: [“23:59”,”00:00”]Output: 1 最快的方法：9ms 1.排序 变成一个循环链表 interval max overLaphttps://www.geeksforgeeks.org/find-the-point-where-maximum-intervals-overlap/1234567891011121314151617 arr[] = &#123;1, 2, 10, 5, 5&#125; dep[] = &#123;4, 5, 12, 9, 12&#125;Below are all events sorted by time. Note that in sorting, if twoevents have same time, then arrival is preferred over exit. Time Event Type Total Number of Guests Present------------------------------------------------------------ 1 Arrival 1 2 Arrival 2 4 Exit 1 5 Arrival 2 5 Arrival 3 // Max Guests 5 Exit 2 9 Exit 1 10 Arrival 2 12 Exit 1 12 Exit 0 lt391 数飞机，interval最多同时多少个飞机lt920 meeting room给定一系列的会议时间间隔，包括起始和结束时间[[s1,e1]，[s2,e2]，…(si &lt; ei)，确定一个人是否可以参加所有会议。[[0,30]，[5,10]，[15,20]]，返回false。贪心12345678910public boolean canAttendMeetings(List&lt;Interval&gt; intervals) &#123; if(intervals == null||intervals.size() == 0)return true; Collections.sort(intervals,(o1,o2)-&gt;o1.start-o2.start); int end = intervals.get(0).end; for (int i = 1; i &lt; intervals.size(); i++) &#123; if(intervals.get(i).start&lt;end)return false; end = Math.max(end,intervals.get(i).end); &#125; return true;&#125; 一个人最多可以参加几个会议12345678910111213public int howmany(List&lt;Interval&gt; intervals)&#123; intervals.sort((a,b)-&gt;a.end-b.end); int cnt = 0; int end = 0; for (int i = 0; i &lt;intervals.length ; i++) &#123; if(end&lt;intervals.get(i).start)&#123; // System.out.println(i); cnt++; end = intervals.get(i).end; &#125; &#125; return cnt;&#125; lt919 !!!需要几个会议室不能贪心： [[1, 5][2, 8][6, 9]]这种情况本来只需要2间房，但是直接贪心就会需要3间房 1234567891011121314151617181920212223242526272829303132333435363738/** |___| |______| |_____| |____| starts: | | | | i ends: | | | | end res++; --------- i end res++; 这个end之前有2个start，前一个会议没有结束 --------- i end end++; start&gt;end表示有个room的会议已经结束，可以安排到这个room --------- *///251ms 74%public int minMeetingRooms2Arr(List&lt;Interval&gt; intervals) &#123; int[] starts = new int[intervals.size()]; int[] ends = new int[intervals.size()]; for(int i=0;i&lt;intervals.size();i++)&#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); int cnt =0; int end = 0; for (int i = 0; i &lt; intervals.size(); i++) &#123; if(starts[i]&lt;ends[end])cnt++; else end++; &#125; return cnt;&#125; 用TreeMap123456789101112131415//240ms 75%public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; TreeMap&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;(); for(Interval i:intervals)&#123; map.put(i.start,map.getOrDefault(i.start,0)+1); map.put(i.end,map.getOrDefault(i.end,0)-1); &#125; int room = 0; int max = 0; for(int num:map.values())&#123; room+=num; max = Math.max(max,room); &#125; return max;&#125; 用PriorityQ1234567891011//403ms 54%public int minMeetingRoomsPQ(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals,(o1, o2)-&gt;o1.start-o2.start); PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;&gt;(intervals.size(),(o1, o2)-&gt;o1.end-o2.end); heap.add(intervals.get(0)); for (int i = 1; i &lt;intervals.size() ; i++) &#123; if(intervals.get(i).start&gt;=heap.peek().end)heap.poll(); heap.add(intervals.get(i)); &#125; return heap.size();&#125; 452 重叠线段？？ 射破全部气球需要的最少次数 Input:[[10,16], [2,8], [1,6], [7,12]]Output:2 12345678910111213int cnt =0;//按结束顺序排序不会出现// |__| 只有： |___| 和 |____|//|______|的情况 |____| |_|Arrays.sort(points,(a,b)-&gt;a[1]-b[1]);for(int i =0;i&lt;points.length;i++)&#123; int cur = points[i][1]; cnt++; while(i+1&lt;points.length&amp;&amp;points[i+1][0]&lt;=cur&amp;&amp;cur&lt;=points[i+1][1])&#123; i++; &#125;&#125;return cnt; 前一个的end在i+1的线段中，则跳过。 986 合并交集 双指针Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] 123456789101112131415public Interval[] intervalIntersection(Interval[] A, Interval[] B) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;&gt;(); int i = 0,j= 0; while(i&lt;A.length &amp;&amp; j&lt;B.length) &#123; int lo = Math.max(A[i].start,B[j].start); int hi = Math.min(A[i].end,B[j].end); if(lo &lt;= hi)&#123; ans.add(new Interval(lo,hi)); &#125; if(A[i].end &lt; B[j].end)i++; else j++; &#125; return ans.toArray(new Interval[0]); &#125; lt821时间交集 区间交集 扫描线 seqA = [(1,2),(5,100)], seqB = [(1,6)], 返回 [(1,2),(5,6)] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Event implements Comparable&lt;Event&gt;&#123; static final int START = 0; static final int END = 1; int time,type; public Event(int time, int type) &#123; this.time = time; this.type = type; &#125; @Override public int compareTo(Event o) &#123; if(this.time!=o.time)&#123; return this.time - o.time; &#125; return this.type-o.type; &#125;&#125;public List&lt;Interval&gt; timeIntersection(List&lt;Interval&gt; seqA, List&lt;Interval&gt; seqB) &#123; List&lt;Event&gt; events = new ArrayList&lt;&gt;(); for(Interval i:seqA)&#123; events.add(new Event(i.start,Event.START)); events.add(new Event(i.end,Event.END)); &#125; for(Interval i:seqB)&#123; events.add(new Event(i.start,Event.START)); events.add(new Event(i.end,Event.END)); &#125; Collections.sort(events); int count = 0; Integer start = null,end = null; List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); for(Event event : events)&#123; if(event.type == 0)&#123; //用户上线 count++; if(count == 2)start = event.time; &#125;else &#123; //用户下线 count--; if(count == 1)end = event.time; &#125; if(start != null &amp;&amp; end != null)&#123; res.add(new Interval(start,end)); start = null;end = null; &#125; &#125; return res;&#125; 56 合并区间 扫描线 Input: [[1,4],[4,5]]Output: [[1,5]] 方法1：O(nLogn) 需要O(n)空间1.按起点排序，2.push第一个interval3.for全部interval： a.不交叉，push b.交叉,更新栈顶的end 59ms 27%展开代码 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if(intervals==null||intervals.size()&lt;2)return intervals; intervals.sort((a,b)-&gt;a.start-b.start); List&lt;Interval&gt; rst = new ArrayList&lt;&gt;(); for(Interval interval:intervals)&#123; if(rst.size()&lt;1)&#123; rst.add(interval); &#125; else if(rst.get(rst.size()-1).end&gt;=interval.start)&#123; // 不用新建 只需要更新栈顶 // Interval newInter = rst.get(rst.size()-1); // rst.remove(rst.size()-1); // newInter.end = Math.max(newInter.end,interval.end); // rst.add(newInter); rst.get(rst.size()-1).end =Math.max(rst.get(rst.size()-1).end,interval.end); &#125;else&#123; rst.add(interval ); &#125; &#125; return rst;&#125; 方法2：分解成start[],end[]思想：后一个区间的start(i+1)一定要大于前一个区间的end(i)98% 10ms1234starts: 1 2 8 15 i i+1ends: 3 6 10 18 j add(1,6)start[i+1]&gt;end[i] 直到找的第一个start&gt;end add(start[j],end[i]) j=i+1如果start到了最后一个，这个区间肯定是从上一个区间(j)开始，到end(i)结束1234567891011121314151617181920public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; int len = intervals.size(); int[] start = new int[len]; int[] end = new int[len]; for(int i =0;i&lt;len;i++)&#123; start[i] = intervals.get(i).start; end[i] = intervals.get(i).end; &#125; Arrays.sort(start); Arrays.sort(end); List&lt;Interval&gt; rst = new ArrayList&lt;&gt;(); for(int i =0,j=0;i&lt;len;i++)&#123; //关键 当start扫描到最后一个 ，直接建立起最后一个区间 if(i==len-1||start[i+1]&gt;end[i])&#123; rst.add(new Interval(start[j],end[i])); //下一个区间起点 j=i+1; &#125; &#125;&#125; 方法3：原地算法1.按地点降序排序 a如果不是第一个，并且和前一个可以合并，则合并b push当前 lt156合并区间 123456[ [ (1, 3), (1, 6), (2, 6), =&gt; (8, 10), (8, 10), (15, 18) (15, 18) ]] O(n log n) 的时间和 O(1) 的额外空间。 原地算法 57 插入一个区间并合并方法1： 将区间插到newInterval.start&gt;interval.start之前的位置，用56的和last比较合并方法2： 分成left+new+right三部分并合并 中间部分取自身和重叠区间的min/max12345678910111213141516171819public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; left = new ArrayList&lt;&gt;(); List&lt;Interval&gt; right = new ArrayList&lt;&gt;(); int start =newInterval.start; int end =newInterval.end; for(Interval interval:intervals)&#123; if(interval.end&lt;newInterval.start)&#123; left.add(interval); &#125;else if(interval.start&gt;newInterval.end)&#123; right.add(interval); &#125;else &#123; start = Math.min(start,interval.start); end = Math.max(end,interval.end); &#125; &#125; left.add(new Interval(start,end)); left.addAll(right); return left;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[每日Review]]></title>
    <url>%2F2018%2F10%2F11%2FInterview-alg%2F</url>
    <content type="text"><![CDATA[循环数组找一个数如何用最少的步骤称出13颗1g砝码中的赝品https://blog.csdn.net/zhtengsh/article/details/38879431 一个圆中三个点构成一个锐角三角形的概率圆内接三角形的最大角至少要大于等于60度，该最大角的范围可从60到180度变化，但只有60到90间为锐角，所以占1/4. 字节流和字符流，读取一个配置文件读一行 写入数据库two sum如果数字在最后怎么优化如果有序two sum怎么做three sum String2Integer16 快速排序基本：最普通的，每次取[0]作子集划分s1+[0]+s2,再递归两个子集。最坏情况123456 O(n^2)1234567891011121314151617181920private void qS(int[] arr,int left,int right)&#123; if(left&gt;=right)return; int pivot = arr[right]; // 因为保证i最后在左集合右边 用++i // 所以初始化的时候边界都向外扩一格 int i = left-1;int j = right; while (true)&#123; // 关键 i&lt;j while (++i&lt;j &amp;&amp; arr[i] &lt;= pivot); while (--j&gt;i &amp;&amp; arr[j] &gt;= pivot); if(i &lt; j)&#123; swap(arr,i , j); &#125; else break; &#125; // 把主元放到左集合右边 swap(arr, i, right); qS(arr, left, i-1); qS(arr, i+1,right); &#125; 注意1：主元：1取头、中、尾的中位数比随机函数便宜。用ifelse判断这三个数，1)把最小的放到左边2)把最大的放到右边3)把中间的数替换到最后位置上pivot = nums[n-1] 然后用pivot划分子集，i从左开始，j从右开始,i最后停在j右边，交换[i],[n-1]，pivot放了正确的位置。 注意2：如果有重复元素 如果11111，1）重复元素也交换，最后pivot也会被换到中间，很等分nlogn。2）不交换，i直接比较到最后，pivot还是在最后，变成n^2 注意3：小规模数据集（N不到100可能还不如插入排序）当递归的长度够小直接插入排序。 JDK Arrays.sort()中的根据阈值从merge，quick，insert，count sort中选一个展开代码 1234567891011/**如果数组长度小于 this, Quicksort 优先于 merge sort.*/private static final int QUICKSORT_THRESHOLD = 286;/**如果数组长度小于 this , insertion sort 优先于 Quicksort.*/private static final int INSERTION_SORT_THRESHOLD = 47;/**如果Byte数组长度大于this, counting sort 优先于 insertion sort. */private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;/** 如果short or char 数组长度大于 this, counting sort 优先于 Quicksort.*/private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200; 17 堆排序 不需要额外空间 大顶堆堆（数组实现的完全二叉树）左孩子是(1+i&lt;&lt;1) // 1+i&lt;&lt;2 奇数右孩子是(i+1)&lt;&lt;1 //偶数父节点是(i-1)&gt;&gt;1 堆排序：线性复杂度将数组调成最大堆O(n)，将堆顶和数组最后交换，堆规模-1，再调成最大堆。 12345heapify(arr);for (int i = 0; i &lt;arr.length ; i++) &#123; swap(arr,0,n-1-i); shiftDown(arr,0,n-1-i);&#125; 建堆方法1：从上到下，每个新加的结点放在最右下，然后shiftUp每个 复杂度O(nlogn) (都可以做全排序了)正确方法：思路：每个叶节点都成一个子堆，下滤操作能完成两个子堆的合并。 12345678910111213141516171819202122//大顶堆private static void shiftDown(int[] arr,int idx,int n)&#123; int lowest = n/2; while(idx &lt; lowest)&#123; int left = (idx*2) + 1; int right = left + 1; if(right &lt; n &amp;&amp; arr[left]&lt;arr[right] &amp;&amp; arr[right]&gt;arr[idx])&#123; swap(arr,idx,right); idx = right; &#125;else if(arr[idx] &lt; arr[left])&#123; swap(arr,idx,left); idx = left; &#125;else break; &#125;&#125;private static void heapify(int[]arr)&#123; int n = arr.length; for(int i = (n-1)/2;i&gt;=0;i--)&#123; shiftDown(arr,i,n); &#125;&#125; 复杂度：复杂度每个节点只需要比较的长度最多是这个节点到叶子的高度（而不是在树中的深度）。O(N)的因为二叉树越底层节点越多。深度越高节点越多，所以上滤复杂度高。 从右下开始依次下滤，所有叶子节点都不用下滤。如果全堆大小为n，内部节点最后一个的idx是(n/2)-1例子：一共9个节点 各层1，2，4，2个。最后一个内部节点是3，它的右边和下面都是叶子。 向堆添加节点（添加在数组最后，上滤）1234567891011private void shifUp(int[] arr,int i,int x)&#123; while (i&gt;0)&#123; int parent = (i-1)&gt;&gt;&gt;1; int e = arr[parent]; if(e &gt;= x)break; // 下移父节点 arr[i] = e; i = parent; &#125; arr[i] = x;&#125; 32 递归冒泡排序123456789101112public void bubblesort(int[] array,int n) &#123; if (n == 1) return; if (array == null || array.length == 0) return; for (int i = 0; i &lt; n - 1; i++) &#123; if (array[i] &gt; array[i + 1]) &#123; swap(array,i,i+1); &#125; &#125; bubblesort(array, n - 1);&#125; 37 二分2.[0,len) 保持len取不到[0]:l=0,r=1,l++,while(l==r)的时候应该结束好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的1234567891011121314int l = 0,r = n;while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)return mid; if(arr[mid]&gt;target)&#123; //在左边，边界为取不到的数 r=mid;//[l,mid) &#125;else&#123; //左闭又开 l = mid+1;//[mid+1,r) &#125;&#125;//如果l==r [1,1)表示空的return -1; 40 !!!线程安全的单例模式单元素枚举类是实现Singleton的最佳方法1234567891011public enum Singleton&#123; //定义1个枚举的元素，即为单例类的1个实例 INSTANCE; // 隐藏了1个空的、私有的 构造方法 // private Singleton () &#123;&#125;&#125;// 获取单例的方式：Singleton singleton = Singleton.INSTANCE; 【初始化占位类模式】如果是静态初始化对象不需要显示同步。静态初始化：JVM在类初始化阶段执行，在类加载后并在线程执行前。JVM会获取锁确保这个类已经被加载。任何一个线程调用getInstance的时候会使静态内部类被加载和初始化。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 用反射强行调用私有构造函数可以创建多个实例。防止序列化：重写私有的readReslove() 当反序列化readObject()的时候会直接调用readReslove替换原本的返回值。 双重检查锁已经被广泛地废弃了！ 懒加载 推迟高开销的对象初始化操作。同步 double checked locking只希望在第一次创建 实例的时候进行同步创建对象分为3个步骤：1）分配内存2）初始化对象3）obj指向内存地址关键：（2）、（3）会被重排序（因为理论上单线程不会有错，而且能提高性能），导致obj不未空，但还没初始化，所以volatile禁止重排序。如果两个操作之间没有happens-before则JVM可以重排序。Volatile变量规则。对一个volatile修饰的变量，对他的写操作先行发生于读操作。 特别对于有final字段的对象，构造函数完成的时候才完成final的写入。初始化安全：防止对对象的初始引用被重排序到构造过程之前。 1234567891011public class LazySingle()&#123; private volatile static LazySingle obj = null; private LazySingle()&#123;&#125; public static getInstance()&#123; if(obj == null)&#123; // 1.只有一个线程能进来 synchronized(LazySingle.class)&#123; if(obj == null)&#123; obj = new LazySingle();&#125;&#125;&#125; return obj;&#125;&#125; 方法2：静态内部类 42 2进制字符串转16进制123456789101112131415161718192021 String b2h(String bins)&#123; int n = bins.length(); String hexs = "0123456789abcdf"; StringBuilder sb = new StringBuilder(); //0101 n =4 while (n&gt;=4)&#123; int idx = (bins.charAt(n - 1) - '0') + ((bins.charAt(n - 2) - '0') * 2) + ((bins.charAt(n - 3) - '0') * 4) + ((bins.charAt(n - 4) - '0') * 8); System.out.println(n); sb.append(hexs.charAt(idx)); n-=4; &#125; int last = 0;int cnt = 0; while (n&gt;0)&#123; last += (bins.charAt(n-- - 1) - '0')*(1&lt;&lt;(cnt++)); &#125; sb.append(hexs.charAt(last)); return sb.reverse().toString();&#125; 43 !十进制转2进制没有oj过12345678public String D2Bin(int de)&#123; StringBuilder sb = new StringBuilder(); while (de != 0)&#123; sb.insert(0,de&amp;1); de &gt;&gt;&gt;= 1; &#125; return sb.toString();&#125; 44 编辑距离1）定义dp[n][m]表示从s1的前n个字符-&gt;s2的前m个字符最少的编辑距离。2）加一个：[n-1][m]+1 减一个: [n][m-1]+1 变一个:[n-1][m-1] +1 相等：[n-1][m-1]1234567891011121314151617public int minDistance(String word1, String word2) &#123; int n = word1.length(); int m = word2.length(); int[][] dp = new int[n+1][m+1]; for(int i =0;i&lt;=n;i++)&#123;dp[i][0] = i;&#125; for(int i =0;i&lt;=m;i++)&#123;dp[0][i] = i;&#125; for(int i =1;i&lt;=n;i++)&#123; for(int j = 1;j&lt;=m;j++)&#123; if(word1.charAt(i-1) == word2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125;else &#123; dp[i][j] = Math.min(Math.min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1); &#125; &#125; &#125; return dp[n][m];&#125; 二维数组搜索12345678910111213public boolean searchMatrix(int[][] matrix, int target) &#123; int n = matrix.length; if(n &lt;1)return false; int m = matrix[0].length; if(m&lt;1)return false; int x = 0; int y = m-1; while(x &lt; n &amp;&amp; y &gt;=0)&#123; if(matrix[x][y] == target)return true; if(target &gt; matrix[x][y])x++; else if(target &lt; matrix[x][y])y--; &#125; return false;&#125; 矩阵旋转90度 lc 48逆时针：第一步交换主对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。 如果是顺时针， 第一步交换对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。12345678910111213141516171819public void rotate(int[][] matrix) &#123; int n = matrix.length; for(int i = 0;i&lt;n;i++)&#123; for(int j = i+1;j&lt;n;j++)&#123; if(i!=j)&#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125; &#125; for(int i =0;i&lt;n;i++)&#123; for(int j = 0;j&lt;n/2;j++)&#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][n-1-j]; matrix[i][n-1-j] = tmp; &#125; &#125;&#125; 人民币转换链接：https://www.nowcoder.com/questionTerminal/00ffd656b9604d1998e966d555005a4b?commentTags=Java输入一个double数输出人民币格式1、中文大写金额数字前应标明“人民币”字样。中文大写金额数字应用壹、贰、叁、肆、伍、陆、柒、捌、玖、拾、佰、仟、万、亿、元、角、分、零、整等字样填写。（30分） 2、中文大写金额数字到“元”为止的，在“元”之后，应写“整字，如￥ 532.00应写成“人民币伍佰叁拾贰元整”。在”角“和”分“后面不写”整字。（30分） 3、阿拉伯数字中间有“0”时，中文大写要写“零”字，阿拉伯数字中间连续有几个“0”时，中文大写金额中间只写一个“零”字，如￥6007.14，应写成“人民币陆仟零柒元壹角肆分“。（ 151121.15人民币拾伍万壹仟壹佰贰拾壹元壹角伍分 思路：整数部分：1）每个数字都是单位+数字（元+个位，十拾十位），2）单位顺序完整应该是【”元”, “拾”, “佰”, “仟”, “万”, “拾”, “佰”, “仟”, “亿”, “拾”, “佰”, “仟”】3）对批量0做flag。4)如果14去掉1其它都ok。 小数部分题目要求0角1分不用输出角则暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Main &#123;public static String[] RMB = &#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;;public static String[] unit1 = &#123;"元", "拾", "佰", "仟", "万", "拾", "佰", "仟", "亿", "拾", "佰", "仟"&#125;;public static String[] unit2 = &#123;"角", "分"&#125;;public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; String s = sc.next(); String result = ""; if(s.contains(".")) &#123; String s1 = s.substring(s.indexOf('.') + 1); String s2 = s.substring(0, s.indexOf('.')); result = "人民币" + integer(s2) + decimal(s1); &#125; else result = "人民币" + integer(s) + "整"; System.out.println(result); &#125;&#125;// 处理整数public static String integer(String s) &#123; if(s.length() == 1 &amp;&amp; s.charAt(0) == '0') return "";//RMB[0]+unit1[0]; int[] arr = new int[s.length()]; int idx = 0; for (int i = s.length()-1; i &gt;= 0; i -- ) arr[idx++] = s.charAt(i)-'0'; StringBuilder sb = new StringBuilder(); boolean zero = false; for (int i = 0; i &lt; arr.length; i ++ ) &#123; if(!zero &amp;&amp; arr[i] == 0)&#123; sb.append(RMB[arr[i]]); zero = true; &#125;else if (arr[i] != 0)&#123; sb.append(unit1[i] + RMB[arr[i]]); zero = false; &#125; &#125; sb = sb.reverse(); if(sb.charAt(0) == '壹' &amp;&amp; sb.charAt(1) == '拾') sb.deleteCharAt(0); return sb.toString();&#125;// 处理小数 public static String decimal(String s) &#123; StringBuilder sb = new StringBuilder();// boolean zero = true; for (int i = s.length()-1; i &gt;=0; i -- ) &#123; int tmp = s.charAt(i)-'0'; if( tmp ==0)continue; // 1分 0角 输出角// if(!zero || tmp &gt; 0)&#123;// sb.append(unit2[i] + RMB[tmp] );// zero = false;// &#125; //不输出角 sb.append(unit2[i] + RMB[tmp] ); &#125; return sb.length()&lt;1?"整":sb.reverse().toString(); &#125; 快速排序25 k个一组反转链表Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; int cnt = 0; ListNode cur = head; while(cur!=null &amp;&amp; cnt &lt;k)&#123; cur = cur.next; cnt++; &#125; if(cnt == k)&#123; // 4-&gt;3-&gt;5 cur = reverseKGroup(cur,k); while(cnt--&gt;0)&#123; ListNode next = head.next; head.next = cur; cur = head; head = next; &#125; // 关键 head = cur; &#125; return head; &#125; 24 两个一组反转链表Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 1234567891011public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null)return head; //保留第二个 ListNode se = head.next; //第一个指向第三个，第三个也是同样修改方案返回头指针 head.next = swapPairs(head.next.next); //第二个指向第一个 se.next = head; //返回第二个当作头指针 return se;&#125; 11 选两点容纳的水面积最大Input: [1,8,6,2,5,4,8,3,7]Output: 49 12345678910111213public int maxArea(int[] height) &#123; int n = height.length; int left = 0; int right = n-1; int rst = 0; while(left&lt;right)&#123; int tmp = Math.min(height[left],height[right]) * (right-left); rst = Math.max(rst,tmp); if(height[left] &gt;height[right])right--; else left++; &#125; return rst;&#125; 42 雨水 水槽问题Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 正确做法：双指针123456789101112131415161718192021public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; // 关键 int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 两个数组做法：left保存当前位置左边的max。right保存当前位置右边的max。123456789101112131415161718public int trap(int[] height) &#123; int n = height.length; int[] left = new int[n]; int[] right = new int[n]; for(int i = 1;i&lt;n;i++)&#123; left[i] = Math.max(left[i-1],height[i-1]); &#125; for(int i = n-2;i&gt;=0;i--)&#123; right[i] = Math.max(right[i+1],height[i+1]); &#125; int rst = 0; for(int i = 0;i&lt;n;i++)&#123; int tmp = Math.min(left[i],right[i]) - height[i]; if(tmp &gt;0) rst += tmp; &#125; return rst;&#125; 146 LRU cache HashMap&lt;Integer,DoubleLinkedList&gt;Cache replacement policiesleast recently used cache最近最少使用缓存java:LinkedHashMap:https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry- 双向链表+hashmap展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class LRUCache &#123; //双向链表 class DoubleLinkedNode&#123; //和hashmap对应，用于日后扩容 int key; int value; DoubleLinkedNode pre; DoubleLinkedNode next; &#125; HashMap&lt;Integer,DoubleLinkedNode&gt; cache; int capacity; DoubleLinkedNode head; DoubleLinkedNode tail; //创建一个头节点 //链表操作： //1. get/update中间的node移到链表最前面 private void move2head(DoubleLinkedNode node)&#123; /**** star ****/ this.remove(node); this.addNode(node); &#125; //2. put1 头插 private void addNode(DoubleLinkedNode node)&#123; node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; &#125; //3. put2 删除节点 (1删除中间的，移到最开头 2.删除尾巴) private void remove(DoubleLinkedNode node)&#123; DoubleLinkedNode pre = node.pre; DoubleLinkedNode next = node.next; pre.next = next; next.pre = pre; &#125; //4.删除尾巴, private int removeTail()&#123; DoubleLinkedNode pre = tail.pre; this.remove(pre); return pre.key; &#125; public LRUCache(int capacity) &#123; cache = new HashMap&lt;&gt;(); this.capacity = capacity; //创建一个头节点 head = new DoubleLinkedNode(); head.pre = null; //创建一个空尾巴 tail = new DoubleLinkedNode(); tail.next= null; head.next = tail; tail.pre = head; &#125; public int get(int key) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) return -1; move2head(node); return node.value; &#125; public void put(int key, int value) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) &#123; //插入新值 DoubleLinkedNode newNode = new DoubleLinkedNode(); newNode.key = key; newNode.value = value; //1. 考虑容量剩余,满不满都要插入，但是满了要先删除 if (capacity == 0) &#123; //删除尾巴 int deleteKey = removeTail(); cache.remove(deleteKey); capacity++; &#125; //2. 插入队列 addNode(newNode); //3. 加入hash cache.put(key, newNode); capacity--; &#125;else &#123; node.value = value; move2head(node); &#125; &#125;&#125; 946 栈顺序Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: true 123456789101112public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;(); int i = 0; for (int p : pushed) &#123; stk.push(p); while (!stk.isEmpty() &amp;&amp; stk.peek() == popped[i]) &#123; stk.pop(); ++i; &#125; &#125; return stk.isEmpty();&#125; 206反转链表 空间是n12345678public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode second = reverseList(head.next); // 1-&gt;(second:7-&gt;6-&gt;5..-&gt;2) (second:7-&gt;6-&gt;5..-&gt;2) -&gt;1-&gt;null head.next.next = head; head.next = null; return second;&#125; 迭代空间是1： 三个指针pre（注意初始为null),cur,next(只用于cur跳跃),用cur控制结束，一个暂存三个赋值。123456789101112public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode prev = null; ListNode curr = head; while(curr != null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev;&#125; 少一个指针 正确做法1234567891011public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode cur = null; while(head!=null)&#123; ListNode next = head.next; head.next = cur; cur = head; head = next; &#125; return cur; &#125; python12345def reverseList(self, head): cur,prev = head,None while cur: cur.next,prev,cur = prev,cur,cur.next return prev 转成栈浪费空间并且代码复杂 141链表环检测空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针最坏情况，快指针和慢指针相差环长q -1步cpp练习 1234567891011121314class Solution&#123; public: bool hasCycle(ListNode *head) &#123; auto slow = head; auto fast = head; while(fast)&#123; if(!fast-&gt;next)return false; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 142 环起始于哪个node1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;3 meet:6a: 从head到环b：快指针走了两次的环内距离(慢指针到环起点的距离)c: 慢指针没走完的环内距离已知快指针走的距离是slow的两倍慢=a+b 快=a+2b+c则a=c从len(head - 环起点) == 慢指针没走完的环距离head与慢指针能在环起点相遇。1234567if(slow==fast)&#123; while(head!=slow)&#123; head=head.next; slow=slow.next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[每日Review]]></title>
    <url>%2F2018%2F10%2F11%2FalgPop%2F</url>
    <content type="text"><![CDATA[熟练度https://docs.qq.com/sheet/DUGZ6cEtrUFJsSGxP 快速排序插入排序好处：在线算法 92 区间反转链表Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 123456789101112131415161718192021public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null || n == m)return head; ListNode dumy = new ListNode(0); dumy.next = head; ListNode pre = dumy; for (int i = 0; i &lt;m-1 ; i++) &#123; pre = pre.next; &#125; ListNode start = pre.next; for (int i = 0; i &lt;n-m ; i++) &#123; //3 下一个要反转到前面的 ListNode next = start.next; //2-&gt;4 接上后面不动的 start.next = next.next; //3-&gt;2 反转到最前面接上反转部分 next.next = pre.next; //1-&gt;3 之前不动部分接上新换上来的节点 pre.next = next; &#125; return dumy.next;&#125; 25 k个一组反转链表Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; int cnt = 0; ListNode cur = head; while(cur!=null &amp;&amp; cnt &lt;k)&#123; cur = cur.next; cnt++; &#125; if(cnt == k)&#123; // 4-&gt;3-&gt;5 cur = reverseKGroup(cur,k); while(cnt--&gt;0)&#123; ListNode next = head.next; head.next = cur; cur = head; head = next; &#125; // 关键 head = cur; &#125; return head; &#125; 24 两个一组反转链表Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 1234567891011public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null)return head; //保留第二个 ListNode se = head.next; //第一个指向第三个，第三个也是同样修改方案返回头指针 head.next = swapPairs(head.next.next); //第二个指向第一个 se.next = head; //返回第二个当作头指针 return se;&#125; 11 选两点容纳的水面积最大Input: [1,8,6,2,5,4,8,3,7]Output: 49 12345678910111213public int maxArea(int[] height) &#123; int n = height.length; int left = 0; int right = n-1; int rst = 0; while(left&lt;right)&#123; int tmp = Math.min(height[left],height[right]) * (right-left); rst = Math.max(rst,tmp); if(height[left] &gt;height[right])right--; else left++; &#125; return rst;&#125; 146 LRU cache HashMap&lt;Integer,DoubleLinkedList&gt;Cache replacement policiesleast recently used cache最近最少使用缓存java:LinkedHashMap:https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry- 双向链表+hashmap展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class LRUCache &#123; //双向链表 class DoubleLinkedNode&#123; //和hashmap对应，用于日后扩容 int key; int value; DoubleLinkedNode pre; DoubleLinkedNode next; &#125; HashMap&lt;Integer,DoubleLinkedNode&gt; cache; int capacity; DoubleLinkedNode head; DoubleLinkedNode tail; //创建一个头节点 //链表操作： //1. get/update中间的node移到链表最前面 private void move2head(DoubleLinkedNode node)&#123; /**** star ****/ this.remove(node); this.addNode(node); &#125; //2. put1 头插 private void addNode(DoubleLinkedNode node)&#123; node.pre = head; node.next = head.next; head.next.pre = node; head.next = node; &#125; //3. put2 删除节点 (1删除中间的，移到最开头 2.删除尾巴) private void remove(DoubleLinkedNode node)&#123; DoubleLinkedNode pre = node.pre; DoubleLinkedNode next = node.next; pre.next = next; next.pre = pre; &#125; //4.删除尾巴, private int removeTail()&#123; DoubleLinkedNode pre = tail.pre; this.remove(pre); return pre.key; &#125; public LRUCache(int capacity) &#123; cache = new HashMap&lt;&gt;(); this.capacity = capacity; //创建一个头节点 head = new DoubleLinkedNode(); head.pre = null; //创建一个空尾巴 tail = new DoubleLinkedNode(); tail.next= null; head.next = tail; tail.pre = head; &#125; public int get(int key) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) return -1; move2head(node); return node.value; &#125; public void put(int key, int value) &#123; DoubleLinkedNode node = cache.get(key); if(node == null) &#123; //插入新值 DoubleLinkedNode newNode = new DoubleLinkedNode(); newNode.key = key; newNode.value = value; //1. 考虑容量剩余,满不满都要插入，但是满了要先删除 if (capacity == 0) &#123; //删除尾巴 int deleteKey = removeTail(); cache.remove(deleteKey); capacity++; &#125; //2. 插入队列 addNode(newNode); //3. 加入hash cache.put(key, newNode); capacity--; &#125;else &#123; node.value = value; move2head(node); &#125; &#125;&#125; 946 栈顺序Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: true 123456789101112public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;(); int i = 0; for (int p : pushed) &#123; stk.push(p); while (!stk.isEmpty() &amp;&amp; stk.peek() == popped[i]) &#123; stk.pop(); ++i; &#125; &#125; return stk.isEmpty();&#125; 206反转链表 空间是n12345678public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode second = reverseList(head.next); // 1-&gt;(second:7-&gt;6-&gt;5..-&gt;2) (second:7-&gt;6-&gt;5..-&gt;2) -&gt;1-&gt;null head.next.next = head; head.next = null; return second;&#125; 迭代空间是1： 三个指针pre（注意初始为null),cur,next(只用于cur跳跃),用cur控制结束，一个暂存三个赋值。123456789101112public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode prev = null; ListNode curr = head; while(curr != null)&#123; ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev;&#125; 少一个指针 正确做法1234567891011public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)return head; ListNode cur = null; while(head!=null)&#123; ListNode next = head.next; head.next = cur; cur = head; head = next; &#125; return cur; &#125; python12345def reverseList(self, head): cur,prev = head,None while cur: cur.next,prev,cur = prev,cur,cur.next return prev 转成栈浪费空间并且代码复杂 141链表环检测空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针最坏情况，快指针和慢指针相差环长q -1步cpp练习 1234567891011121314class Solution&#123; public: bool hasCycle(ListNode *head) &#123; auto slow = head; auto fast = head; while(fast)&#123; if(!fast-&gt;next)return false; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 142 环起始于哪个node1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;3 meet:6a: 从head到环b：快指针走了两次的环内距离(慢指针到环起点的距离)c: 慢指针没走完的环内距离已知快指针走的距离是slow的两倍慢=a+b 快=a+2b+c则a=c从len(head - 环起点) == 慢指针没走完的环距离head与慢指针能在环起点相遇。1234567if(slow==fast)&#123; while(head!=slow)&#123; head=head.next; slow=slow.next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树、链表基础操作]]></title>
    <url>%2F2018%2F10%2F11%2FalgDSbase%2F</url>
    <content type="text"><![CDATA[563 二叉树坡度863 二叉树路径距离K步的node124 二叉树中最大路径和23 k个链表merge正确解法：分治8ms 96% 复杂度kNlogk每次合并2个，需要2n,第一次有k/2对用mergeTwo.第一次的复杂度是 kn总共有log k 次迭代，总的复杂度 kn log k12345678910111213141516171819public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length ==0)return null; if(lists.length == 1) return lists[0]; if(lists.length == 2)&#123; return mergeTwoLists(lists[0],lists[1] ); &#125; int mid = lists.length / 2; ListNode[] sub1 = new ListNode[mid]; ListNode[] sub2 = new ListNode[lists.length - mid]; for (int i = 0; i &lt; mid; i++) &#123; sub1[i] = lists[i]; &#125; for (int i = mid; i &lt;lists.length; i++) &#123; sub2[i-mid] = lists[i]; &#125; ListNode listNode1 = mergeKLists(sub1); ListNode listNode2 = mergeKLists(sub2); return mergeTwoLists(listNode1, listNode2);&#125; 其他同样有nk log k的 用堆 heapify logk,从堆中取nk次最小 解法2： 86ms全部先放在一起，排序，再遍历组成一个链表复杂度 knlog(kn) + kn123456789101112131415161718 public ListNode mergeKLists(ListNode[] lists) &#123; List&lt;ListNode&gt; all = new ArrayList&lt;&gt;(); for(ListNode node : lists)&#123; while (node!=null)&#123; all.add(node); node = node.next; &#125; &#125; all.sort((l1,l2)-&gt;l1.val-l2.val); ListNode tmp = new ListNode(-1); ListNode pre = tmp; for(ListNode node :all)&#123; pre.next = node; pre = pre.next; &#125; return tmp.next;&#125; 暴力解每次向后合并一个 309 ms复杂度： 有k个链表，平均长度n第一次最长比较(n+n)次， 第二次合并最差比较(2n+n)次….直到最后一步k-1个链表合并后和最后一个链表合并(k-1)n+n复杂度(k^2 n)12345678910111213public ListNode mergeKLists(ListNode[] lists) &#123; if(lists == null || lists.length &lt;1)&#123; return null; &#125; if(lists.length == 1)&#123; return lists[0]; &#125; ListNode tmp = lists[0]; for(int i =1;i&lt;lists.length;i++)&#123; tmp = mergeTwoLists(tmp,lists[i]); &#125; return tmp;&#125; 21 链表merge递归todo123456789101112131415161718192021public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode tem_head = new ListNode(-1); ListNode pre = tem_head; while (l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt; l2.val)&#123; pre.next = l1; l1 = l1.next; &#125;else&#123; pre.next = l2; l2 = l2.next; &#125; pre = pre.next; &#125; if(l1!=null)&#123; pre.next = l1; &#125; if(l2!=null)&#123; pre.next =l2; &#125; return tem_head.next;&#125; 24两个一组交换链表创建链表list-&gt;nodelist 会stackOverflow123456Node create(List&lt;Integer&gt; data)&#123; Node first = new Node(data.get(0)); Node sub = create(data.subList(1,data.size())); first.next=sub; return first;&#125; 迭代：123456789101112Node pre = null;Node head =null;for(1 to size)&#123; Node node = new Node(i); if(pre!=null)&#123; pre.next =node; &#125;else&#123; head = node; &#125; pre = node;&#125;return head; 链表DELETE_IF92反转从m到n的链表 一趟扫描二叉树872 叶子相似的树236 最低的二叉树公共祖先LCA方法1：找出两条从root开始的路径，返回路径不开始不相同的前一个点27%空间两个array展开代码 12345678910111213141516171819202122public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; List&lt;TreeNode&gt; pathp = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; pathq = new ArrayList&lt;&gt;(); // if(!findPath(root,p,pathp)||!findPath(root,p,pathp))return findPath(root,p,pathp); findPath(root,q,pathq); int i; for(i = 0;i&lt;Math.min(pathp.size(),pathq.size());i++)&#123; if(pathp.get(i).val!=pathq.get(i).val) break; &#125; return pathp.get(i-1);&#125;private boolean findPath(TreeNode root,TreeNode node,List&lt;TreeNode&gt; path)&#123; if(root == null)return false; path.add(root); if(root.val == node.val)return true; if(root.left!=null&amp;&amp;findPath(root.left,node,path))return true; if(root.right!=null&amp;&amp;findPath(root.right,node,path))return true; path.remove(path.size()-1); return false;&#125; 方法二：只遍历一次树，这种方法如果其中一个q不在树中，会返会p,应该返回null13%12345678public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null)return null; if(root.val==p.val||root.val==q.val)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left!=null&amp;&amp;right!=null)return root; return left!=null?left:right;&#125; 这道题两个点都保证存在，可以absent的 终止条件root==null|root==q||root=p 在左/右子树找p|q，两边都能找到一个值（因为值不重复） 则返回当前root 如果左边没找到p|q，右边找到了p|q，最低的祖先就是找到的p|q，(因为保证p|q一定在树中) 235 BST的LCA8.9%123456TreeNode lcaBST(TreeNode root,TreeNode p,TreeNode q)&#123; if(root== null)return null; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)return lcaBST(root.left,p ,q ); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)return lcaBST(root.right,p ,q ); return root;&#125; 优化1： 13% 9ms123456789public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125;else&#123; return root; &#125;&#125; 222 完全二叉树的节点数83% 110 判断树平衡 在计算高度时同时判断平衡只需要O(n)123456789101112private boolean balance =true;public boolean isbalance(TreeNode root)&#123; height(root); return balance;&#125;private int height(TreeNode root)&#123; if(root==null) return 0; int left = height(root.left); int right = height(root.right); if(Math.abs(left-right)&gt;1)balance = false; return Math.max(left,right)+1;&#125; lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree TraversalMorris Inorder(中序) Tree Traversal先把每个中缀的前缀（左子树最右）指向中缀，遍历完后把这些链接都删除还原为 null 找root的前趋：root 的中序前趋是左子树(第一个左结点)cur的最右标记为pre， pre.right = root12345678//找前趋Node cur = root;if(cur.left!=null)&#123; Node pre = current.left; while(pre.right!=null&amp;&amp;pre.right!=cur)&#123; pre=pre.right; &#125;&#125; 12345//创建链接：第一次到达这个最右的结点，cur的左边其实还有结点if(pre.right==null)&#123; pre.right = cur; cur=cur.left;&#125; 找root.left的前趋：cur向左（相当于新的root（1）的状态），找到cur的最右，标识成pre.right = cur 当cur向左是null则找到中序遍历的第一个输出，cur向右 123if(cur.left==null)&#123; sout(current.val); current=current.right;&#125; 当cur的left==null并且右链接已经建立到上一层。cur移动到上一层，找到前趋pre就是右链接的cur.left。 把这个右链接(pre.right)删除，输出（中），然后继续向右（上）并删除这种从前趋right过来的线。 123456//pre.right=curelse if(pre.right!=null)&#123; pre.right = null; sout(cur.val); cur=cur.right;&#125; 671 ？？根的值&lt;=子树的值的二叉树中的第二小元素123 2 2 54 3(out) 1.dfs在set中加入所有节点，遍历set123456int min = root.val;int ans = Long.MAX_VALUE;for(int v:set)&#123; if(min&lt;v&amp;&amp;v&lt;ans)ans = v;&#125;return ans&lt;Long.MAX_VALUE?(int) ans:-1; 2.在dfs的时候只有node.val == root.val的时候表示这个分支需要继续遍历1234567891011min = root.val;int ans = Long.MAX_VALUE;private dfs(TreeNode rote)&#123; if(root!=null)&#123; if(min&lt;root.val&amp;&amp;root.val&lt;ans) ans = root.val; &#125;else if(min == root.val)&#123; dfs(root.left); dfs(root.right); &#125;&#125; 145 后序遍历二叉树1.函数式编程 不用help函数（可变数组），复制数组 展开代码 12345678910public List&lt;Integer&gt; post(TreeNode root)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null)return list; List&lt;Integer&gt; left = post(root.left); List&lt;Integer&gt; right = post(root.right); list.addAll(left); list.addAll(right); list.add(root.val); return list;&#125; 原理：123456rev_post(root): # 全部反过来刚好是后序遍历 print(root-&gt;val); rev_post(root-&gt;right) rev_post(root-&gt;left)reverse(rev_post(root)); 方法1：12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if(root==null)return list; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; root = stack.pop(); list.addFirst(root.val); if(root.left!=null)stack.push(root.left); //下一次poll出的是右子树 if(root.right!=null)stack.push(root.right); &#125; // 如果使用ArrayList 1% //Collections.reverse(list); return list;&#125; lt66 lc 144 二叉树前序遍历 分治方法分治方法，返回值 适合多线程1234567891011121314public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); if(root == null)&#123; return rst; &#125; // Divide List&lt;Integer&gt; left = preorderTraversal(root.left); List&lt;Integer&gt; right = preorderTraversal(root.right); // Conquer rst.add(root.val); rst.addAll(left); rst.addAll(right); return rst;&#125; 迭代： 效率和先入栈right再入栈左是一样的，只是为了扩展123456789101112131415161718public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); if(root == null)&#123; return rst; &#125; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); while (true) &#123; while (root != null) &#123; rst.add(root.val); if(root.right != null) stack.push(root.right); root = root.left; &#125; if(stack.isEmpty())break; root = stack.pop(); &#125; return rst;&#125; 一般方法，返回值void 用的返回值在参数里展开代码 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); helper(root,rst); return rst;&#125;private void helper(TreeNode root,List&lt;Integer&gt; rst)&#123; if(root == null)&#123; return; &#125; rst.add(root.val); helper(root.left,rst); helper(root.right,rst);&#125; lc 94 中序12345678910111213141516171819public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); if(root == null)&#123; return rst; &#125; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); while(true)&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; if(stack.isEmpty()) break; root = stack.pop(); rst.add(root.val); root = root.right; &#125; return rst;&#125; !!!114原地将二叉树变成链表1.入栈迭代40% 1. 先入栈右子树，再入栈左子树，更新右节点为栈顶。 2. 将当前左子树变成null。下一次循环cur是栈顶（原左子树） 后序遍历 递归6%123456pre = null;flat(root.right);flat(root.left);root.right = pre;root.left = null;pre = root; 前序中序构造二叉树A BDEG CFDBGE A CF1234567891011121314public TreeNodeT&lt;Character&gt; createTree(String preOrder,String inOrder)&#123; if(preOrder.isEmpty())return null; char rootVal = preOrder.charAt(0); int leftLen = inOrder.indexOf(rootVal); TreeNodeT&lt;Character&gt; root = new TreeNodeT&lt;Character&gt;(rootVal); root.left = createTree( preOrder.substring(1,1+leftLen), inOrder.substring(0,leftLen)); root.right = createTree( preOrder.substring(1+leftLen), inOrder.substring(leftLen+1)); return root;&#125; 二叉树深度1234public int maxDepth(TreeNode root) &#123; if(root== null)return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1;&#125; dfs1 用map存储每个node的深度12345678910111213141516171819202122232425public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; Map&lt;TreeNode, Integer&gt; depthMap = new HashMap&lt;&gt;(); depthMap.put(root, 1); int maxDepth = 1; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; root = stack.pop(); int depth = depthMap.get(root); maxDepth = Math.max(maxDepth, depthMap.get(root)); if (root.right != null) &#123; depthMap.put(root.right, depth + 1); stack.push(root.right); &#125; if (root.left != null) &#123; depthMap.put(root.left, depth + 1); stack.push(root.left); &#125; depthMap.remove(root); &#125; return maxDepth;&#125; dfs:1234567891011121314151617181920212223public static int maxDepthDFS(TreeNode root) &#123; if(root==null)return 0; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); Deque&lt;Integer&gt; value = new ArrayDeque&lt;&gt;(); stack.push(root); value.push(1); int max = 0; while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); int tmp = value.pop(); max = Math.max(tmp, max); if(node.left!=null)&#123; stack.push(node.left); value.push(tmp+1); &#125; if(node.right!=null)&#123; stack.push(node.right); value.push(tmp+1); &#125; &#125; return max;&#125; bfs12345678910111213141516public static int maxDepth(TreeNode root) &#123; if(root == null)return 0; Deque&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); que.add(root); int cnt = 0; while (!que.isEmpty())&#123; int size = que.size(); while (size--&gt;0)&#123; TreeNode cur = que.poll(); if(cur.left!=null)que.add(cur.left); if(cur.right!=null)que.add(cur.right); &#125; cnt++; &#125; return cnt;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[algTool 正则]]></title>
    <url>%2F2018%2F10%2F09%2FalgTool%2F</url>
    <content type="text"><![CDATA[lc26有序数组去重 双指针12345678910public int removeDuplicates(int[] nums) &#123; if(nums.length == 0)return 0; int cnt = 1; for(int i = 1;i&lt;nums.length;i++)&#123; if(nums[i] != nums[cnt-1])&#123; nums[cnt++] = nums[i]; &#125; &#125; return cnt;&#125; 判断小括号匹配12345678910111213public boolean isValid(String s)&#123; int cnt = 0; for (int i = 0; i &lt; s.length() ; i++) &#123; char c = s.charAt(i); if(c == '(')&#123; cnt++; &#125; if(c ==')' &amp;&amp; cnt-- == 0)&#123; return false; &#125; &#125; return cnt == 0;&#125; 459 一个字符串是不是由一个子串重复构成的 输入: “abab”输出: True 1234public boolean repeatedSubstringPattern(String str) &#123; //This is the kmp issue return str.matches("(.+)\\1+");&#125; 65 Valid Number 常用判断是否是小数整数，带e的浮点数https://blog.csdn.net/mrzhangjwei/article/details/53409967//1.65%非常慢12345678910111213141516171819202122232425public boolean isNumber(String s) &#123; s = s.trim(); if (s.length() == 0 || s.equals("e") || s.equals(".")) return false; return isFloating(s) || isRegular(s);&#125;// parses non-floating point literalsprivate boolean isRegular(String s) &#123; return (s.matches("[+-]?[0-9]+[.]?[0-9]*") || s.matches("[+-]?[0-9]*[.]?[0-9]+"));&#125;// parses floating point literals as defined here: http://en.cppreference.com/w/cpp/language/floating_literalprivate boolean isFloating(String s) &#123; //first one enforces an number after ., the second one enforces a number before . // we want to make sure there's at least one number present. return (s.matches("[+-]?[0-9]*[.]?[0-9]+[eE][-+]?[0-9]+[f]?") || s.matches("[+-]?[0-9]+[.]?[0-9]*[eE][-+]?[0-9]+[f]?"));&#125;//4%public boolean isNumber(String s) &#123; if (s.trim().length()==0) return false; String regexp = "^(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)(e(\\+|-)?[0-9]+)?$"; return s.trim().replaceAll(regexp,"").length()==0;&#125; 无向图 弗洛伊德算法 扩充全部最短路径12345678910111213141516171819202122232425262728// 读取无向图 cost矩阵//[i][i] = 0 没有路径是infmap = new int[n][n];for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(map[i], inf); map[i][i] = 0;&#125;//path 只保留最短for (int i = 1; i &lt;= m; i++) &#123; u = nextInt(); v = nextInt(); val = nextInt(); map[v][u] = map[u][v] = Math.min(map[u][v], val);&#125;//弗洛伊德for (int k = 0; k &lt; n; k++)for (int i = 0; i &lt; n; i++) &#123; //可去 if (map[i][k] == inf) continue; for (int j = 0; j &lt; n; j++) &#123; //可去 if (map[k][j] == inf) continue; map[j][i] = map[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]); &#125;&#125; 最大公约数gcd 复杂度O(log(max(a,b)))123public static long gcd(long a, long b) &#123; return (b == 0) ? a : gcd(b, a % b);&#125; 素数正确二分查找的写法first/last po12345678910111213141516171819202122232425262728int binarySearch(int[] A,int target)&#123; if(A.length==0)&#123; return -1; &#125; int start = 0; int end = A.length-1; int mid; while(start+1&lt;end)&#123; mid = start + (end-start) / 2; if(A[mid]==target)&#123; //find last //start = mid; end = mid; &#125;else if(A[mid]&lt;target)&#123; start = mid; &#125;else&#123; end = mid; &#125; &#125; //find last 先判断end的if if(A[start] == target)&#123; return start; &#125; if(A[end] == target)&#123; return end; &#125; return -1;&#125; 1.查找范围是 [0,len-1][0]：l=0,r=1-1，while(l==r)的时候应该继续123456789101112131415int l = 0,r=n-1;while(l&lt;=r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)&#123; return mid; &#125; else if(arr[mid]&lt;target)&#123; l=mid+1;// &#125; else&#123; r=mid-1; &#125;&#125;//如果l&gt;rreturn -1; 2.[0,len) 保持len取不到[0]:l=0,r=1,l++,while(l==r)的时候应该结束好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的1234567891011121314int l = 0,r = n;while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid]==target)return mid; if(arr[mid]&gt;target)&#123; //在左边，边界为取不到的数 r=mid;//[l,mid) &#125;else&#123; //左闭又开 l = mid+1;//[mid+1,r) &#125;&#125;//如果l==r [1,1)表示空的return -1; lt 458 lastIndexOf12345678910111213public int lastPosition(int[] nums, int target) &#123; if(nums==null||nums.length&lt;1)return -1; int i = 0, j = nums.length-1; while(i&lt;=j)&#123; int mid = (i+j)/2; if(nums[mid]&gt;target)j = mid-1; //找到了继续向右找 else i =mid+1; &#125; if(j&lt;0)return-1; if(nums[j]==target) return j; return -1;&#125; 34 二分查找数字的first+last idx Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 二分查找获取最左/右边相等的 12345678public int[] searchRange(int[] a, int k) &#123; if(a==null||a.length&lt;1)return new int[]&#123;-1,-1&#125;; int first = lowerBound(a, k); if(first==a.length||a[first]!=k)return new int[]&#123;-1,-1&#125;; int last = upper_bound(a, k); last = last==-1||a[last]!=k?-1:last; return new int[]&#123;first,last&#125;;&#125; lower_bound lc35二分搜索lowerBound1234567891011121314151617/* 满足ai&gt;=k条件的最小i* nums[index] &gt;= target, min(index)*/public static int lowerBound(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lb = -1, ub = nums.length; while (lb + 1 &lt; ub) &#123; int mid = lb + (ub - lb) / 2; if (nums[mid] &gt;= target) &#123; ub = mid; &#125; else &#123; lb = mid; &#125; &#125; return ub;&#125; upper_boundai&lt;=k 的最大i123456789101112public static int upper_bound(int[] a,int k)&#123; if (a == null || a.length == 0) return -1; int lb = -1,ub = a.length; while (ub - lb &gt; 1) &#123; int mid = (lb+ub)/2; if(a[mid]&lt;=k)&#123; lb = mid; &#125;else ub = mid; &#125; return lb;&#125; java快速io123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;int test = nextInt();out.println("Case #" + ttt + ":");out.println(ans);out.flush();out.close();static BufferedReader br = new BufferedReader(new InputStreamReader( System.in));static StreamTokenizer in = new StreamTokenizer(br);static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));static String next() throws IOException &#123; in.nextToken(); return in.sval;&#125;static char nextChar() throws IOException &#123; in.nextToken(); return in.sval.charAt(0);&#125;static int nextInt() throws IOException &#123; in.nextToken(); return (int) in.nval;&#125;static long nextLong() throws IOException &#123; in.nextToken(); return (long) in.nval;&#125;static float nextFloat() throws IOException &#123; in.nextToken(); return (float) in.nval;&#125;static double nextDouble() throws IOException &#123; in.nextToken(); return in.nval;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dfs-dp-回溯 & speedup]]></title>
    <url>%2F2018%2F09%2F09%2Falgdfs2bfs2dp2bb%2F</url>
    <content type="text"><![CDATA[60 Permutation Sequence 字典序第k个排列Input: n = 3, k = 3Output: “213” Bellman-Ford复杂度O（VE）还可以用于检查负圈。全部初始化为0而不是INF。如果第n（N个顶点的循环)还更新了 有负圈 Dijkstra：Bellman 用d[i]+edge（i,j)更新d[j]但是d[i]并不是最短，所以浪费。思想：找到最短距离已经确定的点d[i]，从它出发更新i的所有邻点。堆中存储的是 每个顶点当前最短距离。 POJ3255有P条路，有N个点，问从1到N的次短路径是多少。AC POJ 3723 征兵有N女，M男，如果N和M之间有关系，则先招了其中一个，招另一个就可以少付d钱。最大权森林问题。 POJ 3169 排列牛输入 N头牛 关系好ML的2行，关系不好的MD1行。关系好的牛1和牛3最大距离不能超过10.关系差的牛2和牛3最小距离不能小于3.4 2 11 3 102 4 202 3 3 dp[n]是第n头牛的位置按编号顺序排列牛所以d[i+1]&gt;=d[i] 49 异位词(相同字符)分组//todonext直接拿CharArray的sort重建String当key 49%1234567891011121314151617public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); List&lt;List&lt;String&gt;&gt; rst = new ArrayList&lt;&gt;(); for(String str:strs)&#123; char[] chars = str.toCharArray(); Arrays.sort(chars); String key = new String(chars); List&lt;String&gt; keylist = map.getOrDefault(key, new ArrayList&lt;&gt;()); if(keylist.size()==0)&#123; rst.add(keylist); &#125; keylist.add(str); map.put(key,keylist ); &#125; return rst;&#125; word search用全局mark数组58%，改用char修改board98%展开代码 12345678910111213141516171819202122232425262728293031// boolean[][] marked;public boolean exist(char[][] board, String word) &#123; int n = board.length; int m = board[0].length;// marked = new boolean[n][m]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;m ; j++) &#123; if(word.charAt(0)!=board[i][j])continue; if(dfs(board,0,i,j,word))return true; &#125; &#125; return false;&#125;private boolean dfs(char[][] board,int idx,int i,int j,String word)&#123; if(i&gt;board.length-1||i&lt;0||j&gt;board[0].length-1||j&lt;0||word.charAt(idx)!=board[i][j])return false; if(idx==word.length()-1)return true; char tmp = board[i][j];// marked[i][j] = true;board[i][j]='0'; boolean ans = dfs(board,idx+1,i+1,j,word)|| dfs(board,idx+1,i,j+1,word)||dfs(board,idx+1,i-1,j,word) ||dfs(board,idx+1,i,j-1,word);// marked[i][j]=false; board[i][j]=tmp; return ans;&#125; Boggle 12345678910&gt; board =&gt; [ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]&gt; Given word = &quot;ABCCED&quot;, return true.&gt; Given word = &quot;SEE&quot;, return true.&gt; Given word = &quot;ABCB&quot;, return false.&gt; 494 在数字中间放正负号使之==target递归的2种写法另一种void用全局变量累加？？为什么递归中不能写dfs(idx++)O(2^n)12345678private int dfs(int[] nums,int S,int pos)&#123; if(pos == nums.length)&#123; if(S==0)return 1; else return 0; &#125; int cnt =dfs(nums, S+nums[pos], pos+1)+dfs(nums, S-nums[pos], pos+1); return cnt;&#125; 53%优化记忆化：用当前的idx和当前的S当key 注意如果用String key=idx+&quot;&quot;+S有一个case会报错，应该是数字大的时候混淆了。sum不会超过1000所以Integer key = idx*10000+S就可以通过。 dp??：所有可能的target最大值是全部正号sum(a),或者全部负号）dp[2*sum(a)+1]题目sum最大2k，则dp[4001] 17 九宫格输入法数字对应的字符串12345678910111213private String[] letters = &#123;"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;;private void help(List&lt;String&gt; rst,int idx,String digits,String cur)&#123; if(cur.length()==digits.length())&#123; rst.add(cur); return; &#125; if(digits.charAt(idx)&gt;='2'&amp;&amp;digits.charAt(idx)&lt;='9')&#123; String num2letter = letters[digits.charAt(idx)-'0']; for(int i =0;i&lt;num2letter.length();i++)&#123; help(rst,idx+1,digits,cur+num2letter.charAt(i)); &#125; &#125;&#125; 93 分解Ip地址dfs123456789101112private void dfs(List&lt;String&gt; rst,String s,int idx,String cur,int cnt)&#123; if(cnt&gt;4)return; if(cnt==4&amp;&amp;idx==s.length())&#123; rst.add(cur); &#125; for(int i =1;i&lt;4;i++)&#123; if(idx+i&gt;s.length())break; String tmp = s.substring(idx,idx+i); if((tmp.startsWith("0")&amp;&amp;tmp.length()&gt;1)||(i==3&amp;&amp;Integer.parseInt(tmp)&gt;=256))continue; dfs(rst,s,idx+i,cur+tmp+(cnt==3?"":"."),cnt+1); &#125;&#125; 784 大小写字母的permutation&#39;a&#39;-&#39;A&#39;=32所以就是(1&lt;&lt;5)的位置是0或1，但是不会变快小写和数字都加上这一位继续dfs，大写要123456if(idxchar-'A'&gt;=0&amp;&amp;idxchar-'A'&lt;26||idxchar-'a'&gt;=0&amp;&amp;idxchar-'a'&lt;26)&#123; idxchar = (char)(idxchar^(1&lt;&lt;5)); dfs(s,idx+1,cur+idxchar); idxchar = (char)(idxchar^(1&lt;&lt;5));&#125; dfs(s,idx+1,cur+idxchar); $C(n,r) = P(n,r)/r!$ 46 permutations生成全排列的算法: 移动高位1的全排列只有1，1，2的全排列考虑2 放在1前，1后1，2，3的全排列考虑3 放在 1，2 的全排列的左中右3个位置 一共3*2 = 6种 给定{1..n-1}的排列，存在n种方法将n插入得到{1..n}的排列n个球放入r个盒子里分步递推：$P(n,r)=nP(n-1,r-1)$分类递推：不选第一个球，方案数$P(n-1,r)$,选第一个球方案数$rP(n-1,r-1)$-&gt;$P(n,r)=P(n-1,r)+rP(n-1,r-1)$O(2^n)复杂度 3ms1234if(tmp.size()==nums.length)&#123; rst.add(new ArrayList&lt;Integer&gt;(tmp)); return;&#125; 一定要复制一份tmp，不然tmp是对象最后tmp会被remove为空1234567for(int i =0;i&lt;nums.length;i++)&#123; //dfs的marked if(tmp.contains(nums[i]))continue; tmp.add(nums[i]); help(rst,nums,tmp); tmp.remove(tmp.size()-1);&#125; O(n!)复杂度 只能处理10个数字不用contains 用markd数组 3ms展开代码 1234567891011121314151617181920212223boolean[] used;private void dfs(int idx,List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; tmp,int[] nums)&#123; if(idx&gt;=nums.length)&#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; //注意 排列无顺序 每次从0开始，但是要去重 for(int i = 0;i&lt;nums.length;i++)&#123; if(used[i]) continue; used[i] = true; tmp.add(nums[i]); dfs(idx+1,rst,tmp,nums); tmp.remove(tmp.size()-1); used[i] = false; &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); int n = nums.length; used = new boolean[n]; dfs(0,rst,new ArrayList&lt;&gt;(),nums); return rst;&#125; 方法2 swap java不能int[]-&gt;List SJI算法：可移动数 [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]12345678910111213141516vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; ans; help(nums,0,ans); return ans;&#125;void help(vector&lt;int&gt; &amp;num,int begin,vector&lt;vector&lt;int&gt; &gt; &amp;ans)&#123; if(begin&gt;=num.size())&#123; ans.push_back(num); return; &#125; for(int i =begin;i&lt;num.size();i++)&#123; swap(num[begin],num[i]); help(num,begin+1,ans); swap(num[begin],num[i]); &#125;&#125; 39 Combination tum target 不重复元素组合求目标 candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] 注意这种写法 如果输入[1,1,1] 有重复元素的不行关键：加上start，防止出现3,2,2的重复组合比排列dfs的时候多一个start,每次只向后取数字先输出[2,2,3]44% 15ms12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); help(rst,candidates,target,new ArrayList&lt;&gt;(),0); return rst;&#125;private void help(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,int target,List&lt;Integer&gt; tmp,int idx)&#123;if(target&lt;0)return; if (target == 0) &#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125;for (int i = idx ; i &lt;candi.length; i++) &#123; //因为排序了，如果之后元素都大则不用向装这个向后找了 if(candi[i]&gt;target)break; tmp.add(candi[i]); //可以使用重复元素则idx,不能重复则idx+1 help(rst,candi, target-candi[i], tmp,i); tmp.remove(tmp.size()-1); &#125;&#125; 如果要先输出长度短的：先输出[7] 加个长度d和总长度len可以作为从N个数里选len个数的模板12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSumLenOrder(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); //最长用第一个元素target/candi[0]次 for (int i = 1; i &lt;=target/candidates[0] ; i++) &#123; dfs(rst,candidates,new ArrayList&lt;&gt;(),target,0,0,i); &#125; return rst;&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,List&lt;Integer&gt; tmp,int target,int d,int idx,int len)&#123; if(d==len)&#123; if(target==0)rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = idx; i &lt;candi.length ; i++) &#123; if(candi[i]&gt;target)break; tmp.add(candi[i]); dfs(rst,candi,tmp,target-candi[i],d+1,i,len); tmp.remove(tmp.size()-1); &#125;&#125; lt135 有重复元素的可以利用一个元素多次的comb sum 输入[1,1,1],target = 2 -&gt; [[1,1]] 方法1.用set去重1234567Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i:candidates)set.add(i); int[] nums = new int[set.size()]; int idx =0; for(int i:set)&#123; nums[idx++] = i; &#125; 方法2.加一行12345678for(int i = idx;i&lt;candidates.length;i++)&#123; if(candidates[i]&gt;target)break; //跳过重复的 if(i&gt;0&amp;&amp;candidates[i]==candidates[i-1])continue; tmp.add(candidates[i]); dfs(rst,candidates,target-candidates[i],tmp,i); tmp.remove(tmp.size()-1);&#125; 40 有重复元素且每个元素只能用一次的combsum1.直接用Set&lt;List&gt;-&gt;List&lt;List&gt; 34ms 11% 加上注意一定是&gt;idx,不然[1,1]会被跳过if(i&gt;idx&amp;&amp;candi[i]==candi[i-1])continue;并且dfs(rst,candi, target-candi[i], tmp,i+1); 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; rst = new ArrayList&lt;&gt;(); Arrays.sort(candidates); dfs(rst,candidates,target,new ArrayList&lt;&gt;(),0); return new ArrayList&lt;&gt;(rst);&#125;private void dfs(List&lt;List&lt;Integer&gt;&gt; rst,int[] candi,int target,List&lt;Integer&gt; tmp,int idx)&#123; if(target&lt;0)return; if (target == 0) &#123; rst.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = idx ; i &lt;candi.length; i++) &#123; if(candi[i]&gt;target)break; //不是第一个元素，如果是[1,1,1] 这一层不找相同的元素 if(i&gt;idx&amp;&amp;candi[i]==candi[i-1])continue; tmp.add(candi[i]); //可以使用重复元素则idx,不能重复则idx+1 dfs(rst,candi, target-candi[i], tmp,i+1); tmp.remove(tmp.size()-1); &#125;&#125; 216 从1-9中选k个数字组成target 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] AC 78% 1ms lt564 无重复，可用多次，顺序不一样也计数，组成target的个数 dp 给出 nums = [1, 2, 4], target = 4可能的所有组合有：[1, 1, 1, 1][1, 1, 2][1, 2, 1][2, 1, 1][2, 2][4]返回 6 45jump game cnt 2do next timedp:12345678910111213141516 private int jumpdp(int[] nums)&#123; int n = nums.length; int[] dp = new int[n]; if(n == 0||nums[0] ==0)return 0; dp[0] = 0; for (int i = 1; i &lt; n; i++) &#123; dp[i] = Integer.MAX_VALUE; for (int j = 0; j &lt;i ; j++) &#123; if(i&lt;=j+nums[j]&amp;&amp;dp[j]!= Integer.MAX_VALUE)&#123; dp[i] = Math.min(dp[i],dp[j]+1); break; &#125; &#125; &#125; return dp[n-1];&#125; BFS：12345678910111213141516171819public int jumpBFS(int[] nums)&#123; if(nums==null||nums.length&lt;2)return 0; int level = 0; int cur = 0; int max =0; int i =0; //cur-i+1=1,level++; i&lt;=cur,i++,max = 2;cur = 2; //cur=2,i=1;level++; i&lt;=2,i++,max = 4,max&gt;=n-1 return 2; while (cur-i+1&gt;0)&#123; level++; for(;i&lt;=cur;i++)&#123; max = Math.max(max,nums[i]+i); if(max&gt;=nums.length-1)return level; &#125; cur = max; &#125; return 0;&#125; 递归1234567891011121314151617181920212223public int minJumpRecur(int[] arr)&#123; int n = arr.length; memo = new int[n][n]; return jump(arr, 0, n-1);&#125;int[][] memo;private int jump(int[] steps,int from,int end)&#123;// System.out.println(from+" "+end); if(from==end)return 0; //不可达 if(memo[from][end]!=0)return memo[from][end]; if(steps[from]==0)return Integer.MAX_VALUE; int min = Integer.MAX_VALUE; //当前可以到达的范围是[from,from+step[from]] for(int i = from+1;i&lt;=end&amp;&amp;i&lt;=from+steps[from];i++)&#123; int jumps = jump(steps,i , end); if(jumps!=Integer.MAX_VALUE&amp;&amp;jumps+1&lt;min)&#123; min = jumps+1; memo[from][end] = min; &#125; &#125; return min;&#125; 最正常的做法：12345678910111213141516171819public int jump(int[] nums) &#123; if(nums==null||nums.length&lt;2)return 0; int res = 0; int curMax = 0; int maxNext = 0; //i=0,max = 2 i==cur -&gt;res++,cur = max=2 //i=1,max = max(2,4)=4, i!=cur //i=2,max = max(4,3)=4, i==cur res++,cur = max=4 //i=3,max = max(4,4)=4, i!=cur break //不需要走到i=4,max = max(4,4+4)=8,i==cur res++,cur=max for (int i = 0; i &lt; nums.length-1; i++) &#123; maxNext = Math.max(maxNext,i+nums[i] ); if(i==curMax)&#123; res++; curMax = maxNext; &#125; &#125; return res;&#125; 743 从一个node广播，让所有节点收到最多要多久 单源最短路径 time[[2,1,1],[2,3,1],[3,4,1]] times[i] = (u, v, w) u到v花费wN个节点，从K发送dijkstra如果用heap可以从$N^2$-&gt;$NlogN+E$ O(N+E)Bellman-Ford O(NE)稠密图不好 空间O(N) 可以有负的路径Floyd-Warshall O(N^3) heapDijkstra78%//todo faster dijkstra:每次扩展距离最近的点 70% 32ms1234567891011121314151617181920212223242526272829303132333435363738public int networkDelayTimeDFSDj(int[][] times, int N, int K) &#123; Map&lt;Integer,List&lt;int[]&gt;&gt; graph = new HashMap&lt;&gt;(); for(int[] edge:times) &#123; if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList&lt;int[]&gt;()); graph.get(edge[0]).add(new int[]&#123;edge[1], edge[2]&#125;); &#125; int[] dis = new int[N]; Arrays.fill(dis, Integer.MAX_VALUE); dis[K-1]=0; boolean[] marked = new boolean[N+1]; while (true)&#123; int candNode =-1; int canDist = Integer.MAX_VALUE; for (int i = 1; i &lt;= N ; i++) &#123; //最近的点 if(!marked[i]&amp;&amp;dis[i-1]&lt;canDist)&#123; canDist = dis[i-1]; candNode = i; &#125; &#125;// System.out.println(candNode); //都当作扩展点过了, if(candNode&lt;0)break; marked[candNode] = true; //最近点的邻接 if(graph.containsKey(candNode)) for(int[] next:graph.get(candNode)) dis[next[0]-1] = Math.min(dis[next[0]-1],dis[candNode-1]+next[1]);// System.out.println(Arrays.toString(dis)); &#125; int ans = 0; for(int cost:dis)&#123; if(cost==Integer.MAX_VALUE)return -1; ans= Math.max(ans,cost); &#125; return ans;&#125; dfs: 邻接表 建图，递归终止条件:到达所有点花费的时间已经是最小的了dfs Hashmap6% 改成数组11% 124ms12345678910111213141516171819202122232425262728293031public int networkDelayTimeDFS(int[][] times, int N, int K) &#123; //creategraph Map&lt;Integer,List&lt;int[]&gt;&gt; graph = new HashMap&lt;&gt;(); for(int[] edge:times) &#123; if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList&lt;int[]&gt;()); graph.get(edge[0]).add(new int[]&#123;edge[1], edge[2]&#125;); &#125;//end-creategraph //只是为了加速， 不排序2.8% 352ms for(int node:graph.keySet())&#123; Collections.sort(graph.get(node),(a,b)-&gt;a[1]-b[1]); &#125; dis = new int[N]; Arrays.fill(dis, Integer.MAX_VALUE); dfs(graph,K,0); int ans = 0; for(int cost:dis)&#123; ans = Math.max(ans,cost); &#125; return ans==Integer.MAX_VALUE?-1:ans;&#125;//用于记录到某点的距离，如果到这个点花费的时间已经超过记录的最小值了，不对这个点dfs了。int[] dis;private void dfs(Map&lt;Integer,List&lt;int[]&gt;&gt; graph,int node,int elased)&#123; if(elased&gt;=dis[node-1])return; dis[node-1]=elased; if(graph.containsKey(node))&#123; for(int[] nei:graph.get(node)) dfs(graph,nei[0],elased+nei[1]); &#125;&#125; 12345678910111213141516171819202122232425262728293031/**Bellman Ford 边集 * 从K点广播给N个点需要的最少时间 * @param times u到v花费w秒 1 &lt;= w &lt;= 100. * @param N N will be in the range [1, 100]. * @param K * @return */public int networkDelayTime(int[][] times, int N, int K) &#123; int max_time = 100*101; int[] dis = new int[N]; int rst = Integer.MIN_VALUE; Arrays.fill(dis,max_time); //起点 dis[K-1] = 0; //其他N-1个点 for (int i = 1; i &lt;N ; i++) &#123; //遍历n次边的数组 for(int[] edge:times)&#123; int u = edge[0]-1; int v = edge[1]-1; int w = edge[2]; //动态规划 dis[v] = Math.min(dis[v],dis[u]+w); &#125; &#125; for(int cost:dis)&#123; rst = Math.max(cost,rst ); &#125; return rst == max_time?-1:rst;&#125; 弗洛伊德算法 边集12345678910111213141516171819202122232425public int networkDelayTimeF(int[][] times, int N, int K) &#123; int max_time = 100*101; //二维数组 表示i到j的最短路径 int[][] dis = new int[N][N]; for(int[] d:dis)&#123; Arrays.fill(d,max_time); &#125; for(int[] time:times)&#123; dis[time[0]-1][time[1]-1] = time[2]; &#125; for (int i = 0; i &lt;N ; i++) &#123; dis[i][i] =0; &#125; for (int k = 0; k &lt;N ; k++) for (int i = 0; i &lt;N ; i++) for (int j = 0; j &lt;N ; j++) //三维动态规划 dis[i][j] = Math.min(dis[i][j],dis[i][k]+dis[k][j]); int ans = Integer.MIN_VALUE; for (int i = 0; i &lt;N ; i++) &#123; if(dis[K-1][i]&gt;=max_time)return -1; ans = Math.max(ans,dis[K-1][i]); &#125; return ans;&#125; 343 整数拆分 并使乘机最大 Input: 2Output: 1Explanation: 2 = 1 + 1, 1 × 1 = 1. 123456789101112131415int[] memo;public int IntegerBread(int n)&#123; memo = new int[n+1]; return ib(n);&#125;private int ib(int n)&#123; if(memo[n]!=0)return memo[n]; if(n==1)return 1; int res = -1; for(int i=1;i&lt;n;i++)&#123; res = Math.max(res,Math.max(i*(n-i),i*ib(n-i))); memo[n]=res; &#125; return res;&#125; dp：12345678910public int integerBreak(int n) &#123; int[] dp = new int[n+1]; dp[1]=1; for(int i =2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i-1;j++)&#123; dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j])); &#125; &#125; return dp[n]; 数学方法：考虑f=x(N-x) 当x=N/2的时候取最大值。所以当N是偶数时，最大值是(N/2)(N/2)当N是奇数， 最大值是(N-1)/2 (N+1)/26, 3 * 3&gt;2 * 2 * 2123456789101112public int integerBreak(int n) &#123; if(n==2) return 1; if(n==3) return 2; int product = 1; while(n&gt;4)&#123; product*=3; n-=3; &#125; product*=n; return product;&#125; 787 中间最多停留k次的，最小花费路线 Input: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 1from src to dst with up to k stops 最小花费Output: 200 dfs：复杂度n^(k+1)1.cost边集-&gt;邻接表12345678Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; edgeC2graph(int[][]edges,int n)&#123; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = new HashMap&lt;&gt;(n); for (int[] edge : edges) &#123; graph.putIfAbsent(edge[0], new HashMap&lt;&gt;()); graph.get(edge[0]).put(edge[1], edge[2]); &#125; return graph;&#125; dfs 常规回溯1234567891011121314151617181920212223242526272829303132Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph;boolean[] visited;public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; graph = new HashMap&lt;&gt;(n); for (int[] edge : flights) &#123; graph.putIfAbsent(edge[0], new HashMap&lt;&gt;()); graph.get(edge[0]).put(edge[1], edge[2]); &#125; visited = new boolean[n]; visited[src] = true; dfs(graph, src, dst, K + 1, 0); return ans == Integer.MAX_VALUE ? -1 : ans;&#125;int ans = Integer.MAX_VALUE;private void dfs(Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph, int src, int dst, int k, int cost) &#123; if (src == dst) &#123; ans = cost; return; &#125; if (k == 0) return; Map&lt;Integer, Integer&gt; adj = graph.getOrDefault(src,new HashMap&lt;&gt;()); for (int key : adj.keySet()) &#123; if (visited[key]) continue; if (cost + adj.get(key) &gt; ans) continue; visited[key] = true; dfs(graph, key, dst, k - 1, cost + adj.get(key)); visited[key] = false; &#125;&#125; 94msbfs:复杂度n^(k+1) Dijkstra 最小优先队列扩展，先扩展加上下一个点cost最小的1234567891011121314151617181920public int findCheapestPriceDj(int n, int[][] flights, int src, int dst, int k) &#123; Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; graph = edgeC2graph(flights, n); //每次选cost最小的先扩展 Queue&lt;int[]&gt; que = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[0])); que.add(new int[]&#123;0,src,k+1&#125;); while(!que.isEmpty())&#123; int[] top = que.remove(); int price = top[0]; int city = top[1]; int stops = top[2]; if(city == dst)return price; if(stops&gt;0)&#123; Map&lt;Integer, Integer&gt; adj = graph.getOrDefault(city, new HashMap&lt;&gt;()); for(int a:adj.keySet())&#123; que.add(new int[]&#123;price+adj.get(a),a,stops-1&#125;); &#125; &#125; &#125; return -1;&#125; bellman-ford 单源到所有点的最短路径kn^2 dpdp[k][v] 从起点到v最多k次stop的最小花费123456789101112131415161718192021public int findCheapestPriceDp(int n, int[][] flights, int src, int dst, int k) &#123; int max = 10001*(k+2); //走1~k+1步 int[][] dp = new int[k+2][n]; for(int[] ints:dp)&#123; for (int j = 0; j &lt; n; j++) &#123; ints[j] = max; &#125; &#125; dp[0][src] = 0; //如果不限制中间k个点，则可以遍历n次 for (int i = 1; i &lt;= k+1; i++) &#123; //走i步走到src ， cost 0 dp[i][src] = 0; for(int[] flight:flights)&#123; //关键 dp[i][flight[1]] = Math.min(dp[i][flight[1]],dp[i-1][flight[0]]+flight[2]); &#125; &#125; return dp[k+1][dst]&gt;=max?-1:dp[k+1][dst];&#125; ？96 不同的BST数量 catalan数 Input: 3Output: 5 (为什么是乘)12345671个节点只有1种，2个节点1 2 一共两种 \ / 2 13个节点1 2 3 / \ / \ / \ （0）(2) (1)(1) (2)(0) 1x2 + 1x1 + 2x1 当n=5 $T[4]+T[1][3]+T[2][2]+T[3][1]+T[4]$ 左子树有j个节点，右子树有n-j-1个节点123456789101112int[] dp = new int[n+1];dp[0] = 1;dp[1] = 1;//节点个数for(int i =2;i&lt;=n;i++)&#123; //左边j个 for(int j =0;j&lt;i;j++)&#123; //注意是累加 dp[i]+=dp[j]*dp[i-j-1]; &#125;&#125;return dp[n]; dfs:1234567891011121314public int numTreesDfs(int n) &#123; int[] memory = new int[n+1]; return dfs(n,memory);&#125;public int dfs(int n,int[] memroy)&#123; if(n==0||n==1)return 1; if(memroy[n-1]!=0)return memroy[n-1]; int sum = 0; for (int i = 1; i &lt;=n ; i++) &#123; sum+=dfs(i-1,memroy)*dfs(n-i,memroy); &#125; memroy[n-1] = sum; return sum;&#125; 12int ans[] = &#123;1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190&#125;;return ans[n]; 12345int res = 0;if(n&lt;=1)return 1;for (int i = 0; i &lt; n; i++) &#123; res += catalan(i) * catalan(n - i - 1);&#125; 二项式系数123456789101112private int C(int a,int b)&#123; long res = 1; for(int i =0;i&lt;Math.min(b,a-b);i++)&#123; res=res*(a-i)/(i+1); &#125; return (int)res;&#125;//C(2n,n)/(n+1)public int catalen2(int n)&#123; int c =C(2*n,n); return c/(n+1);&#125; 847 BFS边可以重复访问的访问所有点的最短路径graph.length = N Input: [[1,2,3],[0],[0],[0]] 邻接表Output: 4Explanation: One possible path is [1,0,2,0,3] dp：比tsp少判断一次next已经是访问过的点12345678910111213141516171819202122232425public int shortestPathLengthDP(int[][] graph) &#123; int n = graph.length; int[][] dp = new int[n][1&lt;&lt;n]; Deque&lt;State&gt; que = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(dp[i],Integer.MAX_VALUE); dp[i][1&lt;&lt;i]=0; que.add(new State(i,1&lt;&lt;i)); &#125; while(!que.isEmpty())&#123; State state = que.poll(); for(int next:graph[state.source])&#123; int nextMask = state.mask|(1&lt;&lt;next); if(dp[next][nextMask]&gt;dp[state.source][state.mask]+1)&#123; dp[next][nextMask] = dp[state.source][state.mask]+1; que.add(new State(next,nextMask)); &#125; &#125; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt;n ; i++) &#123; res = Math.min(res, dp[i][(1&lt;&lt;n)-1]); &#125; return res;&#125; BFS： 定点可以访问多次，用当前搜索节点和当前访问过的节点mask作为visited数组 bfs第一层每个顶点都可以作为出发点 que中存储pair&lt;当前节点，访问过的节点&gt; 展开代码 12345678910111213141516171819202122232425262728293031class Pair&lt;K,V&gt;&#123; K key; V value;&#125;public int shortestPathLength(int[][] graph) &#123; int n = graph.length; int endState = (1&lt;&lt;n)-1; Deque&lt;Pair&lt;Integer,Integer&gt;&gt; que = new ArrayDeque&lt;&gt;(); boolean [][] visited = new boolean[n][1&lt;&lt;n]; for(int i=0;i&lt;n;i++)&#123; que.add(new Pair&lt;&gt;(i,1&lt;&lt;i)); &#125; int step =0; while(!que.isEmpty())&#123; int size = que.size(); while(size--&gt;0)&#123; Pair&lt;Integer, Integer&gt; front = que.poll(); Integer cur = front.key; Integer state = front.value; // mask全是1，访问了所有点 if(state == endState) return step; if(visited[cur][state])continue; visited[cur][state] = true; for(int next:graph[cur])&#123; que.add(new Pair&lt;&gt;(next,state|(1&lt;&lt;next))); &#125; &#125; step++; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[need2Learn]]></title>
    <url>%2F2018%2F09%2F07%2Fneed2Learn%2F</url>
    <content type="text"><![CDATA[有用的知识整理https://mp.weixin.qq.com/s/7mnsUxUhUMynZXKQZ3rh2w todoList Octotree 分屏翻译chrome插件 排值日小程序 tx实习 编程基本功扎实，掌握C/C++/JAVA等开发语言、常用算法和数据结构； 熟悉TCP/UDP网络协议及相关编程、进程间通讯编程； 了解Python、Shell、Perl等脚本语言； 了解MYSQL及SQL语言、编程，了解NoSQL,&nbsp;key-value存储原理； 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识； 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。 商汤java开发实习2.具备扎实的Java基础知识和良好的编码风格，深入理解Java虚拟机，反射机制以及常用的设计模式。3.熟悉MVC设计模式，掌握SpringMVC、Mybatis等主流MVC框架的工作原理。4.熟练使用MySQL，至少熟悉Redis、Memcached、Kafka、Dubbo等主流中间件框架中的二种，及其原理。5.熟悉Nginx、Tomcat、Netty等应用服务框架，熟练用Linux/UNIX等服务器的常用命令。6.熟练使用常见的IDE工具，如Idea、eclipse、maven、gradle、git等。7.具有良好的团队协作能力，具备较强的自我驱动意识和学习能力。使]]></content>
  </entry>
  <entry>
    <title><![CDATA[activiti和项目整理]]></title>
    <url>%2F2018%2F09%2F05%2Factiviti%2F</url>
    <content type="text"><![CDATA[查看tomcat启动jps -mlv复制3个war包到tomcat webapphttp://localhost:8080/activiti-app/admin testhttp://localhost:8080/activiti-adminadmin admin git checkout -b bpmnLearn activiti-6.0.0mvn clean test-compile models-activiti-engine 包结构cfg : 配置compatibility : 兼容性debug : 使用debug下的功能 看内部运行机制 可以看到更多logdelegate ： 实现节点的类event ： 节点的事件监听机制form : 工作流的表单 节点的通用表单history : 工作流跑完每个节点的记录 为保证运行时的速度 流程执行完的数据放到historyidentity : 节点的权限认证impl ： 实现 其他都是 概念定义 和 接口配置logging : 打印上下文变量（？的日志 可以看到这条日志是在执行哪个流程的时候打印的management : 管理相关的接口和apiparse : 解析流程文件的xmlquery ： 查询接口 依赖mybatisrepository : 流程部署到数据库runtime ： 执行过程中的api 执行完放到historytask ： 人工处理的节点test : 单元测试 集成测试其他异常类xxxException其他xxxService resources 目录 配置文件META-INF.services里的文件 指定ScriptEnginFactoryorg.activiti 里 db：各种数据库脚本sql文件，对应mybatis的配置文件xml，数据库的properties文件(数据库方言)，db升级 engine.impl 流程的logo misc 国际化文件 test 目录单元测试resource log4j的配置文件等 Activiti 6.0 模块核心模块activiti-engine 核心引擎activiti-spring Spring 集成模块activiti-spring-boot SpringBoot 集成模块 提供了stater和autoconfigureactiviti-rest 对外无状态 rest api 模块 方便为其他第三方提供服务activiti-form-engine 表单引擎模块 方便自定义表单模型activiti-Idap 集成Idap用户模块 依赖的模块bpmn-converter 模型转换模块process-validation 模型流程校验模块image-generator xml绘制图形模块dmn-api 决策标准form-apiform-model 启动models-activiti-app12cd D:\Activiti\modules\activiti-uimvn clen tomcat7:run 访问：http://localhost:9999/activiti-app/ activiti-ui模块activiti-app ： activiti集成发布的war工程 没有java代码 只有前端和依赖的jar包以下都是jar包作为-app的依赖activiti-app-conf ： 业务外的配置 数据源 集成的内容activiti-app-logic ： ui实现的业务逻辑activiti-app-rest ： 提供rest api接口]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2018%2F09%2F05%2Fredis%2F</url>
    <content type="text"><![CDATA[我什么要用setnx作分布式啊？完全没必要，使用setex（原子操作） 不就可以了嘛？ setex 会覆盖之前的设置的 key，返回ok，这样就办法上锁了 过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。 MurmurHash算法输入键有规律 算法仍能给出一个很好的随机分布。 ConcurrentSkipListMap4.搭建redis服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152cd /usr/localtar -zvxf yum -y install gcc gcc-c++ libstdc++-develmake MALLOC=libcyum install tclmake testvi tests/integration/replication-2.tcl 1000-&gt;10000make installredis-servervi redis.conf bind 127.0.0.1-&gt;0.0.0.0所有ip都能访问 :/dae daemonize yes 允许后台执行redis-server ./redis.conf#Redis version=4.0.2, bits=64, commit=00000000, modified=0, pid=10217, just startedps -ef |grep redis#root 10218 1 0 10:42 ? 00:00:00 redis-server 0.0.0.0:6379redis-cli#给redis加密码vi redis.conf :/requirepass # requirepass foobared -&gt; requirepass 123456#重启redis-cli shutdown save exitps -ef | grep redisredis-server ./redis.confredis-cli auth 123456# 变成系统服务cd utils./install_server.sh# 配置文件位置 /usr/local/redis-4.0.2/redis.conf# log位置 /usr/local/redis-4.0.2/redis.log# data位置 /usr/local/redis-4.0.2/data# 可执行文件路径chkconfig --list |grep redis# redis_6379 0:关 1:关 2:开 3:开 4:开 5:开 6:关systemctl status redis_6379systemctl stop redis_6379systemctl start redis_6379ps -ef |grep redis# 改服务名vi /etc/init.d/redis_6379# ！打开防火墙firewall-cmd --zone=public --add-port=6379/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-ports 查看配置config get * 常用APIkeys * 查询所有的键，会遍历所有的键值，复杂度O(n)dbsize 查询键总数，直接获取redis内置的键总数变量，复杂度O(1)exists key 存在返回1，不存在返回0 O(1) ttl 命令可以查看键hello的剩余过期时间，单位：秒（&gt;0剩余过期时间；-1没设置过期时间；-2键不存在）expire key seconds 当超过过期时间，会自动删除，key在seconds秒后过期persist key 去掉过期时间 type key 如果键hello是字符串类型，则返回string；如果键不存在，则返回none 所有key都是字符串 redis 单线程 所以命令会等待redis 使用epoll模型多路复用 redis自身实现的事件处理 将epoll的读写、连接、关闭转换成自身的事件。不在IO上浪费时间fysnc file 是独立线程 数据结构字符串 应用场景： 缓存、计数器、分布式锁结构： key：value因为单线程 所以无竞争 线程安全mget和n次get mget省了很多网络开销 从n网络n命令-&gt;1网络n命令) 场景1： 缓存视频基本信息redismysql 场景2： 分布式ID生成器incr id hash 可以更新属性用户信息用hash 可以部分更新属性但是比较难控制过期时间，只能对一个key设置过期时间 不能对一个属性field 不能相同结构 key-&gt;field,value id看成是一行，field是列 场景1：记录网站每个用户个人主页的访问量hincrby user:1:info pageview count 场景2：缓存视频基本信息redismysql list 列表key：element 是有序（插入顺序）队列 双端队列 可以获得range阻塞插入，对空的队列进行pop，不是立刻返回 而是等一段时间拿到最新的弹出用户生产者消费者模型 消息队列 实现1.capped collection LPUSH+LTRIM 有固定数量的列表而不是无限放大2.消息队列 LPUSH + BRPOP3.stack LPUSH + LPOP4.queue LPUSH + RPOP 场景1：微博TimeLine 将所有我关注的用户的最新微博按新旧排、分页每条微博作为一个对象，自己的微博id作为外联key set 集合key : values (values不能有)可以做 inter(共同）\diff\union操作 1 打标签Tag ： SADD2 随机数 ：SPOP/SRANDMEMBER3 社交网络操作 ： SADD + SINTER 场景1： 抽奖srandmember,spop场景2： like 、 点赞 、 踩场景3： 给用户添加标签，给标签添加用户zset 有序集合结构key : (score:value) value不重复 凭借score排序可以更新score 场景1： 畅销榜使用 时间戳、销售量 关注量作为score同样可以使用集合的交集、并、diff 慢查询可能发在生命周期4步里的第3步。 1 发送命令 2 排队 3 执行命令 4 返回结果配置 maxlen 一般设置成1ms 默认10ms希望一秒执行万次 每条0.1ms 超过1ms就应该记录这条命令了队列长度一般1000 慢查询定期要持久化12345127.0.0.1:6379&gt; config get slowlog*1) "slowlog-log-slower-than"2) "10000" 3) "slowlog-max-len"4) "128" 获取慢查询队列12slowlog get nslowlog len # 长度 流水线redis命令执行时间是微妙北京-上海 1300km， 光速3x10^8 m/s -&gt; 300 000 km/s光线速度是2/3光速 = 200 000 km/s 一条命令的传输时间是 (1300x2)/200 000 = 13 ms m操作是原子的，pipeline不是，还是排队，但是顺序是对的，只能操作在一个redis节点上12345Pipeline pipeline = jedis.pipelined();for (int i = 0; i &lt;100 ; i++) &#123; pipeline.hset("hashkey:"+i,"field"+i ,"value"+i );&#125;pipeline.syncAndReturnAll(); 发布订阅角色： 发布者 订阅者 频道不能消息堆积 现在订阅访问不到以前的1234567127.0.0.1:6379&gt; publish cloud:tv "hello world"(integer) 0 # 订阅的人数127.0.0.1:6379&gt; subscribe cloud:tvReading messages... (press Ctrl-C to quit)1) "subscribe"2) "cloud:tv"3) (integer) 1 epoll实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[背包、鸡蛋、找钱、名人、车票]]></title>
    <url>%2F2018%2F09%2F04%2FalgRight%2F</url>
    <content type="text"><![CDATA[poj2686 车票约束的最短路径123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * * 3 4 3路径数量 1 4 3 1 2 1 2 10 2 3 30 3 4 20 time = graph[v][w]/hourse[i] * @param n ticket number 一张票只能走一条路 * @param m city number * @param graph * @param a 起点 * @param b 终点 * @param hourse 马的数量 * @return */public static double mintime(int n,int m,int[][] graph,int a,int b,int[] hourse)&#123; // dp[S][v]剩下车票S 当前在城市v的最小花费 double[][] dp = new double[1&lt;&lt;n][m]; for (int i = 0; i &lt;1&lt;&lt;n ; i++) &#123; Arrays.fill(dp[i], inf); &#125; //起点 dp[(1&lt;&lt;n)-1][a-1] = 0; double res = inf; //n = 3 S = 111 用哪个车票的子集 for (int S = (1&lt;&lt;n)-1; S &gt;=0 ; S--) &#123; res = Math.min(res, dp[S][b-1]); for (int v = 0; v &lt; m ; v++) &#123; //车票i for (int i = 0; i &lt; n ; i++) &#123; if((S&gt;&gt;i &amp; 1)!=0)&#123; for (int u = 0; u &lt;m ; u++) &#123; if(graph[v][u]&gt;=0)&#123; dp[S&amp;~(1&lt;&lt;i)][u] = Math.min(dp[S&amp;~(1&lt;&lt;i)][u],dp[S][v]+(double)graph[v][u]/hourse[i]); &#125; &#125; &#125; &#125; &#125; &#125; if(res == inf)&#123; return -1; &#125;else return res;&#125; LCS 最长公共子序列 长度 “abcd” “becd” -&gt;3(“bcd”) 1234567891011121314public int lcs(String s,String t)&#123; int n = s.length(); int m = t.length(); int[][] dp = new int[n+1][m+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;m ; j++) &#123; if(s.charAt(i)==t.charAt(j))&#123; dp[i+1][j+1] = dp[i][j]+1; &#125;else dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]); &#125; &#125; return dp[n][m];&#125; 背包9讲:01背包：每个物品只能放1次 dp求解背包问题的复杂度是O(nW) 超大背包v和w都很大，n很小//364 1&lt;wi&lt;10^7 1&lt;w&lt;10^9重量范围很大的01背包！！！测试lt125 同01背包： n = 4; A = {2,1,3,2}; V = {3,2,4,2}; W = 5; dp[i+1][j]表示取前i个物品，获得value j的最小W123456789101112131415161718192021222324int maxV = 100;int maxW = 1000000000;public int bigW01bag(int[] A,int[] V,int W)&#123; int n = A.length; //dp[i+1][j] 前i个物品中挑选出价值总和为j时的总重量的最小值 int[][] dp = new int[n+1][n*maxV+1]; //前0个物品挑任何价值都是INF Arrays.fill(dp[0],maxW ); dp[0][0] = 0; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=n*maxV ; j++) &#123; if(j&lt;V[i])dp[i+1][j]=dp[i][j]; else dp[i+1][j] = Math.min(dp[i][j],dp[i][j-V[i]]+A[i] ); &#125; &#125; int res = 0; //找小于W的最大value for (int i = 0; i &lt;= n*maxV ; i++) &#123; if(dp[n][i]&lt;=W)res = i; &#125; return res;&#125; 01背包N个物品，背包容量VF[i,v]前i件物品放入容量v的背包可获得的最大价值。如果放第i件，转化为前i-i件放入容量为v-Ci的背包中，最大价值是F[i-1,v-Ci]+Wi$F[i,v]=max{F[i-1,v],F[i-1,v-C_i]+W_i}$递归终止条件1：所有物品都装过了-&gt;0 2.这个物品w装不下-&gt;下一个物品记忆化递归1234567891011121314151617181920int[][] dp;//参数组合一共nW种 只需要O(nW)复杂度public int bagmemo(int i,int n,int[][]wv,int w)&#123; dp = new int[n+1][w+1]; return memo(i, n, wv, w);&#125;public int memo(int i,int n,int[][]wv,int w)&#123; if(dp[i][w]&gt;0)return dp[i][w]; int res; if(i==n)return 0; else if(w&lt;wv[i][0])&#123; //不选这个 res = bagrec(i+1,n,wv,w); &#125;else&#123; //选和不选 res = Math.max(bagrec(i+1,n ,wv ,w ),bagrec(i+1, n,wv ,w-wv[i][0])+wv[i][1]); &#125; dp[i][w] = res; return res;&#125; 终止条件：没有物品/剩余重量12345678private int zoknap(int W,int[] val,int[] wt,int n)&#123; if(n == 0||W == 0)&#123; return 0; &#125; //这个物品超重了 跳过 if(wt[n-1]&gt;W)return zoknap(W, val, wt,n-1 ); else return Math.max(val[n-1]+zoknap(W-wt[n-1],val ,wt ,n-1 ),zoknap(W,val ,wt ,n-1) );&#125; dp 复杂度和记忆化递归一样逆向n-1-&gt;0123456789101112public int bagdp(int n,int W,int[][]wv)&#123; int[][] dp = new int[n+1][W+1]; for (int i = n-1; i &gt;=0 ; i--) &#123; for (int j = 0; j &lt;=W ; j++) &#123; if(j&lt;wv[i][0]) dp[i][j] = dp[i+1][j]; else dp[i][j] = Math.max(dp[i+1][j],dp[i+1][j-wv[i][0]]+wv[i][1]); &#125; &#125; return dp[0][W];&#125; 正向dp 123456789101112public int frontDp(int n,int W,int[][] wv)&#123; int[][] dp = new int[n+1][W+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=W ; j++) &#123; if(wv[i][0]&gt;j) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = Math.max(dp[i][j-wv[i][0]]+wv[i][1],dp[i][j]); &#125; &#125; return dp[n][W];&#125; 从前i个物品中选不超过j的状态-&gt;前i+1中选不超过j，前i+1不超过j+w[i]1234567891011public int maxbag(int n,int w,int[][]wv)&#123; int[][] dp = new int[n+1][w+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;=w ; j++) &#123; dp[i+1][j] = Math.max(dp[i+1][j],dp[i][j]); if(j+wv[i][0]&lt;=w) dp[i+1][j+wv[i][0]] = Math.max(dp[i+1][j+wv[i][0]],dp[i][j]+wv[i][1]); &#125; &#125; return dp[n][w];&#125; 输出路径123456789w = W;for (i = n; i&gt;0&amp;&amp;res&gt;0 ; i--) &#123; if(res ==dp[i-1][w])continue; else&#123; System.out.println(wt[i-1]+" "); res-= val[i-1]; w-= wt[i-1]; &#125;&#125; 01背包一维dp123456789private int zoknapdp1d(int W,int[] wt,int[] val,int n)&#123; int[] dp = new int [W+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = W; j &gt;=wt[i] ; j--) &#123; dp[j] = Math.max(dp[j],dp[j-wt[i]]+val[i]); &#125; &#125; return dp[W];&#125; ?taotao要吃鸡h为0代表没有装备背包 n个物品，容量=m+h接下来n行，第i个物品的物品的重量Wi和威力值Vi。0&lt;=Wi,Vi&lt;=100.当装备背包之后，如果可携带重量没有满，就可以拿一个任意重的东西。3 3 32 33 22 30输出8 拿了1，2物品val=5,weight=5&lt;6，可以拿3 1.方法1m+h容量背包，在m+h没装满时可以任意取一个超过重量的最外层遍历：最后一个超额的物品i. 计算m+h-1背包容量的最大val123456789101112int ans = -1;for(int i =0;i&lt;n;i++)&#123; ans = max(ans,v[i]+slove(m+h-1),i);&#125;int slove(int W,int index)&#123; for(int i =0;i&lt;n;i++)&#123; if(i==index)continue; for(int j = W;j&gt;=w[i];j--)&#123; dp[j] = max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125;&#125; 2.方法2直接dp 1.按重量排序123456789101112for(int i =0;i&lt;n;i++)&#123; for(int j = m+h;j&gt;=goods[i].w;j--)&#123; dp[j] = Math.max(dp[j],dp[j-goods[i].w]+goods[i].v); &#125; if(h&gt;0)&#123; //强行装的位置,不能填dp[0]，0表示装满了 for(int j = Math.min(m+h,goods[i].w-1)j&gt;0;j--)&#123; dp[j] = Math.max(dp[j],goods[i].v); &#125; &#125; out.println(dp[m+h]);&#125; 01背包 bb解法展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Item&#123; double weight; int value;&#125;class Node&#123; // level --&gt; Level of node in decision tree (or index // in arr[] // profit --&gt; Profit of nodes on path from root to this // node (including this node) // bound ---&gt; Upper bound of maximum profit in subtree // of this node/ int level,profit,bound; double weight;&#125;public class BBpack &#123; //用分数背包问题的贪心法求接下去可能的最大值 public static int bound(Node u,int n,int W,List&lt;Item&gt; arr)&#123; if(u.weight&gt;=W)return 0; int profit_bound = u.profit; int j = u.level+1; int totweight = (int)u.weight; while(j&lt;n&amp;&amp;(totweight+arr.get(j).weight&lt;=W))&#123; totweight += arr.get(j).weight; profit_bound += arr.get(j).value; j++; &#125; if(j&lt;n)&#123; profit_bound+=(W-totweight)*arr.get(j).value/arr.get(j).weight; &#125; return profit_bound; &#125; public static int knapsack(int W,List&lt;Item&gt;arr,int n)&#123; //1. 排序// Comparator&lt;Item&gt; comparing = Comparator.comparing(item -&gt; item.value / item.weight);// arr.sort(comparing.reversed()); arr.sort(Comparator.comparing((Item item )-&gt; item.value / item.weight).reversed()); //2.队列 System.out.println(arr); Deque&lt;Node&gt; que = new ArrayDeque&lt;&gt;(); // dummy node Node u = new Node(-1,0,0); Node v = new Node(-1,0,0); que.add(u); int MaxProfit = 0; while(!que.isEmpty())&#123; u = que.poll(); if(u.level == -1)&#123; v.level =0; &#125; if(u.level == n-1)continue; v.level = u.level+1; //装 v.weight = u.weight+arr.get(v.level).weight; v.profit = u.profit+arr.get(v.level).value; //如果不超重 更新当前最大收益 if(v.weight&lt;=W&amp;&amp;v.profit&gt;MaxProfit) MaxProfit = v.profit; v.bound = bound(v,n ,W ,arr ); //不装 if(v.bound&gt;MaxProfit) que.add(new Node(v)); v.weight = u.weight; v.profit = u.profit; v.bound = bound(v,n,W ,arr); //不装也有可能 if(v.bound&gt;MaxProfit)&#123; que.add(new Node(v)); &#125; &#125; return MaxProfit; &#125;public static void main(String[] args) &#123; List&lt;Item&gt; arr= new ArrayList&lt;Item&gt;(5); arr.add(new Item(2,40)); arr.add(new Item(3.14,50)); arr.add(new Item(1.98,100)); arr.add(new Item(5,95)); arr.add(new Item(3,30)); int W = 10; System.out.println(knapsack(W, arr, arr.size())); &#125;&#125; 2.初始化F 恰好装满背包，F[0]=0 其余-∞没有装任务物品时，只有容量为0的背包表示装满，其它容量为非法解。 不用装满，F全部为0任何容量的背包，什么都不装，价值F都为0也是合法解。 lt440完全背包 每个物品可用无限次n = 3; [3,4],[4,5],[2,3]; W = 7;out 10 (0选1个，2选2个) dp[i+1][j]计算k的循环和dp[i+1][j-w[i]]计算k-1的循环是重复的 记忆化递归：终止条件，当n==0的时候还要继续削减w1234567891011121314151617181920int[][] memo;public int backPackIII(int[] A, int[] V, int m) &#123; if(A==null||V==null||A.length&lt;1||V.length&lt;1)return 0; int n = A.length; memo = new int[n+1][m+1]; return backrec(n-1,m,A,V);&#125;private int backrec(int n,int w,int[] A,int[] V)&#123; if(memo[n][w]&gt;0)return memo[n][w]; if(w==0)return 0; if(n==0&amp;&amp;w&lt;A[0])return 0; else if(n==0&amp;&amp;w&gt;=A[0])return memo[n][w] = backrec(0,w-A[0],A,V)+V[0]; else if(n&gt;0)&#123; if(A[n]&gt;w)return memo[n][w] = backrec(n-1,w,A,V); else return memo[n][w] = Math.max(backrec(n-1,w,A,V),backrec(n,w-A[n],A,V)+V[n]); &#125; return 0;&#125; 123456789101112public int completeBagDP(int n,int W,int[][] wv)&#123; //dp[i+1][j]从前i种物品中总重&lt;=j的最大值 int[][] dp = new int[n+1][W+1]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;=W ; j++) &#123; for (int k = 0; k*wv[i][0] &lt;=j ; k++) &#123; dp[i+1][j] = Math.max(dp[i+1][j],dp[i][j-k*wv[i][0]]+k*wv[i][1]); &#125; &#125; &#125; return dp[n][W]; &#125; 完全背包一维dp和01背包的一维dp差别只有循环的方向1234567891011public int backPackIII(int[] A, int[] V, int m) &#123; int[]dp = new int[m+1]; int n = A.length; for(int i =0;i&lt;n;i++)&#123; //for(int j = m;j&gt;=A[i];j--) for(int j = A[i];j&lt;=m;j++)&#123; dp[j] = Math.max(dp[j-A[i]]+V[i],dp[j]); &#125; &#125; return dp[m];&#125; 利用奇偶性简化空间dp[2]12345678910111213public int backpackdp2(int[] A, int[] V, int m)&#123; //只需要计算dp[i+1]和dp[i] int[][] dp = new int[2][m+1]; for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt;=m ; j++) &#123; if(j&lt;A[i]) dp[(i+1)&amp;1][j]= dp[i&amp;1][j]; else dp[(i+1)&amp;1][j] = Math.max(dp[i&amp;1][j],dp[(i+1)&amp;1][j-A[i]]+V[i]); &#125; &#125; return dp[A.length&amp;1][m];&#125; 两个状态转移方程$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=kC_i&lt;=v}$$F[i,v] = max(F[i-1,v],F[i,v-C_i]+W_i)$ exactly装满背包需要的最少/最大物品数量 Input : W = 100 val[] = {1, 30} wt[] = {1, 50}Output : 100 放100个{1，1}是物品数最多的方案 1234567891011private int multicnt(int W,int n,int[] val,int[] wt)&#123; int dp[] = new int[W+1]; for (int i = 0; i &lt;=W ; i++) &#123; for (int j = 0; j &lt; n ; j++) &#123; if(wt[j]&lt;=i)&#123; dp[i] = Math.max(dp[i],dp[i-wt[j]]+val[j] ); &#125; &#125; &#125; return dp[W];&#125; 填满背包的方案数多重背包 第i种物品最多Mi件可用 能否恰好装满 p62$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=k&lt;=Mi}$n个不同的数字，每种m个，能否和恰好为K每种数字，每个最多用m次，能否求和K n=3 a = {3,5,8} m = {3,2,2} K = 17 123456789101112131415public boolean canSum(int[] A, int[] V,int K)&#123; int n = A.length; //dp[i+1][j]用钱i种数字是否能加和成j boolean[][] dp = new boolean[n+1][K+1]; dp[0][0] = true; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;=K ; j++) &#123; //为了使用数字i，需要i-1数字加成j-vi,j-2*vi,j-m*vi的情况 for (int k = 0; k &lt;=A[i]&amp;&amp;k*V[i]&lt;=j ; k++) &#123; dp[i+1][j] |= dp[i][j-k*A[i]]; &#125; &#125; &#125; return dp[n][K];&#125; 123456789101112131415161718192021public boolean canSumOnk(int[] A,int[] V,int K)&#123; //dp[i+1][j] 用前i种数求和j 第i种数最多剩多少个 不能得到j 为-1 int[] dp = new int[K+1]; int n = A.length; Arrays.fill(dp,-1 ); dp[0] = 0; for (int i = 0; i &lt; n ; i++) &#123; for (int j = 0; j &lt;=K ; j++) &#123; //如果前i-1可以得到j i不用加，剩下全部 if(dp[j]&gt;=0)&#123; dp[j] = A[i]; &#125;else if(j&lt;V[i]||dp[j-V[i]]&lt;=0)&#123; dp[j] =-1; &#125;else&#123; //前i-1个可以加出 -V[i]的情况 dp[j] = dp[j-V[i]]-1; &#125; &#125; &#125; return dp[K]&gt;=0;&#125; n=3,m=3,a=[1,2,3] 答案1234567891011121314151617public static int multibagans(int[]a,int n,int m,int M)&#123; int[][] dp = new int[n+1][m+1]; //每种都不取 for (int i = 0; i &lt;=n ; i++) &#123; dp[i][0]=1; &#125; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 1; j &lt;=m; j++) &#123; if(j-1-a[i]&gt;=0) dp[i+1][j] = (dp[i+1][j-1]+dp[i][j]-dp[i][j-1-a[i]]+M)%M; else dp[i+1][j]=(dp[i+1][j-1]+dp[i][j])%M; &#125; &#125; return dp[n][m];&#125; 找钱的方案数123456789101112public int waysNCents(int n) &#123; int[] coins = &#123;1,5,10,25&#125;; int[] dp = new int[n+1]; dp[0] = 1; for(int i =0;i&lt;4;i++)&#123; for(int j = 1;j&lt;=n;j++)&#123; if(j-coins[i]&gt;=0) dp[j] += dp[j-coins[i]]; &#125; &#125; return dp[n];&#125; lt740 coin change2123456789101112public int change(int amount, int[] coins) &#123; int n = coins.length; int[] dp = new int[amount+1]; dp[0] =1; for(int i=0;i&lt;n;i++)&#123; for(int j = 1;j&lt;=amount;j++)&#123; if(j&gt;=coins[i]) dp[j]+=dp[j-coins[i]]; &#125; &#125; return dp[amount];&#125; 递归12345678int count(int[] coins,int N,int idx)&#123; if(N==0)return 1; if(N&lt;0)return 0; if(coins==null||(idx&lt;=0&amp;&amp;N&gt;=1)) return 0; //用/不用这枚硬币(无限次)换 return count(coins,N ,idx-1)+count(coins,N-coins[idx-1] ,idx);&#125; 二维dp123456789101112131415public int coinDp2(int amount, int[] coins)&#123; int n = coins.length;// Arrays.sort(coins); int[][] dp = new int[n+1][amount+1]; dp[0][0] =1; for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 0; j &lt;= amount; j++) &#123; if(coins[i-1]&lt;=j) dp[i][j] += dp[i][j - coins[i-1]]; dp[i][j]+= dp[i - 1][j]; &#125; &#125; return dp[n][amount];&#125; 装配线调度问题Assembly Line两条装配线分别有相同的n个station每个任务必须依次通过这n种station在j号station从装配线1/2换到装配线2/1有额外cost T1(j),T2(j)每条线用时要加上开始用时10/12和结束用时18/7123456789101112131415161718192021222324252627282930313233public class assembleLine &#123; public int assembly(int[][]line,int[][]t,int[]e,int[]x)&#123; int n = line[0].length; int[] T1 = new int[n]; int[] T2 = new int[n]; //两条线经过第一个station后的用时 T1[0] = e[0]+line[0][0]; T2[0] = e[1]+line[1][0]; for(int i =1;i&lt;n;i++)&#123; //line1上第二个station用时是line1前一个用时+当前station 和 从line2上跳过来的用时的min T1[i] = Math.min(T1[i-1]+line[0][i],T2[i-1]+t[1][i]+line[0][i]); T2[i] = Math.min(T2[i-1]+line[1][i],T1[i-1]+t[0][i]+line[1][i]); &#125; return Math.min(T1[n-1]+x[0],T2[n-1]+x[1]); &#125; public static void main(String[] args) &#123; //statin num int n = 4; //[2][4]两条装配线上4个station的耗时 int[][] line =&#123; &#123;4, 5, 3, 2&#125;, &#123;2, 10, 1, 4&#125;&#125;; //两条装配线上换装配线到下一个station的额外开销 int[][] t = &#123;&#123;0, 7, 4, 5&#125;, &#123;0, 9, 2, 8&#125;&#125;;// entry time ei and exit time xi //要加上的开始时间和结束时间 int e[] = &#123;10,12&#125;; int x[] = &#123;18,7&#125;; assembleLine sl = new assembleLine(); System.out.println(sl.assembly(line, t, e, x)); &#125;&#125; lt 254 2个鸡蛋从n层楼中找到可以丢碎鸡蛋的楼层，最少几次1.只能从低往高试，碎了鸡蛋就-12.第一次选择楼层n，再向上跳n-1层，再n-2层假如100层的楼，$n+(n-1)+(n-2)+…+1&gt;=100$-&gt;$(n+1)n/2&gt;=100$ -&gt;n=14第一次从n层楼投没破，则需要再跳一段再投，cnt++，当在 n层破了，则需要搜索1~n-1层。为了平衡向上跳一大格和单步搜索，minimize max regret所以每次往上跳一大格应该缩短破了之后搜索的间隔，弥补一下cnt的计算。每次跳一大格，减少单步搜索的次数。 第一次跳到14，如果没破，搜索1~13，在13层破，则最坏情况14步如果最坏情况跳了14步到达100层破了，跳了14步。 假如10层：策略：$(1+n)*n/2&gt;=10$1print(scipy.optimize.fsolve(lambda x: x**2 + 2*x - 20, 0)) 输出3.58所以4,即4步就能把10层楼遍历掉 4-&gt;7-&gt;9-&gt;10 12345678if(n==1||n==2)return n;long ans = 0;//死循环之后外面不需要return语句了for(int i =1;;i++)&#123; ans+=(long)i; if(ans&gt;=(long)n) return i;&#125; !!887 K个蛋，N层楼正确解法：K个鸡蛋移动M次可以check的最大层数dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1移动1步，如果碎了可以checkdp[m - 1][k - 1]层如果没碎，可以checkdp[m - 1][k]层12345678910public int superEggDrop(int K, int N) &#123; int[][] dp = new int[N + 1][K + 1]; int m = 0; while (dp[m][K] &lt; N) &#123; ++m; for (int k = 1; k &lt;= K; ++k) dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1; &#125; return m;&#125; 压缩成1D 81%1234567public int superEggDrop(int K, int N) &#123; int dp[] = new int[K + 1], m = 0; for (m = 0; dp[K] &lt; N; ++m) for (int k = K; k &gt; 0; --k) dp[k] += dp[k - 1] + 1; return m;&#125; drop(9,3)9层楼3个鸡蛋，在6层落下碎了继续[0~5]层drop(5,2),没碎继续[6~9]层drop(3,3)超时原因 复杂度O(K*N^2)展开代码 超时递归123456789101112int eggDrop(int k,int n)&#123; //1层/0层 if(n==0||n==1)return n; if(k==1)return n; int min = Integer.MAX_VALUE; //[0~5]6[7~9] for(int i =1;i&lt;=n;i++)&#123; int res = Math.max(eggDrop(k-1,i-1),eggDrop(k,n-i)); min = Math.min(res,min); &#125; return min+1;&#125; 超时dp初始化第一行（鸡蛋）和前两列（楼）1234567891011121314151617181920212223242526public int superEggDrop(int K, int N) &#123; int[][] dp= new int[K+1][N+1]; //有鸡蛋 两列楼 for(int i=1;i&lt;=K;i++)&#123; dp[i][0] = 0; dp[i][1] = 1; &#125; //1个鸡蛋 有楼 一列行 没鸡蛋也没楼第一行默认0 for(int i =1;i&lt;=N;i++)&#123; dp[1][i] = i; &#125; int min = Integer.MAX_VALUE; //鸡蛋 int i,j; for( i =2;i&lt;=K;i++)&#123; for( j =2;j&lt;=N;j++)&#123; dp[i][j] = Integer.MAX_VALUE; for(int x = 1;x&lt;=j;x++)&#123; int res = 1+Math.max(dp[i-1][x-1],dp[i][j-x]); dp[i][j] =Math.min(dp[i][j],res); &#125; &#125; &#125; return dp[K][N];&#125; 加速优化1leetcode上的优化和数学方法分析递推方程，dp(k-1,x-1)随着x增加递增。dp(k,N-x)随着x增加递减。二分查找到t1=t2的位置是max(t1,t2)最小的位置复杂度降到复杂度O(K*NLogN) 5% 263ms12345678910111213141516171819202122232425Map&lt;Integer,Integer&gt; memo = new HashMap&lt;&gt;();public int superEggDrop(int K,int N)&#123; //1&lt;=k&lt;=100 if(!memo.containsKey(N*100+K))&#123; int ans; if(N==0)ans = 0; else if(K==1)ans = N; else&#123; int lo = 1,hi = N; while(lo&lt;hi)&#123; int mid = (lo+hi)/2; int t1 = superEggDrop(K-1,mid-1); int t2 = superEggDrop(K,N-mid); if(t1&lt;t2)lo = mid+1; else if(t1&gt;t2) hi = mid; //关键 else lo=hi=mid; &#125; ans = 1+Math.min(Math.max(superEggDrop(K-1,lo-1),superEggDrop(K,N-lo)), Math.max(superEggDrop(K-1,hi-1),superEggDrop(K,N-hi))); &#125; memo.put(N*100+K,ans); &#125; return memo.get(N*100+K);&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ToDoAgain]]></title>
    <url>%2F2018%2F09%2F03%2Falg2do%2F</url>
    <content type="text"><![CDATA[37 数独12345678910111213141516171819202122232425262728293031public void solveSudoku(char[][] board)&#123; if(board == null || board.length == 0) return; solve(board);&#125;private boolean solve(char[][] board)&#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length ; j++) &#123; if(board[i][j] == '.')&#123; for(char c = '1';c&lt;='9';c++)&#123; if(isValid(board,i,j,c))&#123; board[i][j] = c; if(solve(board))return true; else board[i][j] = '.'; &#125; &#125; return false; &#125; &#125; &#125; return true;&#125;private boolean isValid(char[][] board,int row,int col,char c)&#123; for (int i = 0; i &lt;9 ; i++) &#123; if(board[i][col] == c)return false; if(board[row][i] == c)return false; if(board[3*(row/3) + i/3][3*(col/3)+i%3]==c)return false; &#125; return true;&#125; 239 滑动窗口最大值 不会x4123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 思路1：左右扫描：把数组按k划分，把每个区间划分成前一个分割right和后一个分割left，预处理先得到每个分割的max。A = [1,3,-1,-3,5,3,6,7], k=31,3,-1,|-3,5,3,|6,7 最后一组可能不足k个left_max[] = 1, 3, 3,| -3, 5, 5 | 6, 7right_max[] = 3, 3, -1,| 5, 3, 3 | 7, 7sliding-max(i) = max{right_max(i), left_max(i+w-1)}sliding_max = right[0,2],left[0,0] = 3 right[1,2],left[3,3] = 3 right[2,2],left[3,4] = 5 right[3,5],left[5,5] = 5注意，算到边界重置,不用仔细算几个边界12345678910111213141516171819public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; if(n == 0)return new int[]&#123;&#125;; int[] leftmax = nums.clone(); int[] rightmax = nums.clone(); for(int i = 1;i&lt;n;i++)&#123; if(i%k ==0)continue; leftmax[i] = Math.max(leftmax[i],leftmax[i-1]); &#125; for(int i = n-2;i&gt;=0;i--)&#123; if(i%k ==k-1)continue; rightmax[i] = Math.max(rightmax[i],rightmax[i+1]); &#125; int[]rst = new int[n-k+1]; for(int i = 0;i+k-1&lt;n;i++)&#123; rst[i] = Math.max(rightmax[i],leftmax[i+k-1]); &#125; return rst; &#125; 方法2：如果之前放入k队列的值比当前小，则这个值不会成为这个k队列区间的max，并且随着区间向后也用不到它了。 138https://leetcode.com/problems/copy-list-with-random-pointer/solution/ poj3617构造最小字典序12345678910111213141516171819202122232425262728293031/** * 不断取Min(S头/尾)放到T末尾 * 相等：判断下一个字符希望先用到小的字符 * 可以的操作： * 从S头删除一个加到T尾 * 从S尾删除一个加到T尾 * * @param S ACDBCB * @return 构造字典序尽可能小的字符串T ABCBCD */public static String BestCowLine(String S)&#123; int a = 0,b = S.length()-1; StringBuilder sb = new StringBuilder(); while (a&lt;=b)&#123; //关键 boolean left = false; //a+i&lt;b关键 for (int i = 0; a+i &lt;= b ; i++) &#123; if(S.charAt(a+i)&lt;S.charAt(b-i))&#123; left = true; break; &#125;else if(S.charAt(a+i)&gt;S.charAt(b-i))&#123; left = false; break; &#125; &#125; if(left)sb.append(S.charAt(a++)); else sb.append(S.charAt(b--)); &#125; return sb.toString(); &#125; 818 A加速，R掉头并减速，到指定位置最少需要多少条指令 当车得到指令 “A” 时, 将会做出以下操作： position += speed, speed *= 2。 当车得到指令 “R” 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。 (当前所处位置不变。) 例如，当得到一系列指令 “AAR” 后, 你的车将会走过位置 0-&gt;1-&gt;3-&gt;3，并且速度变化为 1-&gt;2-&gt;4-&gt;-1。 输入:target = 3输出: 2解释:最短指令列表为 “AA”位置变化为 0-&gt;1-&gt;3 464 博弈两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。输入：maxChoosableInteger = 10desiredTotal = 11 输出：false 暴力递归 A,B玩家轮流从1-10中选数组加到同一个total，让total先大于11的赢.B肯定赢。1.计算1-n个数的permutation，并判断每个赢的可能性复杂度(n!)2.因为1,2…和2,1…是一样的，所以可以降为$2^n$状态压缩 子状态，m个数state[m+1]表示visited 记忆化递归key是子状态，Arrays.toString(state) 遍历state中还是0的没选的数， 如果d-i选这个数赢了或者另一个人递归d-i的子问题不能赢， 更新map中这个state为true，可以先state[i]=0回溯return true到之前的选择(上一层递归) 12345if(d-i&lt;0||!canwin(d-i,hmap))&#123; hmap.put(key,true); state[i]=0; return true;&#125; 如果对方赢了，不选这个state[i]=0，继续尝试循环中其它state如果所有的state都试过了也不行，说明当前子问题hamp.put(key,false),return false 优化19ms：用二进制存一个int表示状态 用byte[i&lt;&lt;M+1]记忆化12int byte[] m_;m = new byte[1&lt;&lt;M+1]; 遍历M个数12345if(state&amp;(1&lt;&lt;i)&gt;0)continue;if(!canwin(d-i,state|(1&lt;&lt;i)))&#123; m_[state]=1; return true;&#125; 出循环，表示这个状态不行12m_[state]=-1;return false; 优化2：如果用byte[1&lt;&lt;M] 遍历0~M ,canwin(d-i+1,state|(1&lt;&lt;i))只需要15ms 1左移i位int mask=1&lt;&lt;i表示选这个数的状态如果(mask&amp;visited)==0表示没使用过这个数另一个玩家能不能赢的state：mask|visited 在visited（上一个状态）的基础将i位也置1 486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高https://leetcode.com/problems/predict-the-winner/solution/{3，9，1，2} 二维数组dp：[i][j]只用右上三角表示两个人都从list取1个数，2个数，3个数到list长能获得的最大差值 填对角线，如果两个人只剩下一个数为3：{A取3，B取0}，剩下9：{A取9，B取0}… 如果剩下2个数，剩下{3,9}[1][2]：{A取9，B剩下{3}回到1的情况}… 如果剩下3个数，剩下{3,9,1}[1][3]:{A取3,B剩下{9,1}即表格[2][3]的情况} 剩下4个数，填[1][4]即为答案 递归：但是会有很多重复计算复杂度$2^n$比如让对手选[3,9,1]后，自己选[9,1]和[3,9]/让对手选[9,1,2]后，自己选[9,1]和[1,2][9,1]被计算了两次。可以进行存储1234567//最大的分数差int dif(int[] nums,int left,int right)&#123; //如果长度为1，获得的差值就是这个数 if(left==right)return nums[left]; //选一个数之后 交给对手用相同策略选 return max(nums[left]-dif(nums,left+1,right),nums[right]-dif(nums,left,right+1));&#125; 用一维数组存储key是left*len+right展开代码 123456789101112131415int[] m;int len =0;public boolean PredictTheWinner(int[] nums) &#123; this.len = nums.length; if(len==1)return true; this.m= new int[len*len]; return help(nums,0,len-1)&gt;=0;&#125;private int help(int[] nums,int l,int r)&#123; if(l==r)return nums[l]; int index = l*len+r; if(m[index]&gt;0)return m[index]; m[index]=Math.max(nums[l]-help(nums,l+1,r),nums[r]-help(nums,l,r-1)); return m[index];&#125; lt 1470 1号玩家先取。问最后谁将获胜。 他们只能从数组的两头进行取数，且一次只能取一个。若1号玩家必胜或两人打成平局，返回1，若2号玩家必胜，返回2。如果数组长度是偶数 先手必胜只要return 1就行了 123456789public int theGameOfTakeNumbers(int[] arr) &#123; if(dif(arr,0,arr.length-1)&gt;=0)return 1; else return 2;&#125;private int dif(int[] nums,int left,int right)&#123; if(left&lt;right)return 0; if(left==right)return nums[left]; return Math.max(nums[left]-dif(nums,left+1,right),nums[right]-dif(nums,left,right-1));&#125; lc 877 偶数堆石子排成一行，每堆都有正整数颗石子 piles[i]输入： [5,3,4,5] 先手可以拿1+3 或者2+4 对手反之拿2+4或者1+3，所以先手选大的那个肯定赢。递归同上 77%可以加一个memo[l][r] 从2^n-&gt;n^2 因为l和r一共有n^2个子问题 dp ：1234567891011121314151617public boolean stoneGame(int[] piles) &#123; int n = piles.length; int[][] dp = new int[n][n]; //left=i,right=i的子问题 for (int i = 0; i &lt;n ; i++) &#123; dp[i][i] = piles[i]; &#125; //长度为[2,n]的子问题 for (int i = 2; i &lt;=n ; i++) &#123; for (int l = 0; l &lt;n-i+1 ; l++) &#123; int r = i+l-1; //[l+1][r]的长度比[l][r]小 已经计算过了 dp[l][r] = Math.max(piles[l]-dp[l+1][r],piles[r]-dp[l][r-1]); &#125; &#125; return dp[0][n-1]&gt;0;&#125; 子问题是 长度-1的dp 降维1234567891011public boolean stoneGameDP1D(int[] piles) &#123; int n = piles.length; int[] dp = piles.clone(); for (int i = 2; i &lt;=n ; i++) &#123; for (int l = 0; l&lt;n-i+1 ; l++) &#123; //dp[i] 还没有更新,都是长度i-1的值 dp[i] = Math.max(piles[l]-dp[i+1],piles[l+i-1]-dp[i] ); &#125; &#125; return dp[0]&gt;0;&#125; ??Convert BST to Greater Tree17ms 66% Reverse Morris In-order Traversal展开代码 123456789101112131415161718192021222324252627282930313233public TreeNode convertBST(TreeNode root) &#123; int sum = 0; TreeNode cur = root; while(cur!=null)&#123; //最右 if(cur.right==null)&#123; sum+=cur.val; cur.val=sum; cur=cur.left; &#125;else&#123; //找前继，键link TreeNode pre = cur.right; //一直向左 while(pre.left!=null&amp;&amp;pre.left!=cur)&#123; pre=pre.left; &#125; //找到了pre 联立链接 if(pre.left== null)&#123; pre.left = cur; cur=cur.right; &#125; //右边没了，并且左连接向上 else&#123; pre.left=null; sum+=cur.val; cur.val= sum; cur=cur.left; &#125; &#125; &#125; return root; &#125; 正常做法递归中序 15ms 99%12345678public TreeNode convertBST(TreeNode root) &#123;if(root==null)return root;convertBST(root.right);sum+=root.val;root.val=sum;convertBST(root.left);return root;&#125; lc393 判断合法UTF8编码287 数组中重复元素网络流https://algs4.cs.princeton.edu/64maxflow/https://www.geeksforgeeks.org/minimum-cut-in-a-directed-graph/ 最小割 st-cut 去掉这几条边，源点S和终点T就会被分为两个不相交的set，S到不了T。这种边集的最小值断掉两点间的通信的最小代价。 最大流max-flow 边的流量小于capacity。每个点的入流和出流相等。除了源点S和终点T。求源点/终点能发出/接收的最大值。 其实可以是一个问题。 Ford-fulkerson算法1 先假设每条边的当前流量是0/capacity2 找到S到T的路径，并最大化这条路径上的空的边的当前流量3 继续找路径，如果可以通过一条边的反向到达T，经过的是一条边的反向流，则减少这条边逆向流过去。4 每条边到达正向包和或者负向为0 不能remove from backward edge flow value lemma :最小cut上的流量 == 最大网络流flow &lt;= capacity of cutmax flw == min cut 已知最大流(cur/capacity) 求cut从S点 正向走最不满的正向流。走最满的逆向流，满正向流和空逆向流当作不存在。 如何找augmenting path BFS如果容量都是integernumber of augemntation &lt;= maxflow value 每次增加至少1 查找插入 786 数组中可能组成的分数排序后第k大的是哪个组合数组长度2000 n^2的算法是超时 A = [1, 2, 3, 5], K = 3Output: [2, 5]Explanation:The fractions to be considered in sorted order are:1/5, 1/3, 2/5, 1/2, 3/5, 2/3.The third fraction is 2/5. M[i][j]=A[i]/A[j]肯定在右上角最小1231/2 1/3 1/5 - 2/3 2/5- - 3/5 1 查比0.5小有1/2,1/3,2/5 大于3个 r =0.52 查比0.25小的有1/5 l=0.253 查比0.375小的有1/3,1/5 l=0.3754 查比0.475小的正好3个 ！？？？95 输出全部不同的BST[1~n]组成的BST1231.......k...n / \[1~k-1] [k+1,n] 与上一层的构建过程是一样的 287 数组中只有1个重复元素 返回元素 containing n + 1 integers where each integer is between 1 and n (inclusive) 不用set，空间降为O(1)将数组的数字想象成链表，找环 1 4 6 6 6 2 3 慢指针走num[slow]快指针走num[num[fast]] 慢指针会在环与head指针相遇12345678910111213141516public int findDuplicate(int[] nums) &#123;// use only constant, O(1) extra space int slow = nums[0]; int fast = nums[0]; do&#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125;while(slow != fast); int head = nums[0]; while(head!=slow)&#123; head= nums[head]; slow = nums[slow]; &#125; return head;&#125; lt848 加油站之间的最小距离719 输入：nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。 方法2：二分查找，找到最小的距离m，至少有k个pair距离&lt;=m。 方法1：350ms排序后找到max，建立max+1个桶对diff计数，最后遍历桶到k&lt;=012345678910111213141516171819public int smallestDistancePair(int[] nums, int k) &#123; int n = nums.length; Arrays.sort(nums); int max = nums[nums.length - 1]; int[] bucket = new int[max+1]; for(int i =0;i&lt;n-1;i++)&#123; for(int j = i+1;j&lt;n;j++)&#123; int idx = nums[j]-nums[i]; bucket[idx]++; &#125; &#125; for(int i =0;i&lt;bucket.length;i++)&#123; k -=bucket[i]; if(k&lt;=0)&#123; return i; &#125; &#125; return -1; &#125; 5只猴子分桃，每次拿走一个正好分成5堆，问桃子数！！687树中值相等的点的路径长438 Anagrams in a String 滑动窗口Arryas.equals Anagrams 字母相同，顺序不同的单词 连续s: “cbaebabacd” p: “abc”Output:[0, 6] 输出起始位置 Sliding Window algorithm16ms 50%12345678910111213141516171819public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); int[] ch = new int[26]; int wcn = p.length(); for(char c:p.toCharArray())&#123; ch[c-'a']++; &#125; int[] window = new int[26]; for (int i = 0; i &lt;s.length() ; i++) &#123; if(i&gt;=wcn)&#123; --window[s.charAt(i-wcn)-'a']; &#125; window[s.charAt(i)-'a']++; if(Arrays.equals(window, ch))&#123; rst.add(i-wcn+1); &#125; &#125; return rst;&#125; 回文树next[i][c] 编号为i的节点表示的回文串两边添加c后变成的回文串编号。fail[i]节点i失配后cnt[i] K-D tree快速排序的各种优化https://algs4.cs.princeton.edu/23quicksort/ 106 中序+后序建树？？？有100个帽子，每个人有几顶，问每个人戴出来都不一样有多少种15 3sum=0 荷兰国旗写法3指针1p：从0~len-2，3个数的和 右边至少留两个数 sum=0-nums[i]转化成2sum问题去重：当num[i]=num[i-1]:continue另外两个指针从1p往后从len-1往前。去重：预判：nums[low]=nums[low+1]:low++;nums[high]=nums[high-1]:high–; poj2406 字符串周期 power stringhttps://my.oschina.net/hosee/blog/661974http://poj.org/problem?id=2406abcd 1aaaa 4ababab 3 459 判断字符串有重复模式 KMPkmp89% todo !!!3 连续最长不重复子序列32%用set维护一个[i,j)窗口，不重复则窗口向右扩展，重复则窗口右移。12345678910111213public int lengthOfLongestSubstring(String s)&#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0,i=0,j=0; while(i&lt;n&amp;&amp;j&lt;n)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans,j-i); &#125; else set.remove(s.charAt(i++)); &#125; return ans;&#125; 优化： todoint[26] for Letters ‘a’ - ‘z’ or ‘A’ - ‘Z’int[128] for ASCIIint[256] for Extended ASCII 659 数组413 数组划分 能组成的等差数列个数 A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 725链表划分成k份子集lt886 判断凸包https://www.lintcode.com/problem/convex-polygon/description ！30 字典中单词连续出现在字符串中的位置 AC自动机（？加入字典的常用写法dict.put(word,dict.getOrDefault(word,0)+1)展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Solution &#123;public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res;&#125;public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start;&#125;public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1);&#125;&#125; 55 ?jump gamejump gamei+nums[i]大于lastp表示i位置可以跳到lastp位置。将lastp更新成现在的i。再向前直到lastp变成0，表示0位置可以到下一个lastp一直到len-1。1234lastp = len-1;for(int i =len-1;i&gt;=0;i--) if(i+nums[i]&gt;=lastp)lastp==i;return lastp==0; 45 ??????jump game最少跳跃次数超时递归（？递归终止条件是from==end，如果有0不可达展开代码 1234567891011121314151617181920212223public int minJumpRecur(int[] arr)&#123; int n = arr.length; memo = new int[n][n]; return jump(arr, 0, n-1);&#125;int[][] memo;private int jump(int[] steps,int from,int end)&#123;// System.out.println(from+" "+end); if(from==end)return 0; //不可达 if(memo[from][end]!=0)return memo[from][end]; if(steps[from]==0)return Integer.MAX_VALUE; int min = Integer.MAX_VALUE; //当前可以到达的范围是[from,from+step[from]] for(int i = from+1;i&lt;=end&amp;&amp;i&lt;=from+steps[from];i++)&#123; int jumps = jump(steps,i , end); if(jumps!=Integer.MAX_VALUE&amp;&amp;jumps+1&lt;min)&#123; min = jumps+1; memo[from][end] = min; &#125; &#125; return min;&#125; 1.在本次可跳跃的长度范围内如果不能达到len-1则表示一定要跳跃//不懂12345678910111213141516171819public int jump(int[] nums) &#123; if(nums==null||nums.length&lt;2)return 0; int res = 0; int curMax = 0; int maxNext = 0; //i=0,max = 2 i==cur -&gt;res++,cur = max=2 //i=1,max = max(2,4)=4, i!=cur //i=2,max = max(4,3)=4, i==cur res++,cur = max=4 //i=3,max = max(4,4)=4, i!=cur break //不需要走到i=4,max = max(4,4+4)=8,i==cur res++,cur=max for (int i = 0; i &lt; nums.length-1; i++) &#123; maxNext = Math.max(maxNext,i+nums[i] ); if(i==curMax)&#123; res++; curMax = maxNext; &#125; &#125; return res;&#125; 2.!!!BFS123456789101112131415161718public int jumpBFS(int[] nums)&#123; if(nums==null||nums.length&lt;2)return 0; int level = 0; int cur = 0; int max =0; int i =0; //cur-i+1=1,level++; i&lt;=cur,i++,max = 2;cur = 2; //cur=2,i=1;level++; i&lt;=2,i++,max = 4,max&gt;=n-1 return 2; while (cur-i+1&gt;0)&#123; level++; for(;i&lt;=cur;i++)&#123; max = Math.max(max,nums[i]+i); if(max&gt;=nums.length-1)return level; &#125; cur = max; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构模板&模板题]]></title>
    <url>%2F2018%2F09%2F01%2FadvanceDS%2F</url>
    <content type="text"><![CDATA[Merkle tree归并树每个节点对应区间排好序的结果 O(nlogn)建立树 连通分量无向图的连通分量可以用并查集（集合）来做并查集：[12,3,4,5]-&gt;[6,2,3,4,5]位置存放的是根节点有向图的连通分量Kosaraju 算法4p3801.将图的边反向,dfs得到逆后序2.按逆后序列dfs原图 cnt++ tarjan https://algs4.cs.princeton.edu/42digraph/TarjanSCC.java.html和拓扑排序一样Tarjan算法的运行效率也比Kosaraju算法高30%左右每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。 130 围棋 用并查集dfs ac100% ! lc200 number of islands 岛屿 水坑dfs 52% 5ms展开代码 123456789101112131415161718192021public int numIslands(char[][] grid) &#123; int cnt =0; for(int i = 0;i&lt;grid.length;i++)&#123; for(int j =0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]=='1')&#123; dfs(grid,i,j); ++cnt; &#125; &#125; &#125; return cnt;&#125;private void dfs(char[][] grid,int x,int y)&#123; if(x&lt;0||x&gt;grid.length-1||y&lt;0||y&gt;grid[0].length-1||grid[x][y]=='0') return; grid[x][y] = '0'; dfs(grid,x+1,y); dfs(grid,x-1,y); dfs(grid,x,y+1); dfs(grid,x,y-1);&#125; 并查集模板find O(1)判断是否在同一个集合中（同一个parent)1.找到一个‘1’2.用并查集把相邻的‘1’都union起来，本来8个‘1’，每次合并两个不同分量的就cnt–22% 8ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//union find模板class UnionFind&#123; int [] parent; int m,n; int count = 0; UnionFind(char[][] grid)&#123; m = grid.length; n = grid[0].length; parent = new int[m*n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == '1')&#123; int id = i*n+j; parent[id] = id; count++; &#125; &#125; &#125;// System.out.println(Arrays.toString(parent));// System.out.println("初始化完成"); &#125; public void union(int node1,int node2)&#123; int find1 = find(node1); int find2 = find(node2); System.out.println("int union:"+node1+" "+node2); System.out.println("find1,find2:"+find1+" "+find2); if(find1 != find2)&#123; parent[find1] = find2; count--; &#125; &#125; public int find (int node)&#123; if(parent[node] == node)return node; parent[node] = find(parent[node]); return parent[node]; &#125;&#125;int[][] distance = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;public int numIslands(char[][] grid)&#123; // if(grid==null||grid.length&lt;1||grid[0].length&lt;1) return 0; UnionFind uf = new UnionFind(grid); int rows = grid.length; int cols = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt;cols ; j++) &#123; if(grid[i][j] == '1')&#123; for(int[] d :distance)&#123; int x = i+d[0]; int y = j+d[1]; if(x&gt;=0&amp;&amp;x&lt;rows&amp;&amp;y&gt;=0&amp;&amp;y&lt;cols&amp;&amp;grid[x][y] == '1')&#123; int id1 = i*cols+j; int id2 = x*cols+y; uf.union(id1,id2); System.out.println(Arrays.toString(uf.parent)); &#125; &#125; &#125; &#125; &#125; return uf.count; &#125; bfs：展开代码 123456789101112131415161718192021222324252627282930313233343536373839public int numIslandsBFS(char[][] grid) &#123; int n = grid.length; int m = grid[0].length; boolean[][] marked = new boolean[n][m]; int count = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (!marked[i][j] &amp;&amp; grid[i][j] == '1') &#123; count++; bfs(grid,marked, i, j); &#125; &#125; &#125; return count;&#125;public void bfs(char[][] grid,boolean[][] marked,int x,int y)&#123; int[][] dxy = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; Deque&lt;int[]&gt; que = new ArrayDeque&lt;&gt;(); que.push(new int[]&#123;x,y&#125;); marked[x][y] = true; while (!que.isEmpty())&#123; int[] xy = que.poll(); for (int i = 0; i &lt;4 ; i++) &#123; int newx = xy[0] + dxy[i][0]; int newy = xy[1] + dxy[i][1]; if(newx &lt; 0 || newx &gt; marked.length || newy &lt;0 || newy &gt; marked[0].length)&#123; continue; &#125; if(!marked[newx][newy] &amp;&amp; grid[newx][newy] == '1')&#123; que.add(new int[]&#123;newx,newy&#125;); marked[newx][newy] = true; &#125; &#125; &#125;&#125; ！684 多余的连接（构成环）用UF模板 uf可以改到97%123456789101112131415161718192021222324252627282930313233//Unifind模板class UnionFind&#123; int [] parent; UnionFind(int size)&#123; parent = new int[size+1]; for (int i = 0; i &lt; size+1; i++) &#123; parent[i] = i; &#125; &#125; public boolean union(int node1,int node2)&#123; int find1 = find(node1); int find2 = find(node2); //已经在一个集合里了 if(find1==find2)return false; if(find1 != find2)&#123; parent[find1] = find2; &#125; return true; &#125; public int find (int node)&#123; if(parent[node] == node)return node; parent[node] = find(parent[node]); return parent[node]; &#125;&#125;public int[] findRedundantConnectionUF(int[][] edges) &#123; UnionFind uf = new UnionFind(edges.length); for(int[]edge:edges)&#123; if(!uf.union(edge[0],edge[1] )) return edge; &#125; return new int[]&#123;&#125;;&#125; 其他方法//todo 547 互相是朋友的圈子有几个208 Trie树 前缀树n个item查询，和item数量无关，只和查询的item长度有关如果不止26个字符，可以直接用一个map保存叶子节点1234567class Node&#123; // 节点可以不存 因为边有了 char c; // 边 Map&lt;char,Node&gt; next; boolean isWord;&#125; 实现Stringinsert search startsWith插入和查找的time都是O(len(s))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TrieNode&#123; public char val; public boolean end; public TrieNode[] children = new TrieNode[26]; TrieNode(char c)&#123; TrieNode node = new TrieNode(); node.val = c; &#125;&#125;class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(' '); &#125; public void insert(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c= word.charAt(i); if(cur.children[c-'a']==null)&#123; cur.children[c-'a'] = new TrieNode(c); &#125; cur = cur.children[c-'a']; &#125; cur.end = true; &#125; public boolean search(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length() ; i++) &#123; char c = word.charAt(i); if(cur.children[c-'a']==null)return false; cur = cur.children[c-'a']; &#125; return cur.end; &#125;//trie.startsWith("app"); // returns true public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (int i = 0; i &lt; prefix.length() ; i++) &#123; char c = prefix.charAt(i); if(cur.children[c-'a']== null)return false; cur = cur.children[c-'a']; &#125; return true; &#125;&#125; Trie应用：https://leetcode.com/problems/implement-trie-prefix-tree/solution/应用场景：1.查找公共前缀的key2.以字典序遍历数据相比hashtable节省空间 211 单词查询.匹配Trie677计算单词前缀的累积和RMQhttps://www.jianshu.com/p/bb2e6b355b31 线段树Segment Tree定义：1.叶节点是输入2.每个内部节点是为不同问题设计的，叶节点的组合（和/最大值/最小值）查找范围内的最小值/和 只需要Log(n) 数组实现https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/ lc307 sum线段树 Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Binary Index Tree/ Fenwick Tree 34% 106msO(logN) sum和update与dp不同，dp[i]存储了前i个的总和 e只存部分visualgo可视化1.树12345678910111213class NumArray &#123; int[] nums=null; int[] e = null; int len =0; public NumArray(int[] nums) &#123; len = nums.length; e = new int[len+1]; this.nums = new int[len]; for(int i =0;i&lt;len;i++)&#123; update(i,nums[i]); &#125; &#125; 每个叶子节点的父节点的计算方法i+lowbit(i)1的父节点=001+001=0102的父节点=010+010=100==44的父节点=100+100 = 1000==8 最低位：lowbit(5) = 101&amp;((010+1)==011)=0015的父节点=101+001=110==6沿着path向上更新，最多只会更新logn(树高个节点)12345678void update(int i,int val)&#123; int dif = val-nums[i]; nums[i++]=val; while(i&lt;e.length)&#123; e[i]+=dif; i+=(i&amp;-i); &#125;&#125; 2.sum树 前7个元素的和=7+11+101234567891011int query(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum+=e[i]; i-=(i&amp;-i); &#125; return sum;&#125;int rangeSum(int i,int j)&#123; return query(j+1)-query(i);&#125; k=末尾零个数 二进制末尾有k个0则e[i] 是2^k个元素的和 1 -&gt; 1 e[1]=a[1] 2 -&gt; 10 e[2]=a[1]+a[2] 3 -&gt; 11 e[3]=a[3] 4 -&gt; 100 e[4]=a[1]+a[2]+a[3]+a[4] = e[2]+e[3]+a[4] 5 -&gt; 101 e[5]=a[5] 6 -&gt; 110 e[6] = e[5]+e[6] 7 -&gt; 111 e[7] = a[7] 8 -&gt; 1000 e[8] = e[4]+e[6]+e[7]+a[8] 区间和查询305+修改307n个元素线段树的初始化时间复杂度和空间复杂度都是O(n)Spare Table 预处理时空复杂度都是O(nlogn) 但是二分查询i只需要O(loglogn)因为节点数是n+n/2+n/4+…=2n1.线段树用模板 59% 80ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class SegmentTreeNode &#123; int start, end; SegmentTreeNode left, right; int sum; public SegmentTreeNode(int start, int end) &#123; this.start = start; this.end = end; this.left = null; this.right = null; this.sum = 0; &#125;&#125;SegmentTreeNode root = null;private SegmentTreeNode build(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; else &#123; SegmentTreeNode ret = new SegmentTreeNode(start, end); if (start == end) &#123; ret.sum = nums[start]; &#125; else &#123; int mid = start + (end - start) / 2; ret.left = build(nums, start, mid); ret.right = build(nums, mid + 1, end); ret.sum = ret.left.sum + ret.right.sum; &#125; return ret; &#125;&#125;public int query(SegmentTreeNode root, int start, int end) &#123; if (root.end == end &amp;&amp; root.start == start) &#123; return root.sum; &#125; else &#123; int mid = root.start + (root.end - root.start) / 2; if (end &lt;= mid) &#123; return query(root.left, start, end); &#125; else if (start &gt;= mid+1) &#123; return query(root.right, start, end); &#125; else &#123; return query(root.right, mid+1, end) + query(root.left, start, mid); &#125; &#125;&#125;void modify(SegmentTreeNode root, int pos, int val) &#123; if (root.start == root.end) &#123; root.sum = val; &#125; else &#123; int mid = (root.end + root.start) / 2; if (pos &lt;= mid) &#123; modify(root.left, pos, val); &#125; else &#123; modify(root.right, pos, val); &#125; root.sum = root.left.sum + root.right.sum; &#125;&#125;public NumArray(int[] nums) &#123; root = build(nums, 0, nums.length-1);&#125;void update(int i, int val) &#123; modify(root, i, val);&#125;public int sumRange(int i, int j) &#123; return query(root, i, j);&#125; 2.用数组实现的线段树 太复杂就快3mshttps://leetcode.com/problems/range-sum-query-mutable/solution/ sqrt(n)复杂度拆分成sqrt份和 8% 308ms12345678910111213141516171819202122232425262728293031323334353637383940414243private int[] b;private int len;private int[] nums;public NumArray(int[] nums)&#123; this.nums = nums; double l = Math.sqrt(nums.length); len = (int)Math.ceil(nums.length/l); b = new int[len]; for (int i = 0; i &lt; nums.length; i++) &#123; b[i/len]+=nums[i]; &#125;&#125;public int sumRange(int i,int j)&#123; int sum = 0; int startBlock = i/len; int endBlock = i/len; //在同一个区间里 if(startBlock == endBlock)&#123; for (int k = i; k &lt;= j ; k++) &#123; sum+=nums[k]; &#125; &#125;else&#123; //start所在区间 //len = 3,start =0 for (int k = i; k &lt;(startBlock+1)*len ; k++) &#123; sum += nums[k]; &#125; //1-2) for (int k = startBlock+1; k &lt;endBlock ; k++) &#123; sum += b[k]; &#125; for (int k = endBlock*len; k &lt;j ; k++) &#123; sum += nums[k]; &#125; &#125; return sum;&#125;public void update(int i,int val)&#123; int bidx = i/len; b[bidx] = b[bidx]-nums[i]+val; nums[i] = val;&#125; lt206区间求和lt201按区间构造线段树展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SegmentTnode&#123; public int start,end; public SegmentTnode left,right; public SegmentTnode(int start, int end) &#123; this.start = start; this.end = end; this.left = null; this.right = null; &#125; @Override public String toString() &#123; Queue&lt;SegmentTnode&gt; q = new ArrayDeque&lt;&gt;(); StringBuilder sb = new StringBuilder(); sb.append("["); q.add(this); while (!q.isEmpty()) &#123; SegmentTnode top = q.remove(); sb.append("["+top.start+","+top.end+"]"); if (top.left != null) &#123; q.add(top.left);&#125; if (top.right != null) &#123; q.add(top.right); &#125; &#125; sb.append("]"); return sb.toString(); &#125;&#125;public SegmentTnode build(int start,int end)&#123; if(start&gt;end)return null; SegmentTnode root = new SegmentTnode(start,end); int left = (start+end)/2; int right = left+1; if(start!=end)&#123; root.left = build(start,left); root.right = build(right,end); &#125; return root;&#125;public static void main(String[] args) &#123; SegmentTree sl = new SegmentTree(); System.out.println(sl.build(1, 4));&#125; lt439 对数组构造max线段树 输入[3,2,1,4]输出“[0,3,max=4][0,1,max=3][2,3,max=4][0,0,max=3][1,1,max=2][2,2,max=1][3,3,max=4]”1.递归到0,0 max =3.回到上一层left = (0,0,3)2.root.right = (1,1,2);3.root.max = max(left,right)4.return root[0,1,3][0,0,3][1,1,2] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class SegmentTreeNode &#123; public int start, end, max; public SegmentTreeNode left, right; public SegmentTreeNode(int start, int end, int max) &#123; this.start = start; this.end = end; this.max = max; this.left = this.right = null; &#125; @Override public String toString() &#123; Queue&lt;SegmentTreeNode&gt; q = new ArrayDeque&lt;&gt;(); StringBuilder sb = new StringBuilder(); sb.append("["); q.add(this); while (!q.isEmpty()) &#123; SegmentTreeNode top = q.remove(); sb.append("["+top.start+","+top.end+", max="+top.max+"]"); if (top.left != null) &#123; q.add(top.left);&#125; if (top.right != null) &#123; q.add(top.right); &#125; &#125; sb.append("]"); return sb.toString(); &#125;&#125;public SegmentTreeNode build(int[] A)&#123; return build(A,0,A.length-1);&#125;private SegmentTreeNode build(int[] A,int start,int end)&#123; if(start==end)&#123;return new SegmentTreeNode(start,end,A[start]);&#125; SegmentTreeNode root = new SegmentTreeNode(start,end,Integer.MIN_VALUE); int left = (start+end)/2; root.left = build(A,start ,left ); root.right = build(A,left+1,end); root.max = Math.max(root.left.max, root.right.max); return root;&#125;public static void main(String[] args) &#123; lt439 sl = new lt439(); System.out.println(sl.build(new int[]&#123;3, 2, 1, 4&#125;));&#125; 202 max线段树查询 对于数组 [1, 4, 2, 3], 对应的线段树为：12345 [0, 3, max=4] / \ [0,1,max=4] [2,3,max=3] / \ / \[0,0,max=1] [1,1,max=4] [2,2,max=2], [3,3,max=3] query(root, 1, 1), return 4query(root, 1, 2), return 4query(root, 2, 3), return 3query(root, 0, 2), return 4 求和线段树1.区间完全匹配的，return value2.区间完全不匹配的，return 03.部分匹配超出查询区间的 递归查询左右子树查[3:4] 遇到[3:5],继续查[3:4],[5,5]完全超出 90%123456789public int query(lt439.SegmentTreeNode root, int start, int end) &#123; if(root.start&gt;=start&amp;&amp;root.end&lt;=end)return root.max; int rst = Integer.MIN_VALUE; int mid = (root.start+root.end)/2; //关键 if(mid&gt;=start)rst = Math.max(rst,query(root.left,start,end)); if(mid+1&lt;=end)rst = Math.max(rst,query(root.right,start,end)); return rst;&#125; 写法2：98%12345678910public int query(SegmentTreeNode root,int start,int end)&#123; if(start&gt;end)return 0; if(root.start==root.end)return root.max; int mid = (root.start+root.end)/2; //分割当前查询区间，如果和左边有交集，则查找左边最大值 int left = query(root.left,start,Math.min(mid,end)); //mid = 4,query(5,4) int right = query(root.right,Math.max(start,mid+1),end); return Math.max(left,right);&#125; lt203 线段树更新123456789101112 [1, 4, max=3] / \ [1, 2, max=2] [3, 4, max=3] / \ / \[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=3]如果调用 modify(root, 2, 4), 返回: [1, 4, max=4] / \ [1, 2, max=4] [3, 4, max=3] / \ / \[1, 1, max=2], [2, 2, max=4], [3, 3, max=0], [4, 4, max=3] 90%1234567891011121314public void modify(SegmentTreeNode root, int index, int value) &#123; if(index&gt;root.end&amp;&amp;index&lt;root.start)return; if(index==root.start&amp;&amp;root.end==index)&#123; root.max = value; return; &#125; int mid = (root.start+root.end)/2; if(mid&gt;=index)&#123; modify(root.left,index,value); &#125;else&#123; modify(root.right,index,value); &#125; root.max = Math.max(root.left.max,root.right.max);&#125; lt205区间最小数LogN 查询时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class segMinNode&#123; public int start,end,min; public segMinNode left,right; public segMinNode(int start,int end,int min)&#123; this.start = start; this.end = end; this.min = min; this.left = null; this.right = null; &#125;&#125;private segMinNode build(int[] A,int start,int end)&#123; if(start&gt;end)return null; if(start == end)return new segMinNode(start,end,A[start]); segMinNode root = new segMinNode(start,end,A[0]); int mid = (start+end)/2; root.left = build(A,start,left); root.right = build(A,left+1,end); root.min = Math.min(root.left.min,root.right.min); return root;&#125;public int query(segMinNode root,int start,int end)&#123; if(start == root.start&amp;&amp;root.end ==end)return root.min; int mid = (root.start+root.end)/2; int left = Integer.MAX_VALUE,right = Integer.MAX_VALUE; //查询区间&lt;=mid，肯定全在左边 if(end&lt;=mid)&#123; left = query(root.left,start,end); &#125; if(mid&lt;end)&#123; //查询区间开始在mid或者mid左边，必须查左子树 if(start&lt;=mid)&#123; left = query(root.left,start,mid); right = query(root.right,mid+1,end); &#125;else&#123; right = query(root.right,start,end); &#125; &#125; return Math.min(left,right);&#125;public List&lt;Integer&gt; intervalMinNumber(int[] A, List&lt;Interval&gt; queries) &#123; segMinNode root = build(A,0,A.length-1); List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(queries.size()); for(Interval in:queries)&#123; rst.add(query(root, in.start,in.end )); &#125; return rst;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Trie</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webflux]]></title>
    <url>%2F2018%2F08%2F30%2Fwebflux%2F</url>
    <content type="text"><![CDATA[函数式编程 lambda+Stream外部迭代 内部迭代外部：for循环内部迭代求和1int sum = IntStream.of(nums).sum(); 惰性求值 求int数组最小值1IntStream.of(new int[]&#123;1,2,3,4,5&#125;).min().getAsInt(); 改成并行：新建线程池，拆分数组，归并1IntStream.of(test).parallel().min().getAsInt(); 展开代码 123456789101112131415Random random = new Random(1024);int[] test = new int[1&lt;&lt;10];for (int i = 0; i &lt;test.length ; i++) &#123; test[i] = random.nextInt(1&lt;&lt;10);&#125;long start1 = System.currentTimeMillis();IntStream.of(test).min().getAsInt();long end1 = System.currentTimeMillis();//44System.out.println(end1-start1);long start = System.currentTimeMillis();IntStream.of(test).parallel().min().getAsInt();long end = System.currentTimeMillis();//3System.out.println(end-start); lambda：1234567891011Object ok = new Runnable() &#123; @Override public void run() &#123; System.out.println("ok"); &#125;&#125;;new Thread((Runnable)ok).start();new Thread(()-&gt;System.out.println("ok")).start();Object target3 = (Runnable)()-&gt;System.out.println("ok");new Thread((Runnable)target3); 4种写法123456789@FunctionalInterfaceinterface interface1&#123; int doubleNum(int i);&#125;interface1 i1 = (i)-&gt;i*2;interface1 i2 = i-&gt;i*2;interface1 i3 = (int i)-&gt;i*2;interface1 i4 = (int i)-&gt;&#123;return i*2;&#125;; 12345678910111213141516//输入int返回Stringinterface IMoneyFormat&#123; String format(int i);&#125;class MyMoney&#123; private final int money; public MyMoney(int money)&#123; this.money = money; &#125; public void printMoney(IMoneyFormat moneyFormat)&#123; System.out.println("存款："+moneyFormat.format(this.money)); &#125;&#125;MyMoney me = new MyMoney(99999);//存款：99,999me.printMoney(i-&gt;new DecimalFormat("#,###").format(i)); 使用JDK8带的函数接口Function1234public void printMoneyJDK8(Function&lt;Integer,String&gt; moneyFormat)&#123; System.out.println("存款："+moneyFormat.apply(this.money));&#125; me.printMoneyJDK8(i-&gt;new DecimalFormat("#,###").format(i)); 好处：链式操作123Function&lt;Integer,String&gt; moneyFormat = i-&gt;new DecimalFormat("#,###").format(i);//存款：RMB99,999me.printMoneyJDK8(moneyFormat.andThen(s-&gt;"RMB"+s)); 级联表达式和科里化//todo类型推断2-13 //todo::方法引用 用::将方法名称与类/对象分隔开1.类::实例方法 12BiFunction&lt;Dog,Integer,Integer&gt; eatFunc = Dog::eat;System.out.println("还有"+eatFunc.apply(new Dog(),2 )); 2.类::静态方法 Integer::valueOf12345678class Dog&#123; //消费者：输入Dog，输出void public static void Bark(Dog dog)&#123; System.out.println("bark"); &#125;&#125;Consumer&lt;Dog&gt; consumer = Dog::Bark;consumer.accept(new Dog()); 对象::实例方法 list::add静态方法和成员方法的区别：静态方法没有thisJDK默认会将当前实例传给非静态方法，叫this，位置必须第一个。java里都是传值而不是引用 所以不会空指针123IntUnaryOperator eat = dog::eat;dog=null;System.out.println("还剩下"+eat.applyAsInt(3)); 1234567891011class Dog&#123; private int food = 10; //函数：输入int，输出int public int eat(Dog this,int num)&#123; System.out.println("eat:"+num+"kg"); this.food-=num; return this.food; &#125;&#125;IntUnaryOperator eat = dog::eat;System.out.println("还剩下"+eat.applyAsInt(3)); 类::构造方法 ArrayList::new提供者：输入空，输出是实例1Supplier&lt;Dog&gt; supplier = Dog::new; 方法：带参构造函数，输入是int,输出是实例1Function&lt;Integer,Dog&gt; dog2 = Dog::new; 四大核心函数式接口 Consumer 消费者 接收一个值消费掉list.forEach 接收T返回void 12Consumer&lt;String&gt; consumer = s-&gt; System.out.println(s);consumer.accept("等待输出"); Function&lt;T,R&gt; 接收一个参数返回一个结果 1234public static String str(String str,Function&lt;String,String&gt; f)&#123; return f.apply(str);&#125;String s = str("functionnnntest",(str)-&gt; str.toUpperCase()); BiFunction&lt;T, U, R&gt; R apply(T t, U u); Supplier::T get();不传参数返回结果 123456public static List&lt;Integer&gt; getNumber(int num,Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i =0;i&lt;num;i++)&#123; list.add(sup.get());&#125; return list;&#125;List&lt;Integer&gt; list = getNumber(10,()-&gt;(int)(Math.random()*100)); Predicate::boolean test(T t);断言 123Predicate&lt;Integer&gt; predicate = i-&gt;i&gt;0;//trueSystem.out.println(predicate.test(9)); 过滤器保留有L的单词1234567891011private static void predicate()&#123;&#125;private static List&lt;String&gt; filter(List&lt;String&gt;list,Predicate&lt;String&gt; prd)&#123; List&lt;String&gt; res=new ArrayList&lt;&gt;(); for(String s:list)&#123; if(prd.test(s))res.add(s); &#125; return res;&#125;List&lt;String&gt; words = Arrays.asList("LL","LB","EE");//[LL, LB]List&lt;String&gt; sig = filter(words,(d)-&gt;d.contains("L")); 有一些自带的类型接口，不用写泛型,优先使用12IntPredicate predicateint = i-&gt;i&gt;0;IntConsumer intConsumer = System.out::println;; Lambda：函数作为方法的参数当接口只有一个抽象方法，函数式接口，不会生成class 内部类写法 1234567interface Ido&#123; public void doo(String thing);&#125;class IdoImp implements Ido&#123; public void doo(String thing)&#123; System.out.println(thing+"adfadfa");&#125;&#125;//mainIdoImp idoimp = new IdoImp();idoimp.doo("thing"); Lambda写法 12interface Ido&#123; public void doo(String thing);&#125;Ido ido = (thing)-&gt; System.out.println(thing+"doooooo"); 比较对象Comparator&lt;Integer&gt; c = (x,y)-&gt;Integer.compare(x,y); 方法引用 123Arrays.sort(strings,String::compareToIgnoreCase);Arrays.sort(strings,(x,y)-&gt;x.compareToIgnoreCase(y));System.out.println(Arrays.toString(strings)); ArrayList 打印全部元素list.forEach(x-&gt;sout(x))list.forEach(System.out::println)]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[可变对象和不可变对象]]></title>
    <url>%2F2018%2F08%2F30%2Fimmutable%2F</url>
    <content type="text"><![CDATA[实现immutable类 class 声明为finalpublic final class String 成员变量 private final (保证其他线程可见时初始化完成），且没有setter 构造对象时，成员变量使用深度拷贝来初始化。 如果有字段是可变对象，必须是private，不能向外暴露。getter方法，使用 copy-on-write原则(防御性复制），创建私有的 copy。 this关键字没有泄露（如匿名内部类在创建的时候修改其状态) final 修饰的 class 代表不可以继承扩展.避免 API 使用者更改基础功能final 的变量是不可以修改的.，利用final 可能有助于 JVM 将方法进行内联(现代高性能 JVM（如 HotSpot）判断内联未必依赖final 的提示)，可以改善编译器进行条件编译的能力.final 的方法也是不可以重写的（override） 不可变对象模式 创建后，对外可见状态保持不变类图：client通过 Manipulator 类 的 change方法生成新的 不可变对象 并set。 不可变对象因为一个对象的修改是直接替换的，所以不会存在Location多线程只修改了一个字段。 !! 如果对象作为key放入HashMap，对象状态变化导致HashCode变化，会导致同样的对象作为Key，get不到相关联的值。 所以不可变对象适合作为Key。 最佳实战：电信服务商的路由表&lt;String,Object&gt; 模式应用：CopyOnWriteArrayList对集合加锁：不适合插入删除操作比遍历多的集合。CopyOnWriteArrayList 应用了不可变对象模式。不用锁的遍历安全。适用于遍历操作比添加删除频繁的场景。源码：加添元素时会复制用实例变量静态变量并且volatile123456789101112131415private transient volatile Object[] array;public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 遍历：直接根据 array 生成一个新的实例1234567891011121314151617181920212223242526/** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator provides a snapshot of the state of the list * when the iterator was constructed. No synchronization is needed while * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the * &#123;@code remove&#125; method. * * @return an iterator over the elements in this list in proper sequence */public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** Snapshot of the array */ private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; ...&#125; 可变对象(可变Integer)输出objTest{val=888}地址1670782018 objTest{val=888}地址1670782018 1234567891011121314151617181920212223class objTest&#123; int val = 0; public objTest(int val) &#123; this.val = val; &#125; @Override public String toString() &#123; return "objTest&#123;" + "val=" + val + '&#125;'; &#125;&#125; private static void dfsObj(List&lt;objTest&gt; rst,objTest tmp,int idx)&#123; if(tmp.val==999)&#123; rst.add(tmp); &#125; for (int i = idx; i &lt;4 ; i++) &#123; tmp.val=999; dfsObj(rst,tmp,idx+1); tmp.val=888; &#125; &#125; 数组 同理List输出：[[I@5674cd4d, [I@5674cd4d,123456789101112List&lt;int[]&gt; rst5 = new ArrayList&lt;&gt;();dfsarr2(rst5,new int[]&#123;0&#125;,0); private static void dfsarr2(List&lt;int[]&gt; rst,int[] tmp,int idx)&#123; if(tmp[0]==3)&#123; rst.add(tmp); &#125; for(int i =idx;i&lt;4;i++)&#123; tmp[0]=3; dfsarr2(rst,tmp,idx+1); tmp[0]=1; &#125; &#125; 不可变对象：Integer 注意-127~128有cache 同理String，Double 的基本数据类型的包装类（如Integer 、 Long 和 Float ）都是不可变的，其它数字类型（如 BigInteger 和 BigDecimal ）也是不可变的。 输出：每次地址不一样1002地址1450495309 1002地址1670782018 1002地址1706377736 1002地址468121027123456789101112131415161718192021private static void dfsInteger(List&lt;Integer&gt; rst,Integer i,int idx)&#123; if(i.equals(999+3))&#123; rst.add(i); return; &#125; for(int j=idx;j&lt;4;j++)&#123; i++; dfsInteger(rst,i,j+1); i--; &#125;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; rst2 = new ArrayList&lt;&gt;(); dfsInteger(rst2,Integer.valueOf(999),0); System.out.println(); System.out.println("Integer结果 "); for(Integer i:rst2)&#123; System.out.print(i+"地址"+System.identityHashCode(i)+ " "); &#125;&#125; 不可变对象的源码：Double1private final double value; Integer1private final int value; String1private final char value[]; 不可变容器：12345Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();map.put(1,1);//java.lang.UnsupportedOperationExceptionMap&lt;Integer, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);unmodifiableMap.put(2,2); 实现源码1private final Map&lt;? extends K, ? extends V&gt; m; 重写了方法直接抛异常123456789101112public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125;public V remove(Object key) &#123; throw new UnsupportedOperationException();&#125;public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; throw new UnsupportedOperationException();&#125;public void clear() &#123; throw new UnsupportedOperationException();&#125; 可变对象源码ArrayList12transient Object[] elementData;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;]]></content>
      <categories>
        <category>并发</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[go]]></title>
    <url>%2F2018%2F08%2F27%2Fgo%2F</url>
    <content type="text"><![CDATA[对象 没有继承和多态 只有封装 只有struct构造123456789101112131415161718192021222324type treeNode struct&#123; value int left,right *treeNode&#125;func main() &#123; var root treeNode root = treeNode&#123;value:3&#125; root.left = &amp;treeNode&#123;&#125; root.right = &amp;treeNode&#123;&#125; root2 :=treeNode&#123;3,nil,nil&#125; root.right.left = new(treeNode) nodes:= []treeNode&#123; &#123;value:3&#125;, &#123;&#125;, &#123;6,nil,&amp;root&#125;, &#125; //&#123;3 0xc04205c400 0xc04205c420&#125; fmt.Println(root) //&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; fmt.Println(root2) // [&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;6 &lt;nil&gt; 0xc04205c3e0&#125;] fmt.Println(nodes)&#125; 没有构造函数可以写工厂函数局部变量的地址也能返回给外面用123func factory(value int)*treeNode&#123; return &amp;treeNode&#123;value:value&#125;&#125; 容器支持中文的go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "fmt" "unicode/utf8")func lengthOfLongestSubstringrune(s string) int &#123; lastcur := make(map[rune]int) start :=0 maxLength :=0 for i,ch:=range []rune(s)&#123; if lastI,ok:=lastcur[ch];ok&amp;&amp;lastI&gt;=start&#123; start = lastcur[ch]+1 &#125; if(i-start+1&gt;maxLength) &#123; maxLength = i - start + 1 &#125; lastcur[ch] = i; &#125; return maxLength;&#125;func main() &#123; s:="中文中文中文字符串我" fmt.Println(len(s)) for _,b := range []byte(s)&#123; //utf-8的编码 fmt.Printf(" %X ",b) &#125; fmt.Println(s) for i,ch := range s&#123; //unicode fmt.Printf("(%d, %X) ",i,ch) &#125; fmt.Println(utf8.RuneCountInString(s)) bytes := []byte(s) for len(bytes)&gt;0&#123; ch,size :=utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf("%c ",ch) &#125; fmt.Println()//每个rune占了4个字节 另外开了一个rune数组 for i,ch := range []rune(s)&#123; fmt.Printf("(%d %c)",i,ch) &#125; fmt.Println(lengthOfLongestSubstringrune("中文字符串中文中文"))&#125; Map除了slice map function其他内建类型都可以当keystruct不包含上面三个也可以当key1234567891011121314151617181920212223242526272829303132333435func main() &#123; m := map[string]string&#123; "A": "a", "B": "b", "C": "c", "D": "d", &#125; m2 := make(map[string]int) // m2 == empty map var m3 map[string]int // m3 == nil// map[A:a B:b C:c D:d] map[] map[] fmt.Println(m, m2, m3)// B b// C c// D d// A a for k,v:=range m&#123; fmt.Println(k,v) &#125; //a courseName := m["A"] fmt.Println(courseName) // false 不存在也会输出空串 courseName ,ok:= m["dd"] fmt.Println(courseName,ok) if courseName ,ok:= m["dd"];ok&#123; fmt.Println(courseName) &#125;else&#123; fmt.Println("not Exist") &#125; //删除 delete(m,"D")&#125; 数组初始化12345678func main() &#123; var arr1 [5]int arr2 := [3]int&#123;1,3,5&#125; arr3 := [...]int&#123;2,4,6,8,10&#125; fmt.Println(arr1,arr2,arr3) var grid [4][5] int fmt.Println(grid)&#125; 遍历123for _,v:=range arr3&#123; fmt.Println(v) &#125; 数组是值类型传到func中不会改变1234567891011121314func printArray(arr [5]int) &#123; arr[0]=100 for i,v:=range arr&#123; fmt.Print(i,v," ") &#125; fmt.Print("\n")&#125;func main()&#123; arr3 := [...]int&#123;2,4,6,8,10&#125; printArray(arr3) for i,v:=range arr3&#123; fmt.Print(i," ",v," ") &#125;&#125; 用指针可以改变12345678910111213141516func printArray(arr *[5]int) &#123; arr[0]=100 for _,v:=range arr&#123; fmt.Print(v," ") &#125; fmt.Print("\n")&#125;func main()&#123; arr3 := [...]int&#123;2,4,6,8,10&#125; //100 4 6 8 10 // 100 4 6 8 10 printArray(&amp;arr3) for _,v:=range arr3&#123; fmt.Print(v," ") &#125;&#125; 切片Slice1234567arr:=[...]int &#123;1,2,3,4,5,6,7,8&#125;// [3 4 5 6 7 8]s:=arr[2:]fmt.Println(s)s[1] =100//[1 2 3 100 5 6 7 8]fmt.Println(arr) 切片可以扩展123456789101112arr:=[...]int &#123;1,2,3,4,5,6,7,8&#125;s:=arr[2:4]//6fmt.Println(cap(s))//[6 7 8]fmt.Println(s[3:6])//[3 4 999] 必须接受append的返回值s2:=append(s, 999)fmt.Println(s2)//[1 2 3 100 999 6 7 8]//如果append超过了cap 会创建新的数组fmt.Println(arr) 创建切片123456789101112131415161718var s3[] int; for i:=0;i&lt;100;i++&#123;// len: 0 cap: 0// len: 1 cap: 1// len: 2 cap: 2// len: 3 cap: 4// len: 4 cap: 4// len: 5 cap: 8 fmt.Println("len: ",len(s3)," cap: ",cap(s3)) s3 = append(s3,2*i+1) &#125; fmt.Println(s3)s4 := [] int&#123;1,2,3,4,5&#125;fmt.Println(s4)s5 := make([]int,16)fmt.Println(s5)s6 := make([]int,16,32)fmt.Println(s6) 拷贝12345//s5:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]//s4:[1 2 3 4 5]copy(s5,s4)//s5:[1 2 3 4 5 0 0 0 0 0 0 0 0 0 0 0]fmt.Println(s5) 删除123456789//删掉3s=append(s[:3],s[4:]...)//popfront := s[0]s = s[1:]//poptail = s[len(s)-1]s = s[:len(s)-1] 基础语法变量simple application1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport "fmt"//包内变量var aa = 3var ss = "kkk"var( dd=3 bb=2)func variable() &#123; var a int var s string fmt.Println(a,s) fmt.Printf("%d %q\n",a,s)&#125;func variableInit()&#123; var a,b int=3,4 var s string = "abc" fmt.Println(a,b,s)&#125;func varDeduction() &#123; var a,b,c,s = 3,4,true,"def" fmt.Println(a,b,c,s)&#125;func varShorter() &#123; a,b,c,s := 3,4,true,"def"; fmt.Println(a,b,c,s);&#125;func main() &#123; fmt.Println("Hello world")//Hello world// 0 // 0 "" variable()//3 4 abc variableInit() varDeduction() varShorter()&#125; 内建变量char用rune为了国际化 32位的 utf8很多字符都是3字节的用4字节的int32表示runebyte 8位byte和rune可以和整数混用，就是整数的别名 常量 一般go语言常量不大写123456789101112131415import ( "fmt" "math")func consts()&#123; const filename = "abc.txt" const a,b = 3,4 var c int c = int(math.Sqrt(a*a+b*b)) fmt.Println(filename,c)&#125;func main()&#123; // abc.txt 5 consts()&#125; 枚举123456789101112131415161718192021222324252627282930313233func enums() &#123; const( cpp = 0 java = 1 python = 2 golang = 3 ) fmt.Println(cpp,java,python,golang)&#125;func enumsiota() &#123; const( cpp = iota java python golang ) fmt.Println(cpp,java,python,golang) const( b = 1&lt;&lt;(10*iota) kb mb gb tb pb ) // 1 1024 1048576 1073741824 1099511627776 1125899906842624 fmt.Println(b,kb,mb,gb,tb,pb)&#125;func main() &#123; enums() //0 1 2 3 4 enumsiota()&#125; 条件语法123456789func bounded(v int) int&#123; if v&gt;100&#123; return 100 &#125;else if v&lt;0&#123; return 0 &#125;else&#123; return v &#125;&#125; 读文件，是个byte数组12345678910111213141516package mainimport ( "io/ioutil" "fmt")func main() &#123; const filename = "file.txt" contents, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Println(err) &#125;else&#123; fmt.Printf("%s\n",contents) &#125;&#125; 像for一样写if 赋值之后再做判断12345if contents,err:= ioutil.ReadFile(filename);err!=nil&#123; fmt.Println(err)&#125;else&#123; fmt.Printf("%s\n",contents)&#125; switch 每个case后默认break，除非用fallthrough1234567891011121314151617181920212223242526272829303132func grade(score int) string &#123; g := "" switch &#123; case score &lt; 0 || score &gt; 100: panic(fmt.Sprintf( "Wrong score: %d", score)) case score &lt; 60: g = "F" case score &lt; 80: g = "C" case score &lt; 90: g = "B" case score &lt;= 100: g = "A" &#125; return g&#125;func main()&#123;// panic: Wrong score: 101// goroutine 1 [running]:// main.grade(0x65, 0x4cffc1, 0x1)// D:/goLearn/branch.go:12 +0x154// main.main()// D:/goLearn/branch.go:43 +0x125 fmt.Println( grade(1), grade(99), grade(70), grade(101), )&#125; 循环 10进制转2进制1234567891011121314151617181920212223242526package mainimport ( "fmt" "strconv")func convert2Bin(n int) string &#123; result := "" if n==0&#123; return "0" &#125; for ; n&gt;0;n/=2&#123; lsb:= n%2 result = strconv.Itoa(lsb) + result &#125; return result&#125;func main() &#123; fmt.Println( convert2Bin(5), convert2Bin(13), convert2Bin(99999999999999), convert2Bin(0), )&#125; 按行读文件 没有wile，只有for1234567891011121314151617181920import ( "fmt" "strconv" "os" "bufio")func fileLine(filename string)&#123; file,err :=os.Open(filename) if err !=nil&#123; panic(err) &#125; scanner := bufio.NewScanner(file) for scanner.Scan()&#123; //读一行 fmt.Println(scanner.Text()) &#125;&#125;func main()&#123; fileLine("file.txt")&#125; 死循环12345func forever()&#123; for&#123; fmt.Println("abc") &#125;&#125; 函数带余数除法：1234567891011121314func div(a,b int) (int , int) &#123; return a/b,a%b&#125;func divname(a,b int) (q,r int) &#123; q = a/b r = a%b return&#125;func main() &#123; fmt.Println(div(3,4)) q,r := divname(3,4) fmt.Println(q,r)&#125; 只想用第一个返回值 第二个用_ 其他都会报unused，iota递增也可以用_表示跳过12345678910111213141516func eval(a, b int, op string) (int, error) &#123; switch op &#123; case "+": return a + b, nil case "-": return a - b, nil case "*": return a * b, nil case "/": q, _ := divname(a, b) return q, nil default: return 0, fmt.Errorf( "unsupported operation: %s", op) &#125;&#125; 函数式编程，传递func给func,匿名函数123456789101112131415161718func apply(op func(int,int)int,a,b int) int &#123; p := reflect.ValueOf(op).Pointer() name := runtime.FuncForPC(p).Name() fmt.Println(name) return op(a,b)&#125;func pow(a,b int) int &#123; return int(math.Pow(float64(a),float64(b)))&#125;func main()&#123; //main.pow apply(pow,3,4) //main.main.func1 fmt.Println(apply(func(a int, b int) int &#123; return int(math.Pow(a,b)) &#125;,3,4))&#125; 可变参数列表,求和12345678910func sum(number ...int)int&#123; s:=0 for i:= range number&#123; s+=number[i] &#125; return s&#125;func main()&#123; fmt.Println(sum(1,2,3,4,5,5,6))&#125; 指针 指针不能运算cpp的值传递和引用传递1234567891011void pass_by_val(int a)&#123;a++;&#125;void pass_by_ref(int&amp; a)&#123;a++;&#125;int main()&#123; int a=3; pass_by_val(a) //3 cout&lt;&lt;a; pass_by_val(a) //4 cout&lt;&lt;a;&#125; go 语言全是值传递，引用传递要用指针1234567891011121314func swap(a,b *int) &#123; *a,*b = *b,*a&#125;//不可变类型的swapfunc swap2(a,b int) (a2,b2 int) &#123; return b,a&#125;func main() &#123; a,b:=3,4 swap(&amp;a,&amp;b) fmt.Println(a,b) a,b = swap2(a,b) fmt.Println(a,b)&#125;]]></content>
      <categories>
        <category>go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cppSTL]]></title>
    <url>%2F2018%2F08%2F12%2FcppSTL%2F</url>
    <content type="text"><![CDATA[操作符重载https://en.cppreference.com/w/cpp/language/operators 不能重载的操作符 operators :: (scope resolution), . (member access), .* (member access through pointer to member), and ?: (ternary conditional) cannot be overloaded. 链表的迭代器：重定义了所有指针的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869template&lt;typename _Tp&gt;struct _List_iterator&#123; typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; _List_iterator() : _M_node() &#123; &#125; explicit _List_iterator(__detail::_List_node_base* __x) : _M_node(__x) &#123; &#125; // Must downcast from _List_node_base to _List_node to get to _M_data. reference operator*() const &#123; return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; &#125; pointer operator-&gt;() const &#123; return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); &#125; _Self&amp; operator++() &#123;_M_node = _M_node-&gt;_M_next;return *this; &#125; _Self operator++(int) &#123;_Self __tmp = *this;_M_node = _M_node-&gt;_M_next;return __tmp; &#125; _Self&amp; operator--() &#123;_M_node = _M_node-&gt;_M_prev;return *this; &#125; _Self operator--(int) &#123;_Self __tmp = *this;_M_node = _M_node-&gt;_M_prev;return __tmp; &#125; bool operator==(const _Self&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _Self&amp; __x) const &#123; return _M_node != __x._M_node; &#125; // The only member points to the %list element. __detail::_List_node_base* _M_node;&#125;; 源码位置 generic programming\devcpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.8.1\include\c++\bits数据list/deque/vector和方法algorithm分开全局函数::sort(c.begin(),c.end());通过iterator/泛化指针作为接口 stl_algobase：1234567891011template&lt;typename _Tp&gt;inline const _Tp&amp;min(const _Tp&amp; __a, const _Tp&amp; __b)&#123; // concept requirements __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;) //return __b &lt; __a ? __b : __a; if (__b &lt; __a)return __b; return __a;&#125; 123456789template&lt;typename _Tp, typename _Compare&gt;inline const _Tp&amp;max(const _Tp&amp; __a, const _Tp&amp; __b, _Compare __comp)&#123; //return __comp(__a, __b) ? __b : __a; if (__comp(__a, __b))return __b; return __a;&#125; list不用全局sort 因为全局sort要求传入的指针是randomaccessstl_algobase：1234567891011template&lt;typename _RandomAccessIterator&gt; inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last)&#123; ... if (__first != __last) &#123; std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2); std::__final_insertion_sort(__first, __last); &#125; &#125; 模板1.类模板在class前加template&lt;typename T&gt;2.函数模板 写typename和class功能相同12345template&lt;class T&gt;inlineconst T&amp; min(const T&amp; a,const T&amp; b)&#123; return b&lt;a?b:a;&#125; 3.成员模板 operator new()/malloc()operator new 调用mallocnewop.cpp1234567891011oid *__CRTDECL operator new(size_t count) _THROW1(_STD bad_alloc)&#123; // try to allocate size bytesvoid *p;while ((p = malloc(count)) == 0) if (_callnewh(count) == 0) &#123; // report no memory static const std::bad_alloc nomem; _RAISE(nomem); &#125;return (p);&#125; STL 分配器Allocator支持容器，处理容器的内存。容器Containers数据和算法Algorithms操作分开。不是OO设计，是模板编程。迭代器是泛化指针 是容器和算法的桥梁。仿函数Functors 容器1 Sequence Containers: Array\vector\deque\list循环双端链表\forwardlist单向链表2 Associative Container:Set\Multiset,Map\Multimap3 unordered Containers: HashTable:Separate Chaning。 array不能改变大小milli-seconds : 11array.size()= 500000array.front()= 41array.back()= 29794数组起点的内存位置array.data()= 0x49c040展开代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;array&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;const long ASIZE = 500000L;array&lt;long,ASIZE&gt; c;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int compareLongs(const void* a, const void* b)&#123; return ( *(long*)a - *(long*)b );&#125;int main()&#123;clock_t timeStart = clock();for(long i =0;i&lt;ASIZE;++i)&#123; c[i]=rand();&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; //cout &lt;&lt; "array.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "array.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "array.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "array.data()= " &lt;&lt; c.data() &lt;&lt; endl; //二分查找qsort(c.data(), ASIZE, sizeof(long), compareLongs);long* pItem = (long*)::bsearch(&amp;target, (c.data()), ASIZE, sizeof(long), compareLongs); if (pItem != NULL) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl;&#125; vectormilli-seconds : 6326vector.max_size()= 2305843009213693951vector.size()= 1000000vector.front()= 41vector.back()= 12679vector.data()= 0x33c5040vector.capacity()= 1048576 target (0~32767): 654target:654std::find(), milli-seconds : 1found, 654bsearch(), milli-seconds : 1387found, 654展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //sort()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int compareStrings(const void* a, const void* b)&#123; if ( *(string*)a &gt; *(string*)b ) return 1; else if ( *(string*)a &lt; *(string*)b ) return -1; else return 0; &#125;int main()&#123;vector&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i)&#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; //曾經最高 i=58389486 then std::bad_alloc abort(); &#125;&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "vector.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //1073747823cout &lt;&lt; "vector.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "vector.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "vector.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "vector.data()= " &lt;&lt; c.data() &lt;&lt; endl;cout &lt;&lt; "vector.capacity()= " &lt;&lt; c.capacity() &lt;&lt; endl &lt;&lt; endl; string target = get_a_target_string();cout&lt;&lt;"target:"&lt;&lt;target&lt;&lt;endl; timeStart = clock(); //find的查找速度 auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl; //二分查找的速度timeStart = clock(); sort(c.begin(),c.end()); string* pItem2 = (string*)::bsearch(&amp;target, (c.data()), c.size(), sizeof(string), compareStrings); cout &lt;&lt; "bsearch(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem2 != NULL) cout &lt;&lt; "found, " &lt;&lt; *pItem2 &lt;&lt; endl &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl &lt;&lt; endl; return 0;&#125; Listmilli-seconds : 5165list.size()= 1000000list.max_size()= 768614336404564650list.front()= 41list.back()= 12679target (0~32767): 554//find循序查找用时std::find(), milli-seconds : 2found, 554//容器内的sort用时c.sort(), milli-seconds : 2098展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;list&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;list&lt;string&gt; c; char buf[10];clock_t timeStart = clock();for(long i=0; i&lt; 1000000; ++i)&#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125;&#125;cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "list.size()= " &lt;&lt; c.size() &lt;&lt; endl;cout &lt;&lt; "list.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //357913941cout &lt;&lt; "list.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "list.back()= " &lt;&lt; c.back() &lt;&lt; endl;string target = get_a_target_string();//find循序查找 timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl;else cout &lt;&lt; "not found! " &lt;&lt; endl; //排序用时timeStart = clock(); //容器的sort c.sort(); cout &lt;&lt; "c.sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 单向链表没有push_back(太慢)只有push_front只能得到第一个元素不能得到最后milli-seconds : 5716forward_list.max_size()= 1152921504606846975forward_list.front()= 12679target (0~32767): 3443std::find(), milli-seconds : 2found, 3443c.sort(), milli-seconds : 2155展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;forward_list&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;forward_list&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_front(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "forward_list.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //536870911 cout &lt;&lt; "forward_list.front()= " &lt;&lt; c.front() &lt;&lt; endl; string target = get_a_target_string(); timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; timeStart = clock(); c.sort(); cout &lt;&lt; "c.sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl;return 0;&#125; dequegnuC的，不是c++11的,用法与forward_list相同slist:milli-seconds : 5096slist.max_size()= 18446744073709551615slist.front()= 12679target (0~32767): 33std::find(), milli-seconds : 4found, 33c.sort(), milli-seconds : 122812#include &lt;ext\slist&gt;__gnu_cxx::slist&lt;string&gt; c; deque分段连续milli-seconds : 6119deque.size()= 1000000deque.front()= 41deque.back()= 12679deque.max_size()= 2305843009213693951target (0~32767): 354std::find(), milli-seconds : 3found, 354sort(), milli-seconds : 1551展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;deque&gt;//#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;deque&lt;string&gt; c; char buf[10];clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.push_back(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "deque.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "deque.front()= " &lt;&lt; c.front() &lt;&lt; endl; cout &lt;&lt; "deque.back()= " &lt;&lt; c.back() &lt;&lt; endl; cout &lt;&lt; "deque.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //1073741821 string target = get_a_target_string(); timeStart = clock(); auto pItem = find(c.begin(), c.end(), target); cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; timeStart = clock(); sort(c.begin(), c.end()); cout &lt;&lt; "sort(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 容器适配器stack/queue用deque实现 push,pop没有iterator，没有find，不然就可以改变中间的值stack：milli-seconds : 5545stack.size()= 1000000stack.top()= 12679stack.size()= 999999stack.top()= 171721stack&lt;string&gt; c; queue:milli-seconds : 4943queue.size()= 1000000queue.front()= 41queue.back()= 12679queue.size()= 999999queue.front()= 18467queue.back()= 12679123queue&lt;string&gt; c;c.front();c.back(); multiset 可以当成关联数据库放进去的时候就排序了，红黑树标准库的find和容器的findmilli-seconds : 7833multiset.size()= 1000000multiset.max_size()= 461168601842738790target (0~32767): 23489std::find(), milli-seconds : 124found, 23489c.find(), milli-seconds : 0found, 23489展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;set&gt;//#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;multiset&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); //比std::find(...)快很多 cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; return 0;&#125; multimap c.insert(pair&lt;long,string&gt;(i,buf));milli-seconds : 6038multimap.size()= 1000000multimap.max_size()= 384307168202282325target (0~32767): 293283c.find(), milli-seconds : 0found, value=8239展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;multimap&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 做 insertion c.insert(pair&lt;long,string&gt;(i,buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //178956970 long target = get_a_target_long(); timeStart = clock(); //迭代器 auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0;&#125; unordered_multiset(hashtable)不是红黑树是hash表milli-seconds : 5832unordered_multiset.size()= 1000000unordered_multiset.max_size()= 768614336404564650unordered_multiset.bucket_count()= 1056323unordered_multiset.load_factor()= 0.94668unordered_multiset.max_load_factor()= 1unordered_multiset.max_bucket_count()= 768614336404564650bucket #33 has 36 elements.bucket #37 has 41 elements.bucket #79 has 16 elements.target (0~32767): 555std::find(), milli-seconds : 81found, 555c.find(), milli-seconds : 0found, 555展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;unordered_set&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;unordered_multiset&lt;string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.bucket_count()= " &lt;&lt; c.bucket_count() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.load_factor()= " &lt;&lt; c.load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_load_factor()= " &lt;&lt; c.max_load_factor() &lt;&lt; endl; cout &lt;&lt; "unordered_multiset.max_bucket_count()= " &lt;&lt; c.max_bucket_count() &lt;&lt; endl; for (unsigned i=1; i&lt; 120; ++i) &#123; if(c.bucket_size(i)!=0) cout &lt;&lt; "bucket #" &lt;&lt; i &lt;&lt; " has " &lt;&lt; c.bucket_size(i) &lt;&lt; " elements.\n"; &#125; string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); //容器内 auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; return 0;&#125; unordered_multimapmilli-seconds : 6266unordered_multimap.size()= 1000000unordered_multimap.max_size()= 768614336404564650target (0~32767): 42342c.find(), milli-seconds : 0found, value=9100展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;unordered_map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;unordered_multimap&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); //multimap 不可使用 [] 進行 insertion c.insert(pair&lt;long,string&gt;(i,buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "unordered_multimap.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0;&#125; set 红黑树放了1000000但是只有32768大小，0~32767milli-seconds : 6963set.size()= 32768set.max_size()= 461168601842738790target (0~32767): 3std::find(), milli-seconds : 4found, 3c.find(), milli-seconds : 0found, 3展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;set&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()using namespace std;string get_a_target_string()&#123;long target=0;char buf[10]; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; snprintf(buf, 10, "%d", target); return string(buf);&#125;int main()&#123;set&lt;string&gt; c; char buf[10];clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c.insert(string(buf)); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "set.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "set.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //214748364 string target = get_a_target_string(); &#123; timeStart = clock();auto pItem = find(c.begin(), c.end(), target); //比 c.find(...) 慢很多 cout &lt;&lt; "std::find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#123; timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, " &lt;&lt; *pItem &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; &#125; &#125; map 可以用[]自动变成一个pair c[i] = string(buf);milli-seconds : 6843map.size()= 1000000map.max_size()= 384307168202282325target (0~32767): 4c.find(), milli-seconds : 0found, value=19169展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;map&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;algorithm&gt; //find()#include &lt;ctime&gt; using namespace std;long get_a_target_long()&#123;long target=0; cout &lt;&lt; "target (0~" &lt;&lt; RAND_MAX &lt;&lt; "): "; cin &gt;&gt; target; return target;&#125;int main()&#123;map&lt;long, string&gt; c; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; 1000000; ++i) &#123; try &#123; snprintf(buf, 10, "%d", rand()); c[i] = string(buf); &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; cout &lt;&lt; "map.size()= " &lt;&lt; c.size() &lt;&lt; endl; cout &lt;&lt; "map.max_size()= " &lt;&lt; c.max_size() &lt;&lt; endl; //178956970 long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout &lt;&lt; "c.find(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; if (pItem != c.end()) cout &lt;&lt; "found, value=" &lt;&lt; (*pItem).second &lt;&lt; endl; else cout &lt;&lt; "not found! " &lt;&lt; endl; return 0; &#125; unordered_set/map1234unordered_set&lt;string&gt; c;c.insert(string(buf)); unordered_map&lt;long, string&gt; c; c[i] = string(buf); GNU C以前用hash_set,hash_map,hash_multiset,hash_multimap#include &lt;ext\hash_set&gt;12#include &lt;ext\hash_map&gt;__gnu_cxx::hash_multimap&lt;long, string&gt; c; GNUC的分配器 VC里名字不一样(1) std::allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4975(2) malloc_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4768(3) new_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 4790(4) __pool_alloc 内存池how many elements: 1000000a lot of push_back(), milli-seconds : 7357(5) __mt_alloc 多线程how many elements: 1000000a lot of push_back(), milli-seconds : 4881(6) bitmap_allocatorhow many elements: 1000000a lot of push_back(), milli-seconds : 7420展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;list&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;#include &lt;cstdlib&gt; //abort()#include &lt;cstdio&gt; //snprintf()#include &lt;algorithm&gt; //find()#include &lt;iostream&gt;#include &lt;ctime&gt; #include &lt;ext\array_allocator.h&gt;#include &lt;ext\mt_allocator.h&gt;#include &lt;ext\debug_allocator.h&gt;#include &lt;ext\pool_allocator.h&gt;#include &lt;ext\bitmap_allocator.h&gt;#include &lt;ext\malloc_allocator.h&gt;#include &lt;ext\new_allocator.h&gt; using namespace std;int main()&#123; //不能在 switch case 中宣告，只好下面這樣. //1000000次 list&lt;string, allocator&lt;string&gt;&gt; c1; //3140 list&lt;string, __gnu_cxx::malloc_allocator&lt;string&gt;&gt; c2; //3110 list&lt;string, __gnu_cxx::new_allocator&lt;string&gt;&gt; c3; //3156 list&lt;string, __gnu_cxx::__pool_alloc&lt;string&gt;&gt; c4; //4922 list&lt;string, __gnu_cxx::__mt_alloc&lt;string&gt;&gt; c5; //3297 list&lt;string, __gnu_cxx::bitmap_allocator&lt;string&gt;&gt; c6; //4781 int choice;long value; cout &lt;&lt; "select: " &lt;&lt; " (1) std::allocator " &lt;&lt; " (2) malloc_allocator " &lt;&lt; " (3) new_allocator " &lt;&lt; " (4) __pool_alloc " &lt;&lt; " (5) __mt_alloc " &lt;&lt; " (6) bitmap_allocator "; cin &gt;&gt; choice; if ( choice != 0 ) &#123; cout &lt;&lt; "how many elements: "; cin &gt;&gt; value; &#125; char buf[10]; clock_t timeStart = clock(); for(long i=0; i&lt; value; ++i) &#123; try &#123; snprintf(buf, 10, "%d", i); switch (choice) &#123; case 1 : c1.push_back(string(buf)); break; case 2 : c2.push_back(string(buf)); break; case 3 : c3.push_back(string(buf)); break; case 4 : c4.push_back(string(buf)); break; case 5 : c5.push_back(string(buf)); break; case 6 : c6.push_back(string(buf)); break; default: break; &#125; &#125; catch(exception&amp; p) &#123; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " " &lt;&lt; p.what() &lt;&lt; endl; abort(); &#125; &#125; cout &lt;&lt; "a lot of push_back(), milli-seconds : " &lt;&lt; (clock()-timeStart) &lt;&lt; endl; return 0;&#125; 可以直接使用allocate 但是不要用 小分配用malloc 大分配用容器123__gnu_cxx::bitmap_allocator&lt;int&gt; alloc6; p = alloc6.allocate(3); alloc6.deallocate(p,3);]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop]]></title>
    <url>%2F2018%2F08%2F09%2Fhadoop%2F</url>
    <content type="text"><![CDATA[split 是mapreduce中的最小计算单元一般和hdfs的blocksize 是一一对应的/ 以下哪个调度器是hadoop的默认调度器正确答案: B 你的答案: C (错误)A调度器Capacity SchedulerB调度器FIFOC资源调度器 Resource SchedulerD调度器Fair Scheduler Hadoop HDFS Client端上传文件到HDFS上的时候下列不正确的是正确答案: A C D 你的答案: A B (错误)A.数据经过NameNode传递给DataNodeB.数据副本将以管道的方式依次传递C.Client将数据写到一台DataNode上，并由Client负责完成Block复制工作D.当某个DataNode失败，客户端不会继续传给其它的DataNode A:Client 向 NameNode 发起文件写入的请求。NameNode 根据文件大小和文件块配置情况，返回给 Client 它所管理部分 DataNode 的信息。Client 将文件划分为多个 Block，根据 DataNode 的地址信息，按顺序写入到每一个DataNode 块中。 Mapper.java模板模式12345678910public void run(Context context) throws IOException, InterruptedException &#123; setup(context); try &#123; while (context.nextKeyValue()) &#123; map(context.getCurrentKey(), context.getCurrentValue(), context); &#125; &#125; finally &#123; cleanup(context); &#125; &#125; 重写方法123456789/*** Called once for each key/value pair in the input split. Most applications* should override this, but the default is the identity function.*/@SuppressWarnings("unchecked")protected void map(KEYIN key, VALUEIN value, Context context) throws IOException, InterruptedException &#123;context.write((KEYOUT) key, (VALUEOUT) value);&#125;]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[systemdesign]]></title>
    <url>%2F2018%2F08%2F07%2Fsystemdesign%2F</url>
    <content type="text"><![CDATA[https://soulmachine.gitbooks.io/system-design/content/cn/api-rate-limiting.htmlhttps://wizardforcel.gitbooks.io/system-design-primer/4.html#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%A2%98%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8Bhttps://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904 需求分析5W1H8C法https://www.kancloud.cn/yunhua_lee/oobaodian/110896How:用例分析法：NEA法用例的具体写法https://www.kancloud.cn/yunhua_lee/oobaodian/110897 设计电梯https://medium.com/system-designing-interviews/design-a-elevator-system-fc5832ca0b8b Log Structured Merge TreesSorted String Tables： 现在小米要举行一次全员野外拉练活动，要求所有员工必须排成一队出去，并且，有的员工要求他必须排在某人的前面或后面，作为组织者的你，收到这样的需求之后，如何给出一个让每个人都满意的排队方式呢？拓扑排序 系统赠送200钻石，玩家可以把它分成20份并分享给自己的10万个粉丝。假如是你来设计开发这个红包功能，你会怎样解决一下问题？ 钻石的最小单位是1，如何设计钻石分配算法？2.红包份数有限，高并发情况下怎么解决固定份数和限额的问题？3.如果高峰阶段，抢红包的并发请求数可能达到8000次/秒，使用什么样的存储系统可以支持该方案？ 1G单词，内存1M，每个词16B以下，返回频率最高的100个。1.$1M=2^20B / 2^4 = 2^16$ 1M内存只能处理1&lt;&lt;16个单词2.$1G = 2^30B$ 1G有1&lt;&lt;26个单词3.所以要把分成至少$2^10$份4.为了把相同的单词划分到一个小文件 （？）5.每个文件取top100个6.归并出top100 多电梯调度 car allocation341 多层List迭代器981 key-timestamp-value输入：inputs = [“TimeMap”,”set”,”get”,”get”,”set”,”get”,”get”], inputs = [[],[“foo”,”bar”,1],[“foo”,1],[“foo”,3],[“foo”,”bar2”,4],[“foo”,4],[“foo”,5]]输出：[null,null,”bar”,”bar”,null,”bar2”,”bar2”]解释：TimeMap kv;kv.set(“foo”, “bar”, 1); // 存储键 “foo” 和值 “bar” 以及时间戳 timestamp = 1kv.get(“foo”, 1); // 输出 “bar”kv.get(“foo”, 3); // 输出 “bar” 因为在时间戳 3 和时间戳 2 处没有对应 “foo” 的值，所以唯一的值位于时间戳 1 处（即 “bar”）kv.set(“foo”, “bar2”, 4);kv.get(“foo”, 4); // 输出 “bar2”kv.get(“foo”, 5); // 输出 “bar2” 1234567891011121314151617181920212223class TimeMap &#123; Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map; /** Initialize your data structure here. */ public TimeMap() &#123; map = new HashMap&lt;&gt;(); &#125; public void set(String key, String value, int timestamp) &#123; if(!map.containsKey(key))&#123; map.put(key,new TreeMap&lt;&gt;()); &#125; map.get(key).put(timestamp,value); &#125; public String get(String key, int timestamp) &#123; if(!map.containsKey(key))&#123; return ""; &#125; TreeMap&lt;Integer,String&gt; tree = map.get(key); Integer pre = tree.floorKey(timestamp); return pre== null?"":tree.get(pre); &#125;&#125; 729 Calendar1 时间区间有无重叠1.List&lt;int[]&gt;两个区间是否重叠s1&lt;e2&amp;&amp;e1&gt;s2另一种思考展开代码 1234567891011121314class MyCalendar &#123;List&lt;int[]&gt; calendar;public MyCalendar() &#123; calendar = new ArrayList&lt;&gt;();&#125;public boolean book(int start, int end) &#123; for(int[] it:calendar)&#123; if(it[0]&lt;end&amp;&amp;start&lt;it[1])return false; &#125; calendar.add(new int[]&#123;start,end&#125;); return true;&#125;&#125; 2.维持一个排序的map(红黑树）二分查找，start当key，end当value TreeMap如果不存在，返回小于查询的最大keyfinal Entry&lt;K,V&gt; getFloorEntry(K key)123public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; 如果不存在，返回大于查询的最小key123public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; 只需要查找query start 的floor的end query start 的ceil的start12345678910111213141516class MyCalendar &#123; TreeMap&lt;Integer,Integer&gt; calendar; public MyCalendar() &#123; calendar = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; Integer prev = calendar.floorKey(start); Integer next = calendar.ceilingKey(start); if((prev==null||calendar.get(prev)&lt;=start) &amp;&amp;(next==null||end&lt;=next))&#123; calendar.put(start,end); return true; &#125; return false; &#125;&#125; 731 不三重预定的日历Haversine formula计算经纬度之间的球面距离 布隆过滤器 url去重https://blog.csdn.net/v_july_v/article/details/6685894https://link.springer.com/article/10.1007/s11036-011-0349-8#Sec9 746. Design Tic-Tac-Toe 井字棋380insert/delete O(1)，getRandom O(1)的数据结构123456789101112131415161718192021222324252627282930class RandomSet&#123; Map&lt;Integer,Integer&gt; valIdx; List&lt;Integer&gt; list; Random rand = new Random(); public RandomSet() &#123; valIdx = new HashMap&lt;&gt;(); list = new ArrayList&lt;&gt;(); &#125; public boolean insert(int val)&#123; if(valIdx.containsKey(val))return false; valIdx.put(val,list.size()); list.add(val); return true; &#125; public boolean remove(int val)&#123; if(!valIdx.containsKey(val))return false; int idx = valIdx.get(val); int last = list.get(list.size()-1); //最后一个插到前面 list.set(idx,last); valIdx.put(last,idx); //删除 list.remove(list.size()-1); valIdx.remove(val); return true; &#125; public int getRandom()&#123; return list.get(rand.nextInt(list.size())); &#125;&#125; LFUgohashpoi-gohash http://redisdoc.com/geo/geoadd.htmlredis使用的geohash编码长度为26位。可以精确到0.59m的精度。 将经纬度-&gt;字符串，一个字符串表示一个矩形，可以用字符串前缀匹配查找范围 算法步骤：精确度https://en.wikipedia.org/wiki/Geohashhttps://www.cnblogs.com/LBSer/p/3310455.html 通过对经纬度二分查找不断逼近，将经纬度变成01序列 纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。 用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。 实现：https://github.com/kungfoo/geohash-java编码部分Point:1234public class Point &#123; private final double longitude; private final double latitude;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class GeoHash &#123;private static final char[] base32 = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f','g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' &#125;;private static final int MAX_BIT_PRECISION = 64;protected byte significantBits = 0;protected long bits = 0;//最后+1protected final void addOnBitToEnd() &#123; significantBits++; bits &lt;&lt;= 1; bits = bits | 0x1;&#125;//最后+0protected final void addOffBitToEnd() &#123; significantBits++; bits &lt;&lt;= 1;&#125; //1.获得经纬度交叉的byteprivate GeoHash(double latitude, double longitude, int strlen) &#123; int desiredPrecision = (strlen * 5 &lt;= 60) ? strlen * 5 : 60; point = new Point(latitude, longitude); desiredPrecision = Math.min(desiredPrecision, MAX_BIT_PRECISION); boolean isEvenBit = true; double[] latitudeRange = &#123; -90, 90 &#125;; double[] longitudeRange = &#123; -180, 180 &#125;; //偶数是经度 while (significantBits &lt; desiredPrecision) &#123; if (isEvenBit) &#123; divideRangeEncode(longitude, longitudeRange); &#125; else &#123; divideRangeEncode(latitude, latitudeRange); &#125; isEvenBit = !isEvenBit; &#125; setBoundingBox(this, latitudeRange, longitudeRange); //变成64位 bits &lt;&lt;= (MAX_BIT_PRECISION - desiredPrecision);&#125;private void divideRangeEncode(double value, double[] range) &#123; double mid = (range[0] + range[1]) / 2; if (value &gt;= mid) &#123; addOnBitToEnd(); range[0] = mid; &#125; else &#123; addOffBitToEnd(); range[1] = mid; &#125;&#125; //2. base32编码成String public String toBase32() &#123; if (significantBits % 5 != 0) &#123; throw new IllegalStateException("Cannot convert a geohash to base32 if the precision is not a multiple of 5."); &#125; StringBuilder buf = new StringBuilder(); long firstFiveBitsMask = 0xf800000000000000l; long bitsCopy = bits; int partialChunks = (int) Math.ceil(((double) significantBits / 5)); for (int i = 0; i &lt; partialChunks; i++) &#123; int pointer = (int) ((bitsCopy &amp; firstFiveBitsMask) &gt;&gt;&gt; 59); buf.append(base32[pointer]); bitsCopy &lt;&lt;= 5; &#125; return buf.toString();&#125;&#125; 测试dr4jb0bn21dr373nzzdrf2kjs728301234567GeoHash hash1 = new GeoHash(40.390943,-75.9375,10);GeoHash hash2 = new GeoHash(41.390943,-76.9375,10);GeoHash hash3 = new GeoHash(47.390943,-72.9375,10);System.out.println(hash1.toBase32());assert (hash1.toBase32().equals("dr4jb0bn21")):"不等于dr4jb0bn21";System.out.println(hash2.toBase32());System.out.println(hash3.toBase32()); 加入表示的矩形12345678910111213141516171819202122232425public class BoundingBox &#123; private double minLat; private double maxLat; private double minLon; private double maxLon; public BoundingBox(Point p1, Point p2) &#123; this(p1.getLatitude(), p2.getLatitude(), p1.getLongitude(), p2.getLongitude()); &#125; public BoundingBox(double y1, double y2, double x1, double x2) &#123; minLon = Math.min(x1, x2); maxLon = Math.max(x1, x2); minLat = Math.min(y1, y2); maxLat = Math.max(y1, y2); &#125;public Point getUpperLeft() &#123; return new Point(maxLat, minLon);&#125;public Point getLowerRight() &#123; return new Point(minLat, maxLon);&#125;public String toString() &#123; return getUpperLeft() + " -&gt; " + getLowerRight();&#125;&#125; 构造函数最后加上,利用划分最后的经纬度区间setBoundingBox(this, latitudeRange, longitudeRange);12345private static void setBoundingBox(GeoHash hash, double[] latitudeRange, double[] longitudeRange) &#123; hash.boundingBox = new BoundingBox(new Point(latitudeRange[0], longitudeRange[0]), new Point( latitudeRange[1], longitudeRange[1]));&#125; 查询部分：给定senter和半径，查询 算法正确性：二分法分割空间成01是Peano空间填充曲线。 Peano曲线就是一种四叉树线性编码方式 但是Peano曲线有突变性，0111和1000并不邻近。解决方法是查询时用周围点一起查询。数据库只需要存经纬度，查询字符串之后计算距离。 为什么需要空间索引：http://www.cnblogs.com/LBSer/p/3392491.html矩形过滤 遍历复杂度高1select id,name from poi where lng between 116.3284 and 116.3296 and lat between 39.9682 and 39.9694; 对维度建立索引 遍历复杂度变成Log(N)1alter table lbs add index latindex(lat); B树其实可以对多个字段进行索引，但这时需要指定优先级，形成一个组合字段，而空间数据在各个维度方向上不存在优先级，我们不能说纬度比经度更重要，也不能说纬度比高程更重要。 其他的空间填充曲线Hilbert最好12345678 0 3 4 5 58 59 60 63 1 2 7 6 57 56 61 62 14 13 8 9 54 55 50 49 15 12 11 10 53 52 51 48 16 17 30 31 32 33 46 47 19 18 29 28 35 34 45 44 20 23 24 27 36 39 40 43 21 22 25 26 37 38 41 42 索引线、折线或者多边形R-tree 弹幕系统一个直播间：在线人数100万1000条弹幕/秒推送频率：100万*1000条/秒 = 10亿/秒 拉模式：客户端轮询服务端推模式：长连接 立即推送（时效性）websocket 将message-&gt;frame go语言携程模型 自带websocket库 604. Design Compressed String Iteratorhttps://leetcode.com/articles/desing-compressed-string-iterator/ 不需要预处理的O(1)：12345678910111213int p=0;int num=0;char next()&#123; if(!hasNext)return ' '; char ch = s.charAt(p++); while(p&lt;res.length&amp;&amp;Character.isDigit(s.charAt(p))) num = num*10+res.charAt(p++)-'0'; num--; return ch;&#125;boolean hasNext()&#123; return p!=s.length()||num!=0;&#125; 时间空间复杂度O(n) 压缩编码的长度n L1e2t1C1o1d1e1-&gt;[1, 2, 1, 1, 1, 1, 1]-&gt;[L, e, t, C, o, d, e] 12int[] nums = Arrays.stream(cmprs.substring(1).split("[a-zA-z]")).mapToInt(Integer::parseInt).toArray();String[] chars = cmprs.split("[0-9]+"); next,hasNext 展开代码 12345678910111213int p=0;public char next() &#123; if(!hasNext())&#123; return ' '; &#125; nums[p]--; char out = chars[p].charAt(0); if(nums[p]==0)p++; return out;&#125;public boolean hasNext() &#123; return p!=chars.length;&#125; 535 短链接Base62 编码是由 10 个数字 26 个大些英文字母和 26 个小写英文字母组成base63(md5(str))[6:]功能要求：1.过期时间，用户能延长过期时间2.自定义短链接 非功能要求：1.系统高可用2.重定向的延迟3.连接地址不可预测 扩展：1.重定向多少次2.REST api]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2018%2F07%2F22%2Fnodejs%2F</url>
    <content type="text"><![CDATA[CommonJS nodejs的模块规范https://morning.work/page/nodejs/ready-to-async-await.htmlglobal对象和process对象一个文件是一个模块使用requirejs需要自己写包裹函数，nodejs省了这一步 node --inspect-brk learn_path.jschrome打开chrome://inspect/#devices12(function (exports, require, module, __filename, __dirname) &#123; &#125;); exports是对外提供的接口/属性require依赖别的模块module是模块本身里export属性]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2018%2F07%2F20%2Fsvg%2F</url>
    <content type="text"><![CDATA[基本图形&lt;elipse&gt;椭圆，cx,cy是圆心&lt;polyline&gt;标签中间用ponits=”x1 y1 x2 y2 x3 y3” 同理&lt;polygon&gt;svg画一个三角形123456789&lt;svg&gt;&lt;polyline points="250 120 300 220 200 220" stroke="red" fill="none"&gt;&lt;/polyline&gt;&lt;/svg&gt; fill填充颜色stroke描边颜色stroke-width描边粗细transform 操作api：做一个svg编辑器html5中inut的type：color调色盘，range进度条1.创建svg标签并设置svg标签属性，挂载到dom树123456789//命名空间function createSVG()&#123; var SVG_NS = 'http://www.w3.org/2000/svg'; var svg = document.createElementNS(SVG_NS, 'svg'); svg.setAttribute('width', '100%'); svg.setAttribute('height', '100%'); _svg.appendChild(svg); return svg&#125;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[dockermysql]]></title>
    <url>%2F2018%2F07%2F05%2Fdockermysql%2F</url>
    <content type="text"><![CDATA[docker imagelinux 内核空间bootfs是共享的用户空间是各种Linux发行版base image是root filesystem (文件和meta data )各种image是分层共享layer的 制作docker当前目录下有可执行文件 hello(编译过的c程序) 写成dockerfiledocker build -t tag/imagename .docker history imageid 可以看到有几层docker run tag/imagename 可以执行1234# docker history 4ab4c602aa5eIMAGE CREATED CREATED BY SIZE COMMENT4ab4c602aa5e 7 weeks ago /bin/sh -c #(nop) CMD ["/hello"] 0 B &lt;missing&gt; 7 weeks ago /bin/sh -c #(nop) COPY file:9824c33ef192ac... 1.84 kB docker containerimage负责app的存储和分发，container负责运行appimage是只读的，在image层上加一层可读可写的container层docker container ls -adocker 交互式启动docker run --help12-i, --interactive Keep STDIN open even if not attached-t, --tty Allocate a pseudo-TTY docker run -it centos12345# docker run -it centos[root@34907a1273a5 /]# ll[root@34907a1273a5 /]# lsanaconda-post.log dev home lib64 mnt proc run srv tmp varbin etc lib media opt root sbin sys usr 可读可写可以yum 删除所有推出的容器docker container ls -f &quot;status=exited&quot; 1234567891011# docker container ls -f "status=exited" -q34907a1273a5f3376a912f8d9759ac9c6bc0995ed8e570c33bec7207f63cbce594d32ceed7b03af091d8202c2c3b05f2ac00bb899d07# docker rm $(docker container ls -f "status=exited" -q) 12345678910111213141516171819# docker container ls --helpUsage: docker container ls [OPTIONS]List containersAliases: ls, ps, listOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template --help Print usage -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes docker container commit在container修改过的image 保存成image123456789101112# docker commit --helpUsage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container's changesOptions: -a, --author string Author (e.g., "John Hannibal Smith &lt;hannibal@a-team.com&gt;") -c, --change list Apply Dockerfile instruction to the created image (default []) --help Print usage -m, --message string Commit message -p, --pause Pause container during commit (default true) 新创建的是da62538702f3 就多加了一层加了5B1234567891011docker history da62538702f3IMAGE CREATED CREATED BY SIZE COMMENTda62538702f3 About a minute ago /bin/bash 5 B 75835a67d134 3 weeks ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0 B &lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL org.label-schema.... 0 B &lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:fbe9badfd2790f0... 200 MB [root@localhost ~]# docker history 75835a67d134IMAGE CREATED CREATED BY SIZE COMMENT75835a67d134 3 weeks ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0 B &lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) LABEL org.label-schema.... 0 B &lt;missing&gt; 3 weeks ago /bin/sh -c #(nop) ADD file:fbe9badfd2790f0... 200 MB dockerFile 语法参考https://github.com/docker-library/mysqlFROM 选择官方image作为base imageLABEL 作者，版本，描述RUN 每写一条RUN都会添加新的一层，所以多条命令用反斜杠换行WORKDIR 自动创建目录 不要使用RUN cd 使用绝对路径ADD COPY 将本地文件添加到镜像中，add 一个压缩文件还直接解压RUN curl wget 添加远程文件EXPOSE 将容器内服务运行的5000端口暴露出去，不然127.0.0.1外部访问不到ENV 设置常量 RUN CMD ENTRYPOINTCMD 容器启动后默认执行的命令和参数ENTRYPOINT 容器启动时的命令 不会被忽略一定会执行最佳实践，写一个shENTRYPOINT [&quot;docker-entrypoint.sh&quot;]让容器以应用程序或服务的形式运行 搭建私库12docker run -d -p 5000:5000 --restart always --name registry registry:2docker container ls -a 重新build image tag 变成仓库ip+端口12ls /etc/dockervi /lib/systemd/system/docker.service docker 网络CentOS7 安装mysql1.下载mysql源1234567891011yum install wgetwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmcd /etc/yum.repos.d/llyum install mysql-serversystemctl enable mysqldmysql -u rootchown -R root:root /var/lib/mysqlservice mysqld restartmysql -u root 改密码1234use mysql;# 一定要引号update user set password=password("root") where user="root";exit; 用windows连接虚拟机mysql配置12345678910bind-address =service mysql restart# ！打开防火墙firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reloadfirewall-cmd --list-portsps aux|grep mysqlnetstat -plntu# tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 15323/mysqld 给外部ip权限1234vi /etc/my.cnf# 强行加上[mysqld]bind-address = 0.0.0.0 给任何ip过来的root用户 密码（identified）为root的，可以访问所有表12grant all privileges on *.* to "root"@"%" identified by "root" with grant option;flush privileges; 可以连接并创建表了，注意字符集将centos上的数据库转移到win：front中-其他-转移 redis 高速缓存集群解除docker集群 docker swarm leave -f查看docker内的网络docker network ls 拉镜像docker pull yyyyttttwwww/redis创建容器docker run -it -d --name r1 -p5000:6379 --net=net2 --ip 172.19.0.2 redis bash进入容器docker exec -it r1 bash修改redis配置文件/usr/redis/redis.conf docker mysql集群PXC防火墙? 拉镜像 12docker pull percona/percona-xtradb-clusterdocker load &lt;pxc.tar.gz 改名 123docker imagesdocker tag docker.io/precona/percona-xtradb-cluster pxcdocker rmi docker.io/precona/percona-xtradb-cluster 创建容器要先划分Docker内部网段 docker自带的是172.17.0.x 123docker network create net1 / docker network create --subnet=172.18.0.0/24 net1docker network insepct net1docker network rm net1 业务数据映射到宿主机，pxc不能直接用目录映射要用docker卷 123docker volume create v1docer inspect v1 #//var/lib/docker/volumes/v1/_datadocker volume rm v1 创建pxc容器 -d 后台运行 -t 交互界面 -p 端口映射 -v 路径映射 -e 启动参数 XTRABACKUP_PASSWORD=abc123456 数据库同步用的密码 --preivileged 最高权限 --ip 内部网段中分到的ip地址 注意：容器创建很快，但是mysql初始化可能要2min以上，能连接到一个后再创建第二个 123456789docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxcdocker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxcdocker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxcdocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc 6.用navicat连接5个数据库在db1create schema test1; 刷新，其他节点也更新了。 负载均衡 Haproxy请求转发器nginx 支持http协议负载均衡，最近才支持TCP/IPhaproxy配置 docker pull haproxy 在宿主机创建配置文件mkdir /home/soft/haproxy/touch /home/soft/haproxy/haproxy.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657global #工作目录 chroot /usr/local/etc/haproxy #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info log 127.0.0.1 local5 info #守护进程运行 daemondefaults log global mode http #日志格式 option httplog #日志中不记录负载均衡的心跳检测记录 option dontlognull #连接超时（毫秒） timeout connect 5000 #客户端超时（毫秒） timeout client 50000 #服务器超时（毫秒） timeout server 50000#监控界面 listen admin_stats #监控界面的访问的IP和端口 bind 0.0.0.0:8888 #访问协议 mode http #URI相对地址 stats uri /dbs #统计报告格式 stats realm Global\ statistics #登陆帐户信息 stats auth admin:abc123456#数据库负载均衡listen proxy-mysql #访问的IP和端口 bind 0.0.0.0:3306 #网络协议 mode tcp #负载均衡算法（轮询算法） #轮询算法：roundrobin #权重算法：static-rr #最少连接算法：leastconn #请求源IP算法：source balance roundrobin #日志格式 option tcplog #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测 option mysql-check user haproxy server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000 server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000 server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 server MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000 server MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000 #使用keepalive检测死链 option tcpka bind 0.0.0.0:3306 表示任何ip地址都可以访问3306端口如果有应用向3306端口发数据库请求，会被转发给具体的pxc数据库实例 haroxy 端口3306 映射到宿主机4002 ，后台监控8888映射到4001可以手动分配haroxy的ip地址，docker也会自动分配 123docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 haproxy 进入容器 12docker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg 在mysql创建haproxy用户 haproxy中间件用这个账号登陆数据库，发心跳检测%表示ip都可以用这个账号登陆mysql数据库 密码为空 1create user 'haproxy'@'%' identified by ''; 登陆 http://192.168.3.109:4001/dbs 看监控画面docker stop node1可以看到MySQL_1变红色用navicat连接haproxy192.168.3.109:4002 root:abc123456向haproxy使用的sql都会均匀分发给真实的mysql实例，然后同步 haproxy双机热备 虚拟ip linux一个网卡可以定义多个ip地址，可以把ip地址分配给对应的程序在两个haproxy容器中部署keepalived抢占一个虚拟ip172.18.0.15,抢到的叫主服务器，没抢到的叫备服务器，有心跳检测，检测到主服务器挂了就抢占ip)1.1. 进入容器docker exec -it h1 bashharpoxy是用Ubuntu创建的 所以要用apt-getapt-get update #可能要换源 安装vim 不是viapt-get install keepalived 1.2. keepalived配置文件/etc/keepalived/keepalived.confstate:MASTER/BACKUP为主/备服务器 抢占虚拟IP,备用不会抢。都master都抢占，没抢到的自动变成salveinterface:虚拟ip写到docker的网卡里,eth0局域网里看不见的，后续虚拟ip映射到局域网的虚拟ipvirtual_router_id：0-255之间 虚拟路由ippriority 权重，优先抢占advert_int:心跳检测间隔authentication 心跳检测的账号密码virtual_ipaddress 虚拟ip 1234567891011121314vrrp_instance VI_1 &#123; state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 123456 &#125; virtual_ipaddress &#123; 172.18.0.201 &#125;&#125; 启动keepalived:service keepalived startexit宿主机 ping 172.18.0.201 在宿主机安装keepalived把宿主机ip映射到docker的虚拟ip 展开代码 1234567891011121314151617181920212223242526272829303132333435363738vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.99.150 &#125;&#125;virtual_server 192.168.99.150 8888 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 8888 &#123; weight 1 &#125;&#125;virtual_server 192.168.99.150 3306 &#123; delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 3306 &#123; weight 1 &#125;&#125; 数据库热备份冷备份mysql dump热备份LVM要锁表 XtraBackup不锁表docker stop/rm node1docker volume create backup 1234docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged -e CLUSTER_JOIN=node2 --name=node1 --net=net1 --ip 172.18.0.2 pxc 全量备份 在PXC容器中安装XtraBackup 1234567docker exec -it --user root node1 bashapt-get updateapt-get install percona-xtrabackup-24innobackupex --user=root --password=abc123456 /data/backup/full#备份在/data/backup/full/2018-07-05_04-54-31/xtrabackup_infoexitdocker inspect backup 恢复 冷还原 1解散PXC集群，2删除节点，3创建新的节点并还原，4创建其他节点，并同步 重建集群 12345678910111213141516171819docker stop node1 node2 node3 node4 node5docker rm node1 node2 node3 node4 node5docker volume rm v1 v2 v3 v4 v5docker volume create v1docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxcdocker exec -it node1 bashrm -rf /var/lib/mysql/*innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-07-05_04-54-31innobackupex --user=root --password=abc123456 --copy-back /data/backup/full/2018-07-05_04-54-31exitdocker stop node1docker start node1]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8]]></title>
    <url>%2F2018%2F06%2F06%2Fjava8%2F</url>
    <content type="text"><![CDATA[JDK9 Reactive Streamjava.timeOptional创建： of工厂方法Optional.of(&quot;abb&quot;); ofNullable:如果为空返回empty()空的optionalOptional.ofNullable(&quot;abb&quot;); .empty() isPresent.. 其它库Guava，Apache Commons Collections ,ambdaj Collector.java接口提供者 the type of input elements to the reduction operation the mutable accumulation type of the reduction operation (often hidden as an implementation detail) the result type of the reduction operation 1234567891011public interface Collector&lt;T, A, R&gt; &#123; //container容器 Supplier&lt;A&gt; supplier(); //操作 BiConsumer&lt;A, T&gt; accumulator(); //并行计算 BinaryOperator&lt;A&gt; combiner(); //返回结果 Function&lt;A, R&gt; finisher(); Set&lt;Characteristics&gt; characteristics();&#125; toList()123456public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123; return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; &#123; left.addAll(right); return left; &#125;, CH_ID);&#125; 1.CH_ID:12static final Set&lt;Collector.Characteristics&gt; CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); 2.Set characteristics();Collecter的特征1234567enum Characteristics &#123;//可以并行处理 CONCURRENT,//一般true 是否保持原来的顺序 UNORDERED, IDENTITY_FINISH&#125; stream().collect()12345678910111213141516public final &lt;R, A&gt; R collect(Collector&lt;? super P_OUT, A, R&gt; collector) &#123; A container; if (isParallel() &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT)) &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123; container = collector.supplier().get(); BiConsumer&lt;A, ? super P_OUT&gt; accumulator = collector.accumulator(); forEach(u -&gt; accumulator.accept(container, u)); &#125; else &#123; container = evaluate(ReduceOps.makeRef(collector)); &#125; return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH) ? (R) container : collector.finisher().apply(container);&#125; .Collectors1..groupingBy(Apple::getColor))1Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType)); 2.计算平均数averaging[Int/Long/Double]都返回&lt;T&gt; Collector&lt;T, ?, Double&gt;1Optional.ofNullable(menu.stream().collect(Collectors.averagingInt(Dish::getCalories))).ifPresent(System.out::println); 3..collectingAndThen附加返回值1Optional.ofNullable(menu.stream().collect(Collectors.collectingAndThen(Collectors.averagingInt(Dish::getCalories),a-&gt;"The ave"+a))).ifPresent(System.out::println); 变成不可变对象1List&lt;Dish&gt; collect = menu.stream().filter(d -&gt; d.getType().equals(Dish.Type.MEAT)).collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)); 4.计数12Optional.of(menu.stream().collect(Collectors.counting())).ifPresent(System.out::println);Optional.ofNullable(menu.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.counting()))).ifPresent(System.out::println); 5.转化成TreeMap1TreeMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingBy(Dish::getType, TreeMap::new, Collectors.averagingInt(Dish::getCalories))); 6.Summary12345public class IntSummaryStatistics implements IntConsumer &#123; private long count; private long sum; private int min = Integer.MAX_VALUE; private int max = Integer.MIN_VALUE;&#125; 1IntSummaryStatistics collect = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories)); 7.groupingByConcurrent1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); 8.Collector&lt;CharSequence, ?, String&gt; joining()前面必须是CharSequence类型,join中还可添加delimiter分隔符1String collect = menu.stream().map(Dish::getName).collect(Collectors.joining(",")); 前后加上分隔符joining(“,”,”Names[“,”]”)输出：Names[pork,…,salmon] 另一种mapping方法IDEA会提示可以使用map().collect()1.collect(Collectors.mapping(Dish::getName, Collectors.joining(","))) 9.maxBy/minBy获得卡路里最高的1Optional&lt;Dish&gt; collect = menu.stream().collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories))); 10.partitioningBy1Map&lt;Boolean, List&lt;Dish&gt;&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian)); 输出是/不是水果的卡路里平均值{false=530.0, true=387.5}12Map&lt;Boolean, Double&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian, Collectors.averagingDouble(Dish::getCalories))); Optional.ofNullable(collect).ifPresent(System.out::println); 11 .reducing 可以加入map 相当于map(::).reduce(0,(,)-&gt;)1Integer collect = menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (d1, d2) -&gt; d1 + d2)); 12 .summingDdouble1Double collect = menu.stream().collect(Collectors.summingDouble(Dish::getCalories)); 13 .toCollection(LinkedList::new)123Optional.ofNullable(menu.stream().collect(Collectors.toCollection(LinkedList::new))).ifPresent(System.out::println);//可以变成Optional.ofNullable(new LinkedList&lt;&gt;(menu)).ifPresent(System.out::println); lambdaexecute around 环绕执行模式泛型限制public static &lt;T&gt; List filter(List, Predicate p) lambda访问lambda主体中的引用（实例变量，静态变量） 在堆中外层变量 在栈中 局部变量是final的，访问的是原始变量的副本。 12345678910111213list.sort(Comparator.comparing(Integer::intValue));public interface Comparator&lt;T&gt; &#123; public static &lt;T, U&gt; Comparator&lt;T&gt; comparing( Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)&#123; Objects.requireNonNull(keyExtractor); Objects.requireNonNull(keyComparator); return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1), keyExtractor.apply(c2));&#125;&#125; 比较器链1list.sort(Comparator.comparing(Integer::intValue).reversed().thenComparing(Integer::byteValue)); 泛型数组 需要知道类型(Item item)1arr.sort(Comparator.comparing((Item item )-&gt; item.value / item.weight).reversed()); 谓词复合.negate(),.and(),.or()函数符合1.andThen12345//g(f(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.andThen(g);int result = h.apply(1);//4 2.compose12345//f(g(x))Function&lt;Integer,Integer&gt; f = x-&gt;x+1;Function&lt;Integer,Integer&gt; g = x-&gt;x*2;Function&lt;Integer,Integer&gt; h = f.compose(g);int result = h.apply(1);//3 3.创建流水线123456789class Letter&#123; String addHeader(String text)&#123;return "From:";&#125; String addFooter(String text)&#123;return "Kind regards";&#125; String checkSpelling(String text)&#123;return text.replaceAll("labda","lambda");&#125;&#125;Fucntion&lt;String,String&gt; addHeader = Letter::addHeader;Fucntion&lt;String,String&gt; pipeline = addHeader. addThen(Letter::checkSpelling). addThen(Letter::addFooter); 闭包：函数的实例，可以无限制地访问函数的非本地变量。lambda作闭包不能修改局部变量内容，lambda在新线程运行。会造成线程不安全。栈在线程之间不共享，堆在线程间共享。 Stream 高级迭代器pipelining 流水线式操作，方法返回一个流，可以链式操作Collection.java根据核数划分123default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125; 查看线程：jconsoleFinalizer是垃圾回收器的线程测试代码：展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Arrays;import java.util.Comparator;import java.util.List;import static java.util.stream.Collectors.toList;class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public enum Type &#123; MEAT, FISH, OTHER &#125;&#125;public class streamm &#123; private static List&lt;String&gt; byStream(List&lt;Dish&gt; menu)&#123; return menu.parallelStream().filter(d-&gt;&#123; try&#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return d.getCalories()&lt;400; &#125;).sorted(Comparator.comparing(Dish::getCalories)).map(Dish::getName).collect(toList()); &#125; public static void main(String[] args) &#123; List&lt;Dish&gt; menu = Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT), new Dish("beef", false, 700, Dish.Type.MEAT), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHER), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHER), new Dish("pizza", true, 550, Dish.Type.OTHER), new Dish("prawns", false, 300, Dish.Type.FISH), new Dish("salmon", false, 450, Dish.Type.FISH) ); List&lt;String&gt; dishNamesByStream = byStream(menu); System.out.println(dishNamesByStream); &#125;&#125; 线程：多了3个ForkJoinPool.commonPool-worker-1/2/3 intermediate 中间方法1.Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);:intermediate将流删选减少数量 1str.filter((s)-&gt;s.length()&gt;4).forEach(System.out::println); 2.&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 投影：映射成数量相同的另一个新流 1str.map(s -&gt; s.toUpperCase()).forEach(System.out::print); IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); 产生一个intStreamStream&lt;T&gt; limit(long maxSize); :intermediate 删掉后面 terminal的void forEach(Consumer&lt;? super T&gt; action); : terminal的void forEachOrdered(Consumer&lt;? super T&gt; action); :terminal&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator); :terminalOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); :terminalboolean anyMatch(Predicate&lt;? super T&gt; predicate); :terminal求和，最大值Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);)12Optional&lt;String&gt; opt = str.reduce((s1,s2)-&gt;s1+s2)String res = opt.get(); 静态方法builder,of,empty of 12Stream&lt;String&gt;str = Stream.of("good","study","good");str.forEach((strr)-&gt; System.out.println(strr)); 合并两个Stream 123public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values); &#125; 其它操作去重distinct1str.distinct().forEach(System.out::print); 创建流Collection可以创建流通过文件创建123456789101112private static Stream&lt;String&gt; createStream()&#123; Path path = Paths.get("./src/java8/aaa"); try(Stream&lt;String&gt; lines = Files.lines(path)) &#123; lines.forEach(System.out::print); return lines; &#125; catch (IOException e) &#123; throw new RuntimeException(); &#125;&#125;public static void main(String[] args) &#123; Stream&lt;String&gt; s = createStream();&#125; 无限流123456private static Stream&lt;Integer&gt; createfromiterator()&#123; Stream&lt;Integer&gt; stream = Stream.iterate(0,n-&gt;n+2).limit(100); return stream;&#125;createfromiterator().forEach(System.out::println);//输出0，2，..198 无限随机数1234private static Stream&lt;Double&gt; fromgenerate()&#123; return Stream.generate(Math::random);&#125;fromgenerate().forEach(System.out::println); fib:123Stream.iterate(new int[]&#123;0,1&#125;, t-&gt;new int[]&#123;t[1],t[0]+t[1]&#125;) .limit(20).map(t-&gt;t[0]) .forEach(System.out::print); 扁平化flatMap两个集合一起12Stream&lt;List&lt;Integer&gt;&gt; ss=Stream.of(Arrays.asList(1,2,3),Arrays.asList(4,5));ss.flatMap(list-&gt;list.stream()).forEach(System.out::print); 1234String[] words = &#123;"hello","word"&#125;;//&#123;h,e,l,l,o&#125;,&#123;w,o,r,l,d&#125;Stream&lt;String[]&gt; stream = Arrays.stream(words).map(w-&gt;w.split(""));Stream&lt;String&gt; stringStream = stream.flatMap(Arrays::stream); {1,2,3},{3,4}-&gt;{[1,3],[1,4]…[3,4]}123456List&lt;Integer&gt; numbers1 = Arrays.asList(1,2,3);List&lt;Integer&gt; numbers2 = Arrays.asList(3,4);List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream().map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList());pairs.forEach(ints -&gt; &#123; System.out.println(Arrays.toString(ints));&#125;); 只返回[2,4],[3,3]加起来是%3=0123List&lt;int[]&gt; pairs = numbers1.stream().flatMap(i-&gt;numbers2.stream() .filter(j-&gt;(i+j)%3==0) .map(j-&gt;new int[]&#123;i,j&#125;)).collect(Collectors.toList()); 查找匹配allMatchfind：12Optional&lt;Integer&gt; first = stream.filter(i -&gt; i % 2 == 0).findFirst();int sum = intStream.filter(i -&gt; i &gt; 3).sum(); reduce:.reduce(Integer::max)拆箱：节省内存mapToInt:IntStream intStream = stream.mapToInt(i -&gt; i.intValue());1234@FunctionalInterfacepublic interface ToIntFunction&lt;T&gt; &#123; int applyAsInt(T value);&#125; 装箱：.boxed(),.mapToObj()给一个数a求1-100里找一个数可以与a勾股定理sqrt(a^2+b^2)%1=0（sqrt后不带小数）.rangeClose(start,end)生成start-end中的所有数字range(1,100)是开区间 不包括结束值12345int a =9;IntStream.rangeClosed(1, 100).filter(b -&gt; Math.sqrt(a * a + b * b) % 1 == 0) .boxed()//IntStream的map只能每个元素返回另一个int 应该流中每个元素是数组（onj） .map(x -&gt; new int[]&#123;a, x, (int) Math.sqrt(x * x + a * a)&#125;) .forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); a也需要自动生成123456789Stream&lt;int[]&gt; stream1 = IntStream.rangeClosed(1, 100) .boxed() //把三元流扁平成一个流 //第二个值生成的range从第一个数c开始，去重复(3,4,5)(4,3,5) .flatMap(c -&gt; IntStream.rangeClosed(c, 100) .filter(b -&gt; Math.sqrt(c * c + b * b) % 1 == 0) //创建了三元流 .mapToObj(b -&gt; new int[]&#123;a, b, (int) Math.sqrt(a * a + b * b)&#125;));stream1.forEach(r-&gt; System.out.println("a="+r[0]+",b="+r[1]+",c"+r[2])); 更紧凑的做法 只计算一次sqrt1234IntStream.rangeClosed(1,100).boxed().flatMap(a-&gt; IntStream.rangeClosed(a,100).mapToObj( b-&gt;new double[]&#123;a,b,Math.sqrt(a*a+b*b)&#125;) .filter(t-&gt;t[2]%1==0)); 拼接字符串效率不高，每次迭代都要新建String对象reduce可以设置初始值1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .reduce("", (n1, n2) -&gt; n1 + n2); 使用joining，内部用到StringBuilder1234String reduce = tras.stream() .map(tra -&gt; tra.getTrader().getName()) .distinct().sorted() .collect(joining()); 找最大值最小值.stream().min(comparing(Transaction::getValue));]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[netty和网络]]></title>
    <url>%2F2018%2F06%2F04%2Fnetty%2F</url>
    <content type="text"><![CDATA[系统通过一个四元组来唯一标识一条TCP连接. 这个四元组的结构是{local_ip, local_port, remote_ip, remote_port}, 对于IPv4, 系统理论上最多可以管理2^(32+16+32+16), 2的96次方个连接. 因为对于同一台服务器来说, 一般只有一个 local_ip, 那么, 同一台服务器可以管理 2^(16+32+16) 个连接. 而一个服务(进程, 如 Nginx 进程)一般只监听一个 local_port, 那么, 同一台服务就可以管理 2^(32+16) 个连接. 而如果从一台远端机器(所谓的 client)来连接这台服务器上的一个服务, 那么 local_ip, local_port, remote_ip 这3个变量是固定的, 那么, 就只能建立 2^16=65536 个连接了. 这就是经典的误解的来源! 一个IP报文，在网络上传输，原地址和目的地址会变吗？如果目的地址经路由表对比，发现不是在本网中，nat将改变源地址的IP改为路由器的IP地址 路由收敛：网络设备的路由表与网络拓扑结构保持一致。RIP，坏消息传得慢，如果有一个节点到达不了，会互相更新路由表直到不能再增加跳数。 设有2条路由21.1.193.0/24和21.1.194.0/24，如果进行路由汇聚，汇聚这两条路由的地址是（）正确答案: C 你的答案: D (错误)21.1.200.0/2221.1.192.0/2321.1.192.0/2121.2.224.0/20 PCI + SDU = PDU 表示层：通信协议语法和语义处理。数据格式变换、加密解密、压缩与恢复。 会话层：向表示层的进程提供建立连接，并在连接上有序地传输数据。会话：建立同步（SYN）作用：1.建立、管理、终止会话2.使用校验点通信失效的时候从校验点/同步点恢复通信。适用于传大文件。 传输层：进程通信。传输单位是报文段或用户数据包。作用：1可靠/不可靠传输2.差错控制3流量控制 4 复用分用复用：多个应用进程使用端口号区分可以同时使用下面层的服务。分用：分别交付给上层应用。 网络层：分组交换。1.路由选择2流量控制（针对发送方）3充错控制4拥塞控制（全局） 物理层信道是有方向的，双工 半双工都需要两条信道 码元、传输速率（主机内的）、波特（码元/s)、带宽(理想值 主机内的) 大端小端已知IBM的PowerPC是big-endian字节序列而Intel的X86是little-endian字节序，如果在地址啊存储的整形值时0x04030201，那么地址为a+3的字节内存储的值在PowerPC和Intel X86结构下的值分别是？A1 41 34 13 14 41 1 Big-endian：将高序字节存储在起始地址（高位编址）12345低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| byte[0]=12 | 34 | 56 | 78 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Little-endian：将低序字节存储在起始地址（低位编址）12345低地址 高地址----------------------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| byte[0]=78 | 56 | 34 | 12 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ epoll和select关于linux的I/O复用接口select和epoll,下列说法错误的是( C )A select调用时会进行线性遍历,epoll采用回调函数机制,不需要线性遍历B select的最大连接数为FD_SETSIZEC select较适合于有大量并发连接,且活跃链接较多的场景D epoll较适用于有大量并发连接，但活跃连接不多的场景E epoll的效率不随FD数目增加而线性下降F epoll通过共享存储实现内核和用户的数据交互 TCP 2个序号，3个标志位seq：数据序号。ack：接收端希望接收的下一个数据包的起始序号。ACK :确认位，表示ack序号有用。所以第一次请求没有要确认的数据ACK0SYN :同步位。建立连接的时候没有数据，则SYN=1将ack设为seq+1FIN :终止位。 DDOS SYN Flood 大量请求发出第一次握手之后不发出第三次，让服务器一直重发。 同一网段的主机ip与10.110.12.29 mask 255.255.255.224属于同一网段的主机IP地址是?主机号全1的是广播地址。 224 -&gt;1110000029 -&gt;00011101范围为10.110.12.1~ 10.110.12.31A错10.110.12.0B正确10.110.12.30C广播地址10.110.12.31D错10.110.12.32 自治：无主从关系边缘部分：端系统核心部分：路由器 链路带宽： 主机发送数据的速率传播速率: 2 x 10^8 200m / us吞吐量： 单位时间内 通过 信道，接口的数据量 （小于带宽）时延：发送（传输）/传播/排队/处理时延带宽积(BDP) (缓冲区大小）bit:某段链路现在有多少bit 传播时延RTT(s) x 带宽利用率：有数据通过的时间 select模型 一个进程打开fd（文件描述符）有限1024/2048？ （最大并发数）FD_SETSIZE 在哪 每次select调用会扫描所有fd 内核拷贝fd的消息到用户空间 epollhttps://segmentfault.com/a/1190000003063859https://www.cnblogs.com/xiehongfeng100/p/4636118.html最大打开的文件数量（并发量）cat /proc/sys/fs/file-max mui文档http://dev.dcloud.net.cn/mui/util/http://www.html5plus.org/doc/zh_cn/webview.html 阻塞与非阻塞是线程访问资源是否就绪的一种处理方式同步和异步 数据访问的机制 数据处理完毕后会通知线程 同步阻塞BIO一个线程一个连接，用线程池 伪异步io NIO 同步非阻塞IO一个server一个selector多路复用器，是一个单线程，client注册到selector，每个client创建一个channel（双向通道），数据读写都会到缓冲区buffer，非堵塞地读取buffer客户端增加不会影响selector性能 同步表示要Selector主动轮询channel数据准备好没有异步是等人通知 AIO 异步非阻塞IO NIO2.0在NIO原有基础上，读写的返回类型是Feature对象，Feature有事件监听,等待通知回调 Netty三种线程模型Reactor线程模型 单线程模型 一个NIO线程处理所有请求 多线程模型，一组NIO县城处理IO操作，reactor线程池 主从线程模型，两个线程池，一组用于接收请求，一组用于处理IO HTTP服务器主从模型1234567891011121314151617181920212223public class HelloServer &#123; public static void main(String[] args) throws InterruptedException &#123; //主线程组 EventLoopGroup parentGroup = new NioEventLoopGroup(); //从线程组 EventLoopGroup childGroup = new NioEventLoopGroup(); //启动类 try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); //设置主从线程组和双向通道和child的处理器 serverBootstrap.group(parentGroup, childGroup) .channel(NioServerSocketChannel.class) .childHandler(new HelloServerInitializer()); //启动server 同步方式 ChannelFuture channelFuture = serverBootstrap.bind(8088).sync(); //监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; parentGroup.shutdownGracefully(); childGroup.shutdownGracefully(); &#125; &#125;&#125; 初始化child线程的处理器pipLine123456789public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt;&#123; @Override protected void initChannel(SocketChannel channel) throws Exception &#123; //获得管道 ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast("HttpServerCodec",new HttpServerCodec()); pipeline.addLast("customHandler",new CustomHandler()); &#125;&#125; 添加自定义的http处理拦截123456789101112131415161718192021222324252627//入站拦截public class CustomHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; //从上下文对象里获得当前channel System.out.println(msg.toString()); System.out.println("--------------"); Channel channel = ctx.channel(); //发送了两次，因为有个图标的请求 //没加路由，所有所有访问8088的请求都会被拦截 if(msg instanceof HttpRequest)&#123; //远程地址 System.out.println(channel.remoteAddress()); //消息big-endian buffer ByteBuf content = Unpooled.copiedBuffer("hello netty", CharsetUtil.UTF_8); //Connection: keep-alive 1.1默认开启 FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,content); //数据类型 response.headers().set(HttpHeaderNames.CONTENT_TYPE,"text/plain"); //长度bytes response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes()); //写到缓冲区再刷到客户端 ctx.writeAndFlush(response); &#125; &#125;&#125; 测试curl 192.168.3.100:80881234567891011--------------DefaultHttpRequest(decodeResult: success, version: HTTP/1.1)GET / HTTP/1.1User-Agent: curl/7.29.0Host: 192.168.3.100:8088Accept: */*--------------/192.168.3.109:58586--------------EmptyLastHttpContent-------------- 生命周期 curl每次发送完会关闭 没有长链接重写SimpleChannelInboundHandler的方法12345678910111213141516171819handlerAddedchannelRegisteredchannelActive--------------DefaultHttpRequest(decodeResult: success, version: HTTP/1.1)GET / HTTP/1.1User-Agent: curl/7.29.0Host: 192.168.3.100:8088Accept: */*--------------/192.168.3.109:58588--------------EmptyLastHttpContent--------------channelReadCompletechannelReadCompletechannelInactivechannelUnregisteredhandlerRemoved 实时通信ajax轮询、Long pull、websocket 零拷贝java读文件:io流-&gt;缓冲区-&gt;java堆netty NIO直接开辟新的堆内存 从io流直接到堆 实现一个简单的协议1.客户端request请求协议12345678public class Request &#123; //编码 private byte encode; //指令 private String command; //命令长度 private int commandLength;&#125; 2.服务器response响应123456public class Response &#123; private byte encode; private int responseLength; //响应内容 private String response;&#125; 3.Server:1234567891011121314151617181920212223ServerSocket server = new ServerSocket(4567);while(true)&#123; Socket client = server.accept(); //客户端数据通过协议解码Request InputStream input = client.getInputStream(); Request request = ProtocolUtil.readRequest(input); OutputStream output = client.getOutputStream(); //封装response,根据客户端请求回应hello或者再见 Response response = new Response(); response.setEncode(Encode.UTF8.getValue()); if(request.getCommand().equals("HELLO"))&#123; response.setResponse("hello!"); &#125;else&#123; response.setResponse("bye bye!"); &#125; response.setResponseLength(response.getResponse().length()); //通过协议发送 ProtocolUtil.writeResponse(output, response); client.shutdownOutput();&#125; 4.编码类1字节长度：12345678910111213public enum Encode &#123; GBK((byte)0), UTF8((byte)1); private byte value = 1; private Encode(byte value)&#123; this.value = value; &#125; public byte getValue()&#123; return value; &#125;&#125; 5.Client端：1234567891011Request request = new Request(Encode.UTF8.getValue(),"HELLO","HELLO".length());Socket client = new Socket("127.0.0.1",4567);OutputStream output = client.getOutputStream();//通过协议发送ProtocolUtil.writeRequest(output, request);//读取服务响应InputStream input = client.getInputStream();Response response = ProtocolUtil.readResponse(input);client.shutdownOutput(); 6.协议实现对socket流的编码解码：InputStream-&gt;Request-&gt;OutputStream InputStream-&gt;Response-&gt;OutputStream 12345678910111213141516171819202122232425262728293031323334353637public class ProtocolUtil &#123; //1.read解码request public static Request readRequest(InputStream input) throws IOException&#123; //1字节编码 byte[] encodeByte = new byte[1]; input.read(encodeByte); byte encode = encodeByte[0]; //4个字节是命令的长度 byte[] commandLengthBytes = new byte[4]; input.read(commandLengthBytes); int commandLength = ByteUtil.bytes2Int(commandLengthBytes); //读命令 byte[] commandBytes = new byte[commandLength]; input.read(commandBytes); String command = ""; command = new String(commandBytes,Encode.GBK.getValue() == encode?"GBK":"UTF8"); //封装返回 return new Request(encode,commandLength,command); &#125; //3.发送请求给服务端 public static void writeRequest(OutputStream output,Request request) throws IOException&#123; //注意read和write的字节顺序要相同 output.write(request.getEncode()); output.write(ByteUtil.int2ByteArray(request.getCommandLength())); output.write(request.getCommand().getBytes(Encode.GBK.getValue() == request.getEncode()?"GBK":"UTF8")); output.flush(); &#125; public static Response readResponse(InputStream input) throws IOException&#123; //... &#125; public static void writeResponse(OutputStream output,Response response) throws IOException&#123;//... &#125;&#125; 读取写入响应长度的byteintjava是大端字节序 TCP/IP协议规定了在网络上必须采用网络字节顺序，也就是大端模式。对于char型数据只占一个字节，无所谓大端和小端。而对于非char类型数据，必须在数据发送到网络上之前将其转换成大端模式。 ByteOrder.nativeOrder()LITTLE_ENDIAN小端 4位大端数据转换{0,0,0,1}11234567891011121314151617public static int bytes2Int(byte[] bytes) &#123; System.out.println(Arrays.toString(bytes)); int num = bytes[3] &amp; 0xFF; num |= ((bytes[2] &lt;&lt; 8) &amp; 0xFF00); num |= ((bytes[1] &lt;&lt; 16) &amp; 0xFF0000); num |= ((bytes[0] &lt;&lt; 24) &amp; 0xFF000000); return num; &#125; public static byte[] int2ByteArray(int i) &#123; byte[] result = new byte[4]; result[0] = (byte)((i &gt;&gt; 24) &amp; 0xFF); result[1] = (byte)((i &gt;&gt; 16) &amp; 0xFF); result[2] = (byte)((i &gt;&gt; 8) &amp; 0xFF); result[3] = (byte)(i &amp; 0xFF); return result; &#125; 利用http协议实现rpc 序列化比较用字节数组流 Hessianhessian-4.0.7.jarObject-&gt;HessianOutput(ByteArrayOutputStream)-&gt;.write(Objcet)-&gt;.toByteArray()HessianInput(ByteArrayInputStream())-&gt;.readObject()1234567891011Person zhangsan = new Person("zhangsan");//序列化 object-&gt;outputStreamByteArrayOutputStream bos = new ByteArrayOutputStream();HessianOutput hot = new HessianOutput(bos);hot.writeObject(zhangsan);byte[] zhangsanByte = bos.toByteArray();//反序列化ByteArrayInputStream ips = new ByteArrayInputStream(zhansanByte);HessianInput hin = new HessianInput(ips);Person person = (Person)hi.readObject(); Java自带的序列化ObjectOutputStream(ByteArrayOutputStream)-&gt;writeObject0&gt;.toByteArray()12345678910Person zhangsan = new Person("zhangsan");//序列化 写到字节数组流-&gt;写到对象流ByteArrayOutputStream os = new ByteArrayOutputStream();ObjectOutputStream out = new ObjectOutputStream(os);out.writeObject(zhangsan);byte[] zhangsanByte = os.toByteArray();//反序列化ByteArrayInputStream is = new ByteArrayInputStream(zhansanByte);ObjectInputStream in = new ObjectInputStream(is);Person person = (Person)in.readObject(); jackson序列化 字符串流jackson-all-1.7.6.jar12345678910//序列化String personJson = null;ObjectMapper mapper = new ObjectMapper();StringWriter sw = new StringWriter();JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);mapper.writeValue(gen, person);gen.close();personJson = sw.toString();//反序列化Person zhangsan = (Person)mapper.readValue(personJson, Person.class); xml xstream-1.4.4.jar123456&lt;pppp&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;address&gt;hangzhou,china&lt;/address&gt; &lt;birth&gt;2018-08-25 11:17:03.450 UTC&lt;/birth&gt;&lt;/pppp&gt; 12345678//将person对象序列化为XMLXStream xStream = new XStream(new DomDriver());//设置Person类的别名xStream.alias("pppp", Person.class);String personXML = xStream.toXML(person);//将XML反序列化还原为person对象Person zhangsan = (Person)xStream.fromXML(personXML); 基于tcp的服务调用 服务接口123public interface SayHelloService&#123; public String sayHello(String str);&#125; Consumer1234567891011121314151617//调用的接口名称String interfaceName = SayHelloService.class.getName();//调用的方法Method method = SayHelloService.class.getMethod("sayHello", java.lang.String.class);//传给服务端方法的参数Object[] arguments = &#123;"hello"&#125;;Socket socket = new Socket("127.0.0.1", 1234);//接口名，方法名，参数类型，参数 传到服务器ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());output.writeUTF(interfaceName); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(arguments); //接收远程方法的结果ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); Object result = input.readObject(); Provider12345678910111213141516171819202122232425262728//所有对外提供的服务注册到map里private static Map&lt;String,Object&gt; services = new HashMap&lt;String,Object&gt;();static&#123; services.put(SayHelloService.class.getName(), new SayHelloServiceImpl());&#125;//mainServerSocket server = new ServerSocket(1234);while(true) &#123; Socket socket = server.accept(); ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); //接口名称 String interfaceName = input.readUTF(); //方法名称 String methodName = input.readUTF(); //参数类型 Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject(); //参数对象 Object[] arguments = (Object[])input.readObject(); //执行方法 Class interfaceClass = Class.forName(interfaceName); //实现的具体类 Object service = service.get(interfaceName); Method method = interfaceClass.getMethod(methodName,parameterTypes); Objcet result = method.invoke(service,arguments); ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result);&#125; 具体实现类12345678public class SayHelloServiceImpl implements SayHelloService &#123; @Override public String sayHello(String str) &#123; if(helloArg.equals("hello"))&#123; return "hello"; &#125;else&#123; return "bye bye"; &#125;&#125;&#125; 报错初始化堆空间不够-Xmx3550m 基于HTTP的RPCservlet-api.jarjackson-all-1.7.6.jarhttpcore4.2.4.jarhttpclient-4.2.5.jarcommons-logging-1.1.1.jar 接口123public interface BaseService &#123; public Object execute(Map&lt;String,Object&gt; args);&#125; 实现：1234567891011public class SayHelloService implements BaseService&#123; public Object execute(Map&lt;String, Object&gt; args) &#123; //request.getParameterMap() 取出来为array,此处需要注意 String[] helloArg = (String[]) args.get("arg1"); if("hello".equals(helloArg[0]))&#123; return "hello"; &#125;else&#123; return "bye bye"; &#125;&#125;&#125; 消费者：123public class ServiceConsumer extends HttpServlet&#123;&#125; 排队延迟 路由器必须检测分组的首部，以确定出站路由，并且还可能对数据进行检查，这些都要花时间。由于这些检查通常由硬件完成，因此相应的延迟一般非常短，但再短也还是存在。最后，如果分组到达的速度超过了路由器的处理能力，那么分组就要在入站缓冲区排队。数据在缓冲区排队等待的时间，当然就是排队延迟。 光纤RTT 应用必须在几百 ms 之内响应。 在软件交互中，哪怕 100~ 200 ms 左右的延迟，我们中的大多数人就会感觉到“拖拉”；如果超过了 300 ms 的门槛，那就会说“反应迟钝”；而要是延迟达到 1000 ms（1s）这个界限，很多用户就会在等待响应的时候分神，有人会想入非非，有人恨不得忙点别的什么事儿。 带宽：通过波分复用（WDM，Wavelength-Division Multiplexing）技术，光纤可以同时传输很多不同波长（信道）的光到 2010 年初，研究人员已经可以在每个信道中耦合 400 多种波长的光线，最大容量可达 171 Gbit/s，而一条光纤的总带宽能够达到 70 Tbit/s TCP fast open TFO每个 ACK 分组都会携带相应的最新 接收窗口大小rwnd 值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。 RARP无盘工作站，没有存储，无法记录自己的IP地址，用物理地址向服务器查询自身IP地址。 数据链路层、网络层、传输层在内核空间中实现（内核缓冲区）应用层在用户空间 子网掩码https://blog.csdn.net/yinshitaoyuan/article/details/51782330 得到子网的网络地址 每个子网络能容纳500台主机，它的子网掩码是多少？500-&gt;111110100 一共9位子网掩码255.255.255.255从后向前的9位变成0（11111111.11111111.11111110.00000000）255.255.254.0。 3、利用子网掩码计算最大有效子网数 A类IP地址，子网掩码为255.224.0.0，它所能划分的最大有效子网数是多少？ ①将子网掩码转换成二进制表示11111111.11100000.00000000.00000000 ②统计一下它的网络位共有11位 ③A类地址网络位的基础数是8，二者之间的位数差是3 ④最大有效子网数就是2的3次方，即最多可以划分8个子网络。 以太网 Frame帧IP packet 分组（不是分片TCP segment 分节应用层 message消息 NIO:Reactor模式reactor对所有客户端的socket套接字做事件处理，派发到不同的线程。 AIO:Proactor模式动作完成后调用handler 网络计时Timekeeping时间：一天86400秒 365天 假设70年 精度为10位有效数字时钟：振荡器oscillator(14.318MHz+计数器counter Timestamp时间点。是指针 不能相加 只能相减。算中间时间：T1+(T2-T1)/2Time interval 是int时间的一阶导是频率二阶导是jittertsc cpu内部的周期计数器 现在不随cpu频率变化。cpu频率以G 10^9 能精度到1ns NTP网络时间同步 基于UDP算出时间差error:[(T4+T1)-(T2+T3)]/2后调整offset和frequency连续调整 避免时钟跳变。如果时间差小于128ms 缓慢调下去。频率跳变时间会阶越效应 当同一个ip后面多个服务器，没有session会发到不同的服务器上NTP在服务端有两个误差，1从网卡内核到用户进程接收计时 2用户进程开始发送计时到内核网卡发出。两个时间可能不对称。 以太网最小帧长64字节ip20字节 udp 8字节 tcp头20字节tcp还有时间戳option12字节ip-tcp52字节 TCP close发送太早可能发生RST分解。连接重置。netcat光发，不接收响应，ttcp接收到服务器ack再发第二个包 本机测试从/dev/zero读取1G的速度nc -l 5000 &gt;/dev/null &amp;dd if = /dev/zero bs = 1M count = 1000 |nc localhost 5000用io重定向测试本地文件传输速度time nc localhost 5001 &lt; file.file用irb计算 10^10(1G)/9.4(s)/10^6 = M/s 得到磁盘性能 第二次time会快很多因为已经在缓存里了 监测数据nc -l 50001 |pv -W &gt; /dev/null pv的单位是二进制，dd用的十进制文件-&gt;tcp-&gt;文件dd |nc,nc -l &gt;/dev/null6次用户与内核间拷贝 /dev/zero-&gt;dd dd-&gt;pipe pipe-&gt;nc nc-&gt;TCP TCP-&gt;服务端nc sysctl -A |grep range本机端口范围 TCP自连接1发起链接时会从ipv4.ip_local_port_range中选择临时端口号2向服务器发送SYNTCP的同时打开，3000端口无进程监听，但是tcp链接打开了3000端口，当作有监听，形成自连接 pipelining数，连发n个收一个ack用阻塞编程 有上限，超过会收不到ack TTCP tcp实现的检测性能muduo 用非阻塞的muduo库写的ttcp.ccstream-&gt;setNoDelay(true) 不用等ack发送 Epoll 可扩展I/O时间通知特性比旧的POSIX select和poll系统调用性能更好。epoll是linux非阻塞网络编程的事实标准。Linux下：将NioEventLoopGroup换成EpollEventLoopGroupNioServerSocketChannel.class换成EpollServerSocketChannel.class 回调方法：指向已经被提供给另一个方法的 方法的引用OutboundHandler出站：从客户端到服务端 ：链尾取到链头Inbound 入站：链头取到链尾handler添加到pipline时会被分配一个ChannelHandlerContext表示绑定。1.直接写道channel中，从Pipeline尾端开始流动2.写到handler关联的Context对象 从从pipeline从下一个handler开始流动 ChannelHandler的三个子类：编码器，解码器 SimpleC..Inbound..nettyIoc 好莱坞原则Reactor模型 应用向中间人注册回调(event handler) 中间人轮询，IO就绪后中间人产生事件，通知handler处理。 第三种reactor模型，将reactor分两部分。mainReactor负责监听server socket的链接（外部client的链接）subReactor 负责读写网络数据。 netty支持单线程、多线程、主从reactor模型。 创建2个线程组多个线程 线程内串行化 避免线程竞争 无锁 操作系统维护TCP 的SYN队列 将网络请求插入队列，返回SYN/ACK 两次握手 半链接（SYN_RCVD) （主reactor） 第三次握手，收到ACK请求，操作系统将SYN队列中的请求转移到ACCEPT队列（阻塞队列）全链接(ESTABLISHED) （子reacotr） 服务器上的应用队列监听阻塞队列（ACCEPT)accept+SYN队列=backlog长度syn长度：/proc/sys/net/ipv4/tcp_max_syn_backlog =1024accept长度：/proc/sys/net/core/somaxconn =128 引导 构建netty的配置服务端12serverBootstrap.group(pgroup,cgroup).channel(NioSocketChannel.class).option(ChannelOption.SO_RCVBUF,32*1024)//接收缓存大小 客户端引导Bootstrap 连接到主机和端口服务端引导ServerBootstrap 绑定一个本地端口客户端只需一个EventLoopGroup客户端需要2个，管理两组不同的Channel。 ServerChannel绑定本地端口并监听 连接请求创建channel 第二组处理传入客户端连接的channel 给channel分配eventloop Netty的buffer有两个指针，读写指针互不影响，NIO只有一个指针要flipdirectByteBuf堆外 零拷贝 客户端 写给服务端12//直接把字节数组包装成bufferctx.writeAndFlush(Unpooled.wrappedBuffer("响应".getBytes())); 服务器端读取1234567try&#123;ByteBuf buf =(ByteBuf)msg;byte[] responseData = new byte[buf.readableBytes()];buf.readBytes(responseData);&#125;finally&#123; ReferenceCountUtil.release(msg);&#125; Netty阻塞io服务端123456789101112131415161718192021222324252627EventLoopGroup group = new OioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(OioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) //用于回调 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( new ChannelInboundHandlerAdapter() &#123; @Override public void channelActive( ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) .addListener( ChannelFutureListener.CLOSE); &#125; &#125;); &#125; &#125;); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync();&#125; 非阻塞服务端1234567NioEventLoopGroup group = new NioEventLoopGroup();try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group).channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) ... &#125; 客户端：12345678910111213141516171819202122232425public void start()throws Exception &#123;EventLoopGroup group = new NioEventLoopGroup();try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; //Pipeline为handler编排顺序 ch.pipeline().addLast( //自定义的handler new EchoClientHandler()); &#125; &#125;); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync();&#125; finally &#123; group.shutdownGracefully().sync();&#125;&#125;]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud zk]]></title>
    <url>%2F2018%2F05%2F08%2Fspring-cloud%2F</url>
    <content type="text"><![CDATA[分布式：节点之间如何通信微服务：按业务划分模块 @EnableEurekaServer 静态文件用Nginx+Lua实现高性能网关文件服务器 FastDFSzk客户端 curator解决watcher注册一次就失效分布式锁 dockerk8s 容器编排工具ZooKeeper1.安装jdk到/usr/ 安装zookeeper到/usr/local/vi /etc/profile12export ZOOKEEPER_HOME=/usr/local/zookeeper-3.4.8export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH:$ZOOKEEPER_HOME/bin 2.cd conf/cp zoo_sample.cfg zoo.cfgtickTime 时间单元 session超时等initLimit=N 用于集群 从从节点连接并同步到主节点 的初始化链接时间 表示是tickTime的N倍syncLimit=N 主发送给从 的请求应答时间长度（心跳）表示是tickTime的N倍 12345678# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir= /usr/local/zookeeper3.4.8/dataDirdataLogDir=/usr/local/zookeeper3.4.8/logDir# the port at which the clients will connectclientPort=2181 并创建dataDir和dataLogDir cd ../bin启动服务器1234[root@localhost bin]# ./zkServer.shZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.8/bin/../conf/zoo.cfgUsage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125; ./zkServer.sh start/restart/stop 启动客户端./zkCli.sh 链接成功后1234567891011121314151617181920212223[zk: localhost:2181(CONNECTED) 0] helpZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] #某个路径下的目录列表 delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit getAcl path close connect host:port ls123456[zk: localhost:2181(CONNECTED) 2] ls /[zookeeper][zk: localhost:2181(CONNECTED) 3] ls /zookeeper[quota][zk: localhost:2181(CONNECTED) 4] ls /zookeeper/quota[] zk 的作用1.M/S节点选举-&gt;高可用2.同步配置文件到所有服务器3.发布订阅MQ4.分布式锁5.集群管理，保证数据强一致性 ls2 /12345678910111213[zk: localhost:2181(CONNECTED) 0] ls2 /[zookeeper]cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0cversion = -1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 1 stat /123456789101112[zk: localhost:2181(CONNECTED) 1] stat /cZxid = 0x0ctime = Thu Jan 01 08:00:00 CST 1970mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0cversion = -1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 0numChildren = 1 get /12345678910111213[zk: localhost:2181(CONNECTED) 2] get / #数据 当前为空cZxid = 0x0 ## 创建了之后zk给它分配的idctime = Thu Jan 01 08:00:00 CST 1970 #创建时间mZxid = 0x0mtime = Thu Jan 01 08:00:00 CST 1970pZxid = 0x0 #子节点idcversion = -1 #子节点的变化dataVersion = 0 #数据版本号aclVersion = 0 # 权限ephemeralOwner = 0x0dataLength = 0numChildren = 1 # 子节点有几个 Session 的基本原理一个C/S连接存在一个会话，会话有超时时间心跳结束 session过期 session 临时节点znode被抛弃 心跳机制：C向S发送ping create1234567891011121314151617181920212223[zk: localhost:2181(CONNECTED) 3] creteZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit getAcl path close connect host:port 创建结点 create /iznode inode-data查看get /iznode123456789101112131415[zk: localhost:2181(CONNECTED) 4] create /iznode inode-dataCreated /iznode[zk: localhost:2181(CONNECTED) 5] get /iznodeinode-datacZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0x4mtime = Sat Sep 15 15:30:32 CST 2018pZxid = 0x4cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 10numChildren = 0 创建临时结点create -e /iznode/tmp inode-data12345678910111213141516171819202122232425262728[zk: localhost:2181(CONNECTED) 6] create -e /iznode/tmp inode-dataCreated /iznode/tmp[zk: localhost:2181(CONNECTED) 7] get /iznodeinode-datacZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0x4mtime = Sat Sep 15 15:30:32 CST 2018pZxid = 0x5cversion = 1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 10numChildren = 1[zk: localhost:2181(CONNECTED) 8] get /iznode/tmpinode-datacZxid = 0x5ctime = Sat Sep 15 15:31:33 CST 2018mZxid = 0x5mtime = Sat Sep 15 15:31:33 CST 2018pZxid = 0x5cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x165dc14dc590001 #临时节点dataLength = 10numChildren = 0 ephemeralOwner可以看出是不是临时结点 客户端关闭后，超时后，临时结点会自动删除ctrl-C关闭客户端再打开 还有 因为时效还在 等一下再get就没了123456789101112131415[zk: localhost:2181(CONNECTED) 2] get /iznode/tmpinode-datacZxid = 0x5ctime = Sat Sep 15 15:31:33 CST 2018mZxid = 0x5mtime = Sat Sep 15 15:31:33 CST 2018pZxid = 0x5cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x165dc14dc590001dataLength = 10numChildren = 0[zk: localhost:2181(CONNECTED) 3] get /iznode/tmpNode does not exist: /iznode/tmp 创建顺序结点create -s /iznode/sec seq-data会自动在名字后面加序列号123456[zk: localhost:2181(CONNECTED) 4] create -s /iznode/sec seq-dataCreated /iznode/sec0000000001[zk: localhost:2181(CONNECTED) 5] create -s /iznode/sec seq-dataCreated /iznode/sec0000000002[zk: localhost:2181(CONNECTED) 6] create -s /iznode/sec seq-dataCreated /iznode/sec0000000003 set set path data [version]和deleteset /iznode 123 1添加乐观锁123 版本号+112345678910111213141516171819202122232425[zk: localhost:2181(CONNECTED) 9] set /iznode newnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xbmtime = Sat Sep 15 15:36:04 CST 2018pZxid = 0xacversion = 5dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3[zk: localhost:2181(CONNECTED) 10] get /iznodenewnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xbmtime = Sat Sep 15 15:36:04 CST 2018pZxid = 0xacversion = 5dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3 set 添加版本号 乐观锁1234567891011121314[zk: localhost:2181(CONNECTED) 11] set /iznode newnewnew 1cZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xcmtime = Sat Sep 15 15:37:19 CST 2018pZxid = 0xacversion = 5dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 3[zk: localhost:2181(CONNECTED) 12] set /iznode newnewnew 1version No is not valid : /iznode delete123456789101112131415161718[zk: localhost:2181(CONNECTED) 17] ls /iznode [sec0000000003, sec0000000001, sec0000000002][zk: localhost:2181(CONNECTED) 18] delete /iznode/sec0000000003[zk: localhost:2181(CONNECTED) 19] ls /iznode [sec0000000001, sec0000000002][zk: localhost:2181(CONNECTED) 20] get /iznodenewnewnewcZxid = 0x4ctime = Sat Sep 15 15:30:32 CST 2018mZxid = 0xcmtime = Sat Sep 15 15:37:19 CST 2018pZxid = 0xecversion = 6dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 2 watch对node的操作都会触发watcher12stat path [watch]get path [watch] 1234567891011121314151617181920[zk: localhost:2181(CONNECTED) 10] create /iwatch2 145Created /iwatch2[zk: localhost:2181(CONNECTED) 11] get /iwatch2 watch 145cZxid = 0x14ctime = Sat Sep 15 15:50:03 CST 2018mZxid = 0x14mtime = Sat Sep 15 15:50:03 CST 2018pZxid = 0x14cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0[zk: localhost:2181(CONNECTED) 12] delete /iwatch2WATCHER::WatchedEvent state:SyncConnected type:NodeDeleted path:/iwatch2 乐观锁：当节点数据变化版本号会累加 子节点watch123456789[zk: localhost:2181(CONNECTED) 15] create /iwatch/abc 88Created /iwatch/abc[zk: localhost:2181(CONNECTED) 16] ls /iwatch watch[abc][zk: localhost:2181(CONNECTED) 17] delete /iwatch/abcWATCHER::WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/iwatch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[zk: localhost:2181(CONNECTED) 18] ls /iwatch watch[][zk: localhost:2181(CONNECTED) 19] create /iwatch/xyz 999WATCHER::WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/iwatchCreated /iwatch/xyz[zk: localhost:2181(CONNECTED) 20] set /iwatch/xyz newnew999cZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x19mtime = Sat Sep 15 15:53:46 CST 2018pZxid = 0x18cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 0[zk: localhost:2181(CONNECTED) 21] get /iwatch/xyz watchnewnew999cZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x19mtime = Sat Sep 15 15:53:46 CST 2018pZxid = 0x18cversion = 0dataVersion = 1aclVersion = 0ephemeralOwner = 0x0dataLength = 9numChildren = 0[zk: localhost:2181(CONNECTED) 22] set /iwatch/xyz newne888 WATCHER::WatchedEvent state:SyncConnected type:NodeDataChanged path:/iwatch/xyzcZxid = 0x18ctime = Sat Sep 15 15:53:27 CST 2018mZxid = 0x1amtime = Sat Sep 15 15:54:25 CST 2018pZxid = 0x18cversion = 0dataVersion = 2aclVersion = 0ephemeralOwner = 0x0dataLength = 8numChildren = 0 watcher使用场景：统一资源配置ACL access control lists 权限控制123setAcl path aclgetAcl pathaddauth scheme auth 12345[zk: localhost:2181(CONNECTED) 3] create /iznode/abc aaaCreated /iznode/abc[zk: localhost:2181(CONNECTED) 4] getAcl /iznode/abc 'world,'anyone: cdrwa [scheme:id:permissions]权限列表c 创建r 读w 写d 删除a admin权限 不加要super123456789101112131415161718192021[zk: localhost:2181(CONNECTED) 5] setAcl /iznode/abc/ world:anyone:crwaCommand failed: java.lang.IllegalArgumentException: Path must not end with / character[zk: localhost:2181(CONNECTED) 6] setAcl /iznode/abc world:anyone:crwa cZxid = 0x1dctime = Sat Sep 15 15:59:43 CST 2018mZxid = 0x1dmtime = Sat Sep 15 15:59:43 CST 2018pZxid = 0x1dcversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 3numChildren = 0[zk: localhost:2181(CONNECTED) 7] getAcl /iznode/abc 'world,'anyone: crwa[zk: localhost:2181(CONNECTED) 8] create /iznode/abc/xyz 123Created /iznode/abc/xyz[zk: localhost:2181(CONNECTED) 9] delete /iznode/abc/xyzAuthentication is not valid : /iznode/abc/xyz digest用户名密码SHA1+BASE641234567891011121314151617181920[zk: localhost:2181(CONNECTED) 17] create /names nnn Created /names[zk: localhost:2181(CONNECTED) 19] create /names/zhangsan zhangsanCreated /names/zhangsan[zk: localhost:2181(CONNECTED) 14] addauth digest username:pw[zk: localhost:2181(CONNECTED) 20] setAcl /names/zhangsan auth:username:pw:cdrwacZxid = 0x27ctime = Sat Sep 15 16:10:09 CST 2018mZxid = 0x27mtime = Sat Sep 15 16:10:09 CST 2018pZxid = 0x27cversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 8numChildren = 0[zk: localhost:2181(CONNECTED) 21] getAcl /names/zhangsan 'digest,'username:cP33D+25T3/l/dheCyIBuhZjI40=: cdrwa ip设置一个网段的权限12345678910111213141516171819[zk: localhost:2181(CONNECTED) create /names/ip ip Created /names/ip[zk: localhost:2181(CONNECTED) 23] setAcl /names/ip ip:10.1.18.11:cdrwacZxid = 0x29ctime = Sat Sep 15 16:13:47 CST 2018mZxid = 0x29mtime = Sat Sep 15 16:13:47 CST 2018pZxid = 0x29cversion = 0dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 2numChildren = 0[zk: localhost:2181(CONNECTED) 24] getAcl /names/ip 'ip,'10.1.18.11: cdrwa[zk: localhost:2181(CONNECTED) 25] get /names/ipAuthentication is not valid : /names/ip super 用户vi zkServer.sh/nohup加上12nohup "$JAVA" "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;" "-Dzookeeper.DigestAuthenticationProvider.superDigest=username:cP33D+25T3/l/dheCyIBuhZjI40="\ -cp "$CLASSPATH" $JVMFLAGS $ZOOMAIN "$ZOOCFG 对应jar包org.apache.zookeeper.server.auth 重启./zkServer.sh restart12345[zk: localhost:2181(CONNECTED) 3] getAcl /names/ip'ip,'10.1.18.11: cdrwa[zk: localhost:2181(CONNECTED) 4] addauth digest username:pw[zk: localhost:2181(CONNECTED) 5] ls /names/ip acl使用场景：开发/测试人员环境分离Four Letter Wordsyum install nc1234567891011121314151617181920[root@localhost bin]# echo stat | nc 10.1.18.133 2181Zookeeper version: 3.4.8--1, built on 02/06/2016 03:18 GMTClients: /10.1.18.133:38240[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/1/11Received: 25Sent: 24Connections: 1Outstanding: 0Zxid: 0x2dMode: standaloneNode count: 15[root@localhost bin]# echo ruok | nc 10.1.18.133 2181imok[root@localhost bin]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (0):ephemeral nodes dump:Sessions with Ephemerals (0): 创建临时节点1create -e /name/tmp-dump 123 dump123456789101112131415161718192021[root@localhost ~]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (3):0 expire at Sat Sep 15 16:37:30 CST 2018:0 expire at Sat Sep 15 16:37:40 CST 2018:1 expire at Sat Sep 15 16:37:50 CST 2018: 0x165dc54602f0001ephemeral nodes dump:Sessions with Ephemerals (0):[root@localhost ~]# echo dump | nc 10.1.18.133 2181SessionTracker dump:Session Sets (4):0 expire at Sat Sep 15 16:38:30 CST 2018:0 expire at Sat Sep 15 16:38:40 CST 2018:0 expire at Sat Sep 15 16:38:42 CST 2018:1 expire at Sat Sep 15 16:38:50 CST 2018: 0x165dc54602f0001ephemeral nodes dump:Sessions with Ephemerals (1):0x165dc54602f0001: #可以看到临时节点的目录 /names/tmp-dump conf123456789[root@localhost ~]# echo conf | nc 10.1.18.133 2181clientPort=2181dataDir=/usr/local/zookeeper-3.4.8/dataDir/version-2dataLogDir=/usr/local/zookeeper-3.4.8/logDir/version-2tickTime=2000maxClientCnxns=60minSessionTimeout=4000maxSessionTimeout=40000serverId=0 cons123[root@localhost ~]# echo cons | nc 10.1.18.133 2181 /10.1.18.133:38260[0](queued=0,recved=1,sent=0) /0:0:0:0:0:0:0:1:37946[1](queued=0,recved=33,sent=33,sid=0x165dc54602f0001,lop=PING,est=1537000478725,to=30000,lcxid=0x3,lzxid=0x31,lresp=1537000778393,llat=0,minlat=0,avglat=1,maxlat=15) 健康信息12345678910111213141516[root@localhost ~]# echo mntr | nc 10.1.18.133 2181zk_version 3.4.8--1, built on 02/06/2016 03:18 GMTzk_avg_latency 1zk_max_latency 15zk_min_latency 0zk_packets_received 76zk_packets_sent 75zk_num_alive_connections 2zk_outstanding_requests 0zk_server_state standalonezk_znode_count 16zk_watch_count 0zk_ephemerals_count 1zk_approximate_data_size 237zk_open_file_descriptor_count 29zk_max_file_descriptor_count 4096 watch数量123[root@localhost ~]# echo wchs | nc 10.1.18.133 21810 connections watching 0 pathsTotal watches:0 zk 集群搭建1.伪分布式 端口号不一样 ip一样的cp zookeeper-3.4.8 zookeeper2 -rfvi zoo.cfg]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原子性 可见性 有序性]]></title>
    <url>%2F2018%2F05%2F07%2Favo%2F</url>
    <content type="text"><![CDATA[原子性： 互斥 同一时间只有一个线程操作atomic竞争激烈能维持常态，性能比Lock还好，但每次只能同步一个值 AtomicInteger123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; Unsafe:12345678910//var1 当前对象 var2当前值 var4 add值public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123;//调用底层native方法获得var2当前值，有没有别的线程处理 var5 = this.getIntVolatile(var1, var2); //直到 主存var5和var2工作内存相等，则执行add &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; compareAndSwapInt是native方法 LongAdder与CAS中的AtomicLong比较：AtomicLong竞争激烈时，大概率修改失败，性能差JVM会将64位的long和double读写会拆成2个32位的操作123public void increment() &#123; add(1L);&#125; LongAdderextends Striped64实现热点数据分离，高并发时会将long变成一个数组Cell[] as，但是并发更新可能会有误差。 compareAndSet用于AtomicBoolean中控制代码只执行一次（只能一个线程）。执行之前是false 执行之后true。compareAndSet(false,true)12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125; AtomicBoolean1234567891011private static AtomicBoolean isHappened = new AtomicBoolean(false);//放在线程中semaphore.acquire();test();semaphore.release();private static void test() &#123; //线程执行1k次，F变T只一次 log只输出一次 if (isHappened.compareAndSet(false, true)) &#123; log.info("execute"); &#125;&#125; atomic机器级指令compareAndSet 比锁快，映射到处理器操作。123largest.updateAndGet(x-&gt;Math.max(x,observed));//或者largest.accumulateAndGet(observed,Math::max); 大量线程访问相同的原子值LongAdder,LongAccumulator线程个数增加自动提供新的加数。所有工作都完成后才需要总和的情况使用。 AtomicIntegerFieldUpdate原子性更新类的更新类中相应字段 必须volatile不能static展开代码 1234567891011121314151617public class AtomicExample5 &#123;private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, "count");public volatile int count = 100;public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if (updater.compareAndSet(example5, 100, 120)) &#123; //执行 log.info("update success 1, &#123;&#125;", example5.getCount()); &#125; if (updater.compareAndSet(example5, 100, 120)) &#123; log.info("update success 2, &#123;&#125;", example5.getCount()); &#125; else &#123;//执行 log.info("update failed, &#123;&#125;", example5.getCount()); &#125;&#125;&#125; AtomicStampReference解决CAS的ABA问题1234567891011 private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125;&#125; ABA其它线程将A改成B再改成A，本线程比较发现没有变。每次更新变量版本号+1123456789101112 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp;//比较stamp ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125; AtomicLongArray数组，可以更新索引位置的值long getAndSet(int i, long newValue)boolean compareAndSet(int i, long expect, long update) 锁synchronized 依赖JVM不可中断锁，必须等到代码执行完,竞争不激烈使用，可读性好1.修饰代码块：作用域调用的对象输出0~9，0~91234567891011121314151617181920public class SynchronizedExample1 &#123; // 修饰一个代码块 public void test1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", i); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedExample1 example1 = new SynchronizedExample1(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); executorService.execute(() -&gt; &#123; example1.test1(); &#125;); &#125;&#125; 2.修饰方法：作用于调用的对象，子类的继承该方法不会带synchronized，需要再声明。因为synchronized不是方法声明的一部分同上输出0~9，0~912345public synchronized void test2() &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", i); &#125;&#125; 当声明另一个对象,两个线程会交叉执行，不同对象之间不影响123SynchronizedExample1 example2 = new SynchronizedExample1();example1.test2();example2.test2(); 3.修饰静态方法：作用于所有对象同一时间只有一个线程可以执行，两个对象也是输出0~9，0~912345public static synchronized void test2(int j) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test2 &#123;&#125; - &#123;&#125;", j, i); &#125;&#125; 4.修饰类：作用于所有对象1234567public static void test1(int j) &#123; synchronized (SynchronizedExample2.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; log.info("test1 &#123;&#125; - &#123;&#125;", j, i); &#125; &#125;&#125; Lock:依赖特殊的CPU指令 可中断unLock竞争激烈维持常态 ReentrantLock123private Lock bankLock = new ReentrantLock();try&#123;bankLock.lock();&#125;finally&#123;bankLock.unlock();&#125; 可见性：每个cpu都有cacheCPU2修改了内存中的a，CPU1读取a只读取cache中的值，不可见虚拟机有两种模式 客户端模式不会优化 -server优化（64位虚拟机一般是server模式） 线程交叉执行 重排序+线程交叉执行 共享变量更新再工作内存和主存没同步 java内存模型线程如何何时看到其它线程修改过的共享变量的值，如何同步地访问共享变量堆 运行时动态分配内存大小。调用栈和本地变量存放在线程栈。 java内存模型JMM对synchronized的两条规定： 线程解锁必须刷新共享变量到主存 线程加锁要清空工作内存中共享变量的值，使用共享变量时从主存读新值（同一个范围的锁） volatile内存屏障，禁止重排序volatile写：会在写操作后加入一条store屏障指令它的修改会立刻刷新到主存，图有问题？？？读：读之前加入load屏障指令，c去内存中读取新值。 使用volatile run(){count++}还是会出错volatile不具有原子性。因为：1. 取值2. +1 3.写回主存，两个线程同时拿到值并+1，同时写回主存，丢1. 使用场景：对变量的写操作不依赖当前值适合当状态标记量：用volatile的值作为线程1的状态加载完毕。线程2 while(!)判断 有序性volatile、synchronized、Lock 不满足happends-beforey原则 JVM就可以重排序volatile 写操作先于读操作终止检测Thread.isAlive()]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io-file]]></title>
    <url>%2F2018%2F05%2F04%2Fjava-io-file%2F</url>
    <content type="text"><![CDATA[管道流 PipedInputStream.. 线程之间的数据通信pin.connect(pout); Java的管道不同于Unix/Linux系统中的管道。在Unix/Linux中，运行在不同地址空间的两个进程可以通过管道通信。在Java中，通信的双方应该是运行在同一进程中的不同线程。 新建一个流对象，下面哪个选项的代码是错误的？正确答案: B 你的答案: A (错误)A.new BufferedWriter(new FileWriter(“a.txt”));B.new BufferedReader(new FileInputStream(“a.dat”));C.new GZIPOutputStream(new FileOutputStream(“a.zip”));D.new ObjectInputStream(new FileInputStream(“a.dat”));public BufferedReader(Reader in, int sz) http://blog.jmecn.net/java-iostream/JNI java native interface 本地接口 NIO原来IO流一个字节一个字节处理。NIO块。每一种java数据类型都有缓冲区1.ByteBuffer bf = ByteBuffer.allocate(8);2.添加 bf.put((byte)10); 获取.get(index)3.偏移量：bf.position()4.缓冲区反转：bf.flip()取值的数据变成position-limit 123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 5.bf.hasRemaining()positon和limit之间有值, bf.remaining()有多少个：return limit - position;123456bf.flip()if(bf.hasRemaining())&#123; for(int i =0;i&lt;bf.remaining();i++)&#123; byte b= bf.get(i); &#125;&#125; 6.campact丢弃position及以前的数据，将position到limit的数据复制到之前，并将pisiton移到复制完的数据之后，用于写入新数据覆盖没被覆盖掉但是已经移到前面去的值，limit放到capacity上。 Channel 文件只能通过RandomAccessFile,FileInput/OutputStream的.getChannel()打开只读/只写 socket有Socket,Server,Datagram三种Channel selector是系统(native)调用select() poll()的封装注册:通道设置成非阻塞，File通道不能是非阻塞123Selector sl = Selector.open();channel.configureBolcking(false);SelectionKey = channel.register(selector,Selection.OP_READ); rigister的第二个参数监听四种不同类型：Connect，Accept，R/W可以用|位运算连接多个监听的值 返回的SelectionKey对象有4个boolean方法表示通道的就绪状态从键可以访问对应的通道和选择器： 12selectionKey.channel();selectionKey.selector(); Selecotr对象维护3个键的Set：每个键关联一个通道 12345public abstract SelectorProvider provider();//已注册的键的集合public abstract Set&lt;SelectionKey&gt; keys();//已注册中的已经准备好的集合public abstract Set&lt;SelectionKey&gt; selectedKeys(); select方法返回上次select之后就绪的通道数(增量)通过就绪key访问通道1234567891011Set selectedKeys = selector.selectedKeys();Iterator KeyIterator = selectedKeys.iterator();while(KeyIterator.hasNext)&#123; SelectionKey key = KeyIterator.next(); //四种就绪状态 if(key.isAcceptable())&#123; ... &#125; //从就绪集中移除，下次通道再就绪时再放入选择集 KeyIterator.remove();&#125; 堆外内存：ByteBuffer1.wrap可以包装一个数组，保证不被直接修改2.ByteBuffer.allocateDirect() 堆外内存。123public static ByteBuffer allocateDirect(int capacity) &#123; return new DirectByteBuffer(capacity);&#125; DirectByteBuffer继承MappedByteBuffer,map..继承ByteBuffer继承BufferBuffer.java中 实现零拷贝1234// Used only by direct buffers// NOTE: 升级为了JNI方法调用的速度hoisted here for speed in JNI GetDirectBufferAddress//堆外内存数据地址用c申请的long address; Reactor模式IO分为广义File I/O和Stream I/O两类common-ioxml解析SAX 事件驱动，顺序。，读取(内存占用小) 解析器工厂 1SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); 创建SAX解析器 1SAXParser saxParser = saxParserFactory.newSAXParser(); 数据处理器 1PersonHandler personHandler = new PersonHandler(); 展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class PersonHandler extends DefaultHandler&#123; public List&lt;Person&gt; getPersons() &#123; return persons; &#125; private List&lt;Person&gt; persons = null; private Person p= null; //用于记录当前正在解析的标签 private String tag; @Override public void startDocument() throws SAXException &#123; super.startDocument(); //开始解析文档 persons = new ArrayList&lt;&gt;(); System.out.println("开始解析标签"); &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); System.out.println("结束解析"); &#125; /* * @param uri 命名空间 * @param localName 不带前缀的标签 * @param qName 带前缀的标签&lt;aa: * @param attributes 标签里的属性集合 */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; super.startElement(uri, localName, qName, attributes); if("Person".equals(qName))&#123; p=new Person(); int id = Integer.parseInt(attributes.getValue("id")); p.setId(id); &#125; //开始解析标签时记录名字 tag = qName; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; super.endElement(uri, localName, qName); //每次结束标记就把tag置空 if ("Person".equals(qName)) &#123; persons.add(p); &#125; tag = null; &#125; @Override //解析文本内容时 public void characters(char[] ch, int start, int length) throws SAXException &#123; super.characters(ch, start, length); //ch是整个xml文件的内容 if (tag != null) &#123; if("name".equals(tag))&#123; p.setName(new String(ch,start,length)); &#125; &#125; &#125;&#125; 开始解析12InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("person.xml");saxParser.parse(is,personHandler); 据说jdom和dom文档超过10M会内存溢出 Dom解析 解析器工厂 1DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); 解析器对象 1DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); 解析（把所有文件读取到内存） 12//树状结构Document parse = documentBuilder.parse(is); 从内存中读取 123456789101112131415161718192021NodeList people = parse.getElementsByTagName("Person");ArrayList&lt;Person&gt; pp = new ArrayList&lt;&gt;();Person p =null;for (int i = 0; i &lt;people.getLength() ; i++) &#123;Node person = people.item(i);p = new Person();//获取person元素的属性idp.setId(Integer.parseInt(person.getAttributes().getNamedItem("id").getNodeValue()));//获取子节点NodeList childNodes = person.getChildNodes();for (int j = 0; j &lt;childNodes.getLength() ; j++) &#123; Node child = childNodes.item(j); if ("name".equals(child.getNodeName())) &#123; p.setName(child.getTextContent()); System.out.println(child.getFirstChild()); System.out.println(child.getFirstChild().getNodeValue()); &#125;&#125;pp.add(p);System.out.println(p);&#125; JDOM 三方 不用NodeList 返回原生的Collection123456789101112131415161718SAXBuilder builder = new SAXBuilder();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document build = builder.build(is);Element root = build.getRootElement();List&lt;Person&gt; list = new ArrayList&lt;&gt;();Person p = null;List&lt;Element&gt; children = root.getChildren();for(Element e :children)&#123; p = new Person(); p.setId(Integer.parseInt(e.getAttributeValue("id"))); List&lt;Element&gt; child = e.getChildren(); for(Element ce:child)&#123; if ("name".equals(ce.getName())) &#123; p.setName(ce.getText()); &#125; &#125; list.add(p);&#125; DOM4JJAXM 和hibernate读写配置文件 都使用1234567891011121314151617181920SAXReader reader = new SAXReader();InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/person.xml");Document doc = reader.read(is);Element root = doc.getRootElement();Iterator&lt;Element&gt; iter = root.elementIterator();ArrayList&lt;Person&gt; people = new ArrayList&lt;&gt;();Person p = null;while(iter.hasNext())&#123; p = new Person(); Element next = iter.next(); p.setId(Integer.parseInt(next.attributeValue("id"))); Iterator&lt;Element&gt; childiter = next.elementIterator(); while(childiter.hasNext())&#123; Element next1 = childiter.next(); if ("name".equals(next1.getName())) &#123; p.setName(next1.getText()); &#125; &#125; people.add(p);&#125; 对象写入生成xml1.XMLEncoder 用decoder直接解析12345BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("outxml.xml"));XMLEncoder xmlEncoder = new XMLEncoder(bos);//forxmlEncoder.writeObject(p);xmlEncoder.close(); 生成1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;java version="1.8.0_144" class="java.beans.XMLDecoder"&gt; &lt;object class="javacoretest.xmljson.Person"&gt; &lt;void property="id"&gt; &lt;int&gt;3&lt;/int&gt; &lt;/void&gt; &lt;void property="name"&gt; &lt;string&gt;第三个&lt;/string&gt; &lt;/void&gt; &lt;/object&gt;&lt;/java&gt; 2.xstream 依赖包xpp312XStream xStream = new XStream(new Xpp3Driver());String xml = xStream.toXML(p); 输出：1234&lt;javacoretest.xmljson.Person&gt; &lt;name&gt;第三个&lt;/name&gt; &lt;id&gt;3&lt;/id&gt;&lt;/javacoretest.xmljson.Person&gt; 修改成Person包名，id为属性:在toXML之前加12xStream.alias("Person",Person.class);xStream.useAttributeFor(Person.class,"id"); 解析:xml是字符串xml(Person)xStream.fromXML(xml); JSON：GSON12[&#123;"id":"1","name":"小明"&#125;, &#123;"id":"2","name":"小红"&#125;] 1解析list123456789InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("javacoretest/xmljson/people.json");InputStreamReader in = new InputStreamReader(is);JsonReader reader = new JsonReader(in);List&lt;Person&gt; list = new ArrayList&lt;&gt;();reader.beginArray();while(reader.hasNext())&#123; list.add(addobj(reader));&#125;reader.endArray(); 2解析obj123456789101112131415161718private static Person addobj(JsonReader reader) throws IOException &#123; Person p = null; //读大括号 reader.beginObject(); p = new Person(); while(reader.hasNext())&#123; String s = reader.nextName(); if ("name".equals(s)) &#123; p.setName(reader.nextString()); &#125; else if("id".equals(s))&#123; int i = reader.nextInt(); p.setId(i); &#125; &#125; reader.endObject(); return p;&#125; 直接用Gson将字符串{:}转化成类 “age”:”4”会自动映射成int12Gson gson = new Gson();list.add(gson.fromJson(reader,Person.class)); 3 生成json12345678910private static String createJson(List&lt;Person&gt; people)&#123; JsonArray array = new JsonArray(); for(Person p: people) &#123; JsonObject obj = new JsonObject(); obj.addProperty("name",p.getName()); obj.addProperty("id",p.getId()); array.add(obj); &#125; return array.toString();&#125; 直接用gson将对象转成json字符串1String s = gson.toJson(pp); 制定生成json list12345//相当于 允许运行时创建一个子列获取typeclass mytype extends TypeToken&lt;List&lt;People&gt;&gt;&#123;&#125;//new一个子类，里面什么都不写TypeToken&lt;List&lt;Person&gt;&gt; typeToken = new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;;List&lt;Person&gt; people = gson.fromJson(reader,typeToken.getType()); 用List生成list json1String pjson = gson.toJson(people,typeToken.getType()); java.io 80个类分4组 数据格式和传输方式 InputStreamReader 是字节 字符转换的桥梁。StreamDecoder是字节到字符解码的实现类。 FileReader 继承ISR 用SD解码用SE编码123456public class FileReader extends InputStreamReaderpublic class InputStreamReader extends Reader &#123; private final StreamDecoder sd;&#125; 123public class OutputStreamWriter extends Writer &#123; private final StreamEncoder se; IO文件File File.separator:winsows:”\”,linux”/“ windows换行符：System.lineSeparator().equals(&quot;\r\n&quot;) trueLinux：equals(&quot;\n&quot;) .list()列出目录下所有文件名.listFiles()返回File[].length()返回文件字节数 123Date last = new Date(f.lastModified());DateFormat df = new SimpleDateFormat();System.out.println(f.getName()+f.length()+df.format(last)); 过滤： 12File[] files = dir.listFiles((pathname) -&gt; pathname.getName().endsWith(".java")); 递归找文件： 展开代码 123456789101112131415 private static void findFile(File start,String file)&#123; if(start==null)return; if(start.isDirectory()) &#123; File[] list = start.listFiles(); if (list != null) &#123; for (File f : list) &#123; findFile(f,file); &#125; &#125; &#125;else&#123; if (start.getName().equals(file)) &#123; System.out.println(start.getAbsolutePath()); &#125; &#125;&#125; 字节流123456789InputStream inputStream = new FileInputStream(a);//汉字两个字节大小过小会出错byte[] bt = new byte[3];int len=-1;StringBuffer sb = new StringBuffer();while ((len=inputStream.read(bt))!=-1)&#123; //如果最后一次只读1个字节，bt[0]是新值，[1-2]是旧值，重复 sb.append(new String(bt,0,len));&#125;System.out.println(sb); InputStream 字节 ：mark() reset() 字符流顶层父类：Writer、Reader 解决不同文字编码占的字节数不同1.Reader用char[]接收1234567Reader rd = new FileReader(a);char[] buff = new char[1];StringBuffer sb = new StringBuffer();int len =-1;while((len = rd.read(buff))!=-1) &#123; sb.append(new String(buff,0,len));&#125;rd.close(); 实现： FileReader extends InputStreamReader private final StreamDecoder sd;sd.read()是一个.class LineNumberReader2.Writer append调用writeprivate char[] writeBuffer;,WRITE_BUFFER_SIZE = 1024;1.关闭流.close()、2.手动刷新、3.缓存满 之后才会把缓冲区写入文件字节流的.write()直接写3.文件复制(用字节流)12byte[] bytes = new byte[1024];int len =-1;while((len=in.read(bytes))!=-1)&#123;out.write(bytes,0,len);&#125; OutputStreamWriter Writer = InputStreamReader Reader= 4个缓冲流1.BufferedOutputStream(OutputStream)的关闭1234@SuppressWarnings("try") public void close() throws IOException &#123; try (OutputStream ostream = out) &#123; flush(); &#125; &#125; 只需要关闭外层bos的close 默认缓存大小8192 8K 使用try语法的类要实现Closeable，作用域在后面的大括号中2.BufferedReader可以readLine() 打印流PrintStream字节,PrintWriter字符添加了更多的print，只是为了遍历输出 对象流 存储到物理介质/网络传输12345678910Student st = new Student("小明",33);File store = new File("src/javacoretest/File/tryst.obj");//写try (ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(store)))&#123;oos.writeObject(st);&#125;//读try(ObjectInputStream ois = new ObjectInputStream( new FileInputStream("src/javacoretest/File/tryst.obj")))&#123; Student xiaoming = (Student) ois.readObject(); System.out.println(xiaoming);&#125; 加上serialVersionUID=1L 版本号用数组实现一组对象的存储trasient在序列化中被忽略,还原时变成默认值 字节数组流ByteArrayInputStream ByteArrayOutputStream内存操作与文件无关，每次读取一个字节，处理字符串，无需关闭从String中得到过滤出全部字母展开代码 12345678910String s = "12345dadfa(*dafAAAdaf@$#234";ByteArrayInputStream bais = new ByteArrayInputStream(s.getBytes());ByteArrayOutputStream baos = new ByteArrayOutputStream();int curr =-1;while((curr=bais.read())!=-1)&#123; if((curr&gt;=65&amp;&amp;curr&lt;=90)||curr&gt;=97&amp;&amp;curr&lt;=122)&#123; baos.write(curr); &#125;&#125;System.out.println(baos.toString()); 数据流DataInputStream DataOutputStream按java基本数据类型,与机器底层无关.writeInt(10) 对应.readXXX.wirteByte(1).writeUTF(&quot;中文&quot;) 分割文件void divide(File target,long cutSize) 123456789for (int i = 0; i &lt;n ; i++) &#123; out = new BufferedOutputStream(new FileOutputStream("src/javacoretest/File/"+(i+1)+".txt")); ... if((len = in.read(bytes))!=-1)&#123; out.write(bytes, 0, len); out.flush(); &#125; out.close();&#125; 合并文件 合并流SequenceInputStream 123456Vector&lt;InputStream&gt; v = new Vector&lt;&gt;();Eumeration es = v.elements();SequenceInputStream sis = new SequenceInputStream(es);sis.read(bytes);bos.write(bytes,0,len);bos.flash(); 字符串流StringReader StringWriterStringTokenizer流标记器1if(st.nextToken()==StreamTokenizer.TT_WORD)cnt++; RandomAccessFile在jdk1.4中nio 被内存映射文件 替代复制文件12RandomAccessFile r = new RandomAccessFile("a.txt","r");RandomAccessFile w = new RandomAccessFile("c.txt","rw"); seek 实现文件续传 Properties 工具类 extends HashtableResourceBundle只能读取12345678910Properties p = new Properties();InputStream cfg = new FileInputStream...p.load(cfg);String name = p.getProperty("username");//放到内存中 setProperty调用的也是putp.put("passwd","dafdafa");String pw = p.getProperty("passwd");//写OutputStream out = new FileOutputStream...p.store(out,"updatatatata"); 可以通过类加载器加载1InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("src/a.p"); 清除所有的键值对p.clear(); 压缩ZipOutputStream压缩 z.putNextEntry(new ZipEntry(name));ZipEntry(String name) 创建条目解压 zIn.getNextEntry() 内存缓存区1outBuf.put(inBuf.get()); Path get file.toPath() FileSystem.getDefault().getPath(“”,); Files工具类 copy move delete deleteifExists]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-Collection]]></title>
    <url>%2F2018%2F04%2F28%2Fjava-Collection%2F</url>
    <content type="text"><![CDATA[集合框架 三大接口：Iterator,Collection,Map 工具类：Collections Arrays Java提供的默认排序方法1.Arrays.sort()2.Collections.sort()（底层是调用 Arrays.sort()） 1.对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序DualPivotQuicksort.javatypically faster than traditional (one-pivot) Quicksort implementations DualPivotQuicksort2.对象数据类型 使用TimSort 归并和二分插入排序（binarySort）结合的优化排序算法思路：查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。 Collections.sort-&gt;list::sort-&gt;Arrays.sort-&gt;TimSort.sort{1, 2, 3, 4, 5, 9, 7, 8, 10, 6} 输出 6{9,8,7,6,5,4, 10}输出6 并且reverse(0,6)-&gt;[4, 5, 7, 6, 8, 9, 10]展开代码 1234567891011121314151617181920212223242526private static &lt;T&gt; int countRunAndMakeAscending(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (c.compare(a[runHi++], a[lo]) &lt; 0) &#123; // Descending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123; // Ascending while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo;&#125;private void reverseRange(Object[] a, int lo, int hi) &#123; hi--; while (lo &lt; hi) &#123; System.out.println(Arrays.toString(a)); Object t = a[lo]; a[lo++] = a[hi]; a[hi--] = t; &#125;&#125; 3.java8的parallelSort ForkJoin框架 package java.util;里的常用类 Vector,Arraylist,LinkedList implements List LinkedList implents Queue List,Queue,Set implememts Collection java9 of静态工厂不可变Java 9 中，Java 标准类库提供了一系列的静态工厂方法，比如，List.of()、Set.of()，大大简化了构建小的容器实例的代码量。不可变的，符合我们对线程安全的需求 Vector ArryList LinkedList的区别 同：1.都实现集合框架中的 List，有序集合。2.都可以按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容。 不同：1.Vector在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。vector:1int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity); 2.只有Vector是线程安全的。 ArrayList fianl修饰的变量，JVM也会提前给我们初始化好。??? 12345678//变量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;//构造函数，避免反复创建无用数组 指向同一个缓存Object[]数组this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA;&#125; .add(e) 创建Object数组，并拷贝 -&gt;ensureCapacityInternal(size+1)-&gt;ensureExplicitCapacity(size+1);-&gt;grow(size+1)-&gt;Arrays.copyOf-&gt;new Object[newLength]，System.arraycopy elementData[size++] = e; object的长度为10，size为逻辑长度，不是数组长度，minCapacity = Math.max(DEFAULT_CAPACITY=10, minCapacity 第一次扩容：就一个元素，在堆内存中占了10个位置 之后扩容：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//&gt;&gt;=/2 .remove(index) 1.将index+1后的numMoved个元素从index开始复制obj-&gt;obj12System.arraycopy(elementData, index+1, elementData, index, numMoved); 2.长度-1，最后一个null elementData[--size] = null; .romove(Object o) 循环查找o==null！=null-&gt;fastremove(index)(基本同上) 1234//当o！=null,按List规范重写equal!!if(o.equal(elementData[index]))&#123; fastRemove(index)&#125; Arrays @SuppressWarnings(&quot;unchecked&quot;)编译器消除警告 unchecked:执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 Arrays. vector1.ArrayListhe和Vector在用法上完全相同addElement(Object obj)和add(Object obj)没什么区别12345 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 123456 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; Vector里有一些功能重复的方法,这些方法中方法名更短的是属于后来新增的方法.更长的是原先vector的方法.而后来ArrayList是作为List的主要实现类. 线程同步不应该使用Vector 应该使用java.util.concurrent.CopyOnWriteArrayList class Stack&lt;E&gt; extends Vector&lt;E&gt; Deque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();LinkedList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, ArrayDeque循环数组https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位 void addFirst(E e)12elements[head = (head - 1) &amp; (elements.length - 1)] = e;//越界处理if (head == tail) doubleCapacity(); 1.head前有空位 2.head是0，加到最后，如果最后是tail则扩容： elements.length必需是2的指数倍，elements - 1就是二进制低位全1 跟head - 1相与之后就起到了【取模】的作用 当head-1=-1;相当于对其取相对于elements.length的补码(正数就是本身) 1234int head = 10;int length = 8;//8-&gt;1000 ;7-&gt;0111;10-1=9-&gt;1001 ;-&gt;1head = (head - 1) &amp; (length - 1); addLast12elements[tail] = e;if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); void doubleCapacity()System.arraycopy12345native void arraycopy(Object src, //原数组 int srcPos,//原数组起始位置 Object dest, //目标数组 int destPos, //起始 int length); //长度 1234567int p = head;int n = elements.length;int r = n - p; // head右边元素的个数//复制右半部分，对应上图中绿色部分System.arraycopy(elements, p, a, 0, r);//复制左半部分，对应上图中灰色部分System.arraycopy(elements, 0, a, r, p); pollFirst()删除并返回Deque首端(head)元素展开代码 1234567891011 public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result;&#125; pollLast()int t =(tail-1)&amp;(element.length-1); E peekFirst()&amp;E peekLast 返回但步删除 LinkedList 双向链表Queue queue = new LinkedList();内部静态类Node Arrays.asListString可以12String[] ss = &#123;"da","da"&#125;;List&lt;String&gt; strings = Arrays.asList(ss); 基本数据类型不行12int[] ss = &#123;1,2&#125;;List&lt;int[]&gt; ints1 = Arrays.asList(ss); 源码：基本数据类型123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 泛型泛型方法： 类型参数放在修饰符public static后，返回类型之前 元素限定&lt;T extends AutoCloseable&gt; void closeAll(ArrayList&lt;T&gt; elems)确保Array的元素类型是AutoCloseable的子类；extends表示子类型、类型限定 多个限定T extends Runnable &amp; AutoCloseable,只能有一个限定类，放在第一个，其它都是接口 Manager是Employee子类但ArrayList&lt;Manger&gt;不是ArrayList&lt;Employee&gt;子类因为123ArrayList&lt;Manger&gt; bosses = new ArrayList&lt;&gt;();ArrayList&lt;Employee&gt; empls = bosses; //非法empls.add(new Employee(...)); //可以在管理员列里添加普通成员 如果使用数组Manger[]和Employee[] 转型是合法的，但赋值会爆ArrayStoreException 如果不对ArrayList写操作，转换是安全的。可以用子类通配符 &lt;? extends Employee&gt; staff可以传Arraylist staff.get(i)可以 可以将&lt;? extends Employee&gt;转成Employee staff.add(i)不行 不能将任何对象转成&lt;? extends Employee&gt; 父类通配符&lt;? super Employee&gt;常用于函数式对象参数（用lambda调用） 泛型类型擦除1234List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();//trueSystem.out.println(l1.getClass() == l2.getClass()); 12345List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();l2.add(1);Method madd = l2.getClass().getDeclaredMethod("add",Object.class);//[1, abc]madd.invoke(l2,"abc"); 泛型约束 类型变量不能实例化 T[] result = new T[n];错误 以【方法引用】方式提供数组的构造函数Sting[]::newIntFunction&lt;T[]&gt; constr T[] result = constr.apply(n) 反射 1234567public static &lt;T&gt; T[] repeat(int n,T obj,Class&lt;T&gt; c1)&#123;//编译器不知道类型，必须转换@SuppressWarnings("unchecked") T[] result = (T[])java.lang.reflect.Array.newInstance(c1,n);for(int i=0;i&lt;n;i++)result[i]=obj;return result;&#125; 调用String[] greetings = repeat(10,&quot;Hi&quot;,String.class); 最简单的方法12345 public static &lt;T&gt; ArrayList&lt;T&gt; repeat(int n,T obj)&#123; ArrayList&lt;T&gt; result = new ArrayList&lt;&gt;(); for(int i =0;i&lt;n;i++) result.add(obj); return result;&#125; 泛型数组Entry&lt;String,Integer&gt;[]是合法的，但是初始化要@SuppressWarnings(“unchecked”)正确方法：ArrayList&lt;Entry&lt;String,Integer&gt;&gt; 1234//可以List&lt;Integer&gt;[] gen = (List&lt;Integer&gt;[]) new ArrayList[10];//可以 List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; guava组件 ImmutableList&lt;String&gt; ilist = ImmutableList.of(&quot;a&quot;,&quot;b&quot;);不可变List 过滤器 工具类Lists 1List&lt;String&gt; lit = Lists.newArrayList("aaa","ddd","bbb"); 1Collection&lt;String&gt; cl =Collections2.filter(lit,(e)-&gt;e.toUpperCase().startsWith("a")); 转换 (有问题)日期 12Set&lt;Long&gt; set = Sets.newHashSet(20170801L,20980320L,19950730L);Collection&lt;String&gt; col = Collections2.transform(set,(e)-&gt;new SimpleDateFormat("yyyy-MM-dd").format(e)); 组合函数Functions.compose(f1,f2) 用google的Function 集合操作 交集SetView&lt;Integer&gt; v1 = Sets.intersection(set, set2); 差集：只是1中没有在2中的元素.difference(s1,s2) 并集：把重复的只留一份 Mutiset无序可重复12345//输出[study, dayday, up, good x 2]String[] sp = s.split(" ");HashMultiset&lt;String&gt; hms = HashMultiset.create();for(String str:sp)&#123; hms.add(str);&#125; 获取次数123 Set&lt;String&gt; ele = hms.elementSet();for(String ss:ele)&#123; System.out.println(ss+":"+hms.count(ss));&#125; Multimap Key 可以重复，一个键对应一个Collection1234567891011121314151617//输出：// 作者2 [书3]// 作者1 [书2, 书1]Multimap&lt;String,String&gt; mmap = ArrayListMultimap.create();Map&lt;String,String&gt; map = new Hashtable&lt;&gt;();map.put("书1","作者1");map.put("书2","作者1");map.put("书3","作者2");Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iter = map.entrySet().iterator();while(iter.hasNext())&#123; Map.Entry&lt;String,String&gt; entry = iter.next(); mmap.put(entry.getValue(),entry.getKey());&#125;for(String key:mmap.keySet())&#123; Collection&lt;String&gt; value = mmap.get(key); System.out.println(key+" "+value);&#125; BiMap 双向map 键值都不能重复BiMap&lt;String,String&gt; map = HashBiMap.create();key和val可以反转map.inverse() 双键Map 行，列，值Table&lt;String,String,Integer&gt; table = HashBasedTable.create();获取条settable.cellSet() 多对多拆分成两个一对多Student和Course生成StudentAndCourse12345class StudentAndCourse&#123; private int id; private int cid;//添加在Course private int sid;//添加在Student&#125; Collections工具类排序类：针对List（set不用排序） shuffle(list)随机打乱 reverse(list) .sort()/(,Comparator c) .swap 123public static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; ArrayList: set返回旧值 123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; rotate(list,int)i移动到(i+d)%size rotate1(list, distance); : 数组实现，并且长度小于100 if (list instanceof RandomAccess ||list.size() &lt; ROTATE_THRESHOLD) leetcode的算法3展开代码 直接放在正确的位置上理解：把0位放到正确位置（distance)后，将这个位置继续当作0位，继续移动distance步，直到i回到0位1234567891011121314151617181920212223private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; distance = distance % size; if (distance &lt; 0) distance += size; if (distance == 0) return; /****以上得的了正确的distance size和distance有一个为零就不动***/ for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123; //size = 5 T displaced = list.get(cycleStart);//1.得到[0] int i = cycleStart; do &#123; i += distance; //向前走3步 if (i &gt;= size) i -= size;//对长度取模 displaced = list.set(i, displaced);//2.赋值给[3],得到[3]的值 nMoved ++;//3.每位放一次一共执行size次同时退出for循环 &#125; while (i != cycleStart); &#125; &#125; 123reverse(list.subList(0, mid));reverse(list.subList(mid, size));reverse(list); 查找 binarySearch,max,min(遍历compare/compareTo) fill(List,o)填充 （遍历调用set） frequency(c,o)c中与o相等元素数量（遍历equals) replaceAll(list,old,new)遍历equals，set 同步重建，加上代码块的锁只有vector/hashtable比较古老是安全的 synchronizedList(list)… 设置不可变的集合emptyXXX,singletonXXX,unmodifiableXXX EmptyList防空指针 UnmodifiableCollection重写了add、remove等方法，直接抛异常 singletonMapsize=1 其它 disjoint(,)没有相同元素返回true addAll(c,T...)全部加入c reverseOrder(Comparator&lt;T&gt; cmp)返回比较器12//反转排序[5, 4, 3, 2, 1] Collections.sort(list,Collections.reverseOrder()); Iterator ListIterator Enumeration Vector使用public Enumeration&lt;E&gt; elements()1234Enumeration&lt;Integer&gt; es = v.elements();while(es.hasMoreElements())&#123; System.out.println(es.nextElement());&#125; 迭代器设计模式1.迭代器接口 2.迭代器的实现（用构造函数传入（3））3.抽象类 4.具体类（return new迭代器） forEach jdk1.8 ArrayList:public void forEach(Consumer&lt;? super E&gt; action) Consumer接口：void accept(T t); 123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; Map 键值setSet&lt;Map.Entry&lt;Integer,String&gt;&gt; enry = map.entrySet(); 值Collection&lt;String&gt; cl = map.values(); forEach(BiConsumer&lt;? super K, ? super V&gt; action) 权限查询.containsKey() 遍历：1for(Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123;&#125; Map接口中的新方法 getOrDefault(Object key, V defaultValue)不存在返回默认值 1return (((v = get(key)) != null) || containsKey(key))? v: defaultValue; V putIfAbsent(K key, V value)不覆盖添加 原本的put覆盖并返回旧值 12V v = get(key);if (v == null) &#123;v = put(key, value);&#125; boolean remove(Object key, Object value)保证key和val都有 1234567 Object curValue = get(key);if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false;&#125;remove(key);return true; boolean replace(K key, V oldValue, V newValue) V compute对key位置上的kv对用BiFunction最后更新并返回计算后的值put(key, newValue); 12map.compute(1,(k,v)-&gt;v+="1");map.computeIfAbsent(5,(k)-&gt;"空空空"); merge 1map.merge(1,"222",(oldv,newv)-&gt;oldv+newv); TreeMapTreeSet12// Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); HashMap 数组+链表+（链表长度达到8，会转化成红黑树）不是同步的，支持 null 键和值 Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distributionwith a parameter of about 0.5 on average for the default resizingthreshold of 0.75,负载因子0.75的清空下，bin满足泊松分布(exp(-0.5) * pow(0.5, k) /factorial(k)).落在0的桶的概率有0.6 用树存储冲突hash when bins contain enough nodes to warrant useTREEIFY_THRESHOLD = 8; 计算hash值 【扰动函数】1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 实验：12345678910111213141516171819202122int a = (65535&lt;&lt;2)+1;//262141 111111111111111101System.out.println(a+" "+Integer.toBinaryString(a));//32是表长int hash=a^(a&gt;&gt;&gt;16);//输出：11 反转最后两位 //扰动(如果&gt;65536，右移16位) //低16与高16位`^`,混合hash的高位低位System.out.println(Integer.toBinaryString(a&gt;&gt;&gt;16));int index = (32-1)&amp;hash;/*11111111111111111011111//只取了低位-------------11110-&gt;30*/System.out.println(Integer.toBinaryString(hash));System.out.println(Integer.toBinaryString(31));System.out.println("-------------");System.out.println(Integer.toBinaryString(index));//262142 30System.out.println(hash+" "+index); put(K key, V value) {return putVal(hash(key), key putVal 123n = (tab = resize()).length;if ((p = tab[i = (n - 1) &amp; hash]) == null)//n=length=16 tab[i] = newNode(hash, key, value, null); putVal如果Node链表太长 12if (binCount &gt;= TREEIFY_THRESHOLD - 1) //TREEIFY_THRESHOLD==8 treeifyBin(tab, hash);//变成红黑树 TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;65536(2^16)&gt;&gt;&gt;16 ==1 table uses power-of-two masking 为了用&amp;2^n-1取模 2^n的table长不是素数很容易冲突 *spreads the impact of higher bits downward int类型自带hashCode范围-2147483648到2147483648 i = (n - 1) &amp; hash 插入位置 n-1=15是1111低位掩码高位归零 int长32&gt;&gt;&gt;16是int的高16位，低16与高16位^,混合hash的高位低位key1=0ABC0000 &amp; (16-1) = 0（8个16进制数，共32位）key2=0DEF0000 &amp; (16-1) = 0hashcode的1位全集中在前16位。key相差很大的pair，却存放在了同一个链表把hashcode的“1位”变得“松散”，比如，经过hash函数处理后，0ABC0000变为A02188B，0DEF0000变为D2AFC70 Hashtable 数组加链表没用二叉树数据结构一样的名字不同：hashtable:private transient Entry&lt;?,?&gt;[] table; 默认大小11hashmap: transient Node&lt;K,V&gt;[] table; LinkedHashMap 双重链表set String、Path都有很好的hash函数 顺序遍历集合TreeSet实现了SortedSet和NavigableSet接口 set的元素必须实现Comparable接口或者构造函数中有Comparator HashSet HashMap实现,用空对象占位 12345private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 保持不重复 使用HashMap的 putVal 比较hashCode相同不一定是同一个对象，再比较equals 重写放入hash的类的hashCode： LinkedHashSet 用链表记录插入的位置TreeSet 排序 需要实现Comparatable或传入Comparator，会根据compare的值覆盖，去重 NavigableSet使用元素自然顺序排序，or 用Comparator]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2018%2F04%2F23%2FJVM%2F</url>
    <content type="text"><![CDATA[标记算法引用计数法无法检测出循环引用，导致内存泄漏123456789101112public class memleak &#123; public memleak childNode;&#125;class problem&#123; public static void main(String[] args) &#123; memleak o1 = new memleak(); memleak o2 = new memleak(); // 循环引用 o1.childNode = o2; o2.childNode = o1; &#125;&#125; 可达性算法遍历所有GC Root引用链 不可达的就是垃圾。GC Root 栈帧中的本地变量表 （局部变量）方法区中常量引用/类静态属性引用对象 （类中的常量对象）本地方法栈中JNI（Native方法）的引用对象。活跃线程引用对象。 回收算法标记清除算法用可达性找到垃圾，再遍历一遍，删掉和去标记。缺点：不移动对象。只对不存活的对象删除。 会产生内存碎片。 复制算法 （半区内存回收）对象存活率低的场景（因为存活的很少，需要复制的少）（年轻代）分为对象面和空闲面， 活得从对象面复制到存活面， 内存清除。 标记整理算法适用于存活率高的场景（老年代）先标记，移动所有存活对象到前面，然后吧末端全部回收。 分代收集算法只有年轻代Minor GC（复制算法）和老年代Full GC。 年轻代有3个区 Eden:from Survivor:to Survivor = 8:1:1把Eden和from存活的复制到to区，并且存活对象年龄+1。年龄阈值-XX:MaxTernuringThreshold （或者年轻代放不下了或者对象很大(-XX:+PretenuerSizeThreshold))）之后放到老年代 Full GC 老年代用标记清理/整理的时候一般年轻代也要整理，所以叫Full GC1）老年代空间不足2）使用GMS GC 出现……3）升级到老年代大于老年代剩余空间4）System.gc()5) 使用RMI进行RPC或管理的 JDK应用 每小时一次Full GC G1收集器堆划分成多个Region 引用类型java 将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除（我会在专栏的第二部分详细介绍），因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。 说到字节流，最常见的形式要属由 Java 编译器生成的 class 文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java applet）字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。 对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。 除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。 双亲委派模型双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。 类加载器Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。 jmx链接 远程tomecat配置Catalina.sh加上java_opt里的jmx端口本机virtlalVM直接输入远程ip:端口就能监控了 27个点 内存占20G堆内存-Xmx12mhttps://www.jianshu.com/p/1b1c998c4448 jstack 发现死锁 jstack pid &gt; out.txthttps://toutiao.io/posts/1ogbep/preview打印所有工作线程 包括析构Finalizer，JIT还有debug的线程状态有6个 javap 字节码指令12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 JVM是基于栈的架构：指令短，指令数多一般x86是基于寄存器的架构：指令长，指令集小 bytecode-viewerjava -XX:MaxHeapSize=734003200 -jar .\Bytecode-Viewer-2.9.11.jar jclasslib bytecode viewer jstat 查看类加载/GC/JIT编译信息jstat官网 jinfo 查看运行中的jvm参数123&gt;jinfo -flag MaxHeapSize 1972-XX:MaxHeapSize=734003200&gt;jinfo -flag ThreadStackSize &lt;进程号&gt; 打印进程Non-default参数（被赋值过的）1&gt;jinfo -flags 1972 展开代码 123456Attaching to process ID 1972, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.144-b01Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=132120576 -XX:MaxHeapSize=734003200 -XX:MaxNewSize=244318208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44040192 -XX:OldSize=88080384 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCCommand line: -Xmx700m -Djava.awt.headless=true -Djava.endorsed.dirs="" -Djdt.compiler.useSingleThread=true -Dpreload.project.path=D:/demo/algLearn -Dpreload.config.path=C:/Users/cecil/.IntelliJIdea2017.2/config/options -Dcompile.parallel=false -Drebuild.on.dependency.change=true -Djava.net.preferIPv4Stack=true -Dio.netty.initialSeedUniquifier=1077334432047011613 -Dfile.encoding=GBK -Djps.file.types.component.name=FileTypeManager -Duser.language=zh -Duser.country=CN -Didea.paths.selector=IntelliJIdea2017.2 -Didea.home.path=C:\Program Files\JetBrains\IntelliJ IDEA 2017.2.5 -Didea.config.path=C:\Users\cecil\.IntelliJIdea2017.2\config -Didea.plugins.path=C:\Users\cecil\.IntelliJIdea2017.2\config\plugins -Djps.log.dir=C:/Users/cecil/.IntelliJIdea2017.2/system/log/build-log -Djps.fallback.jdk.home=C:/Program Files/JetBrains/IntelliJ IDEA 2017.2.5/jre64 -Djps.fallback.jdk.version=1.8.0_152-release -Dio.netty.noUnsafe=true -Djava.io.tmpdir=C:/Users/cecil/.IntelliJIdea2017.2/system/compile-server/alglearn_d660bc04/_temp_ -Djps.backward.ref.index.builder=true -Dkotlin.incremental.compilation.experimental=true -Dkotlin.daemon.enabled -Dkotlin.daemon.client.alive.path="C:\Users\cecil\AppData\Local\Temp\kotlin-idea-4845382868272217760-is-running" jpsjps官网1234jps -l5392 sun.tools.jps.Jps1972 org.jetbrains.jps.cmdline.Launcher6500 JVM参数1.java -help XX参数(JVM调优和Debug) Boolean类型格式：-XX:[+-]&lt;name&gt; 启用或禁用name属性启用CMS垃圾回收器-XX:+UseConcMarkSweepGC启用G1垃圾回收器-XX:+UseG1GC 非boolean kv类型格式：-XX:&lt;name&gt;=&lt;value&gt;GC最大停顿时间-XX:MaxGCPauseMillis=500 -Xmx -Xms-Xms等价于-XX:InitialHeapSize-Xmx等价于-XX:MaxHeapSize-Xss线程堆栈大小 X参数（非标准化参数）各个版本可能会变 不常用java代码是解释执行的，JIT编译信息 即时编译 java代码转化成本地代码-Xint 完全解释执行（不转换成本地代码-Xcomp 第一次就编译成本地代码-Xmixed 混合模式JVM自己决定是否将java代码转本地代码mixed mode:1234java -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode) 解释模式：1234java -Xint -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, interpreted mode) 编译模式：1234java -Xcomp -versionjava version "1.8.0_144"Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, compiled mode) 堆外内存64位的JVM 寻址空间类装载器12345678910/* 只有jvm能创建 * Private constructor. Only the Java Virtual Machine creates Class objects. * This constructor is not used and prevents the default constructor being * generated. */private Class(ClassLoader loader) &#123; // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; &#125; 装载：（磁盘-&gt;内存）1）取得类的二进制流：装载器ClassLoader 读入java字节码装在到JVM2）放到方法区3）在堆中生成java.lang.Class对象 封装方法区的数据结构 链接：1.验证 符合jvm对字节码的要求2.准备 为static final静态变量 分配内存，并初始化默认值。(还没生成对象)3.解析 符号引用转换成指针or地址偏移量（直接引用）（内存中的位置） 初始化：静态变量赋值（用户赋值）&lt;clint&gt; lang.NoSuchFiledError 最终结果是堆区的class对象，提供了访问方法区的接口（反射接口） 主动使用6种1.创建类实例2.读写静态变量3.调用静态方法4.反射Class.forName 5.初始化类的子类 6.启动类其它都是被动使用，都不会类初始化 jvm用软件模拟java字节码的指令集jvm规范定义了：returnAddress数据类型 指向操作码的指针;输出整数的二进制123456789public static void main(String[] args) &#123; int a = 6; //0x80000000表示最高位为1的数字 for(int i =0;i&lt;32;i++)&#123; //取出a的第一位 //无符号右移( &gt;&gt;&gt; ) int t = (a&amp;0x80000000&gt;&gt;&gt;i)&gt;&gt;&gt;(31-i); System.out.print(t); &#125; &#125; public native String intern();运行期间放入常量池]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2018%2F04%2F23%2Fcpp%2F</url>
    <content type="text"><![CDATA[有符号和无符号123456789#include&lt;stdio.h&gt;int main(void)&#123; unsigned int a = 1; signed int b = -3; int c; (a+b&gt;0)?(c=1):(c=0); printf("%d",c); return 0;&#125; 答案 1无符号号整数和有符号整数相加，有符号整数转化为无符号整数. 赋值兼容规则也适用于多重继承的组合赋值兼容规则是指在需要【基类对象】的任何地方都可以使用【公有派生类的对象】来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员，而且所有成员的访问控制属性也和基类完全相同。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。 赋值兼容规则中所指的替代包括以下的情况： 派生类的对象可以赋值给基类对象。 派生类的对象可以初始化基类的引用。 派生类对象的地址可以赋给指向基类的指针。 库文件中间目标文件(.obj,.o的打包叫 库文件 .lib,.a 链接在所有目标文件中寻找函数实现。 makefiletarget:prerequisitestarget 中一个或多个 依赖于 preprequisites 中的文件，如果 preprequisites 有一个比target新，command就执行。 const int给出以下定义，下列哪些操作是合法的？12const char p1 = “hello”;char const p2 = “world”;正确答案: A 你的答案: B (错误)p1++;p1[2] = ‘w’;p2[2] = ‘l’;p2++;即 const在的左边不能改变字符串常量的值，故B错；const在的右边不能改变指针的指向，故D错；若要修改其值，应该改为char str []= “world”;“hello”这样声明的字符串是存储在只读存储区的，不可修改，所以B,C都错误 正确答案: A B C 你的答案: A C E (错误)const int a; //const integerint const a; //const integerint const *a; //a pointer which point to const integerconst int *a; //a const pointer which point to integerint const *a; // a const pointer which point to integer123456p是一个常量指针，指向一个普通变量int *const p; /* p is a const pointer to int */p是一个常量指针，指向一个常量const int *const p; /* p is a const pointer to int const */int const *const p; /* p is a const pointer to const int */ ！！inline 错2次static inline 如果不加static，则表示该函数有可能会被其他编译单元所调用，所以一定会产生函数本身的代码。所以加了static，一般可令可执行文件变小。编译时不会为内联函数单独建立一个函数体。 关于c++的inline关键字,以下说法正确的是()正确答案: D 你的答案: B/C (错误)A使用inline关键字的函数会被编译器在调用处展开 编译器有权忽略这个请求，比如：若此函数体太大，则不会把它作为内联函数展开的。 B头文件中可以包含inline函数的声明 头文件中不仅要包含 inline 函数的声明，而且必须包含定义，且在定义时必须加上 inline C可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数 inline 函数可以定义在源文件中，但多个源文件中的同名 inline 函数的实现必须相同。 D定义在Class声明内的成员函数默认是inline函数 类内的成员函数，默认都是 inline 的。 D优先使用Class声明内定义的inline函数E优先使用Class实现的内inline函数的实现 不管是 class 声明中定义的 inline 函数，还是 class 实现中定义的 inline 函数，不存在优先不优先的问题，因为 class 的成员函数都是 inline 的，加了关键字 inline 也没什么特殊的。 ！！指针 错两次1234567main()&#123; char*a[]=&#123;"work","at","alibaba"&#125;; char**pa=a; pa++; printf("%s",*pa);&#125; 正确答案: A 你的答案: C (错误)at // 因为pa还是指向最外层的数组atalibabaorkorkatalibaba编译错误 错第二次1234567struct st&#123; int *p; int i; char a;&#125;;int sz=sizeof(struct st); 如下C程序,在64位处理器上运行后sz的值是什么?正确答案: C 你的答案: B (错误)2420161413121.struct的对齐原则，必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐?此处指针先占用8字节。int占用4字节，满足要求不用补齐，char占用一个字节，同时总的字节数必须满足8的倍数即16 第二次错1234567891011121314151617181920212223242526#include &lt;iostream&gt; #include &lt;vector&gt;using namespace std;int main(void)&#123; vector&lt;int&gt;array; array.push_back(100); array.push_back(300); array.push_back(300); array.push_back(300); array.push_back(300); array.push_back(500); vector&lt;int&gt;::iterator itor; for(itor=array.begin();itor!=array.end();itor++) &#123; if(*itor==300) &#123; itor=array.erase(itor); &#125; &#125; for(itor=array.begin();itor!=array.end();itor++) &#123; cout&lt;&lt;*itor&lt;&lt;""; &#125; return 0;&#125; 下面这个代码输出的是()正确答案: C 你的答案: F (错误)100 300 300 300 300 500100 3OO 300 300 500100 300 300 500100 300 500100 500程序错误 vector::erase()：从指定容器删除指定位置的元素或某段范围内的元素如果是删除指定位置的元素时：返回值是一个迭代器，指向删除元素下一个元素; 循环语句whlie(int i=0 )i–;的循环次数是0 静态方法？123456789有如下类的定义：class Constants&#123; public: static double GetPI(void)&#123;return 3.14159;&#125;&#125;; Constants constants;下列各组语句中，能输出3.14159的是：cout&lt;&lt;Constants::GetPI();和cout&lt;&lt;constants.GetPI(); 静态成员下面关于一个类的静态成员描述中,不正确的是()正确答案: C 你的答案: E (错误)A静态成员变量可被该类的所有方法访问B该类的静态方法只能访问该类的静态成员函数C该类的静态数据成员变量的值不可修改D子类可以访问父类的静态成员E静态成员无多态特性 多态性是要通过指针或者引用才能体现出来的 构造函数？构造函数的工作是在创建/声明对象时自动执行的。 错误：构造函数可以对静态数据成员进行初始化 默认参数C++语言中，对函数参数默认值描述正确的是：在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值 错误：函数参数的默认值只能设定一个函数参数必须设定默认值 拷贝构造函数通过使用另一个同类型的对象来初始化新创建的对象。对拷贝构造函数的描述正确的是：正确答案: B DA该函数名同类名，也是一种构造函数，该函数返回自身引用B该函数只有一个参数，必须是对某个对象的引用C每个类都必须有一个拷贝初始化构造函数，如果类中没有说明拷贝构造函数，则编译器系统会自动D成一个缺省拷贝构造函数，作为该类的保护成员拷贝初始化构造函数的作用是将一个已知对象的数据成员值拷贝给正在创建的另一个同类的对象 编译器可以跳过拷贝构造函数，直接创建对象 以下代码共调用多少次拷贝构造函数：12345678910Widget f(Widget u)&#123; Widget v(u); Widget w=v; return w;&#125;main()&#123; Widget x; Widget y=f(f(x));&#125; 正确答案: 7 字符串 长度 缓冲区溢出 字符串 长度O（N） C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。 字符串缓冲区溢出char *strcat(char *dest, const char *src); C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 ， 其中 s1 保存了字符串 “Redis” ， 而 s2 则保存了字符串 “MongoDB” 执行strcat(s1, &quot; Cluster&quot;); 会把s2覆盖掉 emplace_back()和push_back()emplace_back()更节省空间边集&lt;u,v,cost&gt;-&gt;邻接表1234unordered_map&lt;int,vector&lt;pair&lt;int,int&gt; &gt; &gt; g_;for(const auto&amp; e: flights)&#123; g_[e[0]].emplace_back(e[1],e[2]);&#125; 大端小端union的存放顺序是所有成员都从低地址开始存放一般操作系统都是小端，而通讯协议是大端的。常见文件的字节序1234567Adobe PS – Big EndianBMP – Little EndianDXF(AutoCAD) – VariableGIF – Little EndianJPEG – Big EndianMacPaint – Big EndianRTF – Little Endian 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;bool IsBigEndian2()&#123; union NUM &#123; //低地址 int a; char b; &#125;num; num.a = 0x1234; if( num.b == 0x12 ) &#123; return true; &#125; return false;&#125;bool IsBigEndian()&#123; //8bit的char int a = 0x1234; //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分 char b = *(char *)&amp;a; if( b == 0x12) &#123; std::cout&lt;&lt;b; return true; &#125; return false;&#125; #include&lt;pthread.h&gt;https://sourceware.org/pthreads-win32/pthreads-w32-2-9-1-release.zipinclude:C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\includelib:C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.14.26428\libdll:x86C:\Windows\SysWOW64dll:x64C:\Windows\System3212#include &lt;pthread.h&gt;#pragma comment(lib,"pthreadVC2.lib") 编译错误C2011 “timespec”:“struct”类型重定义可修改pthread.h文件，在1234#if !defined( PTHREAD_H )#define PTHREAD_H下面加上一行宏定义#define HAVE_STRUCT_TIMESPEC 可以解决“timespec”:“struct”类型重定义错误 1 4 00 10 15 2010 0 35 2515 35 0 3020 25 30 0并行tsp12345678910111213141516171819202122232425262728293031323334353637383940```### MS-MPIhttps://blog.csdn.net/u011514451/article/details/50675222编译期常量constexpr### static_cast强制类型转换### 拓扑排序![topu.jpg](https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/topu.jpg)### 树结构review树结构是为了对vector(数组)和list(链表)的静态操作(search)和动态操作(insert,remove)效率的平衡。1. 任何树，边数(e)=所有顶点度数之和=顶点总数(n)-1 意义：边数与顶点数是同阶的O(n)可以拿顶点数做复杂度的参照2. 路径长度复杂度以边数定义会简化算法描述3. 数和无环和连通的关系：1.无环连通图，2.极小连通图，3.极大无环图 结论：1.任一节点v与【根】存在【唯一】路径，记作path(v)4. 路径(path (from root) to v)、节点、子树(subtree (rooted at) v)是等价类，互相指代 结论：v的深度:depth(v)=|path(v)| 树根深度为0 树是半线性结构：前驱(父节点)是唯一的，后继不唯一，图则都不唯一。 叶子节点中深度最大的为(子)树的高度$height(v) + depth(v) &lt;= height(T)$,单个节点高度为0，空树高度为-1。#### 树存储结构1.`rank[n],data[n],parent[n]`,空间O(n) 时间： 1. 访问父节点`parent()` O(1) 2. `root()`一直沿着`parent[]`到-1 O(n),可以将根放在`rank[0]`变成O(1) 3. 但是找长子O(n)遍历`rank[i]`的parent 兄弟节点也是O(n)2. 将`parent[]`变成指针`child[n]`，指向子节点，子节点的查找效率是度数，但是查找parent变成O(n)3. 保留parent[n]也添加child[n]保证了parent和child的查找速度，但是child指向的list可能是O(n)4. 儿子兄弟法 可以用二叉树表示所有的树#### 二叉树1. 每一层$2^k$个节点2. 树的节点数 $h&lt; n&lt;2^&#123;h+1&#125;$3. 为简化算法思考，为叶子节点加上2个子节点(null)，将每个节点补齐度为2 BinNode:lchild parent rchild dataheight npl(左氏堆) colorsize12345671. 插入左/右孩子```cpp//data和父节点template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;:: insertAsRC(T const &amp;e)&#123; return lchild = new BinNode(e,this);&#125;return rchild = new BinNode(e,this); 计算后代数量O(n) 1234567template &lt;typename T&gt;int BinNode&lt;T&gt;:: size()&#123; int s = 1;//本身 if(lChild) s+=lChild.size(); if(rChild) s+=rChild.size(); return s;&#125; BinTree模板类 1234567891011121314template &lt;typename T&gt; class BinTree&#123; protected: int _size; //树根节点的位置 BinNodePosi(T) _root; //各种二叉树对高度的定义和更新的方法不同 virtual int updateHeight(BinNodePosi(T) x); //更新了一个节点之后更新所有祖先的高度 void updateHeightAbove(BinNodePosi(T) x); public: int size() const &#123;return _size;&#125;//规模 bool empty() const &#123;return !_root;&#125;//判空 BinNodePosi(T) root() const &#123;return _root;&#125;//树根&#125; 高度更新(最深叶节点path) 12345//使用宏定义 空树 h=-1#define stature(p) ((p)?(p)-&gt;height:-1);int BinTree&lt;T&gt; ::updateHeight(BinNodePosi(T) x)&#123; return x-&gt;height = 1+max(stature(x-&gt;lChild),stature(x-&gt;rChild));&#125; 更新了x节点的高度，x的父节点们的高度也高更新O(n=depth(x)) 123456template&lt;typename T&gt;void BinTree&lt;T&gt;:: updateHeightAbove(BinNodePosi(T) x)&#123; while(x)&#123; updateHeight(x);x= x-&gt;parent; &#125;&#125; 节点插入 1234567template &lt;typename T&gt; BinNodePosi(T)BinTree&lt;T&gt; ::insertAsRC(BinNodePosi(T) x,T const &amp;e)&#123; _size++; x-&gt;insertAsRC(e); updateHeightAbove(x); return x-&gt;rChild;&#125; 6. 先序遍历$T(n) =O(1)+T(a)+T(n-a-1) =O(n)$问题是每个递归帧虽然是O(1)但是每个帧差很大，而且是尾递归能用栈优化1234567template &lt;typename T,typename VST&gt;void traverse(BinNodePosi(T) x,VST &amp;visit)&#123; if(!x)return; visit(x-&gt;data); traverse(x-&gt;lChild,visit); traverse(x-&gt;rChild,visit);&#125; 迭代版本1：1234567891011template &lt;typename T,typename VST&gt;void traPre_v1(BinNodePosi(T) x,VST &amp; visit)&#123; //存放位置（引用） Stack&lt;BinNodePosi(T)&gt; s; if(x)s.push(x); while(!s.empty())&#123; x = s.pop();visit(x-&gt;data); if(HasRChild(*x))s.push(x-&gt;rChild); if(HasLChild(*x))s.push(x-&gt;lChild); &#125;&#125; 先放入栈右子树再入栈左子树。不能推广到中序、后序遍历12345while(!s.empty())&#123; x=s.pop();visit(x); if(root.right!=null)stack.push(root.right); if(root.left!=null) stack.push(root.left);&#125; 迭代版本2： 沿着左孩子下行，到左侧空了之后向上遍历刚才没访问的右子树12345678910111213template &lt;typename T,typename VST&gt;static void visitAlongLeftBranch( BinNodePosi(T) x, VST &amp; visit, Stack &lt;BinNodePosi(T)&gt; &amp;s)&#123; //3.pop出的x是null while(x)&#123; visit(x-&gt;data); //1. 如果x是叶子，右节点是null也push了 s.push(x-&gt;rChild); x=x-&gt;lChild; &#125;&#125; 主算法1234567891011template &lt;typename T,typename VST&gt;void trapRE_v2(BinNodePosi(T) x,VST&amp; visit)&#123; Stack &lt;BinNodePosi(T)&gt; S; while(true)&#123; visitAlongLeftBranch(x,visit,S); if(S.empty())break; //进入了以x为根节点的子树 //2. x是叶子节点右指针null x = s.pop(); &#125;&#125; 中序遍历O(n)1.不是尾递归2.一直向左，到左边没有了visit，再访问右子树，回到原来左链上的上个节点访问并继续右子树左侧链上的每个节点是一个阶段，都是相同的，上一个节点访问的时候可以当下一个节点不存在将所有左节点入栈，最后弹出访问并访问右子树12345678910111213141516171819template &lt;typename T&gt;static void goAlongLeftBranch(BinNodePosi(T) x,Stack &lt;BinNodePosi(T)&gt; &amp;S)&#123; //O(n)但是所有左侧链的长度合在一起也是O(n) 每个节点只入栈一次 while(x)&#123;S.push(x);x=x-&gt;lChild;&#125;&#125;template &lt;typename T,typename V&gt; void traIn_v2(BinNodePosi(T) x,V&amp; visit)&#123; Stack &lt;BinNodePosi(T)&gt; S; while(true)&#123; goAlongLeftBranch(x,S); if(S.empty())break; //x的左子树为空 x = S.pop(); //O(n) visit(x-&gt;data); //进入右子树分支 x = x-&gt;rChild; &#125;&#125; 层次遍历12345678910111213template &lt;typename T&gt; template &lt;typename Vst &gt;void BinNode&lt;T&gt;::travLevel(VST &amp; visit)&#123; Queue&lt;BinNodePosi(T)&gt; Q; //根 Q.enqueue(this); while(!Q.empty())&#123; BinNodePosi(T) x = Q.dequeue(); visit(x-&gt;data); //先进先出 if(HasLChild(*x)) Q.enqueue(x-&gt;lChild); if(HasRChild(*x)) Q.enqueue(x-&gt;rChild); &#125;&#125; [先序|后序]+中序可以还原唯一的二叉树先序[r][L][R]中序[L][r][R]左右子树为空不会有歧义 而先序和后序无法分别到底是左子树还是右子树先序 [r][L] 右空 [r][R] 左空后序 [L][r] 右空 [R][r] 左空 每个节点的度是0或2的真二叉树可以由先序，后序还原。左右子树同时为空/非空 图 简单路径：不含重复顶点 欧拉图：一笔画 所有边经过所有顶点、所有边的闭路径（边不重复，允许顶点重复） 欧拉路径：经过所有顶点，所有边的路径（边不重复，顶点重复） 不是闭路径（不需要回到原地）。 欧拉图判定条件：无向图：G是连通的，所有顶点的度都是偶数。有向图：G弱连通，每个顶点的出度和入度相等 欧拉路径判定条件：无向图：G连通，恰有两个顶点的度是奇数。从一个奇数顶点出发，到另一个奇数度顶点结束。有向图：G连通，恰两个顶点出度入度不相等，其实于出度多1的终结与入度多1的。 哈密顿图 所有顶点一条经过所有顶点的回路（不要求经过所有边） 哈密顿通路：经过所有顶点的通路，不要求回路 充分条件：满足： 是哈密顿图 resigter 寄存器变量存放在寄存器中，调用时直接从寄存器中取出参加运算。 对象像指针*,-&gt;智能指针 包装类修改指针的行为 像一个指针-&gt;会对作用到的结果一直作用下去operator*() operator -&gt; () 写法固定 迭代器 包括智能指针，++,–对象像函数()转换函数当编译器遇到要把该类转换成double类型时，调用double explicit 用在构造函数前non-explicit-one-argument 可以把4转换成fraction用了explicit不能自动调用构造函数转型 委托：delegation,空心菱形表示有。又称Composition by reference 生命周期不同步 handle/body(impl)组合：实心菱形 生命周期同步组合是part在内，继承是base在内 cpp继承有三种 java只有public不用写继承的base class的构造函数必须是virtual不然西沟就不会先子类再base1struct ListNode:public _list_node_base&#123;&#125;; 虚函数成员函数有3种12345678class Shap&#123;//纯虚函数 所有子类必须重新定义virtual void draw() const = 0;//可以重新定义virtual void error(const std::string&amp; msg);//不让子类overrideint objId() const;&#125;; delegation+继承组合模式（文件/文件夹）原型模式，继承框架类，将自己定义的新类加入框架让框架调用 静态方法要在类外给内存 .h头文件写法conplex.h1234#ifndef __COMPLEX__#define __COMPLEX__...#endif 语法制导翻译：类型检查/中间代码生成向文法的产生式附加一些规则（或程序片段）语法分析过程时相应的程序片段会被执行。在语法分析的过程中结合语义动作。 语法指导定义 上下文无关文法和属性及规则集合。规则：语义规则 和产生式相关联。属性与文法相关联 splice emplace_front map:find找到第一个相等的元素 iterator :.cend()容器最后面 把vector中的一个元素移动到最前面 12//it-&gt;second map中的值，指向结点的指针list.splice(list.begin(),list,it-&gt;second); 查找vector中的最大最小元素*max_element(first,end) multiset和set在c++里是有序的，是红黑树，用*set.rbegin()可以获得最大值.erase()会遍历删除所有相同的元素，.equal_range()限定范围 123456multiset&lt;int&gt; s;s.insert(5);s.insert(5);s.insert(5);//只删除了第一个5s.erase(s.equal_range(5).first); c++ 的deque：用指针取头尾的连续存储 advance(it,5)将迭代器移动5次，迭代器*it指向第6个元素 dummy标记[0]元素?????? vector1.swap(v2) 与另一个vector交换数据 unordered_set 拉链法hash表 #include读 hash-include ; 读semicolon auto 类型由编译器自动推断 explicit 禁止隐式转换 成员初始化列表语法 继承关系： 共有继承：is a == is a kind of关系不可逆 香蕉是一种水果，水果不是香蕉 has a 午餐包括水果 is like a 律师像鲨鱼 is implemented as a 栈用数组实现 uses a 计算机可以使用打印机使用友元通信 多态：派生类使用基类的方法；方法行为随上下文，取决于调用该方法的对象。 在派生类中重新定义基类方法 虚方法:根据引用/指针指向的对象 的类型选择方法.派生类回重新定义的方法，在基类中应为虚的。 派生通过 作用域解析运算符 调用基类方法 虚函数原理： 每个对象由隐藏成员，是虚函数表（virtual function table） _vtbl,所有虚函数的地址表 例程 fprintf]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVVM]]></title>
    <url>%2F2018%2F04%2F19%2FMVVM%2F</url>
    <content type="text"><![CDATA[实现myvue.b=222页面刷新 1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234let myvue = new myVue(&#123; el:'#app', data:&#123;a:&#123;a:&#123;a:1&#125;&#125;,b:'aaaaaaaaaaa'&#125; &#125;); 12345678910111213141516171819function myVue(options=&#123;&#125;) &#123;//传入的对象（&#123;el:,data:&#125; //将所有属性挂载在$opthion this.$options = options var data = this._data=this.$options.data //用data别名._data observe(data)//-----------&gt;数据劫持 for(let key in data)&#123; //--&gt; this代理了this._data Object.defineProperty(this,key,&#123; enumerable:true, get()&#123; return this._data[key]//this.a=&#123;a:1&#125; &#125;, set(newVal)&#123; this._data[key]=newVal &#125; &#125;) &#125; ///-------渲染 new Compile(options.el,this)&#125; 数据劫持（观察者）对_data定义get/set属性 123456789101112131415161718192021222324252627282930function Observer(data) &#123; for(let key in data)&#123; // let dep = new Dep() let val = data[key] observe(val)//递归 Object.defineProperty(data,key,&#123; enumerable:true, get() &#123; // -- watcher里的this //只有target绑定了this(Watcher函数) 才把watcher函数放入dep队列 Dep.target&amp;&amp;dep.addSub(Dep.target) return val; &#125;, set(newVal)&#123; if(newVal===val)return val=newVal //----深度数据劫持myvue.a=&#123;a:1&#125; 里面的a也有get/set observe(newVal) // dep.notify() &#125; &#125;) &#125;&#125;//观察对象，给对象添加define...function observe(data) &#123; if(typeof data !== 'object')return //为方便递归 return new Observer(data)&#125; 渲染 123456789101112131415161718192021222324252627282930313233343536function Compile(el,vm) &#123; vm.$el=document.querySelector(el); //创建文档碎片 let fragment = document.createDocumentFragment(); // console.log(vm.$el.firstChild) //移到内存中 while(child = vm.$el.firstChild)&#123; fragment.appendChild(child) &#125; replace(fragment) function replace(fragment) &#123; //从DOM元素节点集合返回一个数组 Array.from(fragment.childNodes).forEach(function (item) &#123; let text = item.textContent let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/ //nodeType=3文本节点 if(item.nodeType===3&amp;&amp;reg.test(text))&#123; //获取匹配的第一个分组 //是标签 nodeType=1 let arr = RegExp.$1.split('.')//[a.a] let val = vm//----&gt;vm=myvue arr.forEach(function (k) &#123;//val=vm[a]-&gt;val=vm[a][a] val = val[k] &#125;) // //----------- 监听替换位置 // new Watcher(vm,RegExp.$1,function (newVal) &#123; // item.textContent = text.replace(reg,newVal) // &#125;) item.textContent = text.replace(reg,val)&#125; if(item.childNodes)&#123; replace(item) &#125; &#125;) &#125;&#125; 订阅器：接受更新重新渲染 订阅器[fn1,fn2]方法集合 1function Dep() &#123;this.subs =[]&#125; 订阅器添加方法、订阅器中方法全部执行(约定订阅”update方法”) 1234567Dep.prototype.addSub= function (sub) &#123; this.subs.push(sub)&#125;//假设每个方法里都有update方法 遍历激活Dep.prototype.notify= function () &#123; this.subs.forEach(sub=&gt;sub.update())&#125; 订阅者（Dep数组中的方法类，被激活的方法类) 在观察者Observer中注册let dep = new Dep() 订阅事件在渲染Compile中 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) 定义watcher并添加到订阅中 12345678910111213 function Watcher(vm,exp,fn) &#123; this.fn = fn this.vm= vm this.exp = exp Dep.target = this; let val = vm; let arr = exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) Dep.target=null&#125; 调用get方法更新时添加Dep.target&amp;&amp;dep.addSub(Dep.target) 在set中执行订阅器中所有watcher的方法dep.notify() 12345678910 Watcher.prototype.update=function () &#123; //取最新的值 let val = this.vm let arr = this.exp.split('.') arr.forEach(function (k) &#123;//调用get方法 val = val[k] &#125;) //将新值传给回调函数 this.fn(val)&#125; this.fn(val)回调函数会回到渲染中,用新值替换 123new Watcher(vm,RegExp.$1,function (newVal) &#123; item.textContent = text.replace(reg,newVal) &#125;) ====效果：1.myvue.b放入队列2.myvue.b=222先调用set，调用notify3.执行watcher的update4.回调函数fn更新页面 实现v-model 双向数据绑定1&lt;div id="app"&gt;&lt;p&gt;&#123;&#123;a.a.a&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;b&#125;&#125;&lt;/p&gt;&lt;input type = "text" v-model="b"&gt;&lt;/div&gt; 找到带v-的元素并获得v-model绑定的属性；在渲染中添加监听器；并添加触发事件12345678910111213141516171819202122if(item.nodeType==1)&#123; //如果是元素节点 获取所有dom属性 let nodeAttrs = item.attributes; Array.from(nodeAttrs).forEach(function (attr) &#123; //获取v-model后的属性 //b if(attr.name.indexOf('v-')==0)&#123; let exp = attr.value //初始输入框填值 item.value = vm[exp] //订阅每次更改都更新 new Watcher(vm,exp,function (newVal) &#123; item.value = newVal &#125;) //定义触发事件 item.addEventListener('input',function (e) &#123; console.error(e) let newVal = e.target.value vm[exp] = newVal//调用set方法-&gt;notify-&gt;更新watcher &#125;) &#125; &#125;) &#125; 实现computed的缓存 绑数据挂到vm上1&lt;div&gt;&#123;&#123;hello&#125;&#125;&lt;div&gt; 12345computed:&#123; hello()&#123; return this.b+this.a &#125; &#125; 1234function myVue(options=&#123;&#125;) &#123; ... initComputed.call(this)&#125; 12]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[About-js]]></title>
    <url>%2F2018%2F04%2F17%2FAbout-js%2F</url>
    <content type="text"><![CDATA[rxjshttps://cn.rx.js.org/manual/tutorial.html js 数组数字排序。（数组sort默认是字符串排序）12a = Array.of(32,286,125,192,28,41,297,413,29,64,80,4).sort((a,b)=&gt;a-b)&gt; (12) [4, 28, 29, 32, 41, 64, 80, 125, 192, 286, 297, 413] 控制台导入jq发送ajaxhttps://zju.date/ajax-request-in-chrome-console/不使用contentType: “application/json”则data可以是对象 fetch12345678fetch("http://localhost:3000",&#123; // post请求 method:"POST", headers: &#123; "Content-Type": "application/json" &#125;, body:'&#123;"welcome":"你好"&#125;'&#125;).then(res =&gt; console.log(res.json())) .catch(e=&gt;console.log("something went wrong: " + e)) 使用contentType: “application/json”则data只能是json字符串1234567891011121314var jq = document.createElement('script'); jq.src = 'http://7xsy2w.com1.z0.glb.clouddn.com/jquery-3.1.1.min.js'; //也可以放本地服务器上document.getElementsByTagName('head')[0].appendChild(jq);j=jQueryj.noConflict();j.ajax(&#123; url: 'http://localhost:8080/test/', type: "POST", data: usr, contentType:"application/json;charset=utf-8", dataType: "json", success:function() &#123;console.log('发送成功！'); &#125;, error:function() &#123; console.log('发送失败！'); &#125;&#125;); 手机端查看页面npm install http-server -ghttp-server prototypehttp://prototypejs.org/learn/event-delegation.html js unicode-&gt;中文1unescape(''); h5视频控制到指定位置并播放12345var v = document.getElementsByTagName("video")[0];v.currentTime = 10.0;v.play()//暂停v.pause() html5存储Content-Length 单位是字节DnionOS nginx？ cookie 4kdocument.cookiecookies会有主域名污染在.baidu.com放了cookie之后music子域名访问都带主域名的cookies，请求头会臃肿http-only cookie只能被服务器端读写，客户端无权限。Secure 请求只能是https 单个域名持支的cookie个数。chrome50个，长度4k与localStorage类似 不同域名独立。可以设置cookie的path和domain相同父域共享 H5之前userData 只有IE，存放成XMLindexedDB 按域名分配独立空间，一个域名多个数据库H5离线缓存 manifestnavigator.onLine检测是否在线1&lt;html lang = "en" manifest = 'manifestFile'&gt; manifestFile文件12345CACHE MANIFEST#version 1.1CACHE: img/1.jpgNETWORK 123456789window.addEventListener('load',function(e)&#123; window.applicationCache.addEventListener('updateready',function(e)&#123; if(window.applicationCache.status == window.applicationCache.UPDATEREADY)&#123; window.applicationCache.swapCache() if(confirm("是否更新页面")) window.location.reload() &#125; &#125;,fasle)&#125;,false) 改manifest版本号会更新 本地存储 子域名不能共享 h5 postMessage 共享数据 只有5个api：setItem/getItem/removeItem/clear/keyios的隐身模式没有，需要检测浏览器支持，最好的方法是先set一次1234localStorage.setItem('testkey','testvalue')localStorage.getItem('testkey')localStorage.key(9)localStorage.clear() localstorage 永不过期sessionstorage 重新打开页面/关闭浏览器 消失 每个 域名5MlocalStroage在chrome限制为2.6M 同域名一般共享 所有可以序列化的都能存到localStorage 存图片set(&#39;key&#39;)+get(&#39;key&#39;)展开代码 1234567891011121314151617181920212223242526var src = "./bd_logo1.png"function set(key)&#123; var img = document.createElement('img') img.addEventListener('load',function () &#123; var imgCanvas = document.createElement("canvas"), imgContext = imgCanvas.getContext("2d"); imgCanvas.width = this.width; imgCanvas.height = this.height; imgContext.drawImage(this,0,0,this.width,this.width); //base64 url图片 var imgAsDataUrl = imgCanvas.toDataURL("image/png") try&#123; localStorage.setItem(key,imgAsDataUrl) &#125; catch(e)&#123; console.log("storage failed"+e) &#125;&#125;,false); img.src = src;&#125;function get(key) &#123; var srcStr =localStorage.getItem(key) var imgObj = document.createElement('img') imgObj.src = srcStr document.body.appendChild(imgObj)&#125; 业务代码添加过期控制set(&#39;wait4expire&#39;,&#39;expire&#39;),get(&#39;wait4expire&#39;,60*5*1000)12345678910111213function set(key,v)&#123; var curTime = new Date().getTime() localStorage.setItem(key,JSON.stringify(&#123;data:v,time:curTime&#125;))&#125;function get(key,exp) &#123; var data = localStorage.getItem(key) var dataObj = JSON.parse(data) if(new Date().getTime() - dataObj.time &gt; exp)&#123; console.log("expires") &#125;else&#123; console.log("data = "+dataObj.data) &#125;&#125; HTTP文件缓存Application-FramesEtag响应/if-Node-Match请求同时设置Expire和Cache-Control只有Cache-Control生效 浏览器缓存https://segmentfault.com/a/1190000009638800 Connectionhttps://imququ.com/post/transfer-encoding-header-in-http.htmlHTTP/1.0 的持久连接机制是后来才引入的，通过 Connection: keep-alive 这个头部来实现，服务端和客户端都可以使用它告诉对方在发送完数据之后不需要断开 TCP 连接，以备后用。HTTP/1.1 则规定所有连接都必须是持久的，除非显式地在头部加上 Connection: close。所以实际上，HTTP/1.1 中 Connection 这个头部字段已经没有 keep-alive 这个取值了，但由于历史原因，很多 Web Server 和浏览器，还是保留着给 HTTP/1.1 长连接发送 Connection: keep-alive 的习惯。 浏览器可以通过 Content-Length 的长度信息，判断出响应实体已结束。那如果 Content-Length 和实体实际长度不一致会怎样？有兴趣的同学可以自己试试，通常如果 Content-Length 比实际长度短，会造成内容被截断；如果比实体内容长，会造成 pending。 TTFB（Time To First Byte），它代表的是从客户端发出请求到收到响应的第一个字节所花费的时间。 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\r\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。12345678910111213141516require('net').createServer(function(sock) &#123; sock.on('data', function(data) &#123; sock.write('HTTP/1.1 200 OK\r\n'); sock.write('Transfer-Encoding: chunked\r\n'); sock.write('\r\n'); sock.write('b\r\n'); sock.write('01234567890\r\n'); sock.write('5\r\n'); sock.write('12345\r\n'); sock.write('0\r\n'); sock.write('\r\n'); &#125;);&#125;).listen(9090, '127.0.0.1'); webworkers《高性能网站建设进阶指南》https://www.html5rocks.com/en/tutorials/workers/basics/123456789101112131415161718 var worker = new Worker("./worker.js") console.log("主线程主线程主线程主线程1")//1 worker.addEventListener("message",function(e)&#123; console.log("主线程主线程主线程主线程2")//8 console.log("worker said",e.data)//9 console.log("主线程主线程主线程主线程3")//10 &#125;,false) console.log("主线程主线程主线程主线程4")//2 worker.postMessage("hello world"); console.log("主线程主线程主线程主线程5")//3//worker.jsconsole.log("子线程0")//4self.addEventListener("message",function(e)&#123; console.log("子线程1")//6 self.postMessage(e.data) console.log("子线程2")//7&#125;,false)console.log("子线程3")//5 fisher-yates 洗牌 shuffle the deck first to randomize the order and insure a fair gameO(n) 1234567891011function shuffle(array)&#123; var m = array.length,t,i; while(m)&#123; //99...0 i = Math.floor(Math.random()*m--); t = array[m]; array[m] = array[i]; array[i] = t; &#125; return array;&#125; 测试shuff如果5x2一共10个格，雷5个，则出现的概率应该都是0.51234567891011121314151617181920212223function testshuff (N,n,m,num)&#123; var freq = Array(); for(var i=0;i&lt;m*n;i++) freq[i]=0; var arr = Array() for(var test=0;test&lt;N;test++)&#123; for(var i = 0;i&lt;num;i++)&#123; arr[i]=1; &#125; for(var i = num;i&lt;m*n;i++) &#123; arr[i]=0; &#125;shuffle(arr)//console.log(arr) for(var j=0;j&lt;n*m;j++)&#123; freq[j]+=arr[j]; &#125;&#125;for(var i =0;i&lt;n*m;i++)&#123;console.log(i+" "+freq[i]/N);&#125;&#125; 假装做个扫雷 生成nxm大小的格子里面有num个雷,并且打乱它123456789101112131415161718192021222324252627282930313233function generate(n,m,num)&#123; var mines = new Array() let x,y; for(var i =0;i&lt;n;i++)&#123; mines[i]=new Array(); for(var j=0;j&lt;m;j++)&#123; mines[i][j]=0; &#125; &#125; while(num)&#123; x= Math.floor(Math.random()*n); y= Math.floor(Math.random()*m); //一定要加，不然雷数少于num if(mines[x][y]===0)&#123; mines[x][y]=1; num--; &#125; &#125; return mines;&#125;function shuff2d(mines,n,m)&#123; var t,ix,iy,ranx,rany; for(var i = n*m-1;i&gt;=0;i--)&#123; ix = Math.floor(i/m); iy = i%m; var random = Math.floor(Math.random()*(i+1)); ranx = Math.floor(random/m); rany = random%m; t = mines[ix][iy]; mines[ix][iy]=mines[ranx][rany]; mines[ranx][rany]=t; &#125;&#125; 其他要设置用户点击open[][],这个点周围有多少雷cnt[][]，用户插旗坐标flag[][]另外 点开不是数字的地方要扩展 window.getSelections()https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getSelection css 伪类选择器的notcss权重计算？ 123456789101112131415&lt;head&gt; &lt;style&gt; p:not(.classy) &#123; color: red; &#125; body :not(p) &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p class="classy"&gt;就这条不用这个样式&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;p&gt;Some text.&lt;/p&gt;&lt;span&gt;body里面除了p都是绿的&lt;span&gt;&lt;div&gt;body里面除了p都是绿的&lt;/div&gt; 写一个base62.jsrequirejs异步加载文件加载机制：使用head.appendChild()将每个依赖变成&lt;script&gt;标签helper不是xhr是以js形式加载的Content-Type:application/javascript;charset=UTF-8所以模块加载可以跨域，可以从cdn1&lt;script data-main = "/js/app" src = "/js/require.js"&gt;&lt;/script&gt; app.js123456789//不用data-main直接配置base-Url//在html里两个script标签，先require.js再app.jsrequirejs.config(&#123; baseUrl:'/js'&#125;);require(['helper'],function(helper)&#123; var str = helper.trim(' amd ') console.log(str)&#125;); helper.js12345678//模块名，依赖的模块，加载的依赖中的对象（jquery）define("helper",['jquery'],fucntion($)&#123; return &#123; trim: function(str)&#123; return $.trim(str) &#125; &#125;&#125;); 获取用户信息1.定义简单对象user.js123456define(&#123; username:'username', name:'zhou', email:'abc@abc.com', gender:'男' &#125;) 2.app.js12345678require(['jquery','../js/api'],function($,api)&#123; $("#user").click(function()&#123; //.then异步处理 api.getUser().then(function(user)&#123; console.log(user); &#125;) &#125;)&#125;); 3.api.js12345678define(['jquery'],function($)&#123;//异步处理 var def = $.Deferred(); require(['../js/user'],function(user)&#123; def.resolve(user); &#125;); return def;&#125;); 不支持AMD(require,define)的库：Mondernizr，bootstrapnodejs 单线程IO密集：静态资源（文件），网络，数据库Event loop主进程是单线程，I/O等操作系统多线程调用。nojs有cluster模块可以在每个核启一个进程不会浪费cpu 移动端自适应1.css像素即逻辑像素。一般屏幕【设备像素比】1：1，一个逻辑像素对应一格设备物理像素Retina屏幕，1：2，一个逻辑像素需要4个物理像素表示2.viewport分三类layout viewport 整个网页visual viewport 在手机上拖动显示的网页的一部分ideal viewport 手机的宽和高content=&quot;width=device-width&quot;让layout==手机的ideal 手机自动铺满3.rem：em是相对于父级元素计算大小，rem相对于root element 用viewport和设备像素比可以调整基准像素 spa的好处不用每次请求消耗dns tcp等接口相应时间。单页面只有接口耗费的时间。Prerender可以优化SEO 实现1.History api pushState onpopstate2.Hash hashchange location.hash gulp不用io流式处理 比grunt晚出现 chrome 技巧截图：ctrl+shift+P Captrue full size screenshot Web Component 用法Webview loadUrl浏览器由7部分组成用户界面网络：请求静态资源发起请求js引擎渲染引擎：DOM和CSS内容排版 WebKit中Html和CSS解析可以并行UI后端：选择框、按钮、输入框js解释器持久化数据存储 查看渲染计算后的CSS规则document.defaultView.getComputedStype(document.getElementById(&quot;id&quot;,null))css计算权重：!important&gt;内联样式&gt;id选择器&gt;类选择器&gt;元素选择器 nodejs跨域测试 被请求的添加html里type:xhr12345&lt;script&gt;var xhr = new XMLHttpRequest()xhr.open('GET','http://127.0.0.1:8897')xhr.send()&lt;script&gt; 8897:任何服务都能访问这个服务1response.writeHead(200,&#123;'Access-Control-Allow-Origin':'*'&#125;) 或者特定域名12response.writeHead(200, &#123;'Access-Control-Allow-Origin':'http://localhost:8898'&#125;) jsonp标签里允许跨域不用添加allow-origintype:script1&lt;script src="http://127.0.0.1:8897"&gt;&lt;script&gt; CORS预请求 option跨域只允许get/head/postcontent-type只允许 form表单三种数据类型text/plain multipart/form-data application/x-www.form-urlencodedhtml：报错not allowed by Access-Control-Allow-Headers123456fetch('http://localhost:8897/',&#123; method:'POST', headers:&#123; 'X-cors':'123' &#125;&#125;) fetch允许跨域的header允许的header 其它的都需要服务器端验证先发送option类型再发送post123response.writeHead(200,&#123; 'Access-Control-Allow-Header':'X-Test-Cors'&#125;) 同理可以添加Allow-Methods等设置允许跨域的最长时间不需要再发送option预请求&#39;Access-Control-Max-Age&#39;:&#39;1000&#39; 缓存Cache-Control 可缓存性public：http经过的代理服务器、客户端都能缓存private：只有发起请求的浏览器可以缓存(百度设置了privae) 过期max-age：客户端过期时间s-maxage=代理服务器的过期时间max-stale=使用过期缓存 重新验证must-revalidate 其它对代理服务器nginxno-cache 可以本地缓存。向服务器发起验证是否可以使用本地缓存no-store 不能本地缓存。no-transform 不压缩 在请求服务器设置123response.writeHead(200,&#123;'Cache-Control':'max-age=200,public'&#125;) 服务端12345678const etag = request.headers['if-none-match']if(etag === '777')&#123; response.writeHead(304,&#123; 'Content-Type':'text/javascript', 'Etag':'777' &#125;) response.end('并不会显示，浏览器直接读了缓存')&#125; 设置Cookie禁止javascript修改cookie1234response.writeHead(200,&#123; 'Set-Cookie:['id=123;max-age=2','abc=456;HttpOnly']&#125;)response.end(html) &#39;adc=456;domain=test.com&#39; 不能跨域设置给a.test.com 长链接Network-Connection ID（TCP链接的id）http1.1发送请求有先后顺序。不能并发请求chrome允许并发限制创建6个保持长链接Connect:Keep-Alive 默认都是keep-alive本地开发 把网速调慢：online-&gt;Fast 3G可以设置&#39;Connection&#39;:&#39;close&#39; google 使用h2 都是一个connectID 数据协商AcceptAccept-EncodingAccept-Languagemimetype &#39;X-Content-Type-Options&#39;:&#39;nosniff&#39; 禁止浏览器自动猜测返回类型 使用gzip压缩1234567const fs = require('fs')const zlib = require('zlib')const html = fs.readFileSync('test.html')response.writeHead(200,&#123; 'Content-Encoding':'gzip',&#125;)response.end(zlib.gzipSync(html)) 表单如果用ajax使用application/json或者application/xml123456&lt;form action ='/from' id = "form" method = "POST" enctype="multipart/form-data"&gt;&lt;input type = "text" name = "name"&gt;&lt;input type = "password" name = "password"&gt;&lt;input type="file" name="file"&gt;&lt;input type ="submit" name = "submit"&gt;&lt;/form&gt; ajax发送123456789var form = document.getElementById("form")form.addEventListener('submit',fumction(e)&#123; e.preventDefault()//页面不会跳转 var formData = new FormData(form) fetch('/form',&#123; method:'post', body:formData &#125;)&#125;) 会自动带上Content-Type redirect只有302的头才表示跳转123response.writeHead(302,&#123; 'Location':'/new'&#125;) 改成301永久变更 浏览器会自动只发送/new的请求 /new的路由放到了缓存里。接下来改成200也读不到了。 CSP content-security-policy 内容安全策略1'Content-Security-Policy':'default-src http:https' 考虑同一域名的浏览器请求上限将html放在admin.domain.com下,js+css放在s.下，将image放在image.下前端访问后端api.发生跨域需要使用代理服务器 304是协商缓存 还会和服务器通信一次本地缓存(cache-control/expires) 通过html中引用css地址更新v1放弃缓存 用摘要算法当文件更新时更新css文件名静态资源部署在cdn，动态网页部署在另一个节点。1 先更新页面：加载旧缓存，页面样式错乱2 先静态资源后页面：有缓存则不更新，第一次访问的没缓存用户 页面执行错误。访问量小的网站可以先静态资源后页面非覆盖式发布：新旧css同时存在cdn上，再更新html页面 全局微软雅黑document.getElementByTagName(&quot;body&quot;).sytle.fontFamily=&quot;微软雅黑&quot;Array.from(document.getElementByTagName(&quot;p&quot;).forEach((item)=&gt;item.style.fontFamily=&quot;微软雅黑&quot;)) import有无default ，default导出的只能一个，所以不用大括号 webpack-dev-server 开发模式wepack.config.js:123456789101112131415const isDev = process.env.NODE_ENV==='development'const config=&#123; target: 'web'&#125;if(isDev)&#123; config.devSever =&#123; port:8888 host:0.0.0.0,//可以在内网中用内网ip用手机访问测试 overlay:&#123; errors:true, &#125;, historyFallback:"index.html", hot:ture//只渲染当前组件&#125;&#125; 安装corss-env在windows平台下设置NODE_ENV要用set和linux不同package.json1234"script":&#123; "build":"cross-env NODE_ENV=production webpack --config webpack.config.js", "dev": "cross-env NODE_ENV=development webpack-dev-server --mode development --config webpack.config.js"&#125; html-webpack-pluginautoprefixerpostcss.config.js优化css代码 自动加webkit等前缀 mixin模式typeof一共有五种返回值按存储方式只有值类型和引用类型（共用内存块）只能区分值类型。无法区分引用类型：数组、对象、方法 强制类型转换==123100=='100'//true0=='' //true 都会转换成falsenull==undefine//true 都会转换成false if和逻辑运算符判断变量被当成true还是false12var a = 100console.log(!!a)//true 何时使用===和==除了1234obj.a==null//相当于obj.a===null||obj.a===undefined//来自jquery 其它都用=== 12个js内置函数 （数据封装类对象）JSON和Math也是内置对象12JSON.stringify(&#123;a:10,b:20&#125;)JSON.parse('&#123;"a":10,"b":20&#125;') 原型js构造函数12345678910//构造函数function MathHandle(x,y)&#123; this.x=x; this.y=y;&#125;MathHandle.prototype.add=function()&#123; return this.x+this.y&#125;var m = new MathHandle(1,2)console.log(m.add()) Class语法1234567891011class MathHandle&#123; construct(x,y)&#123; this.x=x; this.y=y; &#125; add()&#123; return x+y &#125;&#125;const m = new MathHandle(1,2);console.log(m.add()) 语法糖实现MathHandle===MathHandle.prototype.constructor true 继承123456789function Animal()&#123; this.eat = function()&#123; console.log("animal")&#125;&#125;function Dog()&#123; this.bark = function()&#123; console.log("bark")&#125;&#125;Dog.prototype = new Animal()var hs = new Dog()//hs有了eat方法 window.onload和DOMContentLoaded区别zeptorollup.js 比webpack小 babel src/index.js zepto小型jquery专门移动端开发Rivets.js数据绑定js预处理器 pug webpack 模版处理器（jade） 数组 arr.includes(4) true/false .find 123let result = arr3.find(function (item,index) &#123; return item.toString().indexOf(5)&gt;-1&#125;) .some找到true后停止返回true .every找到false后停止返回false .reduce变成undefined是因为没有写返回值 对象求和：12//不报错，返回NaN 因为pre从对象变成了数 [&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev.price*prev.count+next.price*next.count) 正确写法：123[0,&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count)//或者添加默认参数[&#123;price:30,count:2&#125;,&#123;price:20,count:3&#125;,&#123;price:40,count:4&#125;].reduce((prev,next)=&gt;prev+next.price*next.count,0) 数组扁平化：二维数组变成一维1[[1,2,3],[4,5,6],[4,5,6]].reduce((prev,next)=&gt;prev.concat(next)) 箭头函数let a = b =&gt; c =&gt; b+ca(1)(2)=3(return function(c){b+c})闭包：返回的是引用数据类型，赋值给外界变量，不会被销毁。 更改this指向 call和apply和bindapply\call详解绑定this上下文，call和apply使函数立即执行 bind返回函数自己实现bind12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125; &#125; 文档碎片在赋值操作中 A||B :A真返回A，A假返回B A&amp;&amp;B :A假返回A，A真返回B &amp;&amp;优先于||应用场景：1234function fn(num,callBack)&#123; num=num||0//undefined会转换成false callBack&amp;&amp;callBack();//只要传了函数进来callBack为真&#125; 闭包里边的作用域被赋值给外面的变量占用了，不能释放。1234567891011var a = 9;function fn()&#123; a=0; return function(b)&#123; return b+a++; &#125;&#125;var f=fn()//占用 function(b)console.log(f(5))//输出5.f(5)执行后会销毁 全局a=1console.log(f()(5))//修改全局a=0 输出5 执行完后a++ 全局a=1console.log(f(5))//输出6 从fn到return之间的被保留 类数组 （arguments形参集合） 以0~n数字作索引 length arguments.callee是函数本身 严格模式不使用 arguments.caller 是fn 严格模式不使用 Array.from()将类数组转换成数组12function sum()&#123;console.log(arguments.callee.caller)&#125;function fn()&#123;sum(1,2,3,4)&#125; 立即执行函数IIFEfunction t (num){console.log(num)}(3) 浏览器的【全局作用域】是window,nodejs的全局作用域是globalvar a=1 给window加了属性 对象数据类型： 浏览器开辟内存空间分配一个16进制的地址， 内存空间存对象键值对 给对象变量存地址 任意数求和123456function fn()&#123; //类数组转化成数组 var ary = Array.prototype.slice.call(arguments); return eval(ary.join('+'))&#125;fn(12,23,34) 函数与对象的创建相同也是地址，函数把js代码当作字符串存到空间中 js中栈内存是作用域，用于执行代码，存放基本数据类型。堆内存用于存储键值对or函数字符串调用栈是连续空间。后进先释放，要节约栈空间。堆是链表。 变量提升：在当前作用域，浏览器把所有 带var的声明， 带function的声明并定义（defined赋值(代码字符串的地址)） 全局作用域var相当于给window加了属性 单例模式：团队合作防止全局变量污染：封装到对象内置类 htmlCollection元素集合类 123getElementByTagNamegetElementByClassNamequerySelectorAll NodeList 节点集合类 12getElementByTagNamechildNodes proto:HTML[Div]Element元素对象-&gt;HTMLElement-&gt;ELement-&gt;Node-&gt;EventTarget-&gt;Object 构造函数构造函数执行方式new fn() 普通函数 fn() this是window 123function fn(num)&#123; console.log(this)&#125; 调用构造函数时 this指向函数本身 输出：nfn的属性nnn:10构造函数过程：创建this实例，对this赋值并返回this并且每次new都是不同实例 12345function nfn(nnn)&#123; console.log(this) this.nnn=nnn;&#125;var ff = new nfn(10) 判断JS数据类型的4种方法js数据类型 typeof 无法区分正则和array 都返回object instanceof 检测当前实例是否属于这个类 .constructor（对象实例的constructor是类） Object.prototype.toString.call in/hasOwnPropertyhsOwnProperty是通过原型链检测是否是Constuctor的实例区别：Object.hasOwnProperty(&#39;hasOwnProperty&#39;) false&#39;hasOwnProperty&#39; in Object truehasOwnProperty用于检测私有属性in 私有共有都返回true共有：类提供，所有实例都能用 （静态方法） 原型和原型链类是函数，实例是对象。 函数的prototype属性是对象 实例的__proto__属性是对象 typeof Object “function” 所有的类都是函数类型Function instanceof Object -&gt;true 所有内置类String/Number 也是”function”类型 原型 三个自带的属性原型链：实例的__proto__是类的prototype prototype对象（原型对象）是所有函数的属性。存储了当前类给实例提供的公共属性和方法通过prototype定义类：使用new Person获得实例 1234567var Person = function()&#123;&#125;;//function Person()&#123;&#125;Person.prototype = &#123; name : 'ecmadao', sayName : function()&#123; console.log(this.name); &#125;&#125;; prototype对象，带constructor属性存的值就是函数本身（类） 每个对象都带__proto__属性，值是当前对象所属类的原型(prototype)1234function fun(num)&#123; this.num = num&#125;var f1 = new fun(10)fun.prototype=== f1.__proto__ //true 对fun.prototype添加的方法1fun.prototype.say = function()&#123;console.log("prototypesay")&#125; 对f1来说f1.hasOwnProperty(&#39;say&#39;) false . 是公共方法 fun.prototype.__proto__是Object.prototype Object.prototype没有__proto__ 有也指向自己 构造原型Fn.prototype = {} 会没有constructor,使用constructor:Fn 会导致原来使用Fn.prototype.c=function的属性被替换（可以遍历原有的克隆） 12var jQuery = function(selector,context)&#123;return new jQuery.fn.init(,)&#125;jQuery.fn = jQuery.prototype=&#123;constructor:jQuery,init:function(,)&#123;&#125;&#125; BOM document.querySelector(&quot;body&quot;).setAttribute(&quot;style&quot;,&quot;background-color:black&quot;);document.querySelector(&quot;body&quot;).style.cssText=&quot;background-color:black&quot;; https://chromium.googlesource.com/chromium/src/+/master/docs/es6_chromium.md 前端模块化 CommonJS CommonJS是不适用于浏览器端,因为文件是从服务器请求过来，不能同步加载模块。 浏览器模块化AMD规范：require.js非同步，指定回调函数浏览器中异步加载。可以并行加载多个模块。???如何并行？ CMD规范：按需加载sea.js ES6模块化 通过babel将不被支持的import编译为当前受到广泛支持的 require 加载过程defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后 虚拟DOMhttps://segmentfault.com/a/1190000015821780 Virtual Node 用json构建，type\props\children{type:”div”,props:{“style:”},children:[]}vnodes-&gt;vdom 柯里化currying：函数式编程风格，组合函数123456789101112131415//两数相乘var multiple = function(a)&#123; return function(b)&#123; return +b*a+"" &#125;&#125;//拼接var concatArray = function(list,fct)&#123; return list.map(fct) .reduce(function(a,b)&#123; return a.concat(b) &#125;) &#125;//运行24concatArray(["1","2"],multiple(2)) Object.defineProperty 为对象定义属性 js对象or DOM对象 属性名 描述符： {value: “covergou”, writable: false, enumerable: true, configurable: false} 12let obj =&#123;&#125;Object.defineProperty(obj,"school",&#123;get:,set:&#125;) value:”name” writable:true/false 是否可写 configurable:false 删除属性、修改属性（writable, configurable, enumerable）的行为将被无效化 enumerable: true 是否能在for-in循环中遍历出来或在Object.keys中列举出来 get/set:function(){}使用get/set不能有writable和value属性 实现数据双向绑定数据劫持12345678Object.defineProperty(dom, 'translateX', &#123;set: function(value) &#123; var transformText = 'translateX(' + value + 'px)'; dom.style.webkitTransform = transformText; dom.style.transform = transformText;&#125;&#125;)dom.scale = 1.5; ES6对象拷贝Object.assign({t:1},{k:2}) 默认参数123function hello(txt)&#123; txt = txt || 'hello world'&#125; es6:1function(txt = 'hello world')&#123;&#125; 模板字符串12var name = 'moe'var txt = `hello $&#123;name&#125;` 箭头函数import {}块状作用域 .map(function(v){return v+1}).map(v=&gt;v+1) 箭头函数内的this指向是定义时this的指向function中this指向是该函数被调用的对象 数组类方法： Array.form(1,2,3,4)转成数组.from(3)生成空位 Array.of(3)与from用法相同，解决了单个值数组 toArray(1,2,3,4)转数组 原型方法（用于实例） .copyWithin(target,start,end) cool()函数丢失了同this之间的绑定var self = this 123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log( this.id ); &#125; &#125;; var id = "not awesome" obj.cool(); // 酷 setTimeout( obj.cool, 100 ); // 不酷 setTimeout中的this指向的是全局对象 var self = this function(){}.bind(this),1000 显示所有全局变量12for(name in this)&#123; vars+=name+"\n"&#125; 对象保护 对象代理 ES3,ES5 123456789//声明类var Person= fuction()&#123; var data=&#123; name='es3', sex:'male', age:15 &#125; this.get,this.set = function()&#123;&#125;&#125; es5:对象的只读属性Object.defineProperty(&quot;Person&quot;,&#39;sex&#39;,{ writable:false,value:&#39;male&#39; })只能读不能写 ES6用代理访问对象1234567let Person=&#123;:,:,:&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; target[key] &#125;, set(target,key,value) &#125;)]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[concurrent并发多线程]]></title>
    <url>%2F2018%2F04%2F13%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着在回到主线程循环100次，如此循环50次，请写出程序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class concurrent &#123; public static void main(String[] args) &#123; final Business business= new Business(); new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 1; j &lt;= 50; j++) &#123; business.sub(j); &#125; &#125; &#125;).start(); for (int j = 1; j &lt;= 50; j++) &#123; business.main(j); &#125; &#125;&#125;class Business &#123; private volatile boolean bshouldSub = true;//子线程和主线程通信信号 public synchronized void sub(int j) &#123; if (!bshouldSub) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int i = 1; i &lt;= 10; i++) &#123; System.out.println("子线程内" + i + ",第" + j+"个子线程"); &#125; bshouldSub = false;//运行结束，设置值为FALSE 让主程序运行 this.notify();//唤醒等待的程序 &#125; public synchronized void main(int j) &#123; if (bshouldSub) &#123;//如果bshouldsub=true ，等待 让子程序运行 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (int i = 1; i &lt;= 100; i++) &#123; System.out.println("内循环 " + i + ",第" + j+"个主线程"); &#125; bshouldSub = true;//让子程序运行 this.notify();//唤醒等待的一个程序 &#125; 不可变对象加锁，锁的不是同一个i++的例子里，如果是Integer，synchronized锁的对象不是同一个 Lock实现业务级别加锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class AccountWithLock &#123; int balance; private Lock lock; public AccountWithLock() &#123; balance = 0; lock = new ReentrantLock(); &#125; public void lockAccount() &#123; lock.lock(); &#125; public void unLockAccount() &#123; lock.unlock(); &#125; public void login() &#123; &#125; public void logout() &#123; &#125; public void add() &#123; balance += 800; System.out.println("After add balance is:" + balance); &#125; public void minus() &#123; balance -= 800; System.out.println("After minus balance is:" + balance); &#125;&#125;class AddThreadWithLock extends Thread &#123; String person; AccountWithLock acc; public AddThreadWithLock(String person, AccountWithLock acc) &#123; this.person = person; this.acc = acc; &#125; public void run() &#123; acc.lockAccount(); acc.login(); System.out.println(person + " login "); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(person + " add money," + i + " cnt"); acc.add(); &#125; System.out.println(person + " logout "); acc.logout(); acc.unLockAccount(); &#125;&#125;class MinusThreadWithLock extends Thread &#123; AccountWithLock acc; String person; public MinusThreadWithLock(String person, AccountWithLock acc) &#123; this.person = person; this.acc = acc; &#125; public void run() &#123; acc.lockAccount(); System.out.println(person + " login "); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(person + " minus money," + i + " cnt"); acc.minus(); &#125; System.out.println(person + " logout "); acc.logout(); acc.unLockAccount(); &#125;&#125;public class LockDemo &#123; public static void main(String[] args) &#123; AccountWithLock acc = new AccountWithLock(); Thread add = new AddThreadWithLock("Tom", acc); Thread minus = new MinusThreadWithLock("Peter", acc); add.start(); minus.start(); &#125;&#125; wait notify 实现库存==1 的生产者消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class ProductData &#123; //表示被哪个生产者线程生产出来的编号 private int number; // 标志位，true表示已经消费 private boolean flag = true; public synchronized void product(int number) &#123; if (!flag) &#123; try &#123; // 未消费等待 wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; this.number = number; // 标记已经生产 flag = false; // 通知消费者已经生产，可以消费 notify(); &#125; public synchronized int consume() &#123; if (flag) &#123; try &#123; // 未生产等待 wait(); &#125; catch (InterruptedException e) &#123; // 省略报异常的语句 // … &#125; &#125; // 标记已经消费 flag = true; // 通知需要生产 notify(); return this.number; &#125;&#125;// 生产者线程class Producer extends Thread &#123; private ProductData s; Producer(ProductData s) &#123; this.s = s; &#125; public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; s.product(i); System.out.println("P[" + i + "] Product."); &#125; &#125;&#125;// 消费者线程class Consumer extends Thread &#123; private ProductData s; Consumer(ProductData s) &#123; this.s = s; &#125; public void run() &#123; int i; do &#123; i = s.consume(); System.out.println("P[" + i + "] Consume."); &#125; while (i != 9); &#125;&#125;public class ProducerConsumer &#123; public static void main(String argv[]) &#123; ProductData s = new ProductData(); new Producer(s).start(); new Consumer(s).start(); &#125;&#125; Condition实现库存&gt;1的生产者消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Store &#123; private Lock lock; private Condition notFull; private Condition notEmpty; private int maxSize; private LinkedList&lt;String&gt; storage; public Store(int maxSize) &#123; lock=new ReentrantLock(); notFull=lock.newCondition(); notEmpty=lock.newCondition(); this.maxSize = maxSize; storage = new LinkedList&lt;String&gt;(); &#125; // 生产方法 public void product() &#123; lock.lock(); try &#123; //如果仓库满了 while (storage.size() == maxSize )&#123; System.out.println(Thread.currentThread().getName()+": wait ");; //阻塞生产线程 notFull.await(); &#125; storage.add("Java Book"); System.out.println(Thread.currentThread().getName()+": put:"+storage.size()); Thread.sleep(1000); //唤醒消费线程 notEmpty.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; // 消费方法 public void consume() &#123; lock.lock(); try &#123; //如果仓库空了 while (storage.size() ==0 )&#123; System.out.println(Thread.currentThread().getName()+": wait");; notEmpty.await();//阻塞消费线程 &#125; //取出消费 System.out.println(storage.poll()); System.out.println(Thread.currentThread().getName()+": left:"+storage.size()); Thread.sleep(1000); notFull.signalAll();//唤醒生产线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; 吸烟者问题 线程安全的单例模式懒汉模式 延迟加载double checkvolatile并且防止重排序.当volatile的共享变量发生写操作，会写回系统内存，并使其他cpu的缓存失效重新读。123456789101112131415161718192021222324252627public class LazySingletonDoubleCheck &#123; // 用volatile可以禁止2，3重排序 用缓存一致性协议 public volatile static LazySingletonDoubleCheck instance = null; private LazySingletonDoubleCheck() &#123; &#125; public static LazySingletonDoubleCheck getInstance()&#123; if(instance == null)&#123; synchronized (LazySingletonDoubleCheck.class)&#123; if(instance == null)&#123; instance = new LazySingletonDoubleCheck(); // new其实包括3步 // 1 分配内存 // 2 初始化对象 // 3 将那块内存空间 赋值给instance // 对于单线程 2，3互换不会改变执行结果，所以多线程里可以重排序 // 多线程 第一个线程先3 instance有了内存空间不是null 但还没初始化 // 第二个线程访问并返回 &#125; &#125; &#125; return instance; &#125;&#125; 2.静态内部类123456789101112public class StaticInnerClassSingle &#123; private StaticInnerClassSingle()&#123; &#125; // jvm会加初始化索 同步多个线程对一个class的初始化 // 类初始化 哪个线程先拿到innerclass的初始化锁 private static class InnerClass&#123; private static StaticInnerClassSingle instance = new StaticInnerClassSingle(); &#125; public static StaticInnerClassSingle getInstance()&#123; return InnerClass.instance; &#125;&#125; 饿汉式12345678910public class HungrySingleton &#123; private final static HungrySingleton instance; static&#123; instance = new HungrySingleton(); &#125; private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return instance; &#125;&#125; 序列化之后的单例 读取后还是原来的对象1234567891011121314public class HungrySingleton implements Serializable&#123; private final static HungrySingleton instance; static&#123; instance = new HungrySingleton(); &#125; private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return instance; &#125; // 添加这个，ObjectInputStream的readObject会通过反射调用 private Object readResolve()&#123; return instance; &#125;&#125; Promise例子:FTPClientUtil客户端尽早调用注意异常处理。 Future&lt;FTPClientUtil&gt; Promise = FTPClientUtil.newInstance(&quot;ftpServer&quot;,&quot;ftpUserName&quot; , &quot;password&quot;); FTPClientUtil 用静态方法调用私有构造函数，并交给执行线程，返回一个凭证12345678910111213141516171819202122232425262728293031323334353637383940public class FTPClientUtil &#123; // 实现一个线程池 private volatile static ThreadPoolExecutor threadPoolExecutor; static&#123; threadPoolExecutor = new ThreadPoolExecutor(1, Runtime.getRuntime().availableProcessors() * 2, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10), new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); return t; &#125; &#125;,new ThreadPoolExecutor.CallerRunsPolicy()); &#125; private final FtpClient ftp = FtpClient.create(); private FTPClientUtil()&#123;&#125; //Promisor.compute public static Future&lt;FTPClientUtil&gt; newInstance(final String ftpServer,final String userName,final String password)&#123; Callable&lt;FTPClientUtil&gt; callable = new Callable&lt;FTPClientUtil&gt;() &#123; @Override public FTPClientUtil call() throws Exception &#123; FTPClientUtil self = new FTPClientUtil(); self.init(ftpServer,userName,password); return self; &#125; &#125;; // task 相等于promise final FutureTask&lt;FTPClientUtil&gt; task = new FutureTask&lt;FTPClientUtil&gt;(callable); // executor threadPoolExecutor.execute(task); return task; &#125;&#125; 客户端尽晚调用Promise.get() synchronized两个用法：对象锁、类锁对象锁：方法锁（默认对象为this) 、同步代码块锁（自己指定锁对象） 类锁：修饰静态方法 或 指定锁为Class对象 java每个对象有内部锁。并且该锁有一个内部条件12while (accounts[from] &lt; amount)wait();notifyAll(); final 匿名内部类中只能使用final？ java 线程状态线程停止下面能让线程停止执行的有正确答案: A B D 你的答案: B C D (错误)A.sleep();B.stop();C.notify();D.yield(); 线程终止下面那些情况可以终止当前线程的运行？BA.当一个优先级高的线程进入就绪状态时B.抛出一个异常时C.当该线程调用sleep()方法时D.当创建一个新线程时 Atomic和synchronized下面关于Atomic(比方说AtomicLong)和synchronized关键字的说法哪些是对的?正确答案: A B 你的答案: A B (正确)A.两者都可以用于线程同步B.synchronized关键字用于同步一段代码，而atomic用于同步某个状态C.两者都可以用于同步一段代码D.多个Atomic在代码中嵌套使用时可能会产生死锁 需要多少资源为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是()k(n-1)+1 = 36 https://blog.csdn.net/javazejian/article/details/72828483 多线程活跃性问题：死锁 饥饿 活锁活锁：主动释放资源，资源不断在线程中跳动，没有一个线程可以拿到资源正常执行。 并发级别：阻塞、无饥饿、无锁、无等待阻塞：synchronized 和重入锁无障碍Obstruction-Free：都可以修改临界区，如果数据竞争就回滚。通过“一致性标记”实现。无饥饿：公平优先级。无锁：有一个线程限步内完成操作，离开临界区。线程无穷循环尝试修改共享变量。总有一个线程可以胜出。无等待：所有线程有限步，不会饥饿。RCU(read-copy-update)。读线程无等待。写副本，合适时机写回。 Gustafon 如果可被并行的代码足够多，那么加速比就能随CPU数量线性增长F是只能串行的比例Gustafon = n-F(n-1) 32系统的long(64位)读写线程有干扰 ThreadLocal可以看成是 Map&lt;Thread,T&gt; 特定于该线程的值 Cache伪共享（False Sharing）：多线程读同一cache line的不同变量，变量无关却要线程同步。X86 cpu的cache line长64字节如果有一对象有成员变量long a,b,c(共24字节）则可能加载在一个cache line中。当 CPU1：线程1和cpu2：线程2 都从内存中读取这个对象放入自己的cache line1和2。当线程1写a则2上的cache line变成Invalid，当2要读b需要重新从内存中读。本来无关的两个线程，并行变成串行。 解决方法：将a,b分到不同的cache line 采用@Contended https://www.jianshu.com/p/7f89650367b8 redis 10w OPSDisruptorhttps://tech.meituan.com/disruptor.htmlhttp://ifeve.com/locks-are-bad/ qucik start1.工厂Event类，用于创建Event类实例对象123456789101112//走IO 要序列化接口public class OrderEvent &#123; private long value;&#125;public class OrederEventFactory implements EventFactory&lt;OrderEvent&gt; &#123; @Override public OrderEvent newInstance() &#123; // 返回空的数据对象 return new OrderEvent(); &#125;&#125; 2.监听事件类，处理数据(Event类)12345678// 处理数据 就是消费者public class OrderEventHandler implements EventHandler&lt;OrderEvent&gt; &#123; @Override public void onEvent(OrderEvent event, long sequence, boolean endOfBatch) throws Exception &#123; System.out.println("消费者"+event.getValue()); &#125;&#125; 3.实例化Disruptor，配置，编写核心组件12345678910111213141516171819202122232425262728293031323334353637public class Main &#123;public static void main(String[] args) &#123; OrederEventFactory factory = new OrederEventFactory(); int ringBufferSize = 1024 * 1024; // 处理器核数 int p = Runtime.getRuntime().availableProcessors(); // 线程池 固定大小的，超过线程数量会放到LinkedBlockingQueue&lt;Runnable&gt;()等待 ExecutorService execotr = Executors.newFixedThreadPool(p); /**1 实例化Distruptor对象 * Event工厂，容器长度，线程池（一般自己实现 实现RejectedExecutionHandler） ，单生产者，等待策略 */ Disruptor&lt;OrderEvent&gt; disruptor = new Disruptor&lt;OrderEvent&gt;( factory, ringBufferSize,execotr, ProducerType.SINGLE, new BlockingWaitStrategy() ); // 2.添加消费者类的监听 disruptor.handleEventsWith(new OrderEventHandler()); // 3启动 disruptor.start(); //4.实际存储数据的容器 RingBuffer&lt;OrderEvent&gt; ringBuffer = disruptor.getRingBuffer(); OrderEventProducer producer = new OrderEventProducer(ringBuffer); ByteBuffer bb = ByteBuffer.allocate(8); for (long i = 0; i &lt;100 ; i++) &#123; bb.putLong(0, i); producer.sendData(bb); &#125; disruptor.shutdown(); execotr.shutdown();&#125;&#125; 4.生产者，向Disruptor容器投递数据12345678910111213141516171819202122public class OrderEventProducer &#123; RingBuffer&lt;OrderEvent&gt; ringBuffer; public OrderEventProducer(RingBuffer&lt;OrderEvent&gt; ringBuffer) &#123; this.ringBuffer = ringBuffer; &#125; public void sendData(ByteBuffer data)&#123; // 获取下一个可用的序号 long sequence = ringBuffer.next(); try &#123; // 空对象 OrderEvent event = ringBuffer.get(sequence); event.setValue(data.getLong(0)); &#125;finally &#123; // 发布出去 消费者会监听到 ringBuffer.publish(sequence); &#125; &#125;&#125; 运行：输出 消费者消费了100条消息 RingBuffer1首尾相接的环，2有序号 指向数组中下一个可用元素，加数据递增 数组长度有限，生产者可能会追上消费者. 基于数组，有sequencer（序号）和策略（WaitStrategy） Disruptor有RingBuffer，消费者线程池、消费者集合ConsumerRepository等引用。 Sequence可以看成是一个AtomicLong 用于标识进度。可以消除CPU伪共享。事件处理过程是沿着序号逐个递增处理，所以原子性 可以多线程并发访问。协调RingBuffer/Producer/Consumer的处理进度。 Sequencer 接口Distruptor的核心有两个实现类SingleProducerSequencer,MultiProducerSequencer实现生产者消费者之间传递数据的并发算法。 Sequence Barrier用于保持对RingBuffer的Main Published Sequence(生产者)和消费者之间的平衡。判断消费者的处理类。 WaitStrategy 接口 消费者如何等待的策略 主要策略BlockingWaitStrategy 阻塞SleepingWaitStrategy 休眠 异步日志YieldingWaitStrategy 线程切换 EventProcessor 主要事件循环最重要的实现类BatchEventProcessor 回调EventHandler接口的实现对象 EventHandler 由用户实现WorkProcessor 多消费者保证一个sequence只能被一个消费者消费 多生产多消费者的Disruptor图解生产者共用一个Sequence每个消费者有sequence每个消费者通过Barrier和生产者的Sequence协调 核心链路PV和QPS估计每天300w PV 80%会在24小时的20%的时间里$3000 000*0.8)/(86400*0.2*)=139(QPS)$如果一台机器QPS是58，则需要139/58=3台机器 并发模型1.进程&amp;线程Apache C10K问题2.异步非阻塞 Nginx Libevent Nodejs 回调复杂度高3.协程Golang Erlang Lua TreeMap是非线程安全的。跳表：数据大时性能高于红黑树123456789101112131415161718private transient volatile HeadIndex&lt;K,V&gt; head;static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125;static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile Node&lt;K,V&gt; next;&#125;static class Index&lt;K,V&gt; &#123; final Node&lt;K,V&gt; node; final Index&lt;K,V&gt; down; volatile Index&lt;K,V&gt; right;&#125; ConcurrentMap的实现类ConcurrentSkipListMap跳表 redis的实现方法1ConcurrentSkipListMap&lt;Dish.Type, Double&gt; collect = menu.stream().collect(Collectors.groupingByConcurrent(Dish::getType, ConcurrentSkipListMap::new, Collectors.averagingInt(Dish::getCalories))); ConcurrentHashMap 读不加锁HashMap的迭代器用modCount 不允许读的时候修改。HashMap的nodestatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;HashTable的entryprivate static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;ConcurrentHashMap 的entryvalue是可以改的value可能是null12345static final class MapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // non-null V val; // non-null final ConcurrentHashMap&lt;K,V&gt; map;&#125; V是volatile 线程同步12345678/*这个类不会被暴露出去当用户可变的 Map.Entry *但是可以用于只读遍历 */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next;&#125; 线程池ThreadPoolExecutor1private final BlockingQueue&lt;Runnable&gt; workQueue; 工作队列（阻塞队列） 保护性暂时挂起模式 线程池中线程数量过多，会竞争浪费事件再上下文切换。线程池大小与处理器利用率之比：$N_{threads}=N_{CPU}处理器核数*U_{CPU}期望的cpu利用率（0-1）*(1+W/C等待时间与计算时间的比率)$ Stream在背后引入Fork/join框架Future接口目标：实现并发，充分利用cpu的核，最大化程序吞吐量，避免因为等待远程服务返回/数据库查询。阻塞线程。对计算结果的建模，返回一个运算结果的引用给调用方。12345678910ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;Double&gt; future = executor.submit(new Callable&lt;Double&gt;() &#123; @Override public Double call() throws Exception &#123; //异步操作 return doSomeLongComputation(); &#125; &#125;); //异步操作运行同时也能执行 doSomeThingElse(); Fork/Join工作窃取算法 发布对象：可以得到成员变量引用对象溢出：内部类 AQS 两个node的队列多个CPU缓存一致性 MESI缓存一致性！！！ 4种数据状态，4种状态转换的cpu操作。M（Modified)被修改：只缓存在该CPU的缓存中，被修改，与主存不一致。写回主存Exlusive独享：缓存行只在该CPU的缓存中，未被修改，与主存一致。其它CPU读取内存时变成S状态。被修改则变成M。Share共享：该缓存行被多个CPU缓存，且与主存相同。当一个CPU修改时其它CPU的变成I。Invaild无效。 local read读本地缓存中数据local write写本地缓存remote read读取内存数据 remote write写回主存 NUMA架构：内存分割，被CPU私有化：一致性协议MESIF：目录表message packmsgpack 并发模拟 PostMan-runner选中测试的接口iteration(并发多少次)delay(每次延迟多少) 安装apahce服务器bin下的ab -n 1000 -c 50 http://localhost:8080/test本次测试请求总数1000次，同时并发数50 1234567891011121314151617181920 并发量Concurrency Level: 50 整个测试所用的时间Time taken for tests: 0.667 seconds 完成的请求数Complete requests: 1000 失败请求数Failed requests: 0 所有响应数据长度总和，包括http头信息和正文数据长度，不包括http请求信息的长度Total transferred: 136000 bytes 所有正文数据长度HTML transferred: 4000 bytes 吞吐率（与并发数相关）=Complete requests:/Time taken for testsRequests per second: 1498.52 [#/sec] (mean) 用户平均请求等待时间Time per request: 33.366 [ms] (mean) 服务器平均请求等待时间Time per request: 0.667 [ms] (mean, across all concurrent requests) 单位时间从服务器获取的数据长度=Total transferred/Time taken for testsTransfer rate: 199.02 [Kbytes/sec] received JMeter 添加线程组File-Test Plan-Add-Threads- Thread Group用户数：50虚拟用户增长时长(Ramp-Up Period): 1Loop Count循环次数：一个虚拟用户做多少次测试 20（共1000次） 添加实例请求 add Sanper HttpRequest 添加监听器 图形结果、查看结果树 Option 打开Logviewer展开代码 Throughput吞吐量 用代码并发模拟123456789101112131415161718192021ExecutorService executorService = Executors.newCachedThreadPool();//同时的并发数final Semaphore semaphore = new Semaphore(threadTotal);//请求完之后统计结果 传入请求总数final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123;//超过了并发数add会被阻塞 semaphore.acquire(); add(); semaphore.release(); &#125; catch (Exception e) &#123; log.error("exception", e); &#125;//闭锁 每执行完一次-1 countDownLatch.countDown(); &#125;); &#125;//保证闭锁到0再执行 countDownLatch.await(); executorService.shutdown(); log.info("count:&#123;&#125;", count);&#125; 通常与线程池一起使用 同步器Semaphore信号量 阻塞线程 控制同一时间请求并发量 适合控制并发数 Semaphore(int count)创建count个许可的信号量 每个线程：123//public void runsemaphore.acquire();//获取1/num个许可证semaphore.release();//释放许可 Semphore（2）则A,B,C三个线程，A执行完后C才能开始执行。 CountDownLatch()计数栓:必须发生指定数量的事件后才可以继续使用阻塞线程，直到满足某种条件线程再继续执行,计数值（count）实际上就是闭锁需要等待的线程数量 适合保证线程执行完再做其它处理 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 123void run()&#123;&#125;//主线程必须在启动其他线程后立即调用CountDownLatch.await()方法CountDownLatch.await();&#125;//等待锁存器 线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。 12345//倒计时为0执行main&#123; new CountDownLatch(3); CountDownLatch.countDown();//触发事件&#125; 面试题解释一下CountDownLatch概念?CountDownLatch 和CyclicBarrier的不同之处?给出一些CountDownLatch使用的例子?CountDownLatch 类中主要的方法? 汇编 jne有条件跳转 jmp无条件跳转进程-详细-设置相关性：分配到指定cpu执行，开的线程只在指定的执行java会把线程直接映射到操作系统 javac xxx.java-&gt;.classjavap -c -v xxx 查看虚拟机字节码 Condition1234567private Condition sufficientFunds;if (accounts[from] &lt; amount) //将该线程放到等待集 sufficientFunds.await();try&#123;////最后。账户发生变化，重新检查余额 sufficientFunds.signalAll();&#125; 阻塞队列CAS(compareAndSwap)AtomicReference&lt;V&gt;模板，可以封装任何对数据加上时间戳解决ABA过程状态敏感问题（充值10，20，花费10if (money.compareAndSet(m, m + 20, timestap, timestap + 1))Pair&lt;V&gt; current = pair;第i个元素在数组中的偏移量123private static long byteOffset(int i) &#123; return ((long) i &lt;&lt; shift) + base;//左移2，00乘4 &#125; shift = 31 - Integer.numberOfLeadingZeros(scale); 29个前导0-&gt;shift=2 前导零：数字转换成二进制数后前面0的个数 数组当中每个元素有多宽：int scale = unsafe.arrayIndexScale(int[].class); 4 private static final int base = unsafe.arrayBaseOffset(int[].class); int的话4个byte 静态工厂方法 casPair使用cas的方式更新 1. .start开启新线程调用run .run不开启新线程Java中Thread类中的start()方法和run()方法有什么区别?A.start()方法创建一个线程，并内部调用run() 两种创建方法1.传入一个runnable对象 2.覆盖runThread:123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 123456@Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 2. stop不建议使用，会释放所有的锁（monitor） 实例方法.interrupt()在run()中处理 123456public void run()&#123; while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125; Thread.yeild();&#125; 用Thread.sleep(2000)异常处理 sleep会释放cpu时间片，不释放监视器所有权。让给其它线程在外部对这个sleep的线程中断会抛出异常.isInterrupted方法可以清除中断状态 1234567891011 while(true)&#123; if(Thread.currentTread().isInterrupted())&#123;break;&#125; &#125;try&#123; Thread.sleep(2000);&#125;catch(InterruptedException e)&#123; //设置中断状态，抛出异常后会清除中断标记位 Thread.currentTread.interrupt();&#125; Thread.yeild(); &#125; 用自定义标记抛出异常 3. suspend &amp; resume 已弃用 If the target thread holds a lock on the monitor protecting a critical system resource when it is suspended, no thread can access this resource until the target thread is resumed.If the thread that would [resume] the target thread attempts to lock thismonitor prior to calling resume, deadlock results. Such deadlocks typically manifest themselves as “frozen” processes. 线程2resume线程1发生在线程1suspend之前，当线程1suspend之后没办法resume，导致线程1资源冻结。测试代码点击显/隐内容 1234567891011121314151617181920212223242526272829package learnThr;public class learnThread &#123; public static Object u = new Object(); static ChangeObjectThread t1 = new ChangeObjectThread("t1"); static ChangeObjectThread t2 = new ChangeObjectThread("t2"); public static class ChangeObjectThread extends Thread&#123; public ChangeObjectThread(String name)&#123; super.setName(name); &#125; @Override public void run()&#123; //加锁 synchronized (u)&#123; Thread.currentThread().suspend(); &#125; &#125; &#125; public static void main(String[] args)throws InterruptedException&#123; t1.start(); Thread.sleep(100); t2.start(); t1.resume(); t2.resume(); t1.join(); t2.join(); &#125;&#125; yield &amp; joinA.join(0)等待A结束后执行 用wait实现join实现 As a thread terminates the this.notifyAll method is invoked.It is recommended that applications not use wait, notify, ornotifyAllon Thread instances.不要在Thread实例上使用，会影响系统API wait该线程释放监视器所有权。 在同步方法中使用虚拟机实现notifyAll，在Object上。结束时会唤醒所有等待线程。12345if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; 守护线程t.setDaemon(true);虚拟机不会管守护线程是否存在，直接退出。 优先级12high.setPriority(Thread.MAX_PRIORITY);low.setPriority(Thread.MIN_PRIORITY); wait &amp; notify-Object.wait() 线程等待在当前对象上 The current thread must own this object’s monitor.releases ownership of this monitor and waits until another thread notifies -Object.notify()通知等待在这个线程上的对象 随机唤醒一个 Wakes up a single threadthat is waiting on this object’s monitor. 12synchronized (object) &#123; object.wait();&#125;synchronized (object) &#123; object.notify();&#125; 同步 synchronized独占加锁 java.util.concurrent 并发工具包 CyclicBarrier(int num)等待多个线程到达预定点 执行器 并发集合 Frok/Join框架：并行 atomic包：不需要锁即可完成并发环境变量使用的原子性操作 locks包]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F04%2F12%2Fperformance%2F</url>
    <content type="text"><![CDATA[谷歌 PageSpeed团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。 浏览器解析 Firefox 规则树 CSS图像精灵 减少http请求次数服务端对静态文件gzip压缩使用css/js（内容不是很多）内嵌式减少http请求 JS和DOM的映射机制是浏览器的监听机制是，DOM操作会触发浏览器回流和重绘。减少css选择器前缀，使用组合名表示层级。避免使用css表达式 服务器多处理304缓存，客户端利用localStoreage将css/js存储在本地。少使用闭包，会产生不销毁的栈内存。内存泄漏。eval性能消耗大，压缩后会错乱。DOM事件绑定使用事件委托（代理），把事件绑定给外层容器，里面元素触发外层也触发（冒泡）。通过事件源判断做不同的操作。 用CSS3替代js动画，css3有硬件加速。减少css滤镜使用和页面flash。 CDN 效果最佳 数据懒加载 分页(后台) html渲染 外部资源在浏览器加载是并发加载，对于单个域名浏览器的并发度有限，设3-4个CDN域名，防止浏览器达到外部资源并发请求数目上限，导致资源不能并发请求。 css阻塞用link在head导入css会阻塞页面渲染，阻塞js执行，但是不阻塞外部脚本加载 js阻塞不用defer和async直接用&lt;script src&gt;会阻塞页面渲染，不阻塞资源加载，阻塞执行async 不会阻塞页面加载，放弃了js依赖关系 懒加载 zepto.js 图片 进入可视区域再加载，浏览器并发上限如果图片和静态资源在的cdn是同一个，图片加载会阻塞js加载 img的src并不是图片的url是只有1px的占位符，图片标签被放在data-url属性上，js监听scroll事件。 lazyload=true。触发时链接放到background-image中 dom上底边(clientHeight) 到页面顶部的距离小于 手机屏高 则可视 addEventListener(&#39;scroll&#39;,lazyload) 遍历所有懒加载标签document.querySelectorAll(&#39;div[lazyload]&#39;) 获取距离顶部的位置 12345element.getBoundingclientRect()&gt;document.querySelectorAll('img[src]')[0].getBoundingClientRect()//输出 DOMRect &#123;x: 0, y: 0, width: 0, height: 0, top: 0, …&#125;&gt;document.querySelectorAll('img[src]')[99].getBoundingClientRect()//输出 DOMRect &#123;x: 835, y: -1604, width: 22, height: 22, top: -1604, …&#125; NodeList，它里面没有.forEach方法 123456789Array.prototype.forEach.call(nodes,function(item,index))&#123;var image = new Image()//请求图片资源image.src=dataurl//赋值到item上image.onload = function()&#123;item.src = img.src&#125;item.removeAttribute('data-original')item.removeAttribute('lazyload')&#125; 预加载preloadjs 九宫格抽奖 style=&quot;display:none&quot; 使用new Image() XMLhttpRequest2加了对请求过程的监控xmlhttprequest.onprogress 会有跨域问题123456789var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callback;xmlhttprequest.open("GET",".jpg",true)xmlhttprequest.send() //请求返回时会 onreadystatechangefunction callback()&#123; if(xmlhttprequest.readyState==4&amp;&amp;xmlhttprequest.status==200)&#123; var responseText = xmlhttprequest.responseText; &#125;&#125;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F04%2F11%2Fwebpack%2F</url>
    <content type="text"><![CDATA[npm init 生成package.json文件 npm i webpack 新建build文件夹 放配置文件 webpack.config.js: 仍出一个webpack配置对象module.exports = { } entry 入口文件 防止系统差异引用const path= require(&#39;path&#39;) app:path.join(__dirname,&#39;../app.js&#39;):__dirname 当前文件夹 output:{filename:&#39;[name].[hash].js} 中括号表示变量,[name]表示entry下对应的名字,加上打包后的hash值，有任何文件改动hash变化，浏览器刷新缓存 publicPath:”” (js,css404:”/“绝对路径，”./“相对路径)静态资源引用时的路径，区分静态资源还是api请求，如果部署到CDN，写CDN前缀 配置moudle识别jsxtest后面跟正则表达式（以jsx的）表示文件类型loader是编译工具，编译成ES5 安装babel-core 1234moudle:&#123;rule:[ test:'/.jsx$/'， loader：'babel-loader' ]&#125; 配置babel（默认编译ES6）的配置文件.babelrc presets 支持的语法 123456&#123; "presets":[ ["es2015",&#123;"loose":true&#125;], "react" ]&#125; 用松散模式编译ES6,用react语法 安装babel的3个包 安装html-webpack-plugin -D并 require 能生成一个html页面把entry里的都注入，路径根据output 123plugins:[new HTMLplugin()] 没有启动服务器没有做路径映射所以访问不到js文件将publicPath设置为’’变成相对路径react的js文件也需要babel但是nodemodules里面都是js 1234567&#123; test:/.js$/, loader:'babel-loader', exclude:[ path.join(_direname,'../node_modules') ]&#125; 服务端渲染：单页js写的应用SEO不友好、请求时间长webpack.config中的内容复制到webpack.config.servertarget:&#39;node打包完在哪执行可以是node/web（浏览器 entry:app： export default的js libraryTarget：’AMD’ 模块加载方案 nodejs：commonjs2 服务端渲染不需要htmlplugin rimraf dist 是nodejs的包 专门用来删除文件夹 moudle.exports nodejs的导出方式 commonjs2 的写法 export default。 require的时候加.default 将node启动后渲染出server.js的插入html 新建html文件new HTMLPlugin({template:path.join(__dirname,&#39;../client/template.html&#39;)})生成的html以template为模板 server端读template文件 同步读12const template = fs.readFileSync(path.join(,index.html),'utf8')res.send(template.replace('&lt;app&gt;&lt;/app&gt;'),appString) Webpack-dev-server安装 contentBase:静态文件地址 hot启动 hot-module-replacement 数据请求也刷新？ 黑色弹窗报错overlay:{ errors:true } cross-env不同系统环境变量配置 mac上可执行的在windows上可能不行 historyApiFailback:{index:’/index.html’404路径返回index webpack.bace放client和server相同的js代码 hot-module-replacement 在babel配置文件中配置]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mySQL]]></title>
    <url>%2F2018%2F04%2F08%2Fmysql%2F</url>
    <content type="text"><![CDATA[626 相邻id的人互换位置12345678910111213141516171819+---------+---------+| id | student |+---------+---------+| 1 | Abbot || 2 | Doris || 3 | Emerson || 4 | Green || 5 | Jeames |+---------+---------+For the sample input, the output is:+---------+---------+| id | student |+---------+---------+| 1 | Doris || 2 | Abbot || 3 | Green || 4 | Emerson || 5 | Jeames |+---------+---------+ mysql存储引擎 MyISAM读操作和插入操作为主 很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高 MyISAM 的表又支持 3 种不同的存储格式，分别是： 1静态（固定长度）表； 静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，如果需要保存的内容后面本来就带有空格，那么在返回结果的时候也会被去掉. 2动态表； 是频繁地更新删除记录会产生碎片，需要定期执行 OPTIMIZE TABLE 语句或 myisamchk -r 命令来改善性能 3压缩表。 innodb自增长列 外键InnoDB 存储表和索引有以下两种方式。1 使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。2 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。 即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和未作日志放在这个文件中。 memoryMEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。可以指定使用 HASH 索引还是 BTREE 索引 使用唯一索引索引的列的基数越大，索引的效果越好。存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M”和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。 explain key_len 计算方法原来数据类型长度+使用变长字段需要额外增加2个字节，使用NULL需要额外增加1个字节 索引左前缀在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。比如：索引index1:(a,b,c)有三个字段走index1索引:12345select * from table where a = '1' select * from table where a = '1' and b = ‘2’ select * from table where a = '1' and b = ‘2’ and c='3' 特殊情况说明下，select * from table where a = &#39;1&#39; and b &gt; ‘2’ and c=&#39;3&#39;这种类型的也只会有a与b走索引，c不会走。 像select * from table where a = &#39;1&#39; and b &gt; ‘2’ and c=&#39;3&#39; 这种类型的sql语句，在a、b走完索引后，c肯定是无序了，所以c就没法走索引，数据库会觉得还不如全表扫描c字段来的快。 Fulltext 索引主要用来替代效率低下的 LIKE ‘%***%’ 操作Fulltext 索引主要用来替代效率低下的 LIKE ‘%***%’ 操作 BTREE 索引与 HASH 索引HASH 索引：1 只用于使用=或&lt;=&gt;操作符的等式比较。2 优化器不能使用 HASH 索引来加速 ORDER BY 操作。3 MySQL 不能确定在两个值之间大约有多少行。如果将一个 MyISAM 表改为 HASH 索引的 MEMORY 表，会影响一些查询的执行效率。4 只能使用整个关键字来搜索一行。 BTREE 索引，当使用&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=或者&lt;&gt;，或者 LIKE ‘pattern’（其中’pattern’不以通配符开始）操作符时，都可以使用相关列上的索引。例如索引字段进行范围查询的时候，只有 BTREE 索引可以通过索引访问：123456789101112131415SELECT * FROM t1 WHERE key_col &gt; 1 AND key_col &lt; 10; SELECT * FROM t1 WHERE key_col LIKE 'ab%' OR key_col BETWEEN 'lisa' AND 'simon';explain SELECT * FROM city WHERE country_id &gt; 1 and country_id &lt; 10 \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: city type: range possible_keys: idx_fk_country_id key: idx_fk_country_id key_len: 2 ref: NULL rows: 24 Extra: Using where 1 row in set (0.00 sec) HASH 索引实际上是全表扫描的： 12345678910111213mysql&gt; explain SELECT * FROM city_memory WHERE country_id &gt; 1 and country_id &lt; 10 \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: city_memory type: ALL possible_keys: idx_fk_country_id key: NULL key_len: NULL ref: NULL rows: 600 Extra: Using where 1 row in set (0.00 sec) INET_ATON INET_NTOAINET_ATON(IP)和 INET_NTOA(num)函数主要的用途是将字符串的 IP 地址转换为数字表示的网络字节序，这样可以更方便地进行 IP 或者网段的比较。 “192.168.1.3”和“192.168.1.20”之间一共有多少 IP 地址： 123select * from t where inet_aton(ip)&gt;=inet_aton('192.168.1.3') and inet_aton(ip)&lt;=inet_aton('192.168.1.20'); 常用字符串函数 !!!176 第二大 limit offset123SELECT MAX(Salary) as SecondHighestSalary FROM Employee WHERE Salary &lt;&gt; ( SELECT MAX( Salary) FROM Employee ) 如果只有一条数据 下面代码不行123select distinct Salary as SecondHighestSalaryfrom Employee order by Salary desc limit 1 offset 1; 196 !!!删除重复的emailsselect and update conflictdelete from Person where id not in(select min(id) as id from Person group by email)错误 You can’t specify target table ‘Person’ for update in FROM clause 正确做法：12345delete from Person where id not in( select t.id from ( select min(id) as id from Person group by email )as t); 12delete p2 from Person p1 ,Person p2where p1.id &lt; p2.id and p1.Email = p2.Email; 时间日期函数 !!! 197 TO_DAYS找到比前一天温度高的天 按日期列排序DATEDIFF12SELECT w1.Id FROM Weather w1, Weather w2WHERE w1.Temperature &gt; w2.Temperature AND DATEDIFF(w1.Date, w2.Date) = 1; Subdate12SELECT w1.Id FROM Weather w1, Weather w2WHERE w1.Temperature &gt; w2.Temperature AND SUBDATE(w1.Date, 1) = w2.Date; TO_DAYS12SELECT w1.Id FROM Weather w1, Weather w2WHERE w1.Temperature &gt; w2.Temperature AND TO_DAYS(w1.Date) = TO_DAYS(w2.Date) + 1; (student,class)表中找学生数&gt;=5的课程1234567SELECT classFROM coursesGROUP BY classHAVING COUNT(DISTINCT student) &gt;= 5; 183 NOT IN 在order表(id,customerid)中找到没买过东西的用户123456select Name as Customers from customerswhere customers.Id not in( select CustomerId from orders); 175 拼接有1列相同的两张表 using , natural left join123select FirstName,LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId; 1234SELECT FirstName, LastName, City, StateFROM PersonLEFT JOIN AddressUSING(PersonId); 12select FirstName,LastName, City, State from Person natural left join Address; 181 根据领导id列找到比领导拿前多的人join on？为什么group by那么快1234567891011select E1.Name as Employee from( select * from Employee )E1 left join ( select * from Employee group by id )E2 on E1.ManagerId = E2.Id where E1.Salary &gt; E2.Salary 182找出重复的 group by和having123select Email from Persongroup by Email having count(Email) &gt; 1; 去重 select distinct Email from Person; mod 用法12345SELECT * FROM CINEMAWHERE id mod 2 = 1 AND description != 'boring'ORDER BY 4 DESC 流程函数 ifnull替换空值1select ifnull(salary,0) from salary; case when 12345select case when salary&lt;=2000 then 'low' else 'high' end from salary; 更新交换字段12345update salary set sex = case sex when 'm' then 'f' else 'm' end; union 比 or 快123456789SELECT name, population, areaFROM WorldWHERE area &gt; 3000000 UNIONSELECT name, population, areaFROM WorldWHERE population &gt; 25000000 比2个or快 using UNION ALL is much faster than UNION since we don’t need to sort the result. Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index. 有哪些清空表的方式？正确答案: A B C 你的答案: A C D (错误)A.drop表然后重建B.truncate表C.delete表D.update表 常用的分析函数有哪些正确答案: A B C 你的答案: B (错误)A.row_number()B.rank()C.dense_rank()D.mix_rank() 取前价最高的top100商品，需要用到哪些函数组合？正确答案: A B C 你的答案: A C (错误)A.order byB.group byC.limitD.max 全文检索MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。 cross join以下数据表连接正确的有？正确答案: A B C D 你的答案: A B C (错误)A.joinB.left joinC.right joinD.cross join Cross Join.From A cross join B is produces the cartesian product A × B. Each A will be repeated once for every B. If A has 100 rows and B has 100 rows, the result set will consist of 10,000 rows. HavingHAVING非常类似于WHERE。事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。 Uinon &amp; Union all在数据库的SQL语言开发中，下述关于Union和Union all的描述哪些是正确的：正确答案: A B D 你的答案: B C D (错误)A 使用Union或Union all组合查询的数据集，需满足两个条件： 列数和列的顺序必须相同；数据类型必须兼容B.Union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。C.Union all返回的结果集就会包含重复的数据了，如果表数据量大的话可能会导致用磁盘进行排序。因此，从效率上说，union要比union all快很多D.如果可以确认合并的两个结果集中不包含重复的数据的话，那么就建议使用Union all Union： UNION中的每个查询必须包含相同的列、表达式或聚集函数 truncate下面关于TRUNCATE 和DELETE 的说法正确的是正确答案: C D 你的答案: A C (错误)A.TRUNCATE 属于DDL，而DELETE 属于DMLB.TRUNCATE 与DELETE 均能够删除表中的指定记录C.TRUNCATE 不能删除表中指定的记录，而DELETE 能够删除表中的指定记录D.在清空表记录的操作时，TRUNCATE 的执行效率比DELETE 高 关于delete与truncate 区别: delete和truncate table的最大区别是delete可以通过WHERE语句选择要删除的记录。但执行得速度不快。而且还可以返回被删除的记录数。而truncate table无法删除指定的记录，而且不能返回被删除的记录。但它执行得非常快。 C:DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。 D:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。 范式以下哪一个不是对数据库关系范式的目的？正确答案: B 你的答案: B (正确)A减少数据冗余B加快查询速度C解决更新异常问题D提高存储空间效率 非主属性非部分依赖于主关键字，这个是哪个范式的定义正确答案: B 你的答案: B (正确)A1NFB2NFC3NF 第三范式 不存在 传递函数依赖关系 名字可以决定分类；分类可以决定分类描述 则存在非关键字段 分类描述 对名称的依赖 在关系数据库系统中，为了简化用户的查询操作，而又不增加数据的存储空间，常用的方法是创建正确答案: C 你的答案: C (正确)A另一个表（TABLE）B游标（CURSOR）C视图（VIEW）D索引（INDEX） QPS TPSmysql当前一个sql语句只能用到一个cpuqps：每秒查询量并发量会使cpu连接数占满1000Mb/8 = 100MB 的网卡 减少从服务器 减少主从同步但表超过千万行 or 表数据文件超过10G mysql&lt;5.5 建立索引会锁表。&gt;=5.5不锁表但是会主从延迟 DDL操作：create、alert、drop、index、syn、cluster 修改表结构的操作mysql主从复制是单线程。大表修改在从服务器上没有完成。其他操作都不能执行。 大事务：windows xp 默认tcp并发数只有10 QPS是每秒处理的sql数量，而40个cpu同时并发处理40个sql是指纳秒级的web应用核心数量比主频更重要。 MyISAM 索引在内存中，数据通过操作系统缓存。InnoDB 同时在内存中缓存数据和索引。缓存可以把浏览量计数器很多次先写到缓存，再一批存到磁盘。 开启mysql查询日志https://blog.csdn.net/leshami/article/details/39779225123456789101112131415show variables like '%general%';+------------------+------------------------------+| Variable_name | Value |+------------------+------------------------------+| general_log | ON || general_log_file | /var/lib/mysql/localhost.log |+------------------+------------------------------+set @@global.general_log=1;cat /var/lib/mysql/localhost.log/usr/sbin/mysqld, Version: 5.6.41 (MySQL Community Server (GPL)). started with:Tcp port: 3306 Unix socket: /var/lib/mysql/mysql.sockTime Id Command Argument180905 18:24:55 5 Query select id,name from poi where lng between 116.3284 and 116.3296 and lat between 39.9682 and 39.9694180905 18:26:00 5 Query show variables like '%general%'180905 18:28:44 5 Query select * from poi where 1=1 mybatis逆向工程generatorConfig.xmlexplain执行计划 ：select,update,insert,replace,delete 分区show plugins;可以看到partition 则可以分区。逻辑上一个表，物理上多个文件中。在create table的最后加上partition by hash(id) partitions 4.frm存储表数据.ibdinndb数据文件分区之后.ibd会有好几个 hash分区 利用表中的int列或者by hash(UNIX_TIMESTAMP(login_time))将timestamp转成intrange分区 log推荐使用 日期/时间 查询的时候包含分区键 适合定期清理历史数据1234partition by range(id)( partition p0 values less than(10000), partition p1 values less than(20000), partition p3 values less than maxvalue); list分区 按枚举123partition by list(type)( partition p0 values in (1,3,5,7,9), partition p1 values in (2,4,6,8)); 到了新的一年添加分区1alter table t1 add partition (partition p4 values less than(2018)); 删除分区1alter table t1 drop partition p0; 归档新建一个和t1结构相同的 非分区表t2 .一般迁移后删除分区，切换归档表的存储引擎分区表只能查询不能写 分区表梗适合用mysam引擎123alter table t1 exchange partition p0 with table t2;#--drop之后切换引擎alter table t2 ENGINE=ARCHIVE; password用char(32)timestamp on update CURRENT_TIMESTAMP字段会在表被修改时自动更新 Mybatis mybatis-3-config.dtd: 可以用&lt;properties&gt;导入配置文件在&lt;mappers&gt;里可以用&lt;package&gt;导入整个有mapper.xml的文件夹 mybatis-3-mapper.dtd&lt;typeAliases&gt;中添加&lt;package&gt;自动扫描包，将类名作为别名 PageHelper.orderBy(&quot;price desc&quot;)按价格降序（sql中的order by 之后的格式） mysql like通配符% 任意多个字符 ER图矩形：实体特化：自顶向下继承设计概化：底向上菱形：联系集：把多对多变成1对多 用虚线连接联系集的属性 双线：全参与：表示在联系集中的参与度&lt;advisor&gt;=student表示每个学生都要有导师，双边菱形：表示弱实体集和它依附的实体集。当弱实体集里放入依赖的实体集的id，则不需要联系集 椭圆：属性角色：&lt;先修课联系集&gt;和[课程]的联系通过course_id和prereq_id角色标识区分派生属性：可以通过其它属性计算得到复合型属性应该拆分成2个属性多值型（一个老师对应多个电话）应该用另一个(id,phone)(1,phone1)(1,phone2)每个属性映射到单行映射基数：1：1，1：n,n:1,n:n基数约束：导师&lt;-&lt;advisor&gt;-学生 一对一：箭头从关系指向实体：导师&lt;-&lt;advisor&gt; 一名学生只有一名导师 一对多：没有箭头表示多端，有箭头表示“一”端 &lt;advisor&gt;-学生 一名老师可以有多名学生。导师 0..* &lt;advisor&gt; 1..1 学生 参与的上限..下限，0表示老师参与的下线是0，不是全参与，是半参与。 天然的三元关系 导师 项目 学生 通过一个联系集不能拆分成2个二元关系。 什么时候作为实体:instructor/ins-phone/phone三张表什么时候作为属性instructor(phone) 只对名字和单值（不是多值（对应多个电话））感兴趣则为属性：性别。 一个对象除了名字意外，还有其它属性要描述则定义成实体：电话、住址、部门。 是实体集还是用联系集（对象之间的动作）：考虑映射的基数customer-&lt;loan&gt;-branch 但是当要表示一个客户在一个银行里多笔贷款customer-&lt;borrow&gt;-loan(实体)-&lt;Loan-bra&gt;-branch客户与贷款多对多，贷款对支行一对多。 用属性student(supervisior-id,supervisior-name)还是用联系集&lt;stu-sub&gt;,&lt;stu-class&gt; innodb有索引组织表 IP地址字符串转intINET_ATON(&#39;255,255,255,255&#39;)=4292967295(无符号int最大值)INET_NTOA(&#39;4292967295&#39;)=’255,255,255,255’Varchar(255)utf-8汉字3个字节 总共765字节避免使用TEXT64k,BLOB 可以用varchar mysql内存映射表不持支，所以排序只能用磁盘映射表 timestamp只能存到2038年01-19 decimal精确浮点类型 预编译语句 每次执行只需要传递参数 节省带宽12345prepare stmt1 from 'select sqrt(pow(?,2)+pow(?,2)) as hypotenuse';set @a=3;set @b=4;execute stmt1 using @a,@b;deallocate prepare stmt1 将where date(ctime)=&quot;20160901&quot;改成where ctime&gt;=&#39;20160901 and ctime&lt;&#39;20160902可以使用索引 范围查询会使联合索引失效 要把范围查询的表放到索引右侧使用leftjoin/not exists代替 not in（会使索引失效 索引列的循序 区分度(列中唯一值数量/总行数)高的放在联合索引左边不使用外键 外键用于数据参照完整性（数据一致性）但是降低写性能，可以用其它方式保证一致性 但是要在表之间的关联键上建立索引 慢查询开启慢查询日志 SQL监控1show variables like 'slow_query_log'; 记录没有使用索引的sqllog_queries_not_using_indexes 变量123show variables like '%log%';set global log_queries_not_using_indexe=on;set long_query_time = 1; long_query_time超过多少秒之后的查询记录在日志中查看慢查询日志的位置1show variables like 'slow%'; 慢查询分析工具mysqldumpslowcount(1)和count(*)和count(*)count(1)比count（*）效率高一些123create table t(id int);insert into t value(1),value(2),(null);select count(*),count(id),count(1) from t; count(*) count(id) count(1) 3 2 3 内置类型now() 数据类型 int(11)和int(21)都占4个字节，区别在于补零位数 123create table t(a int(11) zerofill, b int(21) zerofill);insert into t values (1, 1);select * from t; char和varchar存储字符数。 char 存储255个字符，varchar根据类型计算字符数，上限是65535个字节 char会自动补空，varchar&lt;=255用一个字节&gt;255用两个字节存储长度length desc 查看表结构 mysql join inner join内连接，两张表的公共部分 数据库会先在每个表里先查条件再生成笛卡儿积select a.name from a A inner join b B on A.name =B.name; left outer join左外连接，以左表为基础 内链接当左表中查询条件是null的时候被忽略，外连接则有用左外连接查询只存在A中不存在B中的where B.Key is NULL (优化not in不会使用索引)select * from b left outer join a on a.name =b.name where a.Id is null; right outer joinselect * from a right outer join b on a.name =b.name where a.Id is null; full join count(*),min(p.&#39;price&#39;) group by p.&quot;id&quot;,&quot;name&quot;数据库Myisam表锁 -&gt; Innodb 行锁 从大锁到小锁提升并行度MyISAM引擎不持支事务，优点是读写快,列存储5.5之前的默认Innodb支持事务ACID 行级锁，高并发场景好 JDBCstatic final String JDBC_DRIVER=&quot;com.mysql.jdbc.Driver&quot;; close放在finally里，保证执行 防止空指针异常 12345finally&#123; if(conn!=null)conn.close(); if(stmt!=null)stmt.close(); if(rs!=null) rs.close(); &#125; 游标：读取记录太多，内存放不下。DB_URL:useCursorFetch=true 1static final String DB_URL ="jdbc:mysql://localhost/scraping?characterEncoding=utf8&amp;useCursorFetch=true&amp;useSSL=true"; ptmt=conn.prepareStatement(sql); 每次从服务器端取回记录的数量ptmt.setFetchSize(1); rs = ptmt.executeQuery(); 流方式:记录中存在大字段内容：博文。读一条记录内存可能放不下。 变成二进制流读取小区间 InputStream in = ResultSet.getBinaryStream(&quot;blog&quot;) 在外部生成一个文件，每次读取一行输出到外部文件1234567File f = new File(FILE_URL);OutputStream out = null;out = new FileOutputStream(f);int tmp = 0;while((tmp= in.read)!==-1)out.write(tmp);in.close();out.close(); 连接池 DriverManager.getConnection流程客户端利用密码种子和自己保存的数据库密码按加密算法得到加密密码 每个线程使用数据库连接后不销毁，每个请求从连接池中【租借】连接 数据库服务器端处理请求时要分配资源，请求结束后被释放。服务器设置最大并发连接数。抛toomanyConnection异常。应在客户端中实现业务线程排队获取数据库连接。 DBCP是一组jar包：commons-dbcp,jar,commons-pool.jar,commons-logging.jar dbcp重写了Connection的close方法，把销毁数据库连接改成了归还给连接池 12345678public static void dbpoolInit()&#123; db = new BasicDataSource(); db.setUrl(DB_URL); db.setDriverClassName(JDBC_DRIVER); db.setUsername(USER); db.setPassword(PASSWORD); db.setMaxTotal(2);&#125; 优化连接池 提高第一次访问数据库的速度，在连接池中预制一定数量的连接.setInitialSize(1) .setMaxTotal()设置客户端的最大连接数，超过的不创建新连接，而是进入等待队列 .setMaxWaitMillis()设置最大等待时间 .setMaxIdel()空闲连接数的最大值，超过则销毁 setMinIdel()空闲数低于则创建，建议于MaxIdel相同 DBCP定期检查，服务端会自动关闭空闲连接，连接池可能租借失效的连接 定期检查连接池中连接的空闲时间 开启.setTestWhileIdel(True) 应该销毁的最小空闲时间.setMinEvictableIdleTimeMillis() 检查的时间间隔,应小于服务器自动关闭连接的时间（Mysql 8小时).setTimeBetweenEvictionRunsMillis() Mysql show processlist;查看连接数 防范SQL注入&#39;-- 参数化sql conn.prepareStatement(sql)传入格式化sql,需要传入的参数用？占位 1Select * from user where userName = ? And password=? 传入参数ptmt.setString(1,username) 参数位置从左往右1开始 数据库权限、封装数据库异常 mysql AES_ENCRYPT/AES_DECRYPTstring加密/解密 事务：单个逻辑工作单元执行的一系列操作，逻辑工作单元满足ACID(原子、一致、隔离、持久) ，并发控制的基本单位。1234567try&#123;Connection.setAutoCommit(false)//开启事务Connection.commit()//提交事务Connection.rollback()//事务回滚&#125;catch(SQLException e)&#123; if(Connection!=null)Connection.rollback()&#125; 检查点12Savepoint sp = Connection.setSavepoint();Connection.rollback(sp); 事务的隔离级别 脏读：一个事务读取了一个事务未提交的更新 不可重复读：同一个事务，两次读取值不一样。 幻读：同一个事务，两次读取行记录数目不一样。插入了新记录 隔离级别 脏读 可重复读 幻读 读未提交 √ X √ 读提交 X X √ 可重复读 X √ √ 串行化 X √ X 读未提交：允许脏读 读提交：不允许脏读，可以不可重复读 重复读：可能出现幻读。 MySQL的事务隔离级别。 1set 串行化：最高隔离级别，所有事务串行执行，不能幻读。 设置和获取事务隔离级别12Connection.getTransactionIsolation()Connection.setTransactionIsolation() MySQL的锁 排他锁X：与任何锁都冲突，等待。（写锁） 共享锁S：多个事务共享一把锁。其它事务不会被阻塞。（读锁）加锁方式 外部加锁：SQL语句 共享 select * from table lock in share mode 排他 select * from table for update 内部自动加锁 加锁粒度和策略：表锁table lock：开销少；行锁（row lock): innoDB MySQL所有的select读都是快照读。存储引擎Innodb实现了多版本控制（MVCC)，不加锁快照读。所以一个事务内部保证select数据一致要外部加锁 MVCC 在每行记录后面保存两个隐藏的列：行创建时间，过期时间。通过版本号记录时间，每开始新的事务，系统版本递增。 Update 对行加排他锁X 分析MySQL处理死锁：show engine innodb status Mybatis 底层基于JDBC SqlSessionFactory实例能将对象操作转换成数据库操作事务管理器transactionManager type = &quot;jdbcdataSource驱动、url、用户名、密码 对象类、操作接口 映射文件&lt;mapper namespace = &quot;操作接口&quot;&gt; 将映射文件加载到配置文件&lt;mappers&gt;&lt;mapper resource=&quot;&quot;&gt; 测试123456789101112131415161718192021public static void main(String[] args) &#123; // 1. 声明配置⽂文件的⺫⽬目录渎职 String resource = "confAnnotation.xml"; // 2. 加载应⽤用配置⽂文件 InputStream is = HelloMyBatisAnnotation.class.getClassLoader().getResourceAsStream(resource); // 3. 创建SqlSessonFactory SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder() .build(is); // 4. 获取Session SqlSession session = sessionFactory.openSession(); try &#123; // 5. 获取操作类（接口） GetUserInfo getUserInfo = session.getMapper(GetUserInfo.class); // 6. 完成查询操作 User user = getUserInfo.getUser(11); System.out.println(user.getId() + " " + user.getUserName() + " " + user.getCorp()); &#125; finally &#123; // 7.关闭Session session.close(); &#125; &#125; 在操作接口上用注解@select ResultMap 构造方法 mapper.xml1234567891011&lt;resultMap id="UserMap" type="com.micro.profession.mybatis.resultMapTest.User"&gt; &lt;constructor&gt; &lt;idArg column="userId" javaType="int" /&gt; &lt;arg column="userName" javaType="String" /&gt; &lt;arg column="corp" javaType="String" /&gt; &lt;/constructor&gt; &lt;collection&gt; &lt;association&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F04%2F04%2Fcanvas%2F</url>
    <content type="text"><![CDATA[创建1. canvas正确绘制时，标签内容会被忽略 不能在css中定大小123&lt;canvas id="canvas" width="800" height="600" style="border: 1px solid red;"&gt; 当前浏览器不持支Canvas&lt;/canvas&gt; 2. 判断当前浏览器12345678window.onload= function()&#123; var canvas = document.getElementById('canvas') if(canvas.getContext("2d")) &#123; var context = canvas.getContext('2d') &#125;else&#123; alert("当前浏览器不支持canvas") &#125; &#125; 3. 设置画布大小不需要px12canvas.width=1024canvas.height=768 4. 画路径:.colsePath不是封闭路径时 会自动封闭1.begin 重新规划2.close 自动封闭3..arc(圆心坐标x,y,半径r,开始弧度起始点,结束弧度起始点,是否逆时针false)12345678for(var i = 0;i&lt;10;i++)&#123; context.beginPath() context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10) //只使用beginPath不使用closePath就不会有封闭线段 context.closePath() context.stroke() //下一次.bgeinPath会重新规划路径&#125; 5. context.fill()会把边框内测一半像素覆盖，fill写在路径和stroke中间1234context.arc(50+i*100,60,40,0,2*Math.PI*(i+1)/10)context.fillStyle= "yellow"context.fill()context.stroke() 6. 矩形 路径：.rect(左上角坐标x,y,width,height) 直接绘制： 填充、边框.fillRect(x,y,width,height).strokeRect(x,y,width,height) 7. 线条两端属性lineCapcontext.lineCap=&quot;round&quot; 超出原来的长度的部分是圆形context.lineCap=&quot;squre&quot; 8. 画星 5个角，一个角隔72° 大圆半径300，小圆半径150123456789context.beginPath()for(var i =0;i&lt;5;i++)&#123; context.lineTo(x=Math.cos((18+i*72)/180*Math.PI)*300+400, y=-Math.sin((18+i*72)/180*Math.PI)*300+400) context.lineTo(x=Math.cos((54+i*72)/180*Math.PI)*150+400, y=-Math.sin((54+i*72)/180*Math.PI)*150+400)&#125;context.stroke()context.closePath() 9. lineJoin 线段连接处bevel线条顶端不会衍生自然形成尖角，形成纸带折叠效果context.lineJoin=&quot;miter&quot; context.miterLimit=0.01内角和外角的最大值。超过则使用bevel显示 10. 保存绘图状态,图形变换时123context.save() context.translate(100,100)context.restore() 11. 与鼠标事件交互 down up out move1234567891011121314151617181920var isMouseDown = falsecanvas.onmousedown=function (e) &#123; e.preventDefault() isMouseDown= true&#125;canvas.onmouseup=function (e) &#123; e.preventDefault() isMouseDown= false&#125;//按着画布出画布也是不想画canvas.onmouseout=function (e) &#123; e.preventDefault() isMouseDown= false&#125;canvas.onmousemove=function (e) &#123; e.preventDefault() if(isMouseDown== true)&#123; 画图() &#125;&#125; preventDefault在pc端作用不大，移动端和键盘操作例如：小游戏中的角色运动：上下，同时是浏览器上下移动翻页操作 1. 转换鼠标位置为相对canvas内的位置1234 function window2canvas(x,y)&#123; var canvasbox = canvas.getBoundingClientRect() return &#123;x:Math.round(x-canvasbox.left),y:Math.round(y-canvasbox.top)&#125;&#125; 2. 鼠标移动在canvas上画 onmousemove执行频繁只要绘制直线就能达到曲线 设置变量记录上一个位置var lastLoc = {x:0,y:0} down时记录lastloc,move记录currentloc 123context.moveTo(lastLoc.x,lastLoc.y)context.lineTo(curloc.x,curloc.y) //context.stroke()lastLoc = curloc 平滑移动 12context.lineCap = "round"context.lineJoin = "round" 笔压:速度 = 距离/时间 距离 12function calculateDistance(loc1,loc2) &#123; return Math.sqrt((loc1.x-loc2.x)*(loc1.x-loc2.x)+(loc1.y-loc2.y)*(loc1.y-loc2.y))&#125; 时间var lastTimestamp =0 mouseover:var curstamp = new Date().getTime()var timedif = curstamp-lastTimestamp 宽度1234567891011121314151617function calLineWidth(t,s) &#123; var width var speed = s/t //1. 速度最小，宽度最大 if(speed&lt;=0.1) width= MAXWIDTH //2. 速度很大，宽度最小 else if (speed&gt;10) width = 1 //3. 中间宽度：（当前速度-最小速度）/（最大速度-最小速度）*宽度取值范围 else width = MAXWIDTH- (speed-0.1)/(10-0.1)*(MAXWIDTH-1) console.log(width) if (lastWidth==-1) return width else width = lastWidth*4/5+width*1/5 lastWidth = width return width &#125; 清除画布 context.clearRect(0,0,canvasWidth,canvasHeight) 12. 移动端自适应1234567&lt;meta name="viewport" content = "height = device-height, width = device-width, initial-scale = 1.0, minimum-scale = 1.0, maximum-scale = 1.0, user-scalable=no"/&gt; 13. 触控touch时间 start move end touch = e.touchs[0]从多点触控TouchList中获取touch clientX/Y -&gt;Y:568 pageX/Y -&gt;Y:650 将 e.x/y封装到point.x/y 1234567 canvas.addEventListener("touchmove",function(e)&#123; e.preventDefault() if(isMouseDown) touch = e.touches[0] moveStroke(&#123;x:touch.pageX,y:touch.pageY&#125;)&#125;)]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx/Http/HSTS]]></title>
    <url>%2F2018%2F04%2F02%2Fnginx%2F</url>
    <content type="text"><![CDATA[对于Http1.1协议，如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过content-length来指定，客户端会接收数据直到服务端主动断开连接 浏览器缓存Cache-control（秒）/PragmaPragma : http1.0用的Cache-control 优先级比Expires高指定缓存多少秒 和服务端时间无关。 Expires:日期 带时区的时间是服务端时间浏览器发出请求之前检查页面这个字段，过期了重新发请求。 Last-Modified/Etag服务器在响应中返回Last-Modified。浏览器会在请求头加if-Modified-Since，如果缓存是最新的 返回304. Etag：服务器为每个页面分配编号。用编号区分这个页面是否最新。 dns域名解析10步1.浏览器缓存2.操作系统hosts3.LDNS SPA4.Root Server5.主域名服务器(gTLD) 顶级域名服务器 .com/.cn 全球只有13台左右6.LDNS向gTLD查询7.gTDL 找到域名的 Name Server（注册的）8.Name Server 返回ip和TTL给LDNS。9.LDNS缓存 并设置TTL10.用户拿到ip并设置TTL保存在本地。 一般都到域名的注册服务器去解析，一般都会CNAME到CDN的DNS负载均衡服务器 JVM在InetAddress类也会缓存DNS结果InetAddress解析域名 必须是单例模式 CDN = 镜像+cahce+整体均衡负载目标：可扩展 安全 可靠 响应 执行 https://imququ.com/post/my-nginx-conf-for-wpo.html nginx.conf下列有关Nginx配置文件nginx.conf的叙述正确的是正确答案: A D 你的答案: A B C D (错误)Anginx进程数设置为CPU总核心数最佳B虚拟主机配置多个域名时，各域名间应用逗号隔开(空格？)C.sendfile on;表示为开启高效文件传输模式，对于执行下载操作等相关应用时，应设置为onD设置工作模式与连接数上限时，应考虑单个进程最大连接数(最大连接数=连接数*进程数） sendfile 零拷贝 实际上是 Linux2.0+以后的推出的一个系统调用sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。不过需要注意的是，sendfile 是将 in_fd 的内容发送到 out_fd 。而 in_fd 不能是 socket ， 也就是只能文件句柄。 当 Nginx 是一个静态文件服务器的时候，开启 SENDFILE 配置项能大大提高 Nginx 的性能。 当 Nginx 是作为一个反向代理来使用的时候，SENDFILE 则没什么用了，因为 Nginx 是反向代理的时候。 in_fd 就不是文件句柄而是 socket，此时就不符合 sendfile 函数的参数要求了。 http://xiaorui.cc/2015/06/24/%E6%89%AF%E6%B7%A1nginx%E7%9A%84sendfile%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%A6%82%E5%BF%B5/1.系统调用sendfile()通过 DMA把硬盘数据拷贝到 kernel buffer，然后数据被 kernel直接拷贝到另外一个与 socket相关的 kernel buffer。这里没有 user mode和 kernel mode之间的切换，在 kernel中直接完成了从一个 buffer到另一个 buffer的拷贝。2、DMA 把数据从 kernelbuffer 直接拷贝给协议栈，没有切换，也不需要数据从 user mode 拷贝到 kernel mode，因为数据就在 kernel 里。 在传统的文件传输方式（read、write/send方式），具体流程细节如下： 调用read函数，文件数据拷贝到内核缓冲区read函数返回，数据从内核缓冲区拷贝到用户缓冲区调用write/send函数，将数据从用户缓冲区拷贝到内核socket缓冲区数据从内核socket缓冲区拷贝到协议引擎中在这个过程当中，文件数据实际上是经过了四次拷贝操作： 硬盘—&gt;内核缓冲区—&gt;用户缓冲区—&gt;内核socket缓冲区—&gt;协议引擎 HTTP以下有关Http协议的描述中，正确的有正确答案: A B C 你的答案: B C D (错误)A.post请求一般用于修改服务器上的资源，对发送的消息数据量没有限制，通过表单方式提交B.可以通过206返回码实现断点续传C.HTTP1.1实现了持久连接和管线化操作以及主动通知功能，相比http1.0有大福性能提升D.HTTP返回码302表示永久重定向，需要重新URI http/1.1 字符串传输持久链接：一个tcp链接里可以发送很多http请求。减少三次握手次数。pipeline:添加了host： 《Web性能权威指南》 是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。 它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2.0 最重要的一项增强。 http2:：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。 每个来源一个链接:，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。 http2：分帧传输二进制传输（不用连续）信道复用 同一个链接多个请求一个tcp链接并发http请求，不用等前一个请求接收到之后再发送。server push推送。以前要先解析html再发送请求css/js。现在请求html就获取。 nginx开启http2 开启https才能http2ALPN转称http1.1传给服务器12345server&#123; listen 443 http2; server_name test.com; http2_push_preload on;&#125; nodejs12345678if(request.url === '/')&#123; response.writeHead(200,&#123; 'Content-Type':'text/html', 'Connection':'close', //http2的push 'Link':'&lt;/test.jpg&gt;;as=image;rel=preload' &#125;)&#125; 协议变成h2chrome://net-internals/#http2 看pushed和 claimed 使用1个push到30个push的区别https的握手过程 http2性能测试 1. 环境 基本库yum -y install gcc gcc-c++ autoconf pcr^Cpcre-devel make automake 工具yum -y install wget httpd-tools vim 确认yum源可用yum list|grep gcc 关闭iptables规则iptables -L iptables -F 停用selinuxgetenforce setenforce 0 cd /opt mkdir 重启 nginx -s reload IO多路复用 使用epoll模型Linux文件描述符 文件描述符（file descriptor 是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。sysctl -a|grep fs.file-max系统级别的最大打开文件数ulimit -n 单个进程最大打开文件数 每一个文件描述符会与一个打开文件相对应，不同的文件描述符也会指向同一个文件。 rpm -ql nginx rpm包有哪些配置文件/usr/share/nginx/html HSTS（HTTP Strict-Transport-Security） 是Web安全策略机制（web security policy mechanism）HSTS： 建立起HTTPS连接之前存在一次明文的HTTP请求和重定向（上图中的第1、2步），使得攻击者可以以中间人的方式劫持这次请求，从而进行后续的攻击，例如窃听数据，篡改请求和响应，跳转到钓鱼网站等。 攻击者直接劫持了HTTP请求，并返回了内容给浏览器，根本不给浏览器同真实网站建立HTTPS连接的机会 当用户让浏览器发起HTTP请求时，浏览器将其转换为HTTPS请求，直接略过上述的HTTP请求和重定向，从而使得中间人攻击失效，规避风险。 HSTS 响应 Header：让浏览器得知，在接下来的一段时间内，当前域名只能通过HTTPS进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload] max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。 ncludeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。 preload是可选参数，只有当申请将自己的域名加入到浏览器内置列表的时候才需要使用到它 对于启用了浏览器HSTS保护的网站，如果浏览器发现当前连接不安全，它将仅仅警告用户，而不再给用户提供是否继续访问的选择 第一次访问：Preload List： 在浏览器里内置一个列表，只要是在这个列表里的域名，无论何时、何种情况，浏览器都只使用HTTPS发起连接。这个列表由Google Chromium维护，FireFox、Safari、IE等主流浏览器均在使用。 nginx: hstsadd_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always; 一旦浏览器接收到HSTS Header（假如有效期是1年），但是网站的证书又恰好出了问题，那么用户将在接下来的1年时间内都无法访问到你的网站，直到证书错误被修复，或者用户主动清除浏览器缓存。先将max-age的值设置小一些]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密]]></title>
    <url>%2F2018%2F03%2F27%2Fcryption%2F</url>
    <content type="text"><![CDATA[对称加密算法下面哪些是对称加密算法正确答案: C D 你的答案: B D (错误)A.DSAB.RSAC.DESD.AES 对称加密算法：DES,3DES,AES,RC5，Bloowfish,IDEA,TDEA非对称加密算法：RSA，DSA 不可逆：MD5，SHA1，CRC DES/AESAES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。 RSA 非对称加密算法： 甲方获取乙方的公钥，然后用它对信息加密。 乙方得到加密后的信息，用私钥解密。 n = a*b(a，b质数) n-&gt;二进制位数为密钥长度（1024） 计算n的欧拉函数φ(n) 选择65537 or 其它小于φ(n)并与φ(n)互质的整数e 计算e对φ(n)的【模反元素】dex + φ(n)y = 1求解数对x,y中的x扩展欧几里得 (n,e)为公钥(n,d)为私钥 当n被因式分解，d可以算出 被破解 安全基于角色-&gt;属性的加密算法 外边缘计算的加密算法java MDMD家族长128，MD2,MD5 JDK有实现 MD4（电驴)Bouncy Castle 报文摘要：固定长度的摘要 类似消息验证码MAC关键：找到两段内容不同而摘要相同的数据在计算上是不可能的 消息验证码MAC：计算过程用了密钥javax.crypto.Mac 数据用散列函数计算出消息验证码HMAC 消息验证码加载原始数据后 用密钥对整个数据加密后传输 数字签名security.Signature 用于验证身份A要验证B的身份： B用私钥对消息加密发送给A A用公钥解密 SSL协议 身份验证（钓鱼网站）数字签名证书 数据窃取：数据传输加密 数据串改：数据+消息验证码，接收者完整性验证流程 客户端向服务器确认SSL协议和加密算法。（可请求验证服务器身份） 服务器 发送数字签名给客户端 也可以向客户端验证身份 客户端用私钥对自己的数字证书加密发送给服务器。生成[数据传输]用的密钥，用服务器的公钥加密发送给服务器。（数据传输是对称加密，客服端和服务器使用相同密钥） 服务端验证完客户端身份，切换到数据传输直到关闭。 数字证书=身份信息+公钥。被信任机构的私钥加密，浏览器公钥验证证书合法。HTTPS安全漏洞Network-Doc http请求 Referer 防止CSRF漏洞 http响应 302 跳转 Location:跳转地址 Set-Cookie:颁发凭证 Application 查看Cookie BOM document.cookie 添加cookie document.cookie=”aaaa” window.location.href获取页面URL window.navigator.userAgent 获取浏览器信息 window.open(“http://baidu.com&quot;) 打开页面 XSS漏洞测试prompt(,)提示弹窗 WEB服务架构) SQL union 连接两个select 不显示重复的；union all socket路径：show global variables like ‘socket’; 客户端：XSS(跨站脚本注入):CSRF(跨站请求伪造) 点击劫持，URL跳转服务端：SQL注入 命令注入 文件类操作 XSS漏洞：Cross Site Script存储型 反射型 DOM型 存储型 &lt;img src=&quot;#&quot; onerror=&quot;alert()&quot;&gt;写在评论框，发送给后台 图片加载失败触发onerror事件 XSS 脚本存储在数据库中 反射型 后端写入url的参数中 ?name = &lt;image src = @ onerror= alert()&gt; DOM型window.location.hashurl的hash中#后面的值填到innerHTML CSRF（XSRF）用已登录身份以用户名义非法操作&lt;body onload = &quot;sbm()&quot;页面加载自动提交表单smt(){ .getbyID(&quot;id&quot;).submit()调用表单提交form表单提交有明显页面跳转，将恶意页面用iframe嵌入 width,height=0防止触发查看源代码： view-source:url 点击劫持 UI覆盖攻击用iframe设置height,width:100%,opaocity:0;z-index=2;将iframe上的提交按钮隐藏在页面按钮之下 url页面跳转META跳转 等待5秒后跳转?url = 短链接1&lt;meta http-equiv = "Refresh" content = "5;url&lt;?php echo $url?&gt;" SQL注入mysql注释--闭合、注释 where name = ‘admin&#39;-- and passwd = ‘’数据和代码未分离 union 查看mysql版本 2. 用户名和密码 DOS命令 net user用户名]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apriori_FP]]></title>
    <url>%2F2018%2F03%2F24%2FApriori-FP%2F</url>
    <content type="text"><![CDATA[Apriori 算法 频繁项集：经常出现在一块的物品的集合； 关联规则（association rules）暗示两种物品之间可能存在很强的关系。 频繁的定义：支持度、可信度 支持度：项集{豆奶，尿布}在记录中的出现频率有多少比例的交易记录包含该集合 confidentce： 关联规则{尿布}-&gt;{葡萄酒}的可信度为：“支持度({尿布, 葡萄酒})/支持度({尿布})”。 表示对于包含”尿布”的规则，规则对其中（可信度）%的记录适用。 原理 假设想找到支持度大于0.8的所有项集；4种物品的集合要遍历数据15次 对于包含N种物品的数据集共有2N-1种项集组合。 连线表明两个或者更多集合可以组合成一个更大集合) 某个项集是频繁的，那么它的所有子集也是频繁的) 算法 发现频繁项集：输入：最小支持度，数据集 生成候选集 从{1个元素集合}计数数据集中出现次数 算每个元素出现频次，超出阈值的保留 按计算k=2;k-2求k-2个项相同的并集 12a[:k-2]==b[:k-2].append(a|b)#|set的并，出现在a或b中的元素#a.union(b) 计算{2个元素的集合}的频率(1、2) //+1个元素的集合 当3.的并集为空 得到 #L[0] 1项的频繁集[1]两项 [2]3项的 [3]4 [4]空集#都是支持度超过support的子集 关联规则： 有一个频繁项集{豆奶, 莴苣}，那么就可能有一条关联规则“豆奶 ➞ 莴苣”。P ➞ H的可信度定义为support(P | H)/support(P)。 生成一个可能的规则列表，然后测试每条规则的可信度。如果可信度不满足最小要求，则去掉该规则。) 从一个频繁项集开始，接着创建一个规则列表，其中规则右部只包含一个元素，然后对这些规则进行测试。接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。这种方法也被称作分级法。 FP-growth FP树-频繁集-自动补全 FP只需要对数据库进行两次扫描，Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁， FP树（频繁模式（Frequent Pattern））编码数据集 一个元素项可以在一棵FP树中出现多次。 FP树会存储项集的出现频率，而每个项集会以路径的方式存储在树中。 存在相似元素的集合会共享树的一部分。 算法 对原始数据集扫描两遍。第一遍对所有元素项的出现次数进行计数。 只考虑频繁元素]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题记录]]></title>
    <url>%2F2018%2F03%2F24%2Falg%2F</url>
    <content type="text"><![CDATA[排序算法复杂度 刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 网易https://www.nowcoder.com/discuss/105576?type=2 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://blog.csdn.net/v_july_v/article/details/6803368https://www.cnblogs.com/JuneWang/p/3773880.html https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001 https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html 笔试题todohttps://www.nowcoder.com/test/4575457/summary 数据范围10^4 可以用(n^2)10^8 用O(n)10^7 O(nlogn) 420 强密码检验器由至少6个，至多20个字符组成。至少包含一个小写字母，一个大写字母，和一个数字。同一字符不能连续出现三次 (比如 “…aaa…” 是不允许的, 但是 “…aa…a…” 是可以的)。如果符合返回0，否则返回需要修改的最小步数 关键：计算每个字母连续出现的次数 721 !!账户合并 并查集如果两个账户有至少一个相同的email 就合并，人名相同也是两个账号123Input: accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]] poj 3709 p342非严格单调递增序列a0..an-1 每次操作可以使任意一项-1。要使数列中每一项都满足其他项中至少有k-1项和它相等。最少要对这个数列操作的次数。k=32，2，3，4，4，5，5输出3 （2 2 2 4 4 4 4） 453 数组中n-1个数字每次增加1，最少多少次数组中元素相等 [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 思路：n-1个数字+1和一个数字-1是等价的。所以看需要多少次能把所有数字减成和最小的一样。 1234567891011public int minMoves(int[] nums) &#123; int min = nums[0]; for(int i :nums)&#123; min = Math.min(min,i); &#125; int cnt =0; for(int i:nums)&#123; cnt += i - min; &#125; return cnt; &#125; 630 最多课程Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]Output: 3 选[100,200]，从101开始选[1000,1250],1101天开始选[2000,3200]或者[200,1300]都行 646 递增链Input: [[1,2], [2,3], [3,4]]Output: 2Explanation: The longest chain is [1,2] -&gt; [3,4] 491 所有递增子序列Input: [4, 6, 7, 7]Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] lt476石子合并 区间dp 有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小in : 4 1 1 4 out: 18 lc 473 火柴拼正方形 三星必须使用所有的火柴，可以连接火柴不能折断输入: [1,1,2,2,2]输出: true思路：已知周长，能否分成4个集合，和相等123456789101112131415161718192021222324252627public boolean makesquare(int[] nums) &#123; if(nums.length==0)return false; int sum = 0; for(int num:nums)&#123; sum += num; &#125; if(sum%4!=0)return false; return dfs(0,nums,new int[4],sum/4); &#125; public boolean dfs(int idx,int[] nums,int[] sums,int max) &#123; if (idx == nums.length) &#123; return true; //sums[0] == sums[1] &amp;&amp; sums[1] == sums[2] &amp;&amp; sums[2] == sums[3]; &#125; int e = nums[idx]; for(int i = 0; i &lt; 4; i++) &#123; if (sums[i] + e &lt;= max) &#123; sums[i] += e; if (dfs(idx + 1,nums,sums,max)) &#123; return true; &#125; sums[i] -= e; &#125; &#125; return false;&#125; lc 221 最大正方形Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Output: 4 思路：通解1：用dp[x][y]算出左上角到x,y的和三个for循环确定矩阵起点、边长，计算sum注意：矩阵前缀和下标 lc 85 最大矩形Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;] ]Output: 6 想象成每一行为底的直方图 lc84直方图中的最大矩形poj2559Input: [2,1,5,6,2,3]Output: 10 挑战p335思路：以当前位置的高度为最终高度，如果左右比当前值更大，则这个矩形宽可以左右扩展。定义L[i] 找到以当前高度最大矩形的左边界，就是比hi更高的最左位置R[i] 右边界，比hi更高的最右 0 1 2 3 4 5height [2,1,5,6,2,3]left [0,0,2,3,2,5]right [0,5,3,3,5,5]rst [2,6,10,6,8,3]递增栈 保持栈顶是挡住比当前hi小的元素的下标1234567891011121314151617181920212223public int largestRectangleArea(int[] h) &#123; int rst = 0; int n = h.length; int[] stk = new int[n]; int[] L = new int[n]; int[] R = new int[n]; int t = 0; for (int i = 0; i &lt;h.length ; i++) &#123; while (t&gt;0 &amp;&amp; h[stk[t-1]]&gt;=h[i])t--; L[i] = t ==0?0:(stk[t-1] + 1); stk[t++] = i; &#125; t = 0; for (int i = n-1; i &gt;=0 ; i--) &#123; while (t&gt;0 &amp;&amp; h[stk[t-1]]&gt;=h[i])t--; R[i] = t ==0?n-1:(stk[t-1]-1); stk[t++] = i; &#125; for(int i = 0;i&lt;n;i++)&#123; rst = Math.max(rst,h[i]*(R[i]-L[i]+1)); &#125; return rst;&#125; zh 化学试剂https://www.luogu.org/problemnew/show/CF558C1.容量翻倍2.容量减半 向下取整输出让所有试剂容量相等的最小操作数34 8 2输出 2 979 树中分硬币https://leetcode.com/problems/distribute-coins-in-binary-tree/Input: [0,3,0]Output: 3N个硬币落在树节点上，每次可以移动1个硬币到相邻节点，问最少多少次能让每个节点只有1个硬币。思路：从叶子节点应该向外运几个或者向父节点要几个。12345678910111213int cnt = 0;public int distributeCoins(TreeNode root) &#123; dfs(root); return cnt;&#125;int dfs(TreeNode root)&#123; if(root == null)return 0; int left = dfs(root.left); int right = dfs(root.right); int sum = left + right+root.val; cnt += Math.abs(sum-1); return sum-1;&#125; 942增减字符串匹配poj 1013称硬币:已经分组称了3次12枚硬币，找出假币 &gt; ABCD EFGH even &gt; ABI EFJK up &gt; ABIJ EFGH even &gt; 输出假的硬币 数据结构 char Left[3][7]`char Right[3][7]char result[3][7]一共称3次，每边最多放6个硬币，result（天平右边的情况）isFake(char c,bool light )假设函数：c是轻的for(char c= ‘A’ to ‘L’)枚举假硬币for(3)三次称重情况都匹配 如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换switch result[i][0]选择三种u,e,d的情况 如果 第一次实验为up,右边高，则c应该出现在right,当right.indexOf(c)==null`//没出现 return false如果even 判断出现在left||right + d 判断出现在left 406 按前面有几个高度比自己高的重排[h,k] h 高度 k前面有几个比自己高的Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 思路：按高度排序，再新建一个linkedlist按k插入到相应位置，再转成数组 海盗分金https://baike.baidu.com/item/%E6%B5%B7%E7%9B%97%E5%88%86%E9%87%91 1029 2N个人平分去A、B两地，让花费最小Input: [[10,20],[30,200],[400,50],[30,20]]Output: 110 按照如果去A能省多少钱排序123456789101112public int twoCitySchedCost(int[][] costs) &#123; Arrays.sort(costs,(a,b)-&gt;(b[1]-b[0])-(a[1]-a[0])); int n = costs.length; int rst = 0; for(int i = 0;i&lt;n/2;i++)&#123; rst += costs[i][0]; &#125; for(int i = n/2;i&lt;n;i++)&#123; rst += costs[i][1]; &#125; return rst;&#125; 777 在LR字符串中交换相邻字符一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。输入: start = “RXXLRXRXL”, end = “XRLXXRRLX”输出: True解释:我们可以通过以下几步将start转换成end:RXXLRXRXL -&gt;XRXLRXRXL -&gt;XRLXRXRXL -&gt;XRLXXRRXL -&gt;XRLXXRRLX 778 从左上到右下路径上所需最小最大值https://leetcode.com/problems/swim-in-rising-water/Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]Output: 16Explanation: 0 1 2 3 424 23 22 21 512 13 14 15 1611 17 18 19 2010 9 8 7 6 403 青蛙跳石子第一步只能跳跃一步。上一步跳了k步，下一步可以跳k,[k]+1步或者[k]-1步。问能否跳到终点8个石头[0,1,3,5,6,8,12,17]0-&gt;1跳1步，1-&gt;3跳2步，3-&gt;5跳2步5-&gt;8跳3步8-&gt;12跳4步12-&gt;17跳5步true [0,1,3,5,6,8,12,17] {17=[], 0=[1], 1=[1, 2], 3=[1, 2, 3], 5=[1, 2, 3], 6=[1, 2, 3, 4], 8=[1, 2, 3, 4], 12=[3, 4, 5]} 12345678910111213141516171819202122public boolean canCross(int[] stones) &#123; int n = stones.length; Map&lt;Integer,Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i&lt;n;i++)&#123; map.put(stones[i],new HashSet&lt;&gt;()); &#125; map.get(0).add(1); for(int i = 0;i&lt;n;i++)&#123; for(int step:map.get(stones[i]))&#123; int nxt = stones[i]+step; if(nxt == stones[n-1])return true; if(map.containsKey(nxt))&#123; Set&lt;Integer&gt;steps = map.get(nxt); steps.add(step); if(step-1&gt;0) steps.add(step-1); steps.add(step+1); &#125; &#125; &#125; return false;&#125; 458 毒药1000个水桶，1个有毒药，喝了15分钟死，一小时内搞清哪个有毒最少需要多少只猪5只4个水桶，1个有毒药，喝了15分钟死，30分钟搞清哪个有毒最少需要多少只猪2只 2轮 假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？这 n 只水桶里有且仅有一只有毒的桶。思路：2只猪可以把桶放成一个二维的矩形，每一轮2只确定一行和一列，找到一个坐标。如果3只猪，可以把桶放成三维X X X ，用三只每一轮确定一个位置。 1 23 4第一轮喝 1，2 另一个1，3，都死说明1，不然说明2或者3.不死说明4. 1 2 34 5 67 8 9 第一轮1 2 3， 另一个 1，4 ，7三只猪，测两次，可以测27桶 求数组的维度，我们知道了数组的总个数，所以要尽量增加数组的长宽，尽量减少维度。 数组的长宽其实都是测试的次数+1（因为全部测完了都没发生，下一轮不用测肯定在），所以我们首先要确定能测的次数，通过总测试时间除以毒发时间，再加上1就是测试次数。$$log_{T+1}(N)$$ 123public int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; return (int)Math.ceil(Math.log(buckets)/Math.log(minutesToTest / minutesToDie + 1));&#125; 正常思路：如果2只，4个桶，一轮都不喝0,A喝1，B喝2，AB喝3，00 01 10 11有x个猪可以表示2^x个状态。如果有t次尝试，用t位二进制去表示bucket。 如果8个桶，15分钟死，有40分钟可以测试2轮，用3位二进制表示桶Math.log(8, 3).ceil 407 二维数组存水[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]] Return 4. 用优先队列 629 K个逆序对的排列数量349 数组交集Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2] set1.retainAll(set2); 字符串交集166. Fraction to Recurring Decimal 分数转小数用括号表示循环节Input: numerator = 2, denominator = 3Output: “0.(6)” 395854 Split Array into Fibonacci SequenceInput: “123456579”Output: [123,456,579] 873. Length of Longest Fibonacci SubsequenceInput: [1,3,7,11,12,14,18]Output: 3Explanation:The longest subsequence that is fibonacci-like:[1,11,12], [3,11,14] or [7,11,18]. 842650 只有两个键的键盘输入: 3输出: 3解释:最初, 我们只有一个字符 ‘A’。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 ‘AA’。第 3 步, 我们使用 Paste 操作来获得 ‘AAA’。 n&gt;1时 其实就是将n分解为m个数字的乘积 且m个数字的和最小 即把一个数分解为n个质数的和 从小到大的去试探如果这个数是质数 则这个数只能一个一个的复制得到 操作步数就是这个数本身 如果不是质数 则可以由复制得到 例如20可以由10复制得到 10可以由5复制得到 而5是质数 只能一个一个复制 所以minStep （20） = 9 315 输出数组每个位置后有多少个数字比它小Input: [5,2,6,1]Output: [2,1,1,0] 暴力n^2复杂度一般只能到1k数量级 BIT:倒序:[1,6,2,5]rank:[0,3,1,2]prefix sum:建立rank计数数组，读1，6，2.. 并在prefix 上计数并求和pre：[] BST 二叉搜索树节点(val,sum,dup)sum是左（小）节点的个数，dup是当前数字重复的个数。1.逆序读入建BST 方法3：归并排序 小和问题(右边有多少个数比它大)123451 3 4 2 5 / \1 3 4 2 5 /\ 13 4 归并1,3得小和-&gt;+1归并13，4 得小和-&gt;+1,+3 并且merge好了[1,3,4]归并2,5 得小和-&gt;+2归并134,25 :1比右边多少个数小：2的位置是mid+1，所以通过index可以得到 小和1x2个p1指向3，p2指2，无小和p1=3 p2=5 小和3x1个p1=4 p2=5 小和4x1 例子2123451 3 4 5 6 71比多少个数小：13)-&gt;113)4)-&gt;113)4)567)-&gt;1*3 如果[p1…][p2…]如果p1比p2小，则p1比p2后面的数都小，是后面的数的小和比归并排序就多这一句1res+=arr[p1]&lt;arr[p2]?(r-p2+1)*arr[p1]:0; 展开代码 1234567891011121314151617181920212223242526272829303132333435363738//数组每个数左边比当前小的数累加起来叫这个 组数的小和。//[1,3,4,2,5]-&gt;1 +1+3 +1 +1+3+4+2 public int xiaohe(int[] arr)&#123; if(arr==null||arr.length&lt;2)return 0; return mergesort(arr,0,arr.length-1); &#125; private int mergesort(int[] arr,int l,int r)&#123; if(l==r)return 0; int mid = l+((r-l)&gt;&gt;1); return mergesort(arr,l,mid)+mergesort(arr,mid+1,r)+merge(arr,l,mid,r); &#125;// 如果[p1...][p2...]// 如果p1比p2小，则p1比p2后面的数都小，是后面的数的小和 private static int merge(int[] arr,int l,int mid,int r)&#123; int[] help = new int[r-l+1]; int i = 0; int p1 = l; int p2 = mid+1; int res = 0; while (p1&lt;=mid&amp;&amp;p2&lt;=r)&#123; System.out.println(res); res+=arr[p1]&lt;arr[p2]?(r-p2+1)*arr[p1]:0; help[i++] = arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++]; System.out.println(Arrays.toString(help)); &#125; while (p1&lt;=mid)&#123; help[i++] = arr[p1++]; &#125; while (p2&lt;=r)&#123; help[i++] = arr[p2++]; &#125; for (int j = 0; j &lt;help.length ; j++) &#123; arr[l+j] = help[j]; &#125; System.out.println(Arrays.toString(help)); return res; &#125; lg1966让b数组中第i小的数和a数组中第i小的数在同一个位置42 3 1 43 2 1 4 out:1 1）归并排序$c[b[i].loc]=a[i].loc$ 排序的交换次数，逆序对个数。利用下标的单调升序,用归并排序最后让c[i]=i(x,loc)按数值排序后a:[(1,2), (2,0), (3,1), (4,3)]b:[(1,2), (2,1), (3,0), (4,3)]c:[1, 0, 2, 3]1）树状数组 lg1455 搭配购买 必须搭配购买的背包问题买一朵云则与这朵云有搭配的云都要买，钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。输入输出格式输入格式：第1行n,m,w,表示n朵云，m个搭配和你现有的钱的数目第2行至n+1行，每行ci,di表示i朵云的价钱和价值第n+2至n+1+m ，每行ui,vi表示买ui就必须买vi,同理，如果买vi就必须买ui 输出格式：一行，表示可以获得的最大价值输入输出样例输入样例#1： 5 3 103 103 103 105 10010 11 33 24 2输出样例#1：1 思路：用并查集把n个必须一起买的物品组合成一个大物品，再用背包12345678910111213141516171819202122232425262728293031323334int father[20001],c[20001],w[20001],f[20001];int n,m,k,x,y;int find(int x) //并查集&#123; return x==father[x]?x:father[x]=find(father[x]);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for (int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;w[i],&amp;c[i]); father[i]=i; //初始化 &#125; for (int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if (find(x)!=find(y)) father[find(y)]=find(x); //划为同一集合 &#125; for (int i=1;i&lt;=n;i++) if (father[i]!=i) //如果买了这一件商品就得买另一件商品 &#123; c[find(i)]+=c[i]; w[find(i)]+=w[i]; //划为同一集合 c[i]=w[i]=0; //清零，不清零就可能会造成重复购买一件商品 &#125; for (int i=1;i&lt;=n;i++) for (int j=k;j&gt;=w[i];j--) f[j]=max(f[j],f[j-w[i]]+c[i]); //01背包 printf("%d\n",f[k]); return 0;&#125; 334 三个上升子序列arr[i] &lt; arr[j] &lt; arr[k]given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Input: [5,4,3,2,1]Output: false 639 解码方式Input: “1“Output: 9 + 9 = 181 -&gt; 10 11 12… 19 1,*-&gt; 1,0 1,1… 12345678910111213141516171819public int numDecodings(String s) &#123; long e0 = 1,e1 = 0,e2=0,f0,f1,f2; long M =1000_000_007; for(char c : s.toCharArray())&#123; if(c == '*')&#123; f0 = 9*e0 + 9*e1 +6*e2; f1 = e0; f2 = e0; &#125;else&#123; f0 = ((c &gt; '0')?1:0 )* e0 + e1 + ((c &lt;= '6')?1:0) * e2; f1 = ((c == '1')?1:0 ) * e0; f2 = ((c == '2')?1:0 ) * e0; &#125; e0 = f0 % M; e1 = f1; e2 = f2; &#125; return (int)e0;&#125; 324 摇摆序列sortin：[4,5,5,6]out:[5,6,4,5] 展开代码 123456789101112131415public void wiggleSort(int[] nums) &#123; int n = nums.length; int[] arr = nums.clone(); Arrays.sort(arr); int j = n-1; int half = (n+1)/2; int i = half-1; for(int k = 0;k&lt;n;k++)&#123; if((k%2) ==0)&#123; nums[k] = arr[i--]; &#125;else&#123; nums[k] = arr[j--]; &#125; &#125; &#125; 891 子序列宽度和Input: [2,1,3]Output: 6Explanation:Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].The corresponding widths are 0, 0, 0, 1, 1, 2, 2.The sum of these widths is 6. 思路，1）排序，对第A[i]个数字，有i个比它小，有2^i个序列A[i]是最大的(这i个数字选或者不选的集合），有n-1-i个比它大，有2^(n-1-i)个序列，A[i]是最小的。2）注意 2^i 用1&lt;&lt;i 如果数组长度&gt;32答案会很奇怪（？）123456789101112131415public int sumSubseqWidths(int[] A) &#123; long rst = 0; int mod = 1_000_000_000+7; Arrays.sort(A); int n = A.length; long[] pow2 = new long[n]; pow2[0] = 1; for (int i = 1; i &lt; n; ++i) pow2[i] = pow2[i-1] * 2 % mod; for (int i = 0; i &lt; n ; i++) &#123; rst = (rst+ (pow2[i] - pow2[n-1-i])*A[i])%mod; &#125; return (int)rst;&#125; 870 优势洗牌输入：A = [2,7,11,15], B = [1,10,4,11]输出：[2,11,7,15] 找到A的一种排列，使A[i]&gt;B[i]的数量最多 992 有K个不同整数的子数组的个数输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]. 502 IPO输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4最初有W=0元钱，最多完成k个项目，每个项目有最低资本和利润，最后获得的钱数。从 0 号项目开始，总资本将变为 1。完成 2。最后最大化的资本，为 0 + 1 + 3 = 4。 完成项目是不扣资本的。 两个优先队列AC geohash纬度的二进制编码[-90, 90]1234567891011121314151617public static void main(String[] args) &#123; Scanner sc =new Scanner(System.in); int wd = sc.nextInt(); StringBuilder sb = new StringBuilder(); int[] bound = &#123;-90,90&#125;; for (int i = 0; i &lt;6 ; i++) &#123; int mid = (bound[0]+bound[1])/2; if(wd&gt;=mid)&#123; sb.append(1); bound[0] = mid; &#125;else &#123; sb.append(0); bound[1] = mid; &#125; &#125; System.out.println(sb.toString());&#125; 素数生成&lt;=n之内的所有素数给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10,分别为(5,5),(3,7)）12345678910111213141516171819public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); boolean[] prime = new boolean[num+1]; Arrays.fill(prime, true); for(int i = 2; i &lt;= num; i++)&#123; if(prime[i])&#123; // 将i的2倍、3倍、4倍...都标记为非素数 for(int j = i * 2; j &lt;= num; j = j + i)&#123; prime[j] = false; &#125; &#125; &#125; int cnt = 0; for(int i = 2;i&lt;=num/2;i++)&#123; if(prime[i] &amp;&amp; prime[num-i])cnt++; &#125; System.out.println(cnt); &#125; 切铜板 哈夫曼编码给定数组{10,20,30}， 代表一共三个人， 整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。如果，先把长度60的金条分成10和50， 花费60 再把长度50的金条分成20和30，花费50一共花费110铜板。但是如果， 先把长度60的金条分成30和30， 花费60 再把长度30金条分成10和20， 花费30 一共花费90铜板。 797 All Paths From Source to Target437树中找部分路径，和为target的路径条数123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 hashMap+回溯12345678910111213141516public int pathSum(TreeNode root, int sum) &#123; // key:前缀和 value：有多少种方式可以得到这个值 HashMap&lt;Integer,Integer&gt; preSum = new HashMap&lt;&gt;(); preSum.put(0, 1); return helper(root,0,sum,preSum); &#125;int helper(TreeNode root,int currSum,int target,HashMap&lt;Integer,Integer&gt; preSum)&#123; if(root == null)return 0; currSum += root.val; int rst = preSum.getOrDefault(currSum - target,0); preSum.put(currSum, preSum.getOrDefault(currSum,0)+1); rst += helper(root.left,currSum,target,preSum)+helper(root.right,currSum,target,preSum); // 关键 ？ preSum.put(currSum,preSum.get(currSum)-1); return rst;&#125; pdd 花灯铺路最远距离926 hiho 1326 将01串变成前0后1或全0或全1的最少flip次数 前缀！ Input: “010110”Output: 2Explanation: We flip to get 011111, or alternatively 000111. 思路1：前缀[1..i] 变成全0或者变成[000111]的最小反转次数,推到整个数组12340101100011 S0112333345 oCnt(把所有1转0)0011123444 fCnt(第一个1之后0的个数)0011122333 fCnt更新为min(将当前位置之前的所有1转0，或者当前位置之前1后0转1) 1234567891011121314public int minFlipsMonoIncr(String S) &#123; int oCnt = 0; int fCnt = 0; for(int i =0;i&lt;S.length();i++)&#123; if(S.charAt(i) == '1')&#123; oCnt ++; &#125;else if(oCnt &gt;0)&#123; fCnt ++; &#125; // 关键 fCnt 随前缀更新 fCnt = oCnt &lt; fCnt ? oCnt:fCnt; &#125; return fCnt;&#125; 636 单核cpu函数调用栈日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：”0:start:0” 表示函数 0 从 0 时刻开始运行。”0:end:0” 表示函数 0 在 0 时刻结束。 函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。 输入 n = 2logs =[“0:start:0”, “1:start:2”, “1:end:5”, “0:end:6”]输出：[3, 4] 函数 0 在时刻 0 开始，在执行了 2个时间单位结束于时刻 1。现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。 stack + start[] ac 15% 3 !!最长不重复子串 做了3遍还是不熟练展开代码 Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 思路：abca最长的是两个a之间,start是上一个a。bbvfg最长的是重复b之后更新start。关键：tmmzuxt start应该只增不减。Math.max(start,map.get(c) + 1) 12345678910111213141516public int lengthOfLongestSubstring(String s) &#123; if(s==null || s.length() &lt;1 )return 0; int n = s.length(); int start = 0; int mlen = 0; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i =0;i &lt; n ;i++)&#123; char c = s.charAt(i); if(map.containsKey(c))&#123; start = Math.max(start,map.get(c) + 1); &#125; mlen = Math.max(mlen,i - start +1); map.put(c, i); &#125; return mlen;&#125; 方法2：用Set&lt;Character&gt;维持一个窗口[i,j)， 放到set中，如果没重复继续向右扩展，如果重复，窗口向右移动123456789101112131415public int lengthOfLongestSubstring(String s)&#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0,i=0,j=0; //维持一个窗口[i,j)， 放到set中，如果没重复继续向右扩展，如果重复，窗口向右移动 while (i&lt;n&amp;&amp;j&lt;n)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans,j-i); &#125;else&#123; set.remove(s.charAt(i++)); &#125; &#125; return ans;&#125; 763 划分尽可能多字母区间 返回各区间的长度 双指针 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。ababcba 从第一个a到最后一个a是必须包含的长度 思路：字母last index数组，遍历string，维护一个当前字符出现的最晚index，直到当前字符index就是这个最晚index，可以划分，记录当前长度并且重置start计数。注意：不能直接i跳到curmaxend，因为abab如果a直接跳到下一个a会漏更新b的last index 123456789101112131415161718192021//45%public List&lt;Integer&gt; partitionLabels(String S) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); //每个字母最后出现的index int[] last = new int[26]; for(int i=0;i&lt;S.length();i++)&#123; last[S.charAt(i)-'a'] = i; &#125; int start=0,end=0; for(int i = 0;i&lt;S.length();i++)&#123; //更新当前字母的区间 end = Math.max(end,last[S.charAt(i)-'a']); //关键 if(i==end)&#123; rst.add(end-start+1); start = end+1; &#125; &#125; return rst;&#125; 575 分糖果 两人数量相等 最大化一组的品种Input: candies = [1,1,2,3]Output: 2 思路：获得的种类最多是n/2种 每种都不同，&gt;2次的个数&lt;=n/2。或者重复的元素很多,可以得到所有种类。1234567891011public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; set = new HashSet(); int n = candies.length; for(int i = 0;i &lt; n;i++)&#123; if(!set.contains(candies[i]))&#123; set.add(candies[i]); &#125; if(set.size() &gt; n/2)return n/2; &#125; return set.size();&#125; 888 换1个糖果使两组和相等交换A，B数组中的2个数字(exchange one candy bar)，数组总和相等Input: A = [2], B = [1,3]Output: [2,3]输出是A和B要交换的数字 AC 排序二分 621 !!!!!!任务调度26 种不同种类的任务 每个任务都可以在 1 个单位时间内执行完两个相同种类的任务之间必须有长度为 n 的冷却时间 输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 正确方法：找出slot 方法1 排序： 45% 20ms思路：1.将任务数量排序，保证数量最大的几个任务都连续在数组尾部2.大循环终止条件 ： 最右&gt;0,并且每次都排序。3.冷却时间循环n次，总时间和冷却时间计数器都++，从最后一个任务开始消耗,能消耗就消耗 复杂度O(time) 123456789101112131415161718192021public int leastInterval(char[] tasks, int n) &#123; int[] cnt = new int[26]; int m = tasks.length; for(char c :tasks)&#123; cnt[c - 'A'] ++; &#125; Arrays.sort(cnt); int time = 0; while(cnt[25]&gt;0)&#123; int i = 0; while(i &lt; d)&#123; // 大循环的判断 if(cnt[25] == 0)break; if(i &lt; 26 &amp;&amp; cnt[25 - i] &gt; 0)cnt[25 - i]--; time++; i++; &#125; Arrays.sort(cnt); &#125; return time;&#125; 634 n个数字的错排有几个 lt869在组合数学中，错乱是一组元素的排列，这种排列中没有元素出现在它的原始位置上。最初有一个由n个整数组成的数组，从1到n，按升序排列，你需要找到它能产生的错乱的数量。而且，由于答案可能非常大，您应该返回输出mod 10^9 + 7的结果 给定n=3，返回 2. 解释：原始数组是[1,2,3]。这两个错乱是[2,3,1]和[3,1,2]。 12345678910public int findDerangement(int n) &#123; long dn2 = 0,dn1= 1; long res = (n==1)?0:1; for(int i =3;i&lt;=n;i++)&#123; res = ((i - 1)*(dn1+dn2)) % 1000000007; dn2 = dn1; dn1 = res; &#125; return (int)res;&#125; 801 ??让数组递增的最少交换次数可以交换 A[i] 和 B[i] 的元素Input: A = [1,3,5,4], B = [1,2,3,7]Output: 1交换 A[3] 和 B[3] 后，两个数组如下:A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]两个数组均为严格递增的。 思路：如果两个数组[i]&gt;[i-1]可以保持不变，如果A[i]&gt;B[i-1]&amp;&amp;B[i]&gt;A[i-1]可以尝试交换。dp思想，保存每个位置的两种状态：1）可以交换2）保持不变。 12345678910111213141516171819public int minSwap(int[] A, int[] B) &#123; int n = A.length; int[] swap = new int[n]; int[] keep = new int[n]; swap[0] = 1; for (int i = 1; i &lt;n ; i++) &#123; // 关键 keep[i] = swap[i] = n; if(A[i-1] &lt; A[i] &amp;&amp; B[i-1]&lt;B[i])&#123; keep[i] = keep[i-1]; swap[i] = swap[i-1] +1; &#125; if(A[i-1] &lt;B[i] &amp;&amp; B[i-1] &lt;A[i])&#123; keep[i] = Math.min(keep[i],swap[i-1]); swap[i] = Math.min(swap[i],keep[i-1]+1); &#125; &#125; return Math.min(keep[n-1],swap[n-1]);&#125; 670有序矩阵nxn个复杂度O(n) 在100-999这900个自然数中,若将组成这个数的三个数字认为是三条线段的长度,那么是三条线段组成一个等腰三角形(包括等边)的共有()个.先考虑等边三角形情况则a=b=c=1，2，3，4，5，6，7，8，9，此时n有9个再考虑等腰三角形情况，若a，b是腰，则a=b当a=b=1时，c＜a+b=2，则c=1，与等边三角形情况重复；当a=b=2时，c＜4，则c=1，3（c=2的情况等边三角形已经讨论了），此时n有2个；当a=b=3时，c＜6，则c=1，2，4，5，此时n有4个；当a=b=4时，c＜8，则c=1，2，3，5，6，7，有6个；当a=b=5时，c＜10，有c=1，2，3，4，6，7，8，9，有8个；由加法原理知n有2+4+6+8+8+8+8+8=52个同理，若a，c是腰时，c也有52个，b，c是腰时也有52个所以n共有9+3×52=165个 !!97 s1和s2是否交错组成s3Solution状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中任意位置s3[i]一定是由s1[m],s2[n]组成的123s1=&quot;aa bc c&quot;s2=&quot; db bca&quot;s3=&quot;aadbbcbcac&quot; dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况12345遍历s3的位置： 遍历s1的长度，s3+1-s1为s2的长度 如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了 ||s3当前与s1当前匹配并且dp[s1-1][s2]: dp[s1][s2] = true 可以用滚动数组降成1维 ？？？按背包问题递减更新 99%ct的意义动态规划中的ct123456789101112131415161718public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1.length() + s2.length() != s3.length()) return false; boolean[] dp = new boolean[s1.length() + 1]; dp[0] = true; for (int i = 0; i &lt; s3.length(); i++) &#123; boolean ct = true; for (int j = Math.min(s1.length(), i + 1); j &gt; 0; j--) &#123; if (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = false; else if (dp[j - 1] &amp;&amp; s1.charAt(j- 1) == s3.charAt(i))&#123; dp[j] = true; ct = false; &#125;else dp[j] = false; &#125; if(dp[0]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = false; if(ct)return false; &#125; return true;&#125; 316 !!删除重复字母，输出字典序最小的（按原顺序）Input: “bcabc”Output: “abc” pdd原题不会 12345678910public String removeDuplicateLetters(String s) &#123; int[] cnt = new int[26]; int pos = 0; // the position for the smallest s[i] for (int i = 0; i &lt; s.length(); i++) cnt[s.charAt(i) - 'a']++; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) &lt; s.charAt(pos)) pos = i; if (--cnt[s.charAt(i) - 'a'] == 0) break; &#125; return s.length() == 0 ? "" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll("" + s.charAt(pos), ""));&#125; 677 优美排列，相邻两个数的差有k种的数组输入: n = 3, k = 2输出: [1, 3, 2]解释: diff: [2, 1] 中有且仅有 2 个不同整数: 1 和 2k,n&lt;10^4 大小数字插空放 能有不同的dif，之后就顺序放全部dif为1.1234i: 1 2 3 4 5j: 9 8 7 6out: 1 9 2 8 3 7 4 6 5dif: 8 7 6 5 4 3 2 1 12345678910111213public int[] constructArray(int n, int k) &#123; int[] arr = new int[n]; int c = 0; int l = 1, h = n; while(l &lt;= h) &#123; if(k &gt; 1)arr[c++]= ((k--%2 != 0)?l++:h--); else arr[c++]=l++; &#125; return arr;&#125; 526 1-N构造i位数能整除i或者整除[i]位数的数组输入: 2输出: 2解释: 第 1 个优美的排列是 [1, 2]: 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除 第 2 个优美的排列是 [2, 1]: 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除 bracktrack 计数 796 字符串是不是旋转成的Example 1:Input: A = ‘ab cde’, B = ‘cde ab’Output: true 最正确的做法：虽然是N^2 contains1234public boolean rotateString(String A, String B) &#123; if(A.length() == B.length() &amp;&amp; (A+A).contains(B))return true; else return false;&#125; rolling hash 很慢（？） lc 73 矩阵如果有0,则整行/列置0123456789101112Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]] 正确做法：空间O(1),时间O(MxN)1234567891011121314151617181920212223242526public void setZeroes(int[][] matrix) &#123; int n = matrix.length; int m = matrix[0].length; //用第一行和第一列 记录 所有行，所有列的0的个数。 // 第一行，第一列要不要变0可以存一个在[0][0]上，另一个用一个变量, boolean col0 = false; for (int i = 0; i &lt; n; i++) &#123; // 不用考虑[0][0]，如果[0][0]本身是0，则0行全0. 只需考虑[0]列上有没有本身是0的。 if(matrix[i][0] == 0)col0 = true; for (int j = 1; j &lt;m ; j++) &#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for (int i = n-1; i &gt;=0 ; i--) &#123; for (int j = m-1; j &gt;=1 ; j--) &#123; if(matrix[i][0] ==0 || matrix[0][j] ==0)&#123; matrix[i][j] = 0; &#125; &#125; // 注意一行完了再变第一列 if(col0)matrix[i][0] = 0; &#125;&#125; 295 流数据找中位数addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3)findMedian() -&gt; 2 思路2：BST？思路1：leftmax堆和rightmin堆。保证left大小和right大小相等or大1。 lc 4 两个排序数组的中位数, 排序数组找第k小nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 中位数是两个数组的划分位置，使两个数组左边加起来个数和右边一样。1234x1 x2 | x3 x4 x5 x6y1 y2 y3 y4 y5 | y6 y7 y8x2（L1) &lt;= y6(R2) &amp;&amp; y5(L2)&lt;= x3(R1) 如果划分在num1左边有partX个元素，总共是k=(n+m+1)/2个元素 ,则用这个数字在nums2应该划分出左边有(n+m+1)/2-partX个元素例子：如果partX = 2， k=(6+8+1)/2=7, partY应该=7-2=5.如果 y5=10 &gt; x3 = 8.则表示partX 划少了。如果 x2 &gt; y6 表示partX多了 关键：如果二分partX是0或者n，则在nums2中数partY个肯定对的 1234567891011121314151617181920212223242526272829303132333435public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1 = nums1.length; int n2 = nums2.length; if(n1 &gt; n2) return findMedianSortedArrays(nums2, nums1); int lo = 0, hi = n1; while (lo &lt;= hi)&#123; // mid:短的那个 int partX = (lo + hi)/2; int partY = (n1+n2+1)/2 - partX; //L1&lt;R2 &amp;&amp; L2 &lt; R1 /* x1 x2 | x3 x4 x5 x6 y1 y2 y3 y4 y5 | y6 y7 y8 x2（L1) &lt;= y6(R2) &amp;&amp; y5(L2)&lt;= x3(R1) */ double L1 = (partX == 0)?Integer.MIN_VALUE:nums1[partX-1]; double L2 = (partY == 0)?Integer.MIN_VALUE:nums2[partY-1]; double R1 = (partX == n1)?Integer.MAX_VALUE:nums1[partX]; double R2 = (partY == n2)?Integer.MAX_VALUE:nums2[partY]; if(L1 &lt;= R2 &amp;&amp; L2 &lt;= R1)&#123; if((n1+n2) % 2 ==0)&#123; return (Math.max(L1,L2) + Math.min(R1, R2))/2.0; &#125; else return Math.max(L1, L2); &#125;else if(L1 &gt; R2)&#123; hi = partX - 1; &#125;else &#123; lo = partX + 1; &#125; &#125; return -1;&#125; 【前k二分】(为什么比暴力merge还慢）：在两个数组里都找第k/2个元素2,4, 2小，表示nums1 的[1]之前的元素都不可能是第k大。所以问题变成找第k-k/2大。边界条件：1 num1没有元素，两个数组的第k大就是nums2的B[idx2+k-1]2 终止条件：如果k=1，返回两个第一个元素小的那个。（注意，保证k/2-1是正的。)3 如果有一个数组已经没有k/2个了，则令这个数组的k/2个为无限大。123456789101112131415161718public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1 = nums1.length; int n2 = nums2.length; int l = (n1+n2+1)/2; int r = (n1+n2+2)/2; return (getkth(nums1, 0, nums2,0 ,l )+getkth(nums1, 0, nums2,0 ,r ))/2;&#125;public double getkth(int[] A,int idx1,int[]B,int idx2,int k)&#123; if(idx1 &gt; A.length - 1)return B[idx2+k-1]; if(idx2 &gt; B.length - 1)return A[idx1+k-1]; if(k==1)return Math.min(A[idx1],B[idx2]); int amid = Integer.MAX_VALUE,bmid = Integer.MAX_VALUE; if(idx1+k/2-1&lt;A.length) amid = A[idx1+k/2-1]; if(idx2+k/2-1&lt;B.length) bmid = B[idx2+k/2-1]; if(amid &lt; bmid)return getkth(A, idx1+k/2, B, idx2, k-k/2); else return getkth(A, idx1, B,idx2+k/2,k-k/2 );&#125; 9 判断回文Input: 121Output: true 添加最少字符回文串 区间dp可以在任意位置添加,？ 最尾添加回文串 Manacher 最右回文边界https://www.nowcoder.com/questionTerminal/cfa3338372964151b19e7716e19987ac对于一个字符串，我们想通过添加字符的方式使得新的字符串整体变成回文串，但是只能在原串的结尾添加字符，请返回在结尾添加的最短字符串。“ab”返回“a” （aba）思路：最后n位一定是回文的。例如 abc 12321 ，将前面不是回文的逆序加到后面。加#是为了偶回文。abc12321 n^2的方法, 这个串反转，原串后n位和反转串n前位相同就是回文串。 !131 Palindrome Partitioning 回文切割123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] ?409 string中字符组成回文串的最大长度1.开int[128]，直接用int[char]++计数2.奇数-1变偶数&amp;(~1)3.判断奇数(&amp;1)&gt;0 ！！！516 最长回文子序列123456789101112131415public static int longestPalindromeSubseq(String s) &#123; int[][] dp = new int[s.length()][s.length()]; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; dp[i][i] = 1; for (int j = i+1; j &lt; s.length(); j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; dp[i][j] = dp[i+1][j-1] + 2; &#125; else &#123; dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][s.length()-1];&#125; ！5 最长回文串 lt893http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/!!反转做法不行:abcxyzcba -&gt; abczyxcba -&gt;相同的abc并不是回文!! 不能用LCS“cba”是“abc”的 reversed copy 但是可以再加一步检查下标中心扩展法：回文的中心有奇数：n个，偶数：n-1个位置会输出靠后的abab-&gt;输出bab12345678910111213141516171819202122232425262728int len;public String longestPalindrome(String s) &#123; if(s==null||s.length()&lt;2)return s; len = s.length(); int start = 0;int end = 0; // int max = 0; for(int i =0;i&lt;len;i++)&#123; //"babad" -&gt;"bab" -&gt;i =1 len = 3 //"cbbd" -&gt; "bb" -&gt;i=1 len = 2 int len1 = help(s,i,i);//奇数扩展 int len2 = help(s,i,i+1);//偶数扩展 int max = Math.max(len1,len2); if(max&gt;end-start)&#123; start = i - (max-1)/2;//去掉中间那个左边长度的一半 end = i+max/2;//右边长度的一半 &#125;//end-start= i+max/2-i+(max-1)/2 = max-1/2 &#125; return s.substring(start,end+1); &#125;private int help(String s,int left,int right)&#123; while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; return right-left-1;&#125; Manacher’s 算法 O(n) 并不理解https://algs4.cs.princeton.edu/53substring/Manacher.java.html1回文半径数组，2最右回文串右边界，3最右回文右边界的最左回文中心情况1：回文右边界初始为-1，当前扩展位置是0，不在右边界里面，暴力扩，右边界到0位置。情况2：回文右边界在当前扩展位置右边。情况2.1：当前位置i的对称点i’的半径在当前最右中心的LR里面，则可以复制对称点的半径情况2.2：对称点i’的半径超过L 则半径就是i到R情况2.3：对称点i’的半径和L一样，i要扩展 73%12345678910111213141516171819202122232425262728293031public String longestPalindrome2(String s) &#123; StringBuilder sb = new StringBuilder("^#"); for (int i = 0; i !=s.length() ; i++) sb.append(s.charAt(i)).append("#"); sb.append("$"); final int N = sb.length(); int[] p = new int[N]; //id是长度为mx的回文串的中心 int id = 0,mx = 0; int maxLen = 0,maxId= 0; for (int i = 1; i &lt;N-1 ; i++) &#123; // i在右边界里面, i'的回文半径长度 和 i到当前最右边界的距离 哪个小取哪个 // 如果i在右边界上或者i在右边界右边，不用扩展的区域只有自己 p[i] = mx &gt; i ? Math.min(p[2 * id - i], mx - i ) : 1; // 以i为中心扩展 while(sb.charAt(i+p[i])==sb.charAt(i-p[i])) p[i]++; // 更新最右边界和其中心 if(mx &lt; i+p[i])&#123; mx = i+p[i]; id = i; &#125; // 全局最大回文串和其中心 if(maxLen &lt; p[i])&#123; maxLen = p[i]; maxId = i; &#125; &#125; int start = (maxId-maxLen)/2; return s.substring(start,start+maxLen-1);&#125; 572 A树中是否有B作为一个完整的子树Example 1:Given tree s:12345 3 / \ 4 5 / \1 2 Given tree t:123 4 / \1 2 True 思路1：序列化之后indexOf (kmp) 注意1每个value用“#”前后分割，2区分左右null1234567891011private String tree2string(TreeNode root)&#123; StringBuilder sb = new StringBuilder(); sb.append("#"+root.val+"#"); if(root.left==null)sb.append("l_"); else sb.append(tree2string(root.left)); if(root.right==null)sb.append("r_"); else sb.append(tree2string(root.right)); return sb.toString();&#125; 方法2：递归1234567891011121314public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s == null)return false; // 以根为子树相等 //左子树或者右子树 为子树相等 if(isSame(s,t))return true; return isSubtree(s.left,t) || isSubtree(s.right,t); &#125; // 两棵树是不是每个节点都相等 private boolean isSame(TreeNode s,TreeNode t)&#123; if(s == null &amp;&amp; t == null)return true; if(s == null || t == null)return false; if(s.val != t.val)return false; return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); &#125; KMP算法 两个子串https://www.nowcoder.com/questionTerminal/abf0f0d6b4c44676b44e66060286c45a?orderByHotValue=0&amp;commentTags=Python展开代码 KMP算法核心，在S中indexOf(T),对T建立next数组1:next数组的用法2:next数组构建 给定的一个长度为N的字符串str,查找长度为P(P&lt;N)的字符串在str中的出现次数.下面的说法正确的是()正确答案: D 你的答案: B (错误)A不存在比最坏时间复杂度O(NP)好的算法B不存在比最坏时间复杂度O(N^2)好的算法C不存在比最坏时间复杂度O(P^2)好的算法D存在最坏时间复杂度为O(N+P)的算法E存在最坏时间复杂度为O(log(N+P))的算法以上都不对 给定一个字符串s, 请计算输出含有连续两个s作为子串的最短字符串。 注意两个s可能有重叠部分。例如,”ababa”含有两个”aba”. 123456789101112131415161718192021222324252627String in = sc.next();int n = in.length();int[] next = new int[n+1];Arrays.fill(next,0);next[0] = -1;next[1] = 0;for (int i = 2; i &lt; n+1 ; i++) &#123; char pre = in.charAt(i-1); // 前面多少位和开头一样 后退的位置(个数正好是从头数+1个的位置） // abcab next[b] = 2 int k = next[i-1]; // 中止 如果 abc k = 0 c和开头的a还是不等，k=-1不能往前匹配了next[i]=0下一个 while (k!=-1)&#123; if(in.charAt(k) == pre)&#123; next[i] = next[i-1]+1; break; &#125; //如果 ab dd abc | ab dd abd // k = next[b] = 6 c和d不等， // next[c] = 2 d和d相等，所以最后的next[d] = 3 k = next[k]; &#125;&#125;// 求完最后一个位置的前缀后缀长度 abcdabc next = 3// abcdabc// abc dabcSystem.out.println(in+in.substring(next[in.length()])); lc300 !!!最长上升子序列 最长递增子序列Input: [10,9,2,5,3,7,101,18]Output: 4Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 正常解法123456789101112131415161718public int lengthOfLIS(int[] nums) &#123; if(nums == null || nums.length &lt; 1)return 0; int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp,1); for(int i = 1;i &lt;n;i++)&#123; for(int j = 0;j&lt;i;j++)&#123; if(nums[i] &gt; nums[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; &#125; int max = 0; for(int i : dp)&#123; max = Math.max(i,max); &#125; return max;&#125; nlogn解法!!!思路：单调栈，用更小的数替换掉前面比它大的数，并且长度不变，只有当这个值比栈顶大，长度才增加。注意len是只增不减12345678910111213141516public int lengthOfLIS(int[] nums) &#123; if(nums == null ||nums.length &lt;1)return 0; int len = 0; int n = nums.length; int[] dp = new int[n]; for(int num:nums)&#123; // 关键 查找范围是[0,len) int i = Arrays.binarySearch(dp,0,len,num); if(i &lt; 0)&#123; i = -(i+1); &#125; dp[i] = num; if(i == len)len++; &#125; return len;&#125; lc354 ！！！！俄罗斯套娃Input: [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]). 思路：[0]升序 之后[1]降序.查找[1]应该在的位置。[1]从大到小排序 (1,3)在(1,2)之前，同宽度按[1]排序，先判断可不可能装，如果能装再缩小[1]。为了同宽度的能套上去的只计数一次，所以先放大的。[3, 1] [3, 2] [3, 3] will get 3, but [3, 3], [3, 2], [3, 1] will get 1 ！798数组rotate，每个位置值比index小计分+1，分最大的旋转位置Kwe have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4]. This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point]. 很多赞的题 折纸 折痕https://www.nowcoder.com/questionTerminal/430180b66a7547e1963b69b1d0efbd3c二叉树结构。该二叉树的特点是：根节点是下，每一个节点的左节点是下，右节点是上。该二叉树的中序遍历即为答案，但不需要构造一颗二叉树，用递归方法可打印出来。 ！！！安排机器 有错的题！！！小Q的歌单 01背包求方案数https://www.nowcoder.com/questionTerminal/f3ab6fe72af34b71a2fd1d83304cbbb3xA+yB = K ,x&lt;=X,y&lt;=Y有多少种取法52 3 3 3out:9 方法2：01背包问题的方法数123456789101112131415161718long[][] dp =new long[201][1001];int[] p = new int[201];// 展开成背包物品的输入dp[0][0] = 1;// 放到[1,x+y]上for (int i = 1; i &lt;=x ; i++) &#123;p[i] = a;&#125;for (int i = x+1; i &lt;=x+y ; i++) &#123;p[i] = b;&#125;// 一共有x+y个物品for (int i = 1; i &lt;=x+y ; i++) &#123; for (int j = 0; j &lt;=k ; j++) &#123; if(j &gt;= p[i])&#123; dp[i][j] = (dp[i-1][j] + dp[i-1][j-p[i]]) % mod; &#125; else dp[i][j] = dp[i-1][j]%mod; &#125;&#125;System.out.println(dp[x+y][k]%mod); 方法1：组合数 构建 杨辉三角123456789101112131415161718public static long qlist(int k,int a,int x,int b,int y)&#123; long mod = 1000000007; int max = 101; long[][] tri = new long[max][max]; tri[0][0] = 1; for (int i = 1; i &lt; max; i++) &#123; tri[i][0] = 1; for (int j = 1; j &lt;max ; j++) &#123; tri[i][j] = (tri[i-1][j-1] + tri[i-1][j])%mod; &#125; &#125; long sum = 0; for (int i = 0; i &lt;=k ; i++) &#123; if(i % a == 0 &amp;&amp; (k-i) % b ==0 &amp;&amp; i/a &lt;= 100 &amp;&amp; (k - i) / b &lt;= 100) sum += tri[x][i/a]*tri[y][(k-i)/b]%mod; &#125; return sum % mod;&#125; lc312 lt168 吹气球每次吹气球i可以得到的分数为 nums[left] * nums[i] * nums[right]，Input: [3,1,5,8]Output: 167Explanation: nums = [3,1,5,8] –&gt; [3,5,8] –&gt; [3,8] –&gt; [8] –&gt; [] coins = 315 + 358 + 138 + 181 = 167思路 可以把这个问题建模成矩阵链,每次相乘之后中间一维就消失了变成5个矩阵A1(1x3)A2(3x1)A3(1,5)A4(5x8)A5(8x1)最优解是(((A1(A2xA3))A4)A5) 回溯法超时ac 1[4,1,5,10]1 如果最后是1[1]1,上一次只有两种可能性1[4,1]1,1[1,5]1。 1234567891011121314151617181920public int maxCoins(int[] iNums) &#123; int[] nums = new int[iNums.length + 2]; int n = 1; for (int x : iNums) if (x &gt; 0) nums[n++] = x; nums[0] = nums[n++] = 1; int[][] memo = new int[n][n]; return burst(memo, nums, 0, n - 1);&#125;public int burst(int[][] memo, int[] nums, int left, int right) &#123; if (left + 1 == right) return 0; if (memo[left][right] &gt; 0) return memo[left][right]; int ans = 0; for (int i = left + 1; i &lt; right; ++i) ans = Math.max(ans, nums[left] * nums[i] * nums[right] + burst(memo, nums, left, i) + burst(memo, nums, i, right)); memo[left][right] = ans; return ans;&#125; DP todo lc140lc391 完美矩形每个小矩形用左下角和右上角点表示，问能一起是不是一个大矩形。 lt516 房屋染色给定n个房屋k种颜色的花费相邻的房屋颜色不同，并且费用最小。costs = [[14,2,11],[11,14,5],[14,3,10]] return 10房屋 0 颜色 1, 房屋 1 颜色 2, 房屋 2 颜色 1， 2 + 5 + 3 = 10 lc324 将数组重排成摆动序列Input: nums = [1, 5, 1, 1, 6, 4]Output: One possible answer is [1, 4, 1, 5, 1, 6]. 955 删掉几列让String数组排序Input: [“xga”,”xfb”,”yfa”]Output: 1 poj1408边长1的木方框，每条边上有n个钉子。一共4n个钉子。切分一根长绳子，只能连接在对边中。有n个钉子就有2n条切分，就能分割出2(n+1)个格子，返回最大格子的面积。 poj1273求pond到stream的最大流量N是边数，M是点数。1是pond，M是stream。每一行是从s到e的容量。5 41 2 401 4 202 4 202 3 303 4 10算法1：dfs找到一条路，流量是这条路上的最小值。然后把这条路反向，值就是最小值。再dfs。复杂度是 所有边容量C O（C*(m+n)) 如果有一条边是1，其他便100.可能会执行200次dfs 算法二。用bfs 复杂度是O(nm^2) 649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。 输入: “RD”输出: “Radiant”解释: 第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人 输入: “RDD”输出: “Dire”解释:第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 495 给定攻击时间和中毒状态持续时间，问中毒状态总时长 Input: [1,2], 2Output: 3 (1-2-4) 8ms12345678910public int findPoisonedDuration(int[] timeSeries, int duration) &#123; if(timeSeries==null||timeSeries.length&lt;1||duration==0)return 0; int rst = 0; for(int i =0;i&lt;timeSeries.length-1;i++)&#123; //每次取间隔或者duration rst += Math.min(duration,timeSeries[i+1]-timeSeries[i]); &#125; rst += duration; return rst;&#125; //todo again按 区间的做法：100% 4ms12345678910111213141516public int findPoisonedDuration(int[] timeSeries, int duration) &#123; if(timeSeries==null||timeSeries.length&lt;1||duration==0)return 0; int rst = 0; int start = timeSeries[0]; int end = timeSeries[0]+duration; for(int i = 1;i&lt;timeSeries.length;i++)&#123; //Input: [1,4], 2 if(timeSeries[i]&gt;end)&#123; result += (end-start); start = timeSeries[i]; &#125; end = timeSeries[i]+duration; &#125; result+=(end-start); return result;&#125; 500 判断字符串是不是在键盘的同一行流： 正则很慢 流也很慢123public String[] findWords(String[] words)&#123; return Stream.of(words).parallel().filter(s-&gt;s.toLowerCase().matches("[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*")).toArray(String[]::new);&#125; 683 - K Empty Slots最长01串799倒香槟第[i,j]个杯子的容积 输入: poured(倾倒香槟总杯数) = 2,query_glass(杯子的位置数) = 1, query_row(行数) = 1输出: 0.5解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。 第一行流过10杯，则第二行流过9杯，左边分到4.5 右边分到4.51234567891011121314public double champagneTower(int poured, int query_row, int query_glass) &#123; double[][] A= new double[102][102]; A[0][0] = (double) poured; for(int r = 0;r&lt;= query_row;++r)&#123; for(int c = 0;c&lt;=r;c++)&#123; double q = (A[r][c] - 1)/2; if(q &gt; 0)&#123; A[r+1][c] += q; A[r+1][c+1] += q; &#125; &#125; &#125; return Math.min(1,A[query_row][query_glass]);&#125; 2^N 大整数287 O(1)空间，找到数组中重复的数字查找第二小/大的元素12345678910111213141516171819202122static int secondMin2(int[] arr)&#123; int first = Integer.MAX_VALUE,second = Integer.MAX_VALUE; for (int j = 0; j &lt; arr.length; j++) &#123; if(arr[j]&lt;=first)&#123; second = first; first = arr[j]; &#125;else if(arr[j]&lt;=second&amp;&amp;arr[j]!=first) second = arr[j]; &#125; return second;&#125;static int secondMax(int[] arr)&#123; int first = Integer.MIN_VALUE,second = Integer.MIN_VALUE; for (int j = 0; j &lt; arr.length; j++) &#123; if(arr[j]&gt;=first)&#123; second = first; first = arr[j]; &#125;else if(arr[j]&gt;=second&amp;&amp;arr[j]!=first) second = arr[j]; &#125; return second;&#125; 排序数组中小于target的2 4 6 8 9 target=14 2+9&lt;14 cnt+=4 4+9&lt;14 cnt+=3 6+9&gt;14,6+8==14,start==end 结束 给定一个数字范围，找到其中有几个首尾相同的数字 百万数字中找最大20个用开始20个数字构造20个node的最小堆，接下来的数字比root大则replace，insert 每秒最大桶数量减半，求t时刻一共消耗了多少方法1：按递减排序，减半，再排序，一共排序t次方法2：维持最大堆，每次取root减半再插入 187 rolling-hash DNA序列中出现2次以上长为10的子串//todo 879G 名成员 第i种犯罪会产生profit[i] 利润，需要group[i]名成员参与。计划产生P利润有多少种方案。 Input: G = 5, P = 3, group = [2,2], profit = [2,3]output: 2 dp[k][i][j] 产生i利润 用j个人 完成前k个任务 的方案数 576 无向图访问所有点的最短边数ip2cidr找末尾1的位置x &amp; -x 131819 找出句子中出现频率最高没被ban掉的词正则去掉所有标点 “Bob hit a ball, the hit BALL flew far after it was hit.” pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。 大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。其他六个是L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符P：各种标点 123456//busymannote// [Bob, hit, a, ball, the, hit, BALL, flew, far, after, it, was, hit]paragraph.split("\\PL+");// Bob hit a ball the hit BALL flew far after it was hitparagraph.replaceAll("\\pP","");paragraph.replaceAll("[^a-zA-Z ]", "") 1234567public String mostCommonWord(String paragraph, String[] banned) &#123; Set&lt;String&gt; ban = new HashSet&lt;&gt;(Arrays.asList(banned)); Map&lt;String,Integer&gt; cnt = new HashMap&lt;&gt;(); String[] split = paragraph.toLowerCase().split("\\PL+"); for(String s:split)if(!ban.contains(s))cnt.put(s,cnt.getOrDefault(s,0 )+1); return Collections.max(cnt.entrySet(),Map.Entry.comparingByValue()).getKey();&#125; 亚线性算法o(n)小于输入规模亚线性时间：scale-free networkS：大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接。网络中随机抽取一个节点，它的度是多少呢？这个概率分布就称为节点的度分布顶点的度满足幂律分布（也称为帕累托分布）,所以不能均匀采样计算每个人的平均度数。 亚线性空间中位数问题，知道所有的输入，有O(n)的分治算法 水库抽样Reservpor Sampling 亚线性空间 “给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。” 当扫描到前n个数字时，保留数组中k个均匀的抽样1.k大小的数组2.填充k个元素3.收到第i个元素t。以k/i的概率替换A中的元素。这样保证收到第i个数字的时候，i在k中的概率是k/i。实现：生成[1..k..i]中随机数j，如果j&lt;=k（k/i的概率),A[j]=t证明：第i个数接收时有k/i的概率在k数组中，当第i+1个数接收时,i+1有k/(i+1)概率在数组k中，并且刚好替换掉的是第i个数的概率是k中选i：1/k，所以第i+1个数来之后i还在k中的概率是（1-k/(i+1)*1/k)=（1-1/(1+i)）123456789101112private void select(int[] stream,int n,int k)&#123; int[] reserve = new int[k]; int i; for(i=0;i&lt;k;i++)&#123; reserve[i]=stream[i]; &#125; Random r = new Random(); for(;i&lt;n;i++)&#123; int j = r.nextInt(i+1); if(j&lt;k)reserve[j]=stream[i]; &#125;//sout&#125; 398 数组中重复元素随机返回index int[] nums = new int[] {1,2,3,3,3};Solution solution = new Solution(nums); // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3); // pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 水库抽样：流式处理，空间复杂度O(1),pick O(N)如果用hashmap，初始化O(N)时间，O（N）空间，数组太大就不行。1234567891011121314151617181920212223class Solution &#123; int[] nums; Random r; public Solution(int[] nums) &#123; this.nums=nums; this.r = new Random(); &#125; public int pick(int target) &#123; int cnt =0; int rst =-1; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]!=target)continue; //以1/++cnt的概率抽这个数 // int j = r.nextInt(++cnt); // if(j==0)rst=i; else&#123;//不赋值变量从180ms-&gt;127ms if(r.nextInt(++cnt)==0)rst=i; &#125; &#125; return rst; &#125;&#125; ？？382 随机链表 extremely large and its length is unknown长度不知，读到第三个node，让它的概率变成1/3，用1/3的概率替换掉之前选择的item 由于计算机产生的随机数都是伪随机数，对于相同的随机数引擎会产生一个相同的随机数序列，因此，如果不使用静态变量（static），会出现每次调用包含随机数引擎的函数时，随机数会重新开始产生随机数，因此会产生相同的一串随机数。比如你第一次调用产生100个随机数，第二次调用仍然会产生这一百个随机数。如果将随机数引擎设置为静态变量，那么第一次调用会产生随机数序列中的前100个随机数，第二次调用则会产生第100到200的随机数。 611数组中符合三角形边长的对数Input: [2,2,3,4]Output: 3Explanation:Valid combinations are:2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3 线性扫描 复杂度n^2 思路，排完序之后，固定一个数，用二分双指针，找之前的一个区间两数之和&gt;target例如固定 4, 找[2,2,3] +2固定 3, 找[2,2] +1 123456789101112131415public int triangleNumber(int[] nums) &#123; int cnt = 0; Arrays.sort(nums); int n = nums.length; for (int i = n-1; i &gt;1 ; i--) &#123; int l = 0,r = i-1; while (l&lt;r)&#123; if(nums[l] + nums[r] &gt;nums[i])&#123; cnt += r-l; r--; &#125;else l++; &#125; &#125; return cnt;&#125; 判断点D是否在三角形ABC内思路，计算边AB,BC,CA 顺时针的边和 点D的叉积是不是都&gt;=012345678910// 计算AB 和 AC的叉积 边AB和点C的叉积double Product(point A, point B,point C)&#123; return (B.x - A.x)*(C.y-A.y)-(C.x-A.x)*(B.y-A.y);&#125;boolean isIn(point A,point B,point C,point D)&#123; if(Product(A, B, D) &gt;= 0 &amp;&amp; Product(B, C, D) &gt;=0 &amp;&amp; Product(C,A,D) &gt;=0)&#123; return true; &#125; return false;&#125; 812 最大三角形面积Example:Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]Output: 2 三角形面积公式：https://leetcode.com/problems/largest-triangle-area/discuss/122711/C%2B%2BJavaPython-Solution-with-Explanation-and-Prove123456789101112131415double Product(int[] A, int[] B,int[] C)&#123; return (B[0] - A[0])*(C[1]-A[1])-(C[0]-A[0])*(B[1]-A[1]); &#125; public double largestTriangleArea(int[][] p) &#123; double rst = 0; int n = p.length; for(int i = 0;i&lt;n-2;i++)&#123; for(int j = i+1;j&lt;n-1;j++)&#123; for(int k = j+1;k&lt;n;k++ )&#123; rst = Math.max(rst,0.5 * Math.abs(Product(p[i],p[j],p[k]))); &#125; &#125; &#125; return rst;&#125; 332 欧拉路径 每条边一次(这道题不用判断)只有1个点入度比出度少1（起点）&amp;&amp; 只有一个点入度比出度多1（终点）其余点入度==出度 Hierholzer：O(e)删除边e(u,v)，并dfs(v)，不断寻找封闭回路， 从v点出发一定会回到v。因为入度出度相等。虽然可能不包含所有点和边。总是可以回到以前的点，从另一条路走，把其它所有的边全部遍历掉。 不是拓扑排序，拓扑排序每个点仅1次path里加入{0},{2}头插法{2,0}//保证远的在后面dfs回到1，继续找封闭回路 Input: tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] 用hashmap记录每个点的出度的点，建图 输出字典序靠前的序列，用优先队列，先访问的会后回溯到dfs插到链表头。（后序遍历：全部遍历完了再加入（退栈)） 123456789101112131415161718public List&lt;String&gt; findItinerary(String[][] tickets) &#123; LinkedList&lt;String&gt; rst = new LinkedList&lt;&gt;(); Map&lt;String,PriorityQueue&lt;String&gt; &gt; map = new HashMap&lt;&gt;(); for(String[] edge:tickets)&#123; PriorityQueue&lt;String&gt; nei = map.getOrDefault(edge[0],new PriorityQueue&lt;String&gt;()); nei.add(edge[1]); map.put(edge[0],nei); &#125; dfs(rst,map,"JFK"); return rst;&#125;private void dfs(LinkedList&lt;String&gt; rst,Map&lt;String,PriorityQueue&lt;String&gt; &gt; map,String start)&#123; PriorityQueue&lt;String&gt; pri = map.get(start); while(pri!=null&amp;&amp;!pri.isEmpty()) dfs(rst,map,pri.poll()); rst.addFirst(start); &#125; 后序遍历stack： ?207 先修课程有环则返回false 拓扑排序??和并查集的区别（？按算法4上88.45%1234567891011121314151617181920212223242526272829303132333435private boolean[] marked;private boolean cycle = true;private boolean[] onStack;public boolean canFinish(int numCourses, int[][] prerequisites) &#123; onStack = new boolean[numCourses]; marked =new boolean[numCourses]; List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; for (int i = 0; i &lt;numCourses ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; //&#123;2,0&#125;,&#123;1,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;,&#123;1,3&#125;&#125;-&gt;[[], [0, 3], [0], [1, 2]] for (int[] edge :prerequisites) &#123; graph[edge[0]].add(edge[1]); &#125; for (int i = 0; i &lt; numCourses; i++) &#123; if(!marked[i])dfs(graph,i); &#125; return cycle;&#125;private void dfs(List&lt;Integer&gt;[] graph,int v)&#123; if(graph[v].size()&lt;1)return; //dfs是从起点到v的有向路径，onstack保存了递归中经历的点 onStack[v] = true; marked[v] = true; for(int w :graph[v])&#123; if(!marked[w]) dfs(graph,w); else if(onStack[w])&#123; cycle = false; return; &#125; &#125; //这个点出发没有环 onStack[v] = false;&#125; 56% 有可以优化到100%4ms的方法1.邻接表存储课程依赖图L12345678910List[] graph_;public boolean canFinish(int numCourses, int[][] prerequisites) graph_ = new ArrayList[numCourses]; for(int i =0;i&lt;numCourses;i++) &#123;graph_[i] = new ArrayList&lt;Integer&gt;();&#125; for(int[] back:prerequisites)&#123; int pre = back[0]; int lesson = back[1]; graph_[lesson].add(pre); &#125; 2.定义状态int[] visit = new int[numCourses];3.dfs每个顶点1234for(int i =0;i&lt;numCourses;i++)&#123; if(hasCircle(i,visit))return false;&#125;return true; 4.dfs 检查有没有环12345678910boolean hasCircle(int idx,int[] visited)&#123; if(visited[idx]==1)return true; if(visited[idx]==2)return false; List&lt;Integer&gt; neib = graph_[idx]; for(int i:neib)&#123; if(hasCircle(i,visited))return true; &#125; visited[idx]=2; return false;&#125; 210 输出修课顺序 Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] 用onStack和post 11% kolakoski序列找规律 lc481 返回kolakoski前N中有几个1174 骑士从左上到右下找公主，求初始血量dp[i][j]表示到i,j的最少血量，因为右下角一格也要减dp[n-1][m],dp[n][m-1]=1表示走完了右下角还剩下1点血dp[0~n-2][m]和dp[n][0~m-2]都是非法值，为了取min设置MAX_VALUE1dp[i][j]=Math.max(1,Math.min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]); 伪多项式时间一个整数是否是素数123def isPrime(n): for i in range(2,n): if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ A,B两人选k种可乐达到期望最大A选m个，B选(n-m)个每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大输出 买k种可乐的数量期望和：$m/n*a+(m-n)/n*b$的最大值 全部买期望最大那种输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1m/n=.50.5x1+0.5x2=0.5+1=1.50.5x3+0.5x1 = 2 全部买第二种可乐输出:0 2 ??火车换乘保证每个车错过能在30分钟以后换车输入：城市n 火车数mfrom1 to3 cost800 18:00 21:00…输出从1到n的最小花费 16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)*(P(C进入1/8)*P(A赢了C)+P(D进入1/8)*P(A赢了D))A进入1/2需要赢没比过的另外4个队A变成冠军需要赢没比过的另外8个队分组问题：如果1/4赛 1234 5678是一组4个是一组如果1/2赛 8个是一组 1234567891011for(int i =1;i&lt;4;i++)&#123; int inergroup = 1&lt;&lt;i; int group= 1&lt;&lt;i+1; for (int j = 0; j &lt;16 ; j++) &#123; for(int k=0;k&lt;16;k++) &#123; //在同一个大组 if(j/group==k/group) &#123; //不在同一个小组 if (j / inergroup != k / inergroup) &#123; dp[i][j] += dp[i - 1][j] * dp[i - 1][k] * p[j][k];&#125;&#125;&#125;&#125;&#125; !815 换公交 BFSroutes = [[1, 2, 7], [3, 6, 7]]表示环线1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;求从S-&gt;T的最少公交车数量（不是少的站点） Input: routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6Output: 2乘坐 routes[0]到7，换routes[1]到6 易错点1： bfs的size保留当前层的定点数易错点2： deque的add和poll 展开代码 1234567&#123;&#123;0,1,6,16,22,23&#125;, &#123;14,15,24,32&#125;, &#123;4,10,12,20,24,28,33&#125;, &#123;1,10,11,19,27,33&#125;, &#123;11,23,25,28&#125;, &#123;15,20,21,23,29&#125;, &#123;29&#125;&#125;; S=4 T=21bfs，起点入队，遍历起点可以到达的所有公交(4可以达公交2)，遍历所有公交2上的可达stop{4,10,12,20,24,28,33},如果没到T，则4乘的公交换一辆，再遍历有4公交上的其他可达stop。用size保留当前层的定点数 4的bus全部遍历完后size==0。下一轮重新获取que.size()如果4的所有公交都不能达到T，则必须换乘cnt+1。当前起点变成stop{10}，遍历它的公交和stop，不行就{12}这些都是cnt+1可达的。直到stop{20}-&gt;bus{2,5}遍历公交5的stop找到T，bfs换乘1层找到的。 注意deque的add是addLast，push是addFirst,poll是pollFirst，pop是poolFirst 队列应该是add+poll,bfs如果用栈，则会在这一层还没找完先找下一层cnt=1{4}-&gt;cnt=2{33:[2, 3]}-&gt;将{1,10,11,19,27,33}入队所以回到下一次size–的时候取到了下一层的点33,两个bus都标记过了然后就全乱了{27:[3]}-&gt;{19:[3]}-&gt;{11:[3,4]}-&gt;bus4的最后{28:[2,4]}-&gt;25:[4]-&gt;cnt=3{23:[0,4,5]}-&gt;bus5找到21本来应该bus[2]-&gt;20-&gt;bus[5]结果bus[2]-&gt;bus[4]-&gt;bus[5] 数据结构： {站点：list&lt;经过的公交车id&gt;} list&lt;公交车id&gt; 标记已经乘过的公交 BFS连通分量while(!que.empty)， 遍历一辆车的连通分量while(que.size()&gt;0) 遍历当前节点相邻的busid是否乘过for(int car:list)， 并标记这个车的连通分量已乘过，遍历这个连通分量for(int t:routes[car])中有没有T，有则结束，没有则将整个连通分量入队。1//todonexttime 11 数组index当底边，值当杯子两侧，最大面积242 Anagram 相同字母的单词344 reverse String转成char数组/位运算做法77%比stringbuilder好 551 出现两个以上A或者3个以上L为false1return s.indexOf("A")==s.lastIndexOf("A") &amp;&amp; s.indexOf("LLL") == -1; 476前导012345678910//找到左边第一个1，然后后面全置0public static int highestOneBit(int i) &#123; // HD, Figure 3-1 i |= (i &gt;&gt; 1);//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx i |= (i &gt;&gt; 2);//连续4个1 但是如果位数不够就只有3个1或者更少 i |= (i &gt;&gt; 4); i |= (i &gt;&gt; 8); i |= (i &gt;&gt; 16); return i - (i &gt;&gt;&gt; 1);//让全1的无符号右移1格1111-0111得到1000&#125; 292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢443 !压缩字符串The length after compression must always be smaller than or equal to the original array. aabb可以压缩成a2b2 Input:[“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]Output:Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”]. 123456789101112131415161718192021222324public int compress(char[] chars) &#123; int n = chars.length; int idx = 0;int i = 0; while (idx &lt; n)&#123; char cur = chars[idx]; int cnt = 0; while (idx &lt; n &amp;&amp; chars[idx] == cur) &#123; idx++; cnt++; &#125; chars[i++] = cur; if(cnt != 1)&#123; if(cnt &lt; 10)&#123; chars[i++] = (char)(cnt +'0'); &#125;else&#123; for(char c:Integer.toString(cnt).toCharArray())&#123; chars[i++] = c; &#125; &#125; &#125; &#125; return i;&#125; 899 操作字符串前k个字符放到最后 输出字典序最小的 Input: S = “cba”, K = 1Output: “acb” Input: S = “baaca”, K = 3Output: “aaabc”Explanation:In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”. 当k=1 字符串只能旋转当k&gt;1的时候，固定第一位，可以把后面任意一位转到第二位，即确定第一位，可以和后面所有数字比较，然后放到最后，冒泡排序。 lc749 病毒隔离每天只能隔离一片1的圈,而且必须是不隔离会感染最多的圈，每天1会向周围扩散 Input:12345grid = [[1,1,1,0,0,0,0,0,0], [1,0,1,0,1,1,1,1,1], [1,1,1,0,0,0,0,0,0]]Output: 13 Explanation: The region on the left only builds two new walls. 先隔离掉右边的1 用上5+1+5，然后左边扩散了，之需要把[0][3]和[0][4]隔离了。还有[2]排 所以就只有2个墙了 456 !132 pattern Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2]. 正确做法：栈 方法1：用一个for循环找到当前i之前的min,从[i+1,n)找符合的两个数字12345678910111213public boolean find132pattern(int[] nums) &#123; int n = nums.length; int min_i = Integer.MAX_VALUE; for(int j = 0;j&lt;n-1;j++)&#123; min_i = Math.min(min_i,nums[j]); for(int k =j+1;k&lt;n;k++)&#123; if(nums[k] &gt; min_i &amp;&amp; nums[j]&gt;nums[k])&#123; return true; &#125; &#125; &#125; return false;&#125; lt700 怎么划分最赚钱 完全背包123长度 | 1 2 3 4 5 6 7 8 --------------------------------------------价格 | 1 5 8 9 10 17 17 20 给出 price = [1, 5, 8, 9, 10, 17, 17, 20], n = 8 返回 22//切成长度为 2 和 6 的两段 dp:(0,n),(1,n-1),…,(n/2,n/2)二维dp（？）123456789101112public int cutting(int[] prices, int n) &#123; int[][] dp = new int[n+1][n+1]; for(int j = 1; j &lt;= n; j++) &#123; for(int i = 1; i &lt;=n; i++) &#123; dp[i][j] = Math.max(dp[i][j], dp[i-1][j]); if(j &gt;= i) &#123; dp[i][j] = Math.max(dp[i][j], dp[i][j - i] + prices[i-1]); &#125; &#125; &#125; return dp[n][n];&#125; 记忆递归：展开代码 123456789101112Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();public int cutting(int[] prices, int n) &#123; if(map.containsKey(n))return map.get(n); if(n &lt;=0 )return 0; if(n == 1)return prices[0]; int sum = 0; for (int i = 1; i &lt;n+1; i++) &#123; sum = Math.max(sum, cutting(prices, n-i) + prices[i-1]); &#125; map.put(n, sum); return sum;&#125; 861 01矩阵反转能得到的最大01行和 Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]Output: 39Explanation:Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 思路：贪心1判断行首是0，直接翻转一行，因为2^3比4+2+1还要大同列是一个数量级2^?的，判断列0和1的个数翻转。 1234567891011public int matrixScore(int[][] A) &#123; int R = A.length, C = A[0].length; int ans = 0; for (int c = 0; c &lt; C; ++c) &#123; int col = 0; for (int r = 0; r &lt; R; ++r) col += A[r][c] ^ A[r][0]; ans += Math.max(col, R - col) * (1 &lt;&lt; (C-1-c)); &#125; return ans;&#125; sw44 判断扑克牌是否顺子1.排序，2.数0（大王小王可以当作任意数字）的个数，3.统计数组相邻数字之间的空缺数 1234567891011121314151617public boolean isContinuous(int[] cards)&#123; if(cards == null || cards.length &lt;1)return false; Arrays.sort(cards); int zerocnt = 0; for(int card :cards)&#123; if(card == 0)zerocnt ++; &#125; int interval = 0; for (int i = 1; i &lt;cards.length ; i++) &#123; if(cards[i-1] == 0 ||cards[i-1] ==0)continue; if(cards[i] == cards[i-1])return false; interval += cards[i] - cards[i-1] - 1; if(interval &gt; zerocnt)return false; &#125; return true;&#125; 263 Ugly Number 判断是否是丑数包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。12345678910111213public boolean isUgly(int num) &#123; if(num &lt;=0)return false; while( num % 2 ==0)&#123; num /= 2; &#125; while(num % 3 ==0)&#123; num /= 3; &#125; while( num % 5 ==0)&#123; num /= 5; &#125; return num ==1;&#125; 264 输出第n个丑数正确做法：3ms //todo1234567891011121314public int nthUglyNumber(int n) &#123; int[] nums = new int[n]; nums[0] = 1; int t2 = 0, t3 = 0, t5 = 0; for (int i = 1; i &lt; n; i++) &#123; int m2 = nums[t2] * 2, m3 = nums[t3] * 3, m5 = nums[t5] * 5; int mm = Math.min(m2, Math.min(m3, m5)); if (mm == m2) t2++; if (mm == m3) t3++; if (mm == m5) t5++; nums[i] = mm; &#125; return nums[n - 1];&#125; 8% 105ms123456789101112131415public int nthUglyNumber(int n) &#123; if(n == 1)return 1; PriorityQueue&lt;Long&gt; que =new PriorityQueue&lt;&gt;(n); que.add(1l); for (int i = 1; i &lt;n ; i++) &#123; long tmp = que.poll(); // 重复元素 while (!que.isEmpty() &amp;&amp; que.peek() == tmp)tmp = que.poll(); que.add(tmp * 2); que.add(tmp * 3); que.add(tmp * 5); &#125; return que.poll().intValue();&#125; 859 如果交换A字符串中两个字母可以得到B就true Input: A = “”, B = “aa”Output: false 1.如果长度不一样，false Input: A = “ab”, B = “ab”Output: falseInput: A = “aa”, B = “aa”Output: true 2.如果一样的字符串，一定要有重复的字符 Input: A = “ab”, B = “ba”Output: true 3.不一样的字符只有2个，记录位置并交换比较。123456789101112131415161718192021public boolean buddyStrings(String A, String B) &#123; if(A.length() != B.length())return false; boolean same = false; int[] acnt = new int[26]; int dif = 0; int idx1 = -1,idx2=-1; for(int i = 0;i&lt;A.length();i++)&#123; acnt[A.charAt(i) -'a']++; if(acnt[A.charAt(i) -'a'] &gt;=2)same = true; if(dif == 0 &amp;&amp; i == A.length()-1)return same; if(A.charAt(i) != B.charAt(i))&#123; dif++; if(dif&gt;2)return false; if(idx1 &lt; 0 )idx1 = i; else idx2 = i; &#125; &#125;// System.out.println(idx1+" "+idx2); if(idx1!=idx2)return A.charAt(idx1) == B.charAt(idx2) &amp;&amp; A.charAt(idx2) ==B.charAt(idx1); return false;&#125; lc70爬楼梯123456789public int climbStairs(int n) &#123; int[] dp = new int[n+1]; dp[0] =1; dp[1] =1; for(int i =2;i&lt;n+1;i++)&#123; dp[i] = dp[i-1]+dp[i-2]; &#125; return dp[n];&#125; 有一段楼梯台阶有15级台阶，以小明的脚力一步最多只能跨3级，请问小明登上这段楼梯有多少种不同的走法?() $f(n)=f(n-1)+f(n-2)+f(n-3)$ (对于n&gt;=4)$f(n-1)=f(n-2)+f(n-3)+f(n-4)$ (对于n&gt;=5)前面两式相减可以得到： $f(n)=2*f(n-1)-f(n-4)$ (对于n&gt;=5)而对于n&lt;=5的情况有：f(1)=1f(2)=2f(3)=4f(4)=7一直算到15. 12345678910111213141516public int f(int n)&#123; if(n &lt;=2)return n; if(n == 3)return 4; return f(n-1) + f(n-2) + f(n-3);&#125;public int f2(int n)&#123; int[] dp = new int[n+1]; dp[0] =1; dp[1] =1; dp[2] =2; dp[3] =4; for (int i = 4; i &lt;n+1 ; i++) &#123; dp[i] = dp[i-1]+dp[i-2]+dp[i-3]; &#125; return dp[n];&#125; 栈混洗 火车调度随机数发生器在 C 语言标准库中，Brian W. Kernighan 和 Dennis M. Ritchie 设计的随机数収生器如下：1234567891011121314unsigned long int next = 1; /* rand: return pseudo-random integer on 0..32767 */ int rand(void) &#123; next = next * 1103515245 + 12345; return (unsigned int)(next/65536) % 32768; &#125; /* srand: set seed for rand() */ void srand(unsigned int seed) &#123; next = seed; &#125; 维护一个32位的无符号长整数next，随着next的“随意”变化，不断输出伪随机数。通过srand(seed)，可以设置next的初始值（随机种子）。 在next当前值的基础上乘以1103515245 = 3 5  5  7  129749，并加上12345。 通过整除运算在该长整数的二进制展开中截取高16位，进而通过模余运算抹除最高比特位。经如此的“混沌化”处理之后，即可作为“随机数”返回。 231 2的整数次405 十进制转16进制Input:-1Output:“ffffffff” 每次用1111取右边四位，因为int已经补码表示了，正负都一样取4位直接转。(2^n的时候 位运算&amp;(n-1)正好是取余（？）)12345678910public String toHex(int num) &#123; if(num == 0)return "0"; String hexs = "0123456789abcdef"; String str = ""; while(num != 0)&#123; str = hexs.charAt((num &amp; 15)) +str; num &gt;&gt;&gt;= 4; &#125; return str;&#125; lc 325 lt 919数组嵌套 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } stop adding right before a duplicate element occurs in S. Input: A = [5,4,0,3,1,6,2]Output: 4Explanation:A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2. One of the longest S[K]:S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0} 素数定理从不大于n的自然数随机选一个，它是素数的概率大约是1/ln(n)https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0%E5%AE%9A%E7%90%86/1972457?fromtitle=%E8%B4%A8%E6%95%B0%E5%AE%9A%E7%90%86&amp;fromid=47101261-100有25个素数12&gt;&gt;&gt;math.log(100)4.605170185988092 平面最近点对 分治!!780 x,y可以向下x步，或者向右y步能否到达tx,ty Input: sx = 1, sy = 1, tx = 3, ty = 5One series of moves that transforms the starting point to the target is:(1, 1) -&gt; (1, 2)(1, 2) -&gt; (3, 2)(3, 2) -&gt; (3, 5)out: True 正常递归思路 超时 lt1472 s任意交换奇数位字符和偶数位字符 能否变成t 给出 s=”abcd”，t=”cdab”，返回”Yes”。第一次a与c交换，第二次b与d交换。 对奇数位和偶数位计数 442 1 ≤ a[i] ≤ n 找到所有出现2次的元素 O(1) 空间 some elements appear twice and others appear once.Input:[4,3,2,7,8,2,3,1]Output:[2,3] 123456784-&gt;[4,3,2,-7,8,2,3,1] 3-&gt;[4,3,-2,-7,8,2,3,1]2-&gt;[4,-3,-2,-7,8,2,3,1]7-&gt;[4,-3,-2,-7,8,2,-3,1]8-&gt;[4,-3,-2,-7,8,2,-3,-1]2-&gt;[4,[3],-2,-7,8,2,-3,-1]3-&gt;[4,[3],[2],-7,8,2,-3,-1]1-&gt;[-4,[3],[2],-7,8,2,-3,-1] 1234567891011public List&lt;Integer&gt; findDuplicates(int[] nums)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; nums.length;i++)&#123; int idx = Math.abs(nums[i]) - 1; if(nums[idx] &lt; 0)&#123; res.add(Math.abs(idx) + 1); &#125; nums[idx] = -nums[idx]; &#125; return res;&#125; 401 二进制手表上排1,2,4,8表示小时 下排1,2,4,8,16,32表示分钟上1,2 下 16，8，1 表示3:25 Input: n = 1 两了几个led灯 所有可能的时间Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”] 计算小时和分钟里有多少个11234567891011public List&lt;String&gt; readBinaryWatch(int num)&#123; List&lt;String&gt; times = new ArrayList&lt;&gt;(); for (int h = 0; h &lt; 12 ; h++) &#123; for (int m = 0; m &lt; 60 ; m++) &#123; if(Integer.bitCount((h&lt;&lt;6) + m) == num)&#123; times.add(String.format("%d:%02d",h,m)); &#125; &#125; &#125; return times;&#125; 汉明重量 Hamming weight 32位int有多少个1 Input: 11Output: 3Integer 11 has binary representation 00000000000000000000000000001011 X与X-1相与得到的最低位永远是0 Expression Value X 0 1 0 0 0 1 0 0 0 1 0 0 0 0 X-1 0 1 0 0 0 1 0 0 0 0 1 1 1 1 X &amp; (X-1) 0 1 0 0 0 1 0 0 0 0 0 0 0 0 477 全部汉明距离Integer.bitCount(x ^ y) Input: 4, 14, 2Output: 6HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. 4 = 010014 = 11102 = 00100x3+2*1+2*1+1*2 123456789101112public int totalHammingDistance(int[] nums)&#123; int total = 0,n = nums.length; for (int i = 0; i &lt; 32 ; i++) &#123; int bitCnt = 0; //有几个num这个位是1 for (int j = 0; j &lt; n ; j++) &#123; bitCnt += (nums[j] &gt;&gt; i) &amp; 1; &#125; total += bitCnt*(n-bitCnt); &#125; return total;&#125; 87 判断两个字符串是不是拆分成两半二叉树交换子树构成的great / \ gr eat / \ / \g r e at / \ a t可以换成 rgeat / \ rg eat / \ / \r g e at / \ a t 1234567891011121314151617181920212223242526public boolean isScramble(String s1, String s2) &#123; if(s1.length()!=s2.length())return false; if(s1.equals(s2))return true; // 不剪枝这一步会TL int[] cnt = new int[26]; for (int i = 0; i &lt;s1.length() ; i++) &#123; cnt[s1.charAt(i)-'a']++; cnt[s2.charAt(i)-'a']--; &#125; for (int i = 0; i &lt;26 ; i++) &#123; if (cnt[i]!=0) &#123; return false; &#125; &#125; for (int i = 1; i &lt;s1.length() ; i++) &#123; if((isScramble(s1.substring(0,i), s2.substring(0,i))&amp;&amp; isScramble(s1.substring(i), s2.substring(i)))|| (isScramble(s1.substring(0,i), s2.substring(s1.length()-i))&amp;&amp; isScramble(s1.substring(i), s2.substring(0,s1.length()-i))))&#123; return true; &#125; &#125; return false;&#125; lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161123456789101112131415161718192021public boolean isOneEditDistance(String s, String t) &#123; int sl = s.length(); int tl = t.length(); if(s.equals(t))return false; if(Math.abs(sl-tl)&gt;1)return false; int idx = 0; int len = Math.min(sl,tl); for(int i = 0; i &lt; len; i++)&#123; idx = i+1;// &gt;=1 // 前面已经相等了 if(s.charAt(i) != t.charAt(i))&#123; // 比较两个字符串的a, b的index+1, index+1 位以后是否相等 // 或者 index+1, index 是否相等， // 或者index, index+1是否相等 return s.substring(idx).equals(t.substring(idx)) || s.substring(idx).equals(t.substring(idx-1)) || s.substring(idx-1).equals(t.substring(idx)); &#125; &#125; return true;&#125; 取模和取余remjava的%取余 python 取模求 整数商： c = a/b; 计算模或者余数： r = a - c*b.例如：计算-7 Mod 412&gt;&gt;&gt; -7%41 那么：a = -7；b = 4； 第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）； 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。 469 lt886 判断凸多边形输入: points = [[0, 0], [0, 1], [1, 1], [1, 0]]输出: true 思路：计算3个点的偏向，是否和之前3个点的偏向相同。注意环，最后一个点要模到第1、2个点123456789101112131415double product(int[]A,int[]B,int[]C)&#123; return (C[1]-A[1])*(B[0]-A[0]) - (C[0]-A[0])*(B[1]-A[1]); &#125;public boolean isConvex(int[][] point) &#123; int n = point.length; double pre = 0; for(int i = 0;i&lt;n;i++)&#123; double pro = product(point[i],point[(i+1)%n],point[(i+2)%n]); if(pro!=0)&#123; if(pro * pre &lt;0)return false; else pre = pro; &#125; &#125; return true;&#125; 149 在同一条直线上最多的点数Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:1234567^|| o| o| o +-------------&gt;0 1 2 3 4 注意如果x相等的斜率应该为INT_MAX不是0. 相同的点要单独算（？） 线段上格点的个数P1=(1,11) P2=(5,3)out: 3 (2,9) (3,7) (4,5) 答案是gcd(|x1-x2|,|y1-y2|)-1最大公约数：共有约数中最大的一个x相差4，y相差8 求分成（/）最多多少份，x,y都是整数 15 3sum a + b + c = 0 Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 关键：去重技巧1234567891011121314151617181920212223//75%public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;num.length-2; i++) &#123; //关键去重 if(i==0||(i&gt;0&amp;&amp;num[i]!=num[i-1]))&#123; int lo = i+1,hi=num.length-1,sum = 0-num[i]; //关键 while (lo&lt;hi)&#123; if(num[lo]+num[hi] == sum)&#123; res.add(Arrays.asList(num[i],num[lo],num[hi])); //去重 while (lo&lt;hi&amp;&amp;num[lo]==num[lo+1])lo++; while (lo&lt;hi&amp;&amp;num[hi]==num[hi-1])hi--; lo++;hi--; &#125;else if(num[lo]+num[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res;&#125; lt 1487 2sum 最接近target16 3sum 最接近target的值//todo nexttime 18 4sum 外层for 用3sum找target-nums[i]454 4 sum 2 poj2785 4 Values whose Sum is 0用poj的方法11%4个分别有n个数字的数组ABCD，每个数组中取一个，合为0的组合数。c+d = -a-b从A,B中找出n^2种组合，从C,D中找出n^2种组合，排序二分找到lowerbound和upbound。 正确方法：计算c+d的时候放入hashmap计数12345678910111213141516public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt;C.length ; i++) &#123; for (int j = 0; j &lt;D.length ; j++) &#123; int sum = C[i] + D[j]; map.put(sum,map.getOrDefault(sum,0 )+1 ); &#125; &#125; int res = 0; for (int i = 0; i &lt;A.length ; i++) &#123; for (int j = 0; j &lt;B.length ; j++) &#123; res += map.getOrDefault(-(A[i]+B[j]),0 ); &#125; &#125; return res;&#125; 914 相同数字的牌划分成一组，每组数量相同 能否划分 输入：[1,2,3,4,4,3,2,1]输出：true解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 计数，求最大公约数123456789101112public boolean hasGroupsSizeX(int[] deck) &#123; if(deck==null||deck.length&lt;2)return false; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); int res = 0; for (int i : deck) count.put(i, count.getOrDefault(i, 0) + 1); for (int i : count.values()) res = gcd(i, res); return res &gt; 1;&#125;public int gcd(int a, int b) &#123; return b &gt; 0 ? gcd(b, a % b) : a;&#125; 916 A单词出现B中所有字母 b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称单词 b 是单词 a 的子集。 例如，“wrr” 是 “warrior” 的子集，但不是 “world” Input: A = [“amazon”,”apple”,”facebook”,”google”,”leetcode”], B = [“e”,”o”]Output: [“facebook”,”google”,”leetcode”] 7 整数反转 integer越界展开代码 123456789101112public int reverse(int x) &#123; int flag = x&lt;0?-1:1; int rst = 0; while(x!=0)&#123; int add = x%10; x/=10; if(rst&gt;Integer.MAX_VALUE/10||(rst==Integer.MAX_VALUE/10&amp;&amp;add&gt;7))return 0; if(rst&lt;Integer.MIN_VALUE/10||(rst==Integer.MIN_VALUE/10&amp;&amp;add&lt;-8))return 0; rst = rst*10+add; &#125; return rst;&#125; 319！！！ n个灯泡 n轮开关 重要初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。输入: 3输出: 1解释:初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。被按奇数下的灯泡还亮着。1的因数有1 ，2的因数有1\2 ，3的因数有1\3所以1亮。如果n=4,4有因数1，2，4 亮。当且仅当 a=b*c b和c相等才可能 出现奇数个因数。问题等价于：小于n有多少平方数。123int bulbSwitch(int n) &#123; return sqrt(n);&#125; 451 字符串按频率排序 桶排序Input:“tree” Output:“eert” 123456789101112131415161718192021222324public String frequencySort(String s) &#123; int[] cnt = new int[256]; for(char c:s.toCharArray())&#123; cnt[c]++; &#125; StringBuilder sb = new StringBuilder(); while(true)&#123; int max = 0; int maxc = 1; for(int i = 0;i&lt;256;i++)&#123; if(cnt[i] &gt;max)&#123; max = cnt[i]; maxc = i; &#125; &#125; if(max == 0)break; while(max--&gt;0)&#123; sb.append((char)maxc); &#125; cnt[maxc]=0; &#125; return sb.toString();&#125; Rearrange a stringhttps://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/ NqueenBBN – 1’ in the backslash code is there to ensure that the codes are never negative because we will be using the codes as indices in an array.123456789slash / 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 2 3 4 5 6 7 8 9 3 4 5 6 7 8 9 10 4 5 6 7 8 9 10 11 5 6 7 8 9 10 11 12 6 7 8 9 10 11 12 13 7 8 9 10 11 12 13 14 123456789backslash \ 7 6 5 4 3 2 1 0 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 10 9 8 7 6 5 4 3 11 10 9 8 7 6 5 4 12 11 10 9 8 7 6 5 13 12 11 10 9 8 7 6 14 13 12 11 10 9 8 7 123456for (int r = 0; r &lt;N ; r++) &#123; for (int c = 0; c &lt;N ; c++) &#123; slashCode[r][c]=r+c; backslashCode[r][c]=r-c+(N-1); &#125;&#125; bb 5ms 78%123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int[][] slashCode, backslashCode;//记录这个code是不是已经占用了boolean[] rowocc;boolean[] slashocc,backslashocc;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; rst = new ArrayList&lt;&gt;(); int[][] board = new int[n][n]; slashCode = new int[n][n]; backslashCode = new int[n][n]; rowocc = new boolean[n]; slashocc = new boolean[2*n-1]; backslashocc = new boolean[2*n-1]; for (int r = 0; r &lt;n ; r++) &#123; for (int c = 0; c &lt;n ; c++) &#123; slashCode[r][c]=r+c; backslashCode[r][c]=r-c+(n-1); &#125; &#125; nqueen(rst,0,n,board); return rst;&#125;private List&lt;String&gt; addBoard(int[][] board)&#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); for(int[] row:board)&#123; StringBuilder sb = new StringBuilder(); for(int i:row)&#123; sb.append((i==0?".":"Q")); &#125; rst.add(sb.toString()); &#125; return rst;&#125;boolean isSafe(int[][] board,int row, int col)&#123; if (slashocc[slashCode[row][col]] || backslashocc[backslashCode[row][col]] || rowocc[row]) return false; return true;&#125;private void nqueen(List&lt;List&lt;String&gt;&gt; rst,int col,int n,int[][] board)&#123; if(col&gt;=n)&#123; rst.add(addBoard(board)); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(isSafe(board,i,col))&#123; board[i][col] = 1; rowocc[i] = true; slashocc[slashCode[i][col]] = true; backslashocc[backslashCode[i][col]] = true; nqueen(rst,col+1,n,board); rowocc[i] = false; slashocc[slashCode[i][col]] = false; backslashocc[backslashCode[i][col]] = false; board[i][col] =0; &#125; &#125;&#125; check whether slash code ( j + i ) or backslash code ( j – i + 7 ) are used (keep two arrays that will tell us which diagonals are occupied). 179 一组非负数，拼接成最大的正整数 (cd)Input: [10,2]Output: “210” 12345678910111213141516public String largestNumber(int[] nums) &#123; if(nums==null||nums.length&lt;1)return ""; String[] strs = new String[nums.length]; //变成String数组 for (int i = 0; i &lt;nums.length ; i++) &#123; strs[i] = String.valueOf(nums[i]); &#125; //关键 Arrays.sort(strs,(a,b)-&gt;(b+a).compareTo(a+b)); if(strs[0].equals("0"))return "0"; StringBuilder sb = new StringBuilder(); for(String str:strs)&#123; sb.append(str); &#125; return sb.toString();&#125; 402 去掉数字串中k个数字留下最小的数字Input: num = “1432219”, k = 3Output: “1219”找最小数字：从高位，越高位越小的数。算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉用栈，下一个位置比栈顶小，则把栈顶换掉。注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。1234567891011num="1234567890";k=9;for(int i =0;i&lt;len;i++)&#123; // len=10,k=9 但是0比所有前9个都小，则while(top!=0&amp;&amp;num.charAt(i)&lt;stack[top-1]&amp;&amp;k&gt;0)&#123; top--; k--; &#125; //0覆盖掉1 之后截取stack中len-k=1长度并且去掉0 stack[top++]=num.charAt(i);&#125; 567 s1的一种排列是否在s2中Input:s1 = “ab” s2 = “eidbaooo”Output:True 正确方法22ms：频率数组在s2中滑动 直到有一个窗口可以把s1全置0123456789101112131415161718192021222324public boolean checkInclusion(String s1, String s2) &#123; if(s1.length() &gt; s2.length())return false; int[] cnt = new int[26]; for(int i = 0;i&lt;s1.length();i++)&#123; char c = s1.charAt(i); char c2 = s2.charAt(i); cnt[c - 'a'] ++; cnt[c2 - 'a'] --; &#125; if(allzero(cnt))return true; for (int i = s1.length(); i &lt;s2.length(); i++) &#123; cnt[ s2.charAt(i) - 'a'] --; cnt[ s2.charAt(i - s1.length()) - 'a']++; if(allzero(cnt))return true; &#125; return false;&#125;private boolean allzero(int[] cnt)&#123; for(int t : cnt)&#123; if(t !=0) return false; &#125; return true;&#125; 129ms从s2中取每个s1长度的substring 统计字符频率，和s1的频率相等。123456789101112131415161718192021222324252627public boolean checkInclusion(String s1, String s2) &#123; int[] s1cnt = new int[26]; for(char c : s1.toCharArray())&#123; s1cnt[c - 'a'] ++; &#125; for (int i = 0; i &lt;s2.length()-s1.length()+1 ; i++) &#123; String s2tmp = s2.substring(i, i + s1.length()); if(cntmatch(s1cnt, s2tmp))&#123; return true; &#125; &#125; return false; &#125; boolean cntmatch(int[] s1cnt,String s2)&#123; int[] s2cnt = new int[26]; for(char c : s2.toCharArray())&#123; int idx = c - 'a'; s2cnt[idx] ++; if(s2cnt[idx] &gt; s1cnt[idx])return false; &#125; for (int i = 0; i &lt;26 ; i++) &#123; if(s2cnt[i] != s1cnt[i])return false; &#125; return true; &#125; 1078ms的排序：从s2中取每个s1长度的substring排序，和s1的排序相等。展开代码 123456789101112131415public boolean checkInclusion(String s1, String s2) &#123; s1 = sort(s1); for (int i = 0; i &lt;s2.length()-s1.length()+1 ; i++) &#123; if(s1.equals(sort(s2.substring(i,i+s1.length() ))))&#123; return true; &#125; &#125; return false;&#125;String sort(String s1)&#123; char[] s11 = s1.toCharArray(); Arrays.sort(s11); s1 = new String(s11); return s1;&#125; 超时的全排列展开代码 1234567891011121314151617181920212223boolean flag = false;public boolean checkInclusion(String s1, String s2) &#123; permute(s1, s2, 0); return flag;&#125;void permute(String s1, String s2, int idx) &#123; if (idx == s1.length()) &#123; if (s2.indexOf(s1) &gt;= 0) flag = true; &#125; else &#123; char[] chars = s1.toCharArray(); for (int i = idx; i &lt; s1.length(); i++) &#123; char tmp = chars[i]; chars[i] = chars[idx]; chars[idx] = tmp; String news = new String(chars); permute(news, s2, idx + 1); chars[idx] =chars[i]; chars[i] = tmp; &#125; &#125;&#125; pdd 数组中找三个数乘积的最大值3 4 1 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package niuke.pdd;import java.util.Scanner;public class chenji &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long[] nums = new long[n]; for (int i = 0; i &lt;n ; i++) &#123; nums[i] = sc.nextInt(); &#125; if(n == 3)&#123; System.out.println(nums[0] * nums[1] * nums[2]); &#125;else&#123; long max1 = Long.MIN_VALUE; long max2 = Long.MIN_VALUE; long max3 = Long.MIN_VALUE; long min1 = Long.MAX_VALUE; long min2 = Long.MAX_VALUE;// System.out.println(numss.length); for (int i = 0; i &lt;n ; i++) &#123; Long tmp = nums[i];// System.out.println(tmp); if(tmp &gt; max1)&#123; max3 = max2;max2 = max1; max1 = tmp; &#125;else if(tmp &gt; max2)&#123; max3 = max2;max2 = tmp; &#125;else if(tmp &gt; max3)&#123; max3 = tmp; &#125; if(tmp &lt; min1)&#123; min2 = min1;min1 = tmp; &#125;else if(tmp &lt; min2)&#123; min2 = tmp; &#125; &#125; System.out.println(Math.max(min1*min2*max1, max1*max2*max3)); &#125; &#125;&#125; 爱奇艺 平方串 最长公共子序列如果一个字符串S是由两个字符串T连接而成,即S = T + T, 我们就称S叫做平方串,例如””,”aabaab”,”xxxx”都是平方串.输入例子1:frankfurt 输出例子1:4 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str = sc.next(); int n = str.length(); if (n == 0 || n == 1) System.out.println(0); int max = 0; for (int i = 1; i &lt;n-1 ; i++) &#123; int len = LCS(str.substring(0, i),str.substring(i,n)); max = Math.max(max, len); &#125; System.out.println(max*2);&#125;// 最长公共子序列 s长度以i结尾，t到j结尾的最长匹配长度private static int LCS(String s,String t)&#123; int n = s.length(); int m = t.length(); int[][] dp = new int[n+1][m+1]; for (int i = 0; i &lt;n ; i++) &#123; for (int j = 0; j &lt;m ; j++) &#123; if(s.charAt(i)==t.charAt(j))&#123; dp[i+1][j+1] = dp[i][j]+1; &#125;else dp[i+1][j+1] = Math.max(dp[i][j+1],dp[i+1][j]); &#125; &#125; return dp[n][m];&#125; fraction 背包问题Items can be broen down 贪心按value/weight排序 顶点覆盖 最大团：在一个无向图中找出一个点数最多的完全图任务分配问题一般可以在多项式时间内转化成最大流量问题hdu 1813 IDA搜索Iterative Deepening A,tsp最小生成树解TSP这样求得的最优解不超过真正最优解的2倍证明：2-近似算法任何一个哈密顿回路OPT删去一条边就是一个生成树。我们找的是最小生成树T肯定小于哈密顿回路减1条边的生成树长度所以T&lt;OPT所以欧拉回路&lt;2OPT因为抄近路不会增加长度所以MST生成的结果不会超过2OPT 最小权匹配算法MM1.奇数度的顶点一定是偶数个，将偶数个奇数度定点两两配对2.将每个匹配加入最小生成树，每个顶点都变成偶数度，得到欧拉图3.沿着欧拉回路跳过走过的点抄近路 得到哈密顿回路证明：不超过最优解的1.5倍 代价函数：在搜索树结点计算的最大化问题以该节点为根的值（可行解/目标函数）的上界。父节点不小于子节点（最大化问题） 界：到达叶节点得到的最优值 optaPlanner 数学公式定义 随机算法模板2.1 迭代局部搜索 tsp数据集https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/ https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournamentTSPP:tsp with profit（在顶点上）分3种 PTP(profitable tour problem)找到最小 cost-profit 的circuit OP(orienteering problem),也叫selective TSP(STSP)。cost是约束，求不超过cost的最大profit PCTSP（prize-collecting)profit是约束，目的是找到不低于profit的最小cost。 数据：遗传算法：最大效益中國郵差問題 time window on vertex OP VRP 0~3的tspdp解法 频繁元素计算 Misra Gries(MG)算法笛卡尔树链式前向星堆排序不稳定测试：6 5 12 至少都比内置的快展开代码 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; String str="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; String[] words2 = new String[10000]; Random random=new Random(); for (int j= 0; j &lt;words2.length ; j++) &#123; StringBuffer sb=new StringBuffer(); int length = random.nextInt(30); for(int i=0;i&lt;length;i++)&#123; int number=random.nextInt(62); sb.append(str.charAt(number)); &#125; words2[j] = sb.toString(); &#125; String[] word3 = words2.clone(); String[] word4 = words2.clone(); long start = System.currentTimeMillis(); sort(words2, 0,words2.length-1 ,0 ); long end = System.currentTimeMillis(); System.out.println(end-start); long start2 = System.currentTimeMillis(); MSD.sort(word3); long end2 = System.currentTimeMillis(); System.out.println(end2-start2); long start3 = System.currentTimeMillis(); Arrays.sort(word4); long end3 = System.currentTimeMillis(); System.out.println(end3-start3); &#125; 三向快速排序 不稳定取第一位，将所有字符串分成3份展开代码 1234567891011121314151617181920212223242526272829303132public class threewaypart &#123; private static int charAt(String s,int d)&#123; if(s.length()&gt;d)return s.charAt(d); else return -1; &#125; private static void swap(String[] a ,int i,int j)&#123; String tmp = a[i]; a[i]=a[j]; a[j]=tmp; &#125; private static void sort(String[] a,int lo,int hi,int d)&#123; if(hi&lt;=lo)return; int lt = lo,gt = hi; int v = charAt(a[lo],d); int i = lo+1; while (i&lt;=gt)&#123; int t = charAt(a[i],d); if(t&lt;v)swap(a,lt++,i++); else if(t&gt;v)swap(a,i,gt--); else i++; &#125; sort(a,lo,lt-1,d); if(v&gt;=0)sort(a, lt, gt, d+1); sort(a,gt+1,hi , d ); &#125; public static void main(String[] args) &#123; String[] words = &#123;"4PGC938","2iye230","2iye231","3cio720","fds","1","4PGC933","4PGC9382","4PGC9384","4PGC9385","4PGC9387","4PGC9388","4PGC9389"&#125;; sort(words,0 , words.length-1,0 ); System.out.println(Arrays.toString(words)); &#125;&#125; MSD most-significant-digit-first 不用长度相同从左开始一般也是NW复杂度，对于N很大的情况可以达到$Nlog_RN$ASCII的R是256，需要count[258]Unicode需要65536，可能要几小时按第0位分组，对每组递归按第1位分组…n当前前d位都相同的组，组内字符串个数小于15，用插入排序展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class MSD &#123;private static String[] aux;private static int R = 256;private static final int M = 3;private static int charAt(String s,int d)&#123; if(s.length()&gt;d)return s.charAt(d); else return -1;&#125;public static void sort(String[] a)&#123; aux = new String[a.length]; sort(a,0,a.length-1,0);&#125;private static boolean less(String v,String w,int d)&#123; for (int i = d; i &lt;Math.min(v.length(),w.length()) ; i++) &#123; if(v.charAt(i)&lt;w.charAt(i))return true; if(v.charAt(i)&gt;w.charAt(i))return false; &#125; return v.length()&lt;w.length();// return v.substring(d).compareTo(w.substring(d))&lt;0;&#125;private static void sort(String[] a,int lo,int hi,int d)&#123; if(hi&lt;=lo)return; //添加一步阈值，如果a长度太小，直接用插入排序 if(hi&lt;=lo+M)&#123; for (int i = lo; i &lt;=hi ; i++) &#123; for (int j = i; j &gt;lo&amp;&amp;less(a[j],a[j-1],d);j--) &#123; String tmp = a[j]; a[j]=a[j-1]; a[j-1]=tmp; &#125; &#125; return; &#125; //0位留作字符串结尾？ int[] count = new int[R+2 ]; for (int i = lo; i &lt;=hi ; i++) &#123; count[charAt(a[i],d)+2]++; &#125; for (int i = 0; i &lt;R+1 ; i++) &#123; count[i+1]+=count[i]; &#125; for (int i = lo; i &lt;=hi ; i++) &#123; aux[count[charAt(a[i],d)+1]++] = a[i]; &#125; for (int i = lo; i &lt;=hi ; i++) &#123; a[i] =aux[i-lo]; &#125; for (int i = 0; i &lt;R ; i++) &#123; sort(a,lo+count[i],lo+count[i+1]-1,d+1); &#125;&#125;public static void main(String[] args) &#123; String[] words = &#123;"4PGC938","2iye230","2iye231","3cio720","fds","1","4PGC933","4PGC9382","4PGC9384","4PGC9385","4PGC9387","4PGC9388","4PGC9389"&#125;; sort(words); System.out.println(Arrays.toString(words));&#125;&#125; LSD 基数排序radix sort 定长字符串 复杂度WN 低位优先长度相同的字符串，从最后一位开始排序（如何应用到变长字符串？）123456789101112131415161718192021222324public static void sort(String[] a,int w)&#123; int N = a.length; int R = 256; //只初始化一次 String[] aux = new String[N]; for (int d = w-1; d &gt;=0 ; d--) &#123; int[] count = new int[R+1]; for (int i = 0; i &lt;N ; i++) &#123; count[a[i].charAt(d)+1]++; &#125; for (int i = 0; i &lt;R ; i++) &#123; count[i+1]+=count[i]; &#125; for (int i = 0; i &lt;N ; i++) &#123; aux[count[a[i].charAt(d)]++]=a[i]; &#125; for (int i = 0; i &lt; N; i++) &#123; a[i]=aux[i]; &#125; &#125;&#125; key-index count sort键索引计数法 稳定的count:[0, 2, 3, 1, 2, 1, 3]累加cnt[0, 2, 5, 6, 8, 9, 12] 起始索引结果[a, a, b, b, b, c, d, d, e, f, f, f]123456789101112131415161718192021222324252627static int[] count = new int[7];static private int[] countt(String s)&#123; int N = s.length(); for (int i = 0; i &lt;N ; i++) &#123; //关键 +1 count[s.charAt(i)-'a'+1]++; &#125; return count;&#125;static private int[] acu()&#123; for (int i = 0; i &lt; count.length-1; i++) &#123; count[i+1]+=count[i]; &#125; return count;&#125;static private char[] axuu(String s)&#123; char[] axu = new char[s.length()]; for (int i = 0; i &lt; s.length(); i++) &#123; //关键 ++ axu[count[s.charAt(i)-'a']++] = s.charAt(i); &#125; return axu;&#125;System.out.println(Arrays.toString(countt("dacffbdbfbea")));System.out.println(Arrays.toString(acu()));String dacffbdbfbea = Arrays.toString(axuu("dacffbdbfbea")); pdd给定一堆点，判断能连成几个三角形40 00 11 01 1输出 4 思路：遍历所有3个点的组合，只要不是三点共线都行123int a = (x1-x2)*(y1-y3) ;int b = (y1-y2)*(x1-x3);if(a!=b)cnt++; 数组组成三角形的最大周长nlogn贪心，排序，如果 $a[i]&lt;a[i-1]+a[i-2]$ 则没有其他两条边可以两边之和&gt;第三边了，换下一条当最长边。12345678public int maxC(int[] A)&#123; Arrays.sort(A); int n = A.length; for (int i = n-1; i &gt;=2 ; i--) &#123; if(A[i]&lt;A[i-1]+A[i-2])return A[i]+A[i-1]+A[i-2]; &#125; return 0;&#125; MST：将图的点分成2个集合，用边连接两个集合中的点，最小的边集是MST MST和聚类：连通图将图的点分成2个集合，边两端连的是不同集合，最小的边集是MST假设分为6和其它点2个集合，在6-2 3-6 6-0 6-4四条连接两个集合的边中取最小边，标记成黑色。再随机分两个集合，不要让黑色边跨集合 kruskalkruskal遍历所有边(优先队列)，判断边的两点是否在一个集合里(find)，如果在则说明这条边加上会有环，如果不在，则union(v,w)并且将这条边加入mst。直到找到n-1条边。复杂度$ElogE$ 空间E 因为不仅维护优先队列还要union-find所以效率一般比prim慢 primprim复杂度$ElogV$ 空间Vprim优化：将marked[]和emst[] 替换为两个顶点索引数组edgeTo[] 和distTo[]每个没在MST中的顶点只保留(更新)离mst中点最短的边。 聚类：single link Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.两个帅不能处在同一条直线上的所有可行位置1231 2 34 5 67 8 9 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; int i = 81; while(i--)&#123; if(i/9%3==i%9%3)continue; cout&lt;&lt;i/9+1&lt;&lt;" "&lt;&lt;i%9+1&lt;&lt;endl; &#125;&#125; 翻煎饼排序的最少次数164 桶排序找区间最大值求数组的最大gap二分图 让每条边的两个顶点属于不同的集合max match：没有两点共享1点，最多的边数maximal:再加一条边就有两条边有共同顶点了maximum：有两种matching的画法，3条边的为max 室友分配问题不是二分图，因为有3人团，是最大团问题 出租车和乘客匹配问题 问题是求最小边和 分配老师给班级是二分图max match问题 785 是否是二分图1234567输入[0]=&#123;1,3&#125;0的邻点是1,3[[1,3], [0,2], [1,3], [0,2]]The graph looks like this:0----1| || |3----2 不用建图，已经是邻接表了。按算法4上75%还可以优化mark和color为一个数组，用位运算变更状态，变成boolean的dfs123456789101112131415161718boolean[] marked;boolean[] color;boolean isTwo = true;public boolean isBiartie(int[][] graph)&#123; marked = new int[graph.length]; color = new int[graph.length]; for(int s =0;s&lt;graph.length;s++)&#123; if(!marked[s])dfs(graph,s); &#125; return isTwo;&#125;private void dfs(int[][] G,int v)&#123; marked[v]=true; for(int w :G[v])&#123; color[w]=!color[v]; dfs(G,w); &#125;else if(color[w]==color[v])isTwo=false;&#125; 改成boolean的dfs-&gt;100%12345678910111213141516171819202122boolean[] marked;boolean[] color;public boolean isBipartite(int[][] graph) &#123; marked = new boolean[graph.length]; color = new boolean[graph.length]; for (int s = 0; s &lt;graph.length ; s++) &#123; if(!marked[s]&amp;&amp;!dfs(graph,s))return false; &#125; return true;&#125;private boolean dfs(int[][] graph,int v)&#123; marked[v]=true; for(int w:graph[v])&#123; //*关键 if(!marked[w])&#123; color[w]=!color[v]; if(!dfs(graph,w))return false; &#125; else if(color[w]==color[v])return false; &#125; return true;&#125; 886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人边集-&gt;邻接表-&gt;二分图 边集-&gt;邻接矩阵-&gt;二分图dfs染色12345678910111213141516171819202122232425262728public boolean possibleBiparitition(int N,int[][] dislikes)&#123; int[][] graph = new int[N][N]; //边集-&gt;无向图 邻接矩阵 for(int[] d:dislikes)&#123; graph[d[0]-1][d[1]-1] = 1; graph[d[1]-1][d[0]-1] = 1; &#125; int[] group = new int[N]; for (int i = 0; i &lt; N; i++) &#123; if(group[i] == 0&amp;&amp; !dfs2d(graph,group,i,1))return false; &#125; return true;&#125;//可不可以分到g组private boolean dfs2d(int[][] graph,int[] group,int idx,int g)&#123; group[idx] = g; //行是邻边 for (int i = 0; i &lt; graph.length; i++) &#123; if(graph[idx][i] == 1)&#123; if(group[i] == g)&#123; return false; &#125; if(group[i] == 0&amp;&amp;!dfs2d(graph,group,i,-g))return false; &#125; &#125; return true;&#125; 图的度1.顶点v的度1234567public static int degree(Map&lt;Integer,List&lt;Integer&gt;&gt; graph,int v)&#123; int degree = 0; for(int w :graph.get(v))&#123; degree++; &#125; return degree;&#125; 2.所有顶点的最大度1234567public static int maxDegree(Map&lt;Integer,List&lt;Integer&gt;&gt; graph)&#123; int max = 0; for(int v:graph.keySet())&#123; max = Math.max(degree(graph,v ),max); &#125; return max;&#125; 3. 图的遍历顺序展开代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DepthFirstOrder &#123; private boolean[] marked; private List&lt;Integer&gt; pre; private List&lt;Integer&gt; post; private Deque&lt;Integer&gt; reversePost; public DepthFirstOrder(int n,int[][] edges)&#123; List&lt;Integer&gt;[] graph = new ArrayList[n]; for (int i = 0; i &lt;n ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int[] edge:edges)&#123; graph[edge[0]].add(edge[1]); &#125; marked = new boolean[n]; pre = new ArrayList&lt;&gt;(); post = new ArrayList&lt;&gt;(); reversePost = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt;n ; i++) &#123; if(!marked[i])dfs(graph,i); &#125; &#125; private void dfs( List&lt;Integer&gt;[] graph ,int v)&#123; pre.add(v); marked[v] = true; for(int w :graph[v])&#123; if(!marked[w]) dfs(graph,w); &#125; post.add(v); reversePost.push(v); &#125;/*[0, 1, 5, 4, 6, 9, 10, 11, 12, 2, 3, 7, 8][1, 4, 5, 10, 12, 11, 9, 6, 0, 3, 2, 7, 8][8, 7, 2, 3, 0, 6, 9, 11, 12, 10, 5, 4, 1]*/ public static void main(String[] args) &#123; DepthFirstOrder sl = new DepthFirstOrder(13,new int[][]&#123;&#123;0,1&#125;,&#123;0,5&#125;,&#123;0,6&#125;,&#123;2,0&#125;,&#123;2,3&#125;,&#123;3,5&#125;,&#123;5,4&#125;,&#123;6,4&#125;,&#123;6,9&#125;,&#123;7,6&#125;,&#123;8,7&#125;,&#123;9,10&#125;,&#123;9,11&#125;,&#123;9,12&#125;,&#123;11,12&#125;&#125;); System.out.println(sl.pre); System.out.println(sl.post); System.out.println(sl.reversePost); &#125;&#125; 调度问题：给定一组任务，安排执行时间-&gt;拓扑排序DAG的拓扑排序是dfs逆后排序将一张图拉成边全部向下的图 拓扑排序：有向环 {0, 3}, {1, 3}, {3, 2}, {2, 1} 0-&gt; 3-&gt;2-&gt;1-&gt;3 展开代码 12345678910111213141516171819202122232425262728293031323334353637383940414243//算法4 p386private boolean[] marked;private int[] edgeTo;private Deque&lt;Integer&gt; cycle;//环private boolean[] onStack;public Deque cycle(int numCourses, int[][] prerequisites) &#123; onStack = new boolean[numCourses]; edgeTo = new int[numCourses]; marked =new boolean[numCourses]; List&lt;Integer&gt;[] graph=new ArrayList[numCourses]; for (int i = 0; i &lt;numCourses ; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for (int[] edge :prerequisites) &#123; graph[edge[0]].add(edge[1]); &#125; System.out.println(Arrays.toString(graph)); for (int i = 0; i &lt; numCourses; i++) &#123; if(!marked[i])dfs(graph,i); &#125; return cycle;&#125;private void dfs(List&lt;Integer&gt;[] graph,int v)&#123; onStack[v] =true; marked[v] =true; if(graph[v].size()&lt;1)return; for(int w:graph[v])&#123; if(cycle!=null) return; else if(!marked[w])&#123; edgeTo[w] = v; dfs(graph,w); &#125; else if(onStack[w])&#123; cycle = new ArrayDeque&lt;&gt;(); for (int x = v; x !=w ; x=edgeTo[x]) &#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v] =false;&#125; 62 从左上角走到右下角总共有多少种不同方式f[m][n] = f[m-1][n]+f[m][n-1]简化成一维dp1234567891011public int uniPath(int m,int n)&#123; int[] res = new int[n]; for(int i =0;i&lt;m;i++)&#123; //一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法 for(int j =1;j&lt;n;j++)&#123; //加上左边走过来的走法 res[j]+=res[j-1]; &#125; &#125; return res[n-1];&#125; !数学公式m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。$C_{m+n-2}^{m-1}$12345long rst=1;for(int i =0;i&lt;Math.min(m-1,n-1);i++)&#123; rst=rst*(m+n-2-i)/(i+1);&#125;return (int)rst; 63 有障碍物的左上到右下dp[i][j]定义为走到i,j的方法数，障碍物则为01if(obs[i][j]==1)continue;//dp[i][j]=0//res[j]=0; 64 从左上角走到右下角的最少sumgrid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]); 本福特定律以1为首位的数字的概率为30% 节点是随机变量的有向无环图=贝叶斯网络BN求联合概率会用到最小生成树 求进制 如果$84*148=B6A8$成立，则公式采用的是__进制表示的$(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8$$=&gt;(3x^2+6x+2)(x-12)=0$$=&gt;x=12$ 快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数24表示在这种进制下个位应该为0 假设在n进制下,下面的等式成立,n值是()240*12=2880正确答案: F 你的答案: E (错误)1918171615以上都对 逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A DLS可以达到BFS一样空间的DFS 后缀树字典树 每层多一个字符的字典树后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)后缀数组 A[]后缀的起始位置//Memory Limit Exceeded12345678910private final String[] suffixes;private final int N;public SuffixArray(String s)&#123; N = s.length(); suffixes = new String[N]; for (int i = 0; i &lt; N; i++) &#123; suffixes[i] = s.substring(i); &#125; Arrays.sort(suffixes);&#125; “alohomora”1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀 [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra A[i]的i是字典序的i，值是真实位置 例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8); 生成后缀数组Manber-Myers O(n)但是太复杂 排序后缀目录：桶排序 Aho-Corasick1添加失败链接2缝衣针字符串序号数组 ?347桶排序 int数组中最常出现的n个桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。99%不用map，遍历一次找到max和min 建len = max-min+1的数组计数展开代码 123456789101112131415161718192021222324252627282930313233public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; rst = new ArrayList&lt;&gt;(); if(nums.length == 0) return rst; int min = Integer.MAX_VALUE,max = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &lt; min)min = nums[i]; if(nums[i] &gt;max) max = nums[i]; &#125; int[] data = new int[max-min + 1]; for (int i = 0; i &lt;nums.length ; i++) &#123; data[nums[i] - min]++; &#125; List&lt;Integer&gt;[] bucket = new ArrayList[nums.length+1]; for(int i = 0;i&lt;data.length;i++)&#123; if(data[i]&gt; 0)&#123; if(bucket[data[i]]== null)&#123; bucket[data[i]] = new ArrayList&lt;Integer&gt;(); bucket[data[i]].add(i+min); &#125;else&#123; bucket[data[i]].add(i+min); &#125; &#125; &#125; for(int i =nums.length;i&gt;0;i--)&#123; if(k&lt;=0)return rst; if(bucket[i]!=null)&#123; rst.addAll(bucket[i]); k-=bucket[i].size(); &#125; &#125; return rst;&#125; 用map AC34% 优先队列O(nlogk)如果k和n的数量差不多 还能维护一个(n-k)的堆 复杂度变成nlog(n-k) 238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法left数组：自己左边数的乘积[1,1,2,6]right数组:自己右边的乘积（包括自己）[24,12,4,1]left和right对应位置相乘不用extra space12345678910res[0]=1;for(1 to n-1)&#123; res[i]=res[i-1]*nums[i-1];&#125;int right=1;for(n-1 to 0)&#123; res[i]*right; right*=nums[i];&#125;return res; 371 不用’+’用位运算完成求和123456public int getSum(int a, int b) &#123; int rst = a^b;//0^0=0,0^1=1,1^1=0 int carry = (a&amp;b)&lt;&lt;1;//当ab相等的时候需要进位 //a+b=（a xor b）+ （(a and b) &lt;&lt; 1） if(carry!=0)return getSum(rst,carry); return rst;&#125; 412 遇到3||5和3&amp;5的倍数变成特定字符不用%最快方法!对于CPU取余数的运算相对来说效率很低1234567891011121314151617for(int i=1,fizz=0,buzz=0;i&lt;=n ;i++)&#123; fizz++; buzz++; if(fizz==3 &amp;&amp; buzz==5)&#123; ret.add("FizzBuzz"); fizz=0; buzz=0; &#125;else if(fizz==3)&#123; ret.add("Fizz"); fizz=0; &#125;else if(buzz==5)&#123; ret.add("Buzz"); buzz=0; &#125;else&#123; ret.add(String.valueOf(i)); &#125; &#125; 2-3树10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间 红黑树：将3-结点变成左二叉树，将2-3变成二叉树有二叉树高效查找和2-3树高效平衡插入红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$ 插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转） 160 链表相交于哪一点12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val思路2：将a,b连成m+n长的链表遍历两遍12345a1 → a2 c1 → c2 → c3 -null- b1 → b2 → b3 c1 → c2 → c3 // ↘ // c1 → c2 → c3 // ↗ b1 → b2 → b3 c1 → c2 → c3 -null- a1 → a2 c1 → c2 → c3 展开代码 123456789101112public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null)return null; ListNode a = headA; ListNode b = headB; while(a!=b)&#123; if(a==null)&#123;a=headB;&#125;else&#123;a=a.next;&#125; if(b==null)&#123;b=headA;&#125;else&#123;b=b.next;&#125; &#125; return a; &#125;&#125; 168 lt13501 -&gt; A2 -&gt; B3 -&gt; C…26 -&gt; Z27 -&gt; AA28 -&gt; AB递归26进制123 public String convertToTitle(int n) &#123; return n == 0 ? "" : convertToTitle(--n / 26) + (char)('A' + (n % 26));&#125; 88%1234567StringBuilder sb = new StringBuilder();while (n!=0)&#123; --n; sb.insert(0,(char)(n%26+'A' )); n/=26;&#125;return sb.toString(); 1. 爬山：局部贪心，快速找到可行解，局部最优 8数码:启发函数：当前状态和目标状态的距离：错位方块个数。 深度优先 每次将当前节点S的子节点按启发式函数由大到小压入栈 8数码BFS优先队列展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void swap(int[][] matrix,int x,int y,int newX,int newY)&#123; int tmp = matrix[x][y]; matrix[x][y] = matrix[newX][newY]; matrix[newX][newY] = tmp;&#125;void printPath(Node root)&#123; if(root == null)return; printPath(root.parent); print2D(root.mat); System.out.println();&#125;Node createNode(int[][] matrix,int x,int y,int newX,int newY,int level,Node parent)&#123; Node node = new Node(); node.parent = parent; node.mat = new int[matrix.length][]; for (int i = 0; i &lt; matrix.length; i++) &#123; node.mat[i] = matrix[i].clone(); &#125; swap(node.mat,x ,y , newX,newY); node.cost = Integer.MAX_VALUE; node.x = newX; node.y = newY; return node;&#125;void slove(int[][] from,int x,int y,int[][] end)&#123; //扩展距离小的 PriorityQueue&lt;Node&gt; que = new PriorityQueue&lt;&gt;( Comparator.comparingInt(node -&gt; (node.cost + node.level)) ); Node root = createNode(from,x ,y ,x ,y ,0 , null); root.cost = calCost(from,end ); que.add(root); while(!que.isEmpty())&#123; Node min = que.poll(); //结果，从子节点向上递归打印 if(min.cost==0) &#123; printPath(min); return; &#125; //4个方向挪动白块四个方向为什么不会重复状态死循环 for (int i = 0; i &lt; 4; i++) &#123; if(isInBoard(min.x+row[i],min.y+col[i]))&#123; Node child = createNode(min.mat,min.x ,min.y , min.x+row[i], min.y+col[i], min.level+1, min); child.cost = calCost(child.mat,end ); que.add(child); &#125; &#125; &#125;&#125; Best-First搜索：全局最优贪心 当前所有可扩展节点中启发函数最优点 用堆 分支界限：组合优化 多阶段图搜索：最短路径 爬山与BF算法得到最优解都需要遍历整个空间 用爬山生成界限(可行解or最优解的上限) Rabin-KarpO(MN) 1. 枚举： 小于N的完美立方 $a^3=b^3+c^3+d^3$ 按a的值从小到大输出a&gt;b&gt;c&gt;d a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1] 熄灯问题(deng.java) 按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4给定每盏灯的初始状态，求按钮方案，使灯全熄灭输入 01矩阵 输出 01矩阵一个按钮按两次及以上是无意义的，按钮次序无关{0,1,1,0,1,0},{1,0,0,1,1,1},{0,0,1,0,0,1},{1,0,0,1,0,1},{0,1,1,1,0,0} 枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数） 只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按 一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1] 一个bit异或1 反转1^1-&gt;0反转0^1-&gt;1反转； j位 置1 |=(1&lt;&lt;j) j位 置0 &amp;=~(1&lt;&lt;j) 取第j 位的值 &gt;&gt;j&amp;1 主循环：1.遍历第一行开关状态 2.每次换第一行重置原来灯状态lighting[]=输入 3.对每一行，每一个灯，按switch更新lighting 123456for (int j = 0;j&lt;6;j++)&#123; if(getBit(result,i,j)==1)&#123;if(j&gt;0)FlipBit(lights,i,j-1);FlipBit(lights,i,j);if(j&lt;5)FlipBit(lights,i,j+1);&#125;&#125;if(i&lt;4)&#123;lights[i+1]^= switchs;&#125; &gt; 4.更新开关，下一行开关为上一行还亮着灯的位置回3 &gt; 5.当lighting最后一行为0，结束 递归 汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2) A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c) 再将B上n-1个移动到C，用A中转 回到0 A上n-2个移动到C，用B中转 n皇后 递归代替多重循环 654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树stack：[3,2,1,6,0,5]1.栈底是数组最大值，即树根1234567891011123left-&gt; right-&gt;2-&gt;1 stack:3,2,1将栈里比cur小的右链变成当前最大值的左链，pop所有比6小的元素6left-&gt;3 -&gt;right-&gt;2-&gt;1 stack：66left-&gt;3 right-&gt;0 stack:6,05left-&gt;0,6right-&gt;56-&gt;left-&gt;3 -&gt;right-&gt;2-&gt;1 -&gt;right-&gt;5 -&gt;left-&gt;0 68%1234567891011Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();for(int i =0;i&lt;nums.length;i++)&#123; TreeNode cur = nums[i]; while(!stack.isEmpty()&amp;&amp;stack.peek().val&lt;cur.val)&#123; cur.left = stack.pop(); &#125; if(!stack.isEmpty()) stack.peek().right=cur; stack.push(cur); &#125;return stack.isEmpty()?null:stack.removeLast(); 递归95% 递归熟练 11ms123456789101112build(nums,0,nums.length-1);private TreeNode build(int[] nums,int start,int end)&#123; if(start&gt;end)return null; int max = start; for(int i =start+1;i&lt;=end;i++)&#123; max = nums[] &#125; TreeNode root = new TreeNode(nums[max]); root.left = build(nums,start,max-1); root.right = build(nums,max+1,end); return root;&#125;]]></content>
      <categories>
        <category>算法备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busyman Notes]]></title>
    <url>%2F2018%2F03%2F21%2Fbusyman%2F</url>
    <content type="text"><![CDATA[signature???方法签名就由方法名+形参列表构成 并行 计算很长数组的总和1long sum = IntStream.of(a).parallel().sum(); Stream 统计一本书中的长单词 \PL 拆分单词 12String contents = new String(Files.readAllBytes(Paths.get(""),StandardCharsets.UTF_8));List&lt;String&gt; words = Arrays.asList(contents.split("\PL+")); stream代替迭代 12long count = aaa.stream().filter(w-&gt;w.length()&gt;12).count();System.out.println(count); 所有单词转换成小写 1Stream&lt;String&gt; lower = words.stream().map(String::toLowerCase); 每个单词的第一个字母 1Stream&lt;String&gt; first = words.stream().map(s-&gt;s.substring(0,1)); 创建流 集合-&gt;流：Collection.stream() 数组-&gt;流：Stream.of Arrays.stream(array,from,to) 方法 Stream&lt;Stream&lt;String&gt;&gt;用.flatMap(lambda) .limit(int)前int N个元素；.skip(n)丢弃前n个元素；.concat(stream,stream)拼接流 .distinct()删除重复元素 Optional防止空指针引用，对null封装默认值 收集 toArray stream.collect(Collectors.toList/toSet/toCollection(TreeSet::new)) 收集一个国家的语言Map&lt;String,List&lt;Local&gt;&gt;&#39;处理相同键 分类函数：.collect(Collectors.groupingBy(Local::getCountry)) 当分类函数是布尔值.partitioningBy(l-&gt;l.getLanguage().equal(&quot;en&quot;)); groupingBy可以针对List&lt;Local&gt;加下游收集器参数toSet()等 求一个流所有字符串总长度,reduce要求(T,T)-&gt;T返回值和参数 类型一样累加器函数：(total,word)-&gt;total+word reduce并行所以最后total要汇总（注意线程安全）12int result = aaa.stream().reduce(0,(total,word)-&gt;total+word.length(), (total1,total2)-&gt;total1+total2); 映射到一个数字流1int m2i=aaa.stream().mapToInt(String::length).sum(); 避免装箱，基本类型流 byte\short\char\boolean使用IntStream.of(1,2,3,4)和Arrays.stream 并行流 不能使用paralineStream.forEach forEach中的函数会在多个线程中并发执行，更新共享的数组 按长度将字符串进行分组并计数123Map&lt;Integer,Long&gt; shortWordCount = aaa.parallelStream() .filter(s-&gt;s.length()&lt;10) .collect(groupingBy(String::length,counting())); 并发收集123Map&lt;Integer,List&lt;String&gt;&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length)); 值是次数123Map&lt;Integer,Long&gt; result = aaa.parallelStream() .collect(Collectors .groupingByConcurrent(String::length,counting())); Properities12345Properties st = new Properties();st.put("",);try(OutputStream out = Files.newOutputStream(path))&#123; st.store(out,"name");&#125; EnumSetEnumSet没有公共构造函数，使用静态工厂方法构造EnumSet：12enum Weekday&#123;MONDAY&#125;;Set&lt;Weekday&gt; alwarys = EnumSet.allof(Weekday.class); EnumMap指定[键]类型1EnumMap&lt;Weekday,String&gt; personInChange = new EnumMap&lt;&gt;(Weekday.class); BitSet用户标识位序列 第i个位置位1表示i在集合内栈、队列等 栈没有Stack接口，有Stack类，避免使用。使用ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); 优先队列和作业调度PriorityQueue&lt;Job&gt; jobs = new PriorityQueue&lt;&gt;();容纳实现了Comparable的类 WeakHashMap:当键的唯一引用来自哈希表条目，删除键/值 视图 KeySet、values、asList方法生成视图 范围range 任何子列表的添加删除都会影响原先列表 12List&lt;String&gt; st = ;List&lt;String&gt; nextfive = st.subList(5,10); 有序集合通过上下界 输出[1,2] 1234 TreeSet&lt;String&gt; words = new TreeSet&lt;&gt;();words.addAll(Arrays.asList(new String[]&#123;"1","2","3","4","5","6"&#125;));SortedSet&lt;String&gt; asOnly = words.subSet("1","3");System.out.println(asOnly); 轻量级创建map类型的属性12Collections.emptyMap()System.out.println(Collections.singletonMap("id","222")); 检查视图，检查错误类型（堆污染）,监视ArrayList 1List&lt;String&gt; strings = Collections.checkedList(new ArrayList&lt;&gt;(),String.class); 不要使用Collections的同步视图，并发使用util.concurrent的数据结构 迭代器Iterator&lt;String&gt; iter= coll.iterator() coll.removeIf(e-&gt;e fulfill the condition iter.remove()移除最后一个访问的元素，不是指向元素，不能两次连用remove 异常 已检查错误：可提前预知 IOException。Integer.parseInt(str)检查str是否是整数是可能的 覆盖方法时，不能抛出比父类方法中声明更多的已检查异常 @throws异常注释文档化 实现了AutoCloseable/Closeable的类 try(PrintWriter out = new PrintWriter(&quot;out.txt&quot;){}保证了out.close()必会调用，替换finally{in.close()}因为close可能异常 ·ex.getSuppressed()捕获了主要异常时检测得到第二个异常 可以catch到已检查异常后连接到未检查异常 检测非空值123public void process(String directions)&#123; this.directions = Object.requireNonNull(directions,"空指针");&#125; 会抛出空指针异常 Logger代替print：7种级别默认会记录INFO及更高级别。CONFIG/FINE/FINER.FINEST对用户无意义12Logger.getGlobal().info(()-&gt;ex.getMessage());Logger logger = Logger.getLogger("com.Logger"); log输出到文件用户文件夹下javan.log12FileHandler handler = new FileHandler();logger.addHandler(handler); 未检查：逻辑错误：NullPointerExcepterClass.forName(str)不可能知道类能否成功加载。 接口 要使用子类的方法，强制cast，先检查类型 123if (a instanceof B)&#123; B b = (B)a;&#125; Collection/AbstractCollection/Collections,Path/Paths default Stream stream() 接口中添加了，为了保持兼容以前版本，写了默认方法 Comparable 接口 返回不一定是1,-1,0； 当两个大负数相减可能变正，用Integer.compare() 浮点数 Double.compare() Arrays.sort()可以对Comparable对象数组进行排序 Comparator 接口不能更改String的compareTO,创建一个Comparator实现类。 创建Comparator comp 对象=new 实现了接口的对象(); 在Comparator对象上调用.compare(,) compare方法不是静态方法！ （？？？） Arrays.sort(obj,new Comparatorobj) Runable 接口 A implements Runnable{run(){}} new Thread(A).start UI回调 EventHandler lambda表达式 带有自由变量值的代码块是闭包。捕获闭合作用域中变量值 lambda中只能引用值不变的量，不能捕获变量，也不能改变 123for(int i =0;i&lt;n;i++)&#123; new Thread( ()-&gt; sout(i) ).start(); //报错&#125; for(Sting arg:args)中的变量是final的，作用域是单个迭代 可以捕获；每个底碟会创建新的arg变量；for(i)的作用域是整个循环。 只有一个抽象方法的接口对象，函数式接口 将lambda表达式放入类型为函数式接口的变量中，转化成接口的实例 ArrayList removeIf(Predictae) //e-&gt;e==nullremoveIf(Object::isNull)123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; 函数式接口@FunctionalInterface 单个方法的接口 高阶函数：返回函数的函数1. Comparator `public static &lt;T, U&gt; Comparator comparing(Function&lt;? super T, ? extends U&gt; keyExtractor, Comparator&lt;? super U&gt; keyComparator)` key提取器将类型T映射到可比较的类型 comparingDouble避免装箱 nullsLast`nullsFirst`避免null抛出异常 naturalOrder()适合实现了Comparable的类 thenComparing 局部内部类，实现接口的类。 方法中的类，可以接受方法中的值，不需要构造函数和存储在实例变量中。 匿名 继承和反射 代理对象实现接口，将所有方法路由到一个handler super() 因为子类不能访问父类的私有变量，所有要通过父类的构造函数初始化。]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库锁]]></title>
    <url>%2F2018%2F03%2F16%2FDDB%2F</url>
    <content type="text"><![CDATA[on duplicate key update如果存在则更新,如果不存在则新增 完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞下面有关事务隔离级别说法正确的是?正确答案: A B C D 你的答案: B C D (错误)A串行读(Serializable):完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞B未提交读(Read Uncommitted):允许脏读,也就是可能读取到其他会话中未提交事务修改 的数据C提交读(Read Committed):只能读取到已经提交的数据D可重复读(Repeated Read):在同一个事务内的查询都是事务开始时刻一致的 where 子句中不能出现聚合函数（列函数）以下哪个函数不能直接出现在SQL的WHERE子句中正确答案: A B 你的答案: C (错误)A.SUMB.COUNTC.ORDER BYD.LIMIT聚集函数也叫列函数，它们都是基于整列数据进行计算的，而where子句则是对数据行进行过滤的。sql语句的执行顺序为 from子句 where 子句 group by 子句 having 子句 order by 子句 select 子句 关系型数据库和对象表和类关联行和对象关联字段和属性关联 B+树数据库中，B+树的高度一般在2到3层。也就是说查找某一键值的记录，最多只需要2到3次IO开销。按磁盘每秒100次IO来计算，查询时间只需0.0.2到0.03秒 不确定：100w个Integer B+树需要多少层 inodb后台AIO 线程数12345678mysql&gt; show variables like 'innodb_%io_threads'\G*************************** 1. row ***************************Variable_name: innodb_read_io_threads Value: 4*************************** 2. row ***************************Variable_name: innodb_write_io_threads Value: 42 rows in set, 1 warning (0.01 sec) 读线程id小于写线程id12345678910111213mysql&gt; show engine innodb status\G;FILE I/O--------I/O thread 0 state: wait Windows aio (insert buffer thread)I/O thread 1 state: wait Windows aio (log thread)I/O thread 2 state: wait Windows aio (read thread)I/O thread 3 state: wait Windows aio (read thread)I/O thread 4 state: wait Windows aio (read thread)I/O thread 5 state: wait Windows aio (read thread)I/O thread 6 state: wait Windows aio (write thread)I/O thread 7 state: wait Windows aio (write thread)I/O thread 8 state: wait Windows aio (write thread)I/O thread 9 state: wait Windows aio (write thread) 磁盘最小单位扇区512字节文件系统最小单位 块 4kInnoDB最小单元 页 16k指针大小在6字节都是16的整数倍1234567mysql&gt; show variables like 'innodb_page_size';+------------------+-------+| Variable_name | Value |+------------------+-------+| innodb_page_size | 16384 |+------------------+-------+1 row in set, 1 warning (0.00 sec) 单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。 那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。 根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170117016=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。 隔离级别是对一致性的破坏。事务之间的Happen-before关系：4种 【读写，写读，读读】，写写 排他锁 排队：序列化读写 不需要冲突控制，无死锁 排他锁：用n个队列，发生共享数据冲突就并行，不然就串行。对数据加锁，只允许一个线程访问。 读写锁：读写分离。读可以并行（可重复读），写写、写读、读写依然串行。对于读多写少的应用性能提升并行度。针对读读、读写优化。 读写锁的第二种（读已提交，不可重复读）：实现读后写并行。读锁可以被写锁升级。读锁-&gt;写锁。 写读还不能并行。死锁：读写：事务1申请A的读锁，事务2也加读锁并行读A。当事务1想把A升级成写锁需要等2释放读锁。反过来2要等1释放读锁。Update set A=A-1 where id=100先读查where再写会死锁U锁：先判断事务中的写操作，申请锁时把原来的读锁改写锁。事务2想要先read再update写A的时候就等待。 读写锁第三种（读未提交）：把读锁去掉，读不加锁。写后读并行，写后的读可提前。但是可能会读到读的中间状态。 mvcc多版本并发控制 本质：copy on write。每次写都是写一个新的数据，写在log里，不是原地更新。针对写读场景优化，例如：当前数据版本号v10,读版本号v5则去log里找v5的数据。在写操作加锁时，依然可以并发读。现在主流做法：实现写读、读读、读写不冲突。当写&gt;读 记录的日志很多 会增加延迟。 减小锁的覆盖范围：原地锁-&gt;MVCC多版本锁增加锁上可并行的线程数：读写分离 有的数据库不能支持大事务原因在于写读冲突，读在外面等待。 隔离性的扩展：SNAPSHOT 快照隔离级别：就是mvcc copy on write 无锁编程。 快照读：读事务开始之前的版本。达到读未提交的并行度。保证读到一致性的数据。 悲观锁：数据加锁使线程bloking状态，等到等待的锁ok回到runnable状态。把寄存器的数据换成另一个线程，把缓存清空，cpu的cache清空，增加系统开销。适合并发争抢严重的场景。乐观锁： 持久性延迟：RAID Controller 保证一个操作写两个以上磁盘group commit 组提交 mvcc：读应该读哪一个写之后的数据：逻辑时间戳(保证顺序) 说明事务内单元的先后SCN(Oracle)Trx_id（Innodb) 原子性：记录了undo操作，可以全部成功/失败 故障恢复： 业务属性不匹配：记录事务前的数据锁定bob、smith的账户-&gt;检查bob账户是否有100元-X不满足-&gt;回滚 死锁检测：碰撞检测/等锁超时https://www.cloudera.com/developers/get-started-with-hadoop-tutorial.htmlFragmentation: process of partitioning the database into disjoint fragments, Data allocation, degree of replication 事务(transaction)：对数据库进行读或写的一个操作序列.mysql 中 myisam innodb LVM（逻辑卷） Hash 分片 round robin ：每次新+物理机$hash(key)mod(K+1)$都要重新分配，在线系统缺乏灵活性 将物理机映射和数据分片映射由一个hash函数承担，机器个数K出现在映射函数中，紧耦合。 虚拟桶 virtual buckets:虚拟桶作为数据分片，用hash映射；物理机映射采用表格 3. 一致性哈希：和弦（chord）系统中提出。 哈希长度为5，哈希空间为32，节点映射到环的位置随机) 每个机器节点负责存储一段哈希空间的数据，N14存储6-14的数据；N5存储0-5， 查询 N14接收到查询请求，Hash(key)=27,不在下一个节点20 查找每个机器节点都有的路由表，找到小于27的最大节点N25（前趋） 路由表存储距离$2^k$距离的节点($14+2^3&lt;25&lt;14+2^4$),路由表存储哈希空间长度条路由信息 回1，29返回数据给14 新节点 查找后继 更新前趋，新节点，后继的前趋后继信息 将后继节点s上存储的数据分片迁移到新节点 稳定性检测当有多个新节点插入，新节点的前趋节点置空 加入N8，将N8后继置N14，前趋置空开始稳定性检测 询问后继的前趋指向是N5 不是自己 N5不在N8和N14中间，通知后继修改前趋指向N8 N14中hash6-8的值迁移到N8完成稳定性检测 对前趋N5稳定性检测 N5询问后继的前趋不是自己 ，N8介于自己和N14之间，N5修改后继 完成检测 定期更新路由表 CAP 一致性(多副本对外单副本) 可用性（延迟） 分区容忍性（网络分区现象仍工作）改进：先识别网络分区，网络分区发生时记录每个分区的状态，执行各自操作，当分区恢复，融合产生新状态。P出现时每个分区经可能执行ACID 数据无副本，发生网络分区现象or宕机数据不可访问，不满足P 副本存储在不同机器上： 选择强一致性。数据同步前拒绝读，不能满足A可用信 选择可用性并不是最新数据，不满足C 幂等性：反复执行多次和一次的效果相同。$f(f(x))=f(x)$(取绝对值)$f(x,x) = x$ max(x,x) =x ; a AND a = a 最终一致性:不一致窗口 一致性协议脏读对象存储？？？ 大数据日知录]]></content>
      <categories>
        <category>数据库dockerHadoop微服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flowRecommend图计算]]></title>
    <url>%2F2018%2F03%2F15%2FflowRecommend%2F</url>
    <content type="text"><![CDATA[服务计算http://act.buaa.edu.cn/hsun/SOC2016/index.html 偏态系数 和 峰态系数中位数和均值的偏差，均值大叫正偏分布集中强度，正太分布的峰态是3，如果有一个分布的峰态5则可以拒绝正太分布假设 三大分布1.卡方分布：几个标准正太分布的平方和的分布2.t分布：正太分布的随机变量/卡方分布的变量 用于小样本估计成正太分布方差未知的总体的均值3.f分布：两个卡方分布的商 抽样误差数据分类定距（间隔）可以测量差值，但无绝对零点（温度）乘法，除法，比例是无意义的 判断正太分布84.5%的样本比 均值-标准差 大正太分布+-1倍标准差之间的累计值占69%，其它两边各占15.5%如果偏态系数绝对值大(0.x)， 极大似然 TUX GraphChi Preference 偏好 Goal model 系统：自然语言偏好表达-&gt;用目标模型解释的正式的偏好说明。组成： 正则、统计语义相似性，基于语料库的偏好强度分级。目标：基于优先级的软件个性化定制接口。 流程推荐 流程结构相似度 相似度-&gt; 目的：检索、合并、重组计算流程相似度 计算优化分解策略 聚合策略 mapreduce 建模【流程模型】： 用图 邻接矩阵、流程模型： PTN:probabilistic time Petri net 流程信息 控制流、数据流、资源 流程文本、流程结构、流程语义 相似度方法结构相似度 MDS：matrix distance similarity MWT最小加权时间 方法-&gt;时间效率最高 图的编辑距离： greedyalgorithm､exhaustivealgorithm withpruning､processheuristicalgorithm､Astaralgorithm,其中平均性能最好的是 greedyalgorithm｡ 图挖掘算法：gSpan 频繁子图 流程相似度 执行轨迹 可达状态 因果关系 原则路径：根据流程结构可能发生的路径表示成一个集合 变迁系统（节点空间爆炸） 流程中的数据走向: 活动发生的概率。矩阵间距离 绝对值距离：非负、同一、对称、三角不等式-&gt;只比较部分对象 差异矩阵的所有元素 树的编辑距离现状：基于图的相似度检测复杂流程：计算路径的相似度 匹配搜索的效率并行！分解和合并得到拟合出来的相似度与串行计算的准确度计算 编辑距离(geeksforgeeks)[https://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/] 123456789i=len(a);j=len(b); d[i][j] 表示a转换成b的编辑距离 for (i = 0; i &lt;= lena; i++) &#123; d[i][0] = i; &#125; 长度为j的字符串转换成长度为0的字符串最小步数。 for (j = 0; j &lt;= lenb; j++) &#123; d[0][j] = j; &#125; 表示a[0]-a[j] -&gt;"" 123456（1）当a[i]==b[i],d[i][j]=d[i-1][j-1] // fxy -&gt; fay 的编辑距离等于 fx -&gt; fa (2) 当≠，min（ &lt;1&gt; fxy -&gt; fab 删除a[i] d[i-1][j]+1 fx-&gt;fab &lt;2&gt; fxy -&gt; fab 插入b[j] d[i][j-1]+1 fxyb-&gt;fab-&gt;(1)-&gt;fxy-&gt;fa &lt;3&gt; fxy-&gt;fab 替换a[i]为b[j] d[i-1][j-1]-&gt;fxb-&gt;fab) (3) 边界：a[i][0]=i CART -&gt; MARCH c-&gt;m t-&gt;c +H [] a只需要d[i]一行 MPI]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>grap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQueryCode]]></title>
    <url>%2F2018%2F03%2F15%2FjQueryCodee%2F</url>
    <content type="text"><![CDATA[MPV设计模式jquery btn绑定事件 添加列表12345678910111213141516171819function Page()&#123;&#125;$.extend(Page.prototype,&#123; init: function()&#123; this.bindEvents() &#125;, bindEvents: function()&#123; var btn = $('#btn'); btn.on('click',$.proxy(this.handleBtnClick,this)) &#125;, handleBtnClick:function()&#123; var inputElem = $("#input"); var inputVal = inputElem.val() var ulElem = $("#ul"); ulElem.append('&lt;li&gt;' + inputVal + '&lt;/li&gt;') inputElem.val(''); &#125;&#125;)var page = new Page();page.init(); browser sync自动刷新 npm install -g browser-sync 进入监听文件夹// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 腻子？ JavaScript代码，能够赋予浏览器未曾有过的功能 HTML5shiv 原理？ jq 目录 代码风格：.editorconfig 不同程序员和IDE协作文件 代码规范：eslintrc- node(后端) -brower(前端);.eslintrc.json继承，便于替换 项目版本：git 基于nodejs开发 使用grunt进行工程化管理 package.json devDependencies开发阶段依赖的包 转换规则babel-plugin-transform-es2015-for-of&quot;: &quot;7.0.0-beta.0&quot; 转换命令grunt-babel自动化任务 husky阻止git中不好的操作 .git/hooks commitplease保证git提交注释的格式规则 core-jses5\6\7的腻子 eslint-config-jquery 代码规范的配置 grunt-eslint grunt- grunt-cli(一般全局安装）控制台命令接口，安装对应的自动化插件 测试相关 require.js AMD规范 sizzle 纯js选择器 scripts可以运行的脚本npm commitplease 插件配置 npm install -g全局安装，操作系统任意路径都能找到 –save 本地安装 项目目录里 –save-dev 只在开发环境依赖 运行环境不依赖 npm install grunt --save-dev 加到devdependenceis grunt Gruntfile.js初始化grunt ，加载grunt插件的脚本文件，创建自动化任务 测试环境nodejs测试环境 chrome://inspect 控制台 node --inspect-brk .\app.js 第一行里加断点浏览器测试环境 &lt;script&gt;插入require.js;并设置入口文件data-main=&quot;index.js&quot; 123456789index.js 1. 默认路径配置require.config(&#123; baseUrl:"../src"&#125;)2. 声明依赖模块 路径是src/css.js(返回jqrery)require(['css'],function($)&#123; $('div')&#125;) jquery.js core.js define(依赖的模块,function(依赖模块返回的对象)) toArray: return slice.call( this ); 关联的对象转成数组return [].slice .call(this) 绑定上下文 [].slice.call(this)返回[window]类数组 get: return num &lt; 0 ? this[ num + this.length ] : this[ num ];从后往前数数组 pushStack:jQuery.merge(构建新的jQ对象 ES5普通的创建对象 每个构造函数都有一个原型对象 constructor属性指向构造函数123456789101112131415//1.创建构造函数function Student(name,sex)&#123; this.name = name ...&#125;//2. 创建构造函数原型对象Student.prototype=&#123; constructor:Student, //添加实例共享的方法 study:function()&#123; &#125;&#125;//3. 使用构造函数必须要用new 可以返回thisvar stu = new Student(a,b);stu.study(); jquery 构造函数 core.js:return new init(,) 避免使用new 但return的是init类型，prototype的方法不能用 init.js:init = jQuery.fn.init = function放到了jq的原型里； init.prototype = jQuery.fn;两个原型相等，解决原型方法 让两个构造函数引用同一个原型对象 jQuery.fn = jQuery.prototype添加fn属性，其实是prototype的简写 init.js创建DOM对象 if ( selector.nodeType )DOM元素有nodetype属性 slector不是string/DOM/functionreturn jQuery.makeArray( selector, this );是js对象 如果是string:判断是html标签 123if ( selector[ 0 ] === "&lt;" &amp;&amp; selector[ selector.length - 1 ] === "&gt;" &amp;&amp; selector.length &gt;= 3 ) parseHTML.js 1/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i ^&lt; 第一个符号是&lt; [^\/\0&gt;:\x20\t\r\n\f]*不是/,\0匹配NULL (U+0000) 字符,&gt;，:，\x20空格… [\x20\t\r\n\f]*很多空格 \/?可以有一个/ (?:)非捕获组。 捕获组：([a-zA-Z])\1:\1捕获组 $1捕获组的引用 &lt;\/\1&gt;:\1捕获前面([a-z][^\/\0&gt;:\x20\t\r\n\f]*)小括号中的内容 /i (忽略大小写)添加属性 $(html, props) 添加属性props是js对象this.attr( match, context[ match ] ); 是string但不是&lt;&gt;开头结尾： 正则html标签rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/, 非捕获+很多空白+&lt;任意一个字母或数字或下划线\和所有字母、数字、下划线以外的字符&gt;[^&gt;]* 除了&gt;之外的符号可以有很多个 或者 是id 是string 是css选择器 .class: findFilter.js document.find(selector)-&gt;jQuery.fn.extend( { find: function( selector ) 使用了第三方的Filter库 ？？？？使用sizzle $(“.face”,”#box”)在box找.facereturn this.constructor( context ).find( selector ); 重新返回构造#box的jquery中查找.face 是string 是function 传给jQuery.Deferred(); DOM加载完毕后执行 window.onload = function(){} 所有资源加载完毕后执行,只能绑定一次事件处理函数，绑定多次会覆盖 $(function(){});只要dom加载好，图片,css,js等不需要，可以绑定多次 callbacks 等待耗时操作执行完后自动执行的函数 字符串转对象 option可选参数12 sizzlesizzle $().ready(function(){ }) Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。 门面接口底层接口快捷方法ready和load事件ready先执行，load后执行 DOM文档加载的步骤： (1) 解析HTML结构。(2) 加载外部脚本和样式表文件。(3) 解析并执行脚本代码。(4) 构造HTML DOM模型。//ready(5) 加载图片等外部文件。(6) 页面加载完毕。//load promise1document.addEventListener( "DOMContentLoaded", completed, false ); 类数组对象 jquery实现了9种方法的重载 123456789101112131415var aQuery = function(selector) &#123; //强制为对象 if (!(this instanceof aQuery)) &#123; return new aQuery(selector); &#125; var elem = document.getElementById(/[^#].*/.exec(selector)[0]); this.length = 1; this[0] = elem; this.context = document; this.selector = selector; this.get = function(num) &#123; return this[num]; &#125; return this;&#125; 属性与方法作为对象的key与value的方式给映射到this上 立即调用表达式12345(function(window, undefined) &#123; var jQuery = function() &#123;&#125; // ... window.jQuery = window.$ = jQuery; &#125;)(window); 减少变量查找所经过的scope作用域:当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量 挂在到window下执行 在外面就可以用$()执行函数 自执行 匿名函数，不存在外部引用.防止全局变量污染。 jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表）小括号把表达式组合分块，每个小伙好把匿名函数括起来返回一个匿名函数Function对象。（function（）{})()目的：使匿名函数像有名字一样，可以取得它的引用位置。（单利模式）在这个引用位置后面加参数列表，实现普通函数调用。 1234(function(window)&#123; var jQuery=function()&#123;console.log("jqqqqqqq");&#125; window.aaa=jQuery//保留jquery定义的变量，只暴露为aaa() &#125;)(window); zepto的方式 12345var Zepto=(function() &#123; var Zepto= function()&#123;&#125;; return Zepto&#125;)();Zepto()]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javanet]]></title>
    <url>%2F2018%2F03%2F11%2Fjavanet%2F</url>
    <content type="text"><![CDATA[自动化测试功能测试，工具类还是要用单元测试新建Util类 文档管理工具swagger//todo销售端产品查询 申购赎回 对账jsonrpc添加全局依赖123456ext &#123;libs = [jsonrpc:[ "com.github.briandilley.jsonrpc4j:jsonrpc4j:1.5.1"],]&#125; 添加到api模块123dependencies&#123; compile libs.jsonrpc&#125; 添加entity依赖新建接口api-ProductRpc123456789101112131415@JsonRpcService("rpc/products")public interface ProductRpc &#123; /** * 查询多个产品 * @param req * @return */ List&lt;Product&gt; query(ProductRpcReq req); /** * 查单个产品 * @param id * @return */ Product findOne(String id); 将参数复杂的接口的参数封装到请求对象api-domain123456public class ProductRpcReq &#123; private List&lt;String&gt; idList; private BigDecimal minRewardRate; private BigDecimal maxRewardRate; private List&lt;String&gt; statusList; &#125; 修改manger添加api依赖1compile project(":api") 在管理端新建包rpcrpc实现类12345678910111213141516171819202122232425@AutoJsonRpcServiceImpl@Servicepublic class ProductRpcImpl implements ProductRpc &#123; private static Logger LOG = LoggerFactory.getLogger(ProductRpcImpl.class); @Autowired private ProductService productService; @Override public List&lt;Product&gt; query(ProductRpcReq req) &#123; LOG.info("查询多个产品：&#123;&#125;",req ); Pageable pageable = new PageRequest(0,1000, Sort.Direction.DESC,"rewardRate"); Page&lt;Product&gt; page = productService.query(req.getIdList(), req.getMinRewardRate(), req.getMaxRewardRate(), req.getStatusList(), pageable); LOG.info("查询多个结果：&#123;&#125;",page ); return page.getContent(); &#125; @Override public Product findOne(String id) &#123; LOG.info("请求id:&#123;&#125;",id); Product rst = productService.findOne(id); LOG.info("结果id:&#123;&#125;",rst); return rst; &#125;&#125; 将rpc地址交给spring管理的配置类在manager新建包configuration rpc服务端1234567@Configurationpublic class RpcConfiguration &#123; @Bean public AutoJsonRpcServiceImplExporter rpcServiceImplExporter()&#123; return new AutoJsonRpcServiceImplExporter(); &#125;&#125; 可以看到日志信息 说明在manager的rpc实现导出到api中的地址成功122018-08-30 13:17:37.832 WARN 21224 --- [ main] o.s.c.a.ConfigurationClassEnhancer : @Bean method RpcConfiguration.rpcServiceImplExporter is non-static and returns an object assignable to Spring&apos;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&apos;s declaring @Configuration class. Add the &apos;static&apos; modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details.2018-08-30 13:17:37.846 INFO 21224 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : exporting bean [productRpcImpl] ---&gt; [/products] saller模块：添加api依赖，新建saller包并添加启动类123dependencies&#123; compile project(":api")&#125; 123456@SpringBootApplicationpublic class SellerApp &#123; public static void main(String[] args) &#123; SpringApplication.run(SellerApp.class); &#125;&#125; 新建service包1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class ProductRpcService &#123; private static Logger LOG = LoggerFactory.getLogger(ProductRpcService.class); @Autowired private ProductRpc productRpc; /** * 查询全部产品 暂时不分页返回 * @return List */ public List&lt;Product&gt; findAll()&#123; ProductRpcReq req = new ProductRpcReq(); List&lt;String&gt; status = new ArrayList&lt;&gt;(); //只能查询销售中的 status.add(ProductStatus.IN_SELL.name()); req.setStatusList(status); LOG.info("rpc查询全部产品 请求:&#123;&#125;",req); List&lt;Product&gt; result = productRpc.query(req); LOG.info("rpc查询全部产品 结果:&#123;&#125;",result); return result; &#125; //测试类 @PostConstruct public void testFindAll()&#123; findAll(); &#125; public Product findOne(String id)&#123; LOG.info("单个产品请求:&#123;&#125;", id); Product rst = productRpc.findOne(id); LOG.info("单个产品 结果:&#123;&#125;", rst); return rst; &#125; @PostConstruct public void testfindone()&#123; findOne("001"); &#125; 添加配置文件映射rpc路径application.yml123456server: servlet: context-path: /seller port: 8082rpc.manager.url: http://localhost:8081/manager/ 新建configuration包 导出bean创建rpc客户端123456789101112131415161718@Configuration@ComponentScan(basePackageClasses = &#123;ProductRpc.class&#125;)public class RpcConfiguration &#123; private static Logger LOG = LoggerFactory.getLogger(RpcConfiguration.class); @Bean public AutoJsonRpcClientProxyCreator rpcClientProxyCreator(@Value("$&#123;rpc.manager.url&#125;") String url)&#123; AutoJsonRpcClientProxyCreator creator = new AutoJsonRpcClientProxyCreator(); //设置地址 try&#123; creator.setBaseUrl(new URL(url)); &#125;catch (MalformedURLException e)&#123; LOG.error("创建rpc服务地址错误",e); &#125; //扫描接口 creator.setScanPackage(ProductRpc.class.getPackage().getName()); return creator; &#125;&#125; 修改路径1bean [productRpcImpl] ---&gt; [rpc/products] jsonRPC注意点：1.不能传递复杂参数不要传递分页对象2.路径rpc路径前不能有/3.RPC配置类的扫描路径 JSONRPC 客户端原理123logging: level: com.googlecode.jsonrpc4j: debug 开启客户端debug log122018-08-30 15:28:40.612 DEBUG 31512 --- [ main] c.g.j.s.AutoJsonRpcClientProxyCreator : Scanning 'classpath:api/**/*.class' for JSON-RPC service interfaces.2018-08-30 15:28:40.613 DEBUG 31512 --- [ main] c.g.j.s.AutoJsonRpcClientProxyCreator : Found JSON-RPC service to proxy [api.ProductRpc] on path 'rpc/products'. 12342018-08-30 15:28:42.819 INFO 31512 --- [ main] saller.service.ProductRpcService : 单个产品请求:0012018-08-30 15:28:42.836 DEBUG 31512 --- [ main] c.g.jsonrpc4j.JsonRpcHttpClient : Request &#123;"id":"1269662779","jsonrpc":"2.0","method":"findOne","params":["001"]&#125;2018-08-30 15:28:42.872 DEBUG 31512 --- [ main] c.g.jsonrpc4j.JsonRpcHttpClient : JSON-PRC Response: &#123;"jsonrpc":"2.0","id":"1269662779","result":&#123;"id":"001","name":"金融1号","status":"AUDITING","thresholdAmount":10.0,"stepAmount":1,"lockTerm":0,"rewardRate":3.86,"memo":null,"createAt":"2018-08-29T11:38:02.000+0000","updateAt":"2018-08-29T11:38:02.000+0000","createUser":null,"updateUser":null&#125;&#125;2018-08-30 15:28:42.905 INFO 31512 --- [ main] saller.service.ProductRpcService : 单个产品 结果:entity.Product@12fcc71f[id=001,name=金融1号,status=AUDITING,thresholdAmount=10.0,stepAmount=1,lockTerm=0,rewardRate=3.86,memo=&lt;null&gt;,createAt=Wed Aug 29 19:38:02 CST 2018,updateAt=Wed Aug 29 19:38:02 CST 2018,createUser=&lt;null&gt;,updateUser=&lt;null&gt;] AutoJsonRpcClientProxyCreator源码展开代码 自动注入Application从容器中获取bean之后会调用方法postProcessBeanFactory1implements BeanFactoryPostProcessor, ApplicationContextAware 1234567891011121314151617181920212223242526272829303132private String resolvePackageToScan() &#123; return CLASSPATH_URL_PREFIX + convertClassNameToResourcePath(scanPackage) + "/**/*.class";&#125;@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; SimpleMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory(applicationContext); DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) beanFactory; //配置的包路径 String resolvedPath = resolvePackageToScan(); logger.debug("Scanning '&#123;&#125;' for JSON-RPC service interfaces.", resolvedPath); try &#123; for (Resource resource : applicationContext.getResources(resolvedPath)) &#123; if (resource.isReadable()) &#123; MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(resource); ClassMetadata classMetadata = metadataReader.getClassMetadata(); //扫描注解 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); String jsonRpcPathAnnotation = JsonRpcService.class.getName(); //如果是jsonRpc服务 if (annotationMetadata.isAnnotated(jsonRpcPathAnnotation)) &#123; String className = classMetadata.getClassName(); String path = (String) annotationMetadata.getAnnotationAttributes(jsonRpcPathAnnotation).get("value"); logger.debug("Found JSON-RPC service to proxy [&#123;&#125;] on path '&#123;&#125;'.", className, path); //注册到容器 registerJsonProxyBean(defaultListableBeanFactory, className, path); &#125; &#125; &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(format("Cannot scan package '%s' for classes.", resolvedPath), e); &#125;&#125; 注册到容器1234567891011121314151617181920/** * Registers a new proxy bean with the bean factory. */private void registerJsonProxyBean(DefaultListableBeanFactory defaultListableBeanFactory, String className, String path) &#123; BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder //代理类 .rootBeanDefinition(JsonProxyFactoryBean.class) .addPropertyValue("serviceUrl", appendBasePath(path)) .addPropertyValue("serviceInterface", className); if (objectMapper != null) &#123; beanDefinitionBuilder.addPropertyValue("objectMapper", objectMapper); &#125; if (contentType != null) &#123; beanDefinitionBuilder.addPropertyValue("contentType", contentType); &#125; defaultListableBeanFactory.registerBeanDefinition(className + "-clientProxy", beanDefinitionBuilder.getBeanDefinition());&#125; JsonProxyFactoryBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JsonProxyFactoryBean extends UrlBasedRemoteAccessor implements MethodInterceptor, InitializingBean, FactoryBean&lt;Object&gt;, ApplicationContextAware &#123;@Override @SuppressWarnings("unchecked") public void afterPropertiesSet() &#123; super.afterPropertiesSet(); //根据接口创建代理对象 proxyObject = ProxyFactory.getProxy(getServiceInterface(), this); if (jsonRpcHttpClient==null) &#123; //与spring容器共用一个objectMapper if (objectMapper == null &amp;&amp; applicationContext != null &amp;&amp; applicationContext.containsBean("objectMapper")) &#123; objectMapper = (ObjectMapper) applicationContext.getBean("objectMapper"); &#125; if (objectMapper == null &amp;&amp; applicationContext != null) &#123; try &#123; objectMapper = BeanFactoryUtils.beanOfTypeIncludingAncestors(applicationContext, ObjectMapper.class); &#125; catch (Exception e) &#123; logger.debug(e); &#125; &#125; if (objectMapper == null) &#123; objectMapper = new ObjectMapper(); &#125; try &#123; //通过HTTP的方式发送数据的 jsonRpcHttpClient = new JsonRpcHttpClient(objectMapper, new URL(getServiceUrl()), extraHttpHeaders); jsonRpcHttpClient.setRequestListener(requestListener); jsonRpcHttpClient.setSslContext(sslContext); jsonRpcHttpClient.setHostNameVerifier(hostNameVerifier); if (contentType != null) &#123; jsonRpcHttpClient.setContentType(contentType); &#125; if (exceptionResolver!=null) &#123; jsonRpcHttpClient.setExceptionResolver(exceptionResolver); &#125; &#125; catch (MalformedURLException mue) &#123; throw new RuntimeException(mue); &#125; &#125; &#125;&#125; 实际与服务端交互的http方法12345678910111213@Overridepublic Object invoke(MethodInvocation invocation) throws Throwable &#123; Method method = invocation.getMethod(); if (method.getDeclaringClass() == Object.class &amp;&amp; method.getName().equals("toString")) &#123; return proxyObject.getClass().getName() + "@" + System.identityHashCode(proxyObject); &#125; Type retType = (invocation.getMethod().getGenericReturnType() != null) ? invocation.getMethod().getGenericReturnType() : invocation.getMethod().getReturnType(); Object arguments = ReflectionUtil.parseArguments(invocation.getMethod(), invocation.getArguments()); return jsonRpcHttpClient.invoke(invocation.getMethod().getName(), arguments, retType, extraHttpHeaders);&#125; jsonRpcHttpClient.java12345678910111213141516171819private HttpURLConnection prepareConnection(Map&lt;String, String&gt; extraHeaders) throws IOException &#123; // create URLConnection HttpURLConnection connection = (HttpURLConnection) serviceUrl.openConnection(connectionProxy); connection.setConnectTimeout(connectionTimeoutMillis); connection.setReadTimeout(readTimeoutMillis); connection.setAllowUserInteraction(false); connection.setDefaultUseCaches(false); connection.setDoInput(true); connection.setDoOutput(true); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); connection.setRequestMethod("POST"); setupSsl(connection); addHeaders(extraHeaders, connection); return connection;&#125; 测试调用rpc路径bug1234567891011121314151617181920212223242526272829/** * Appends the base path to the path found in the interface. */private String appendBasePath(String path) &#123; try &#123; return new URL(baseUrl, path).toString(); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException(format("Cannot combine URLs '%s' and '%s' to valid URL.", baseUrl, path), e); &#125;&#125; public static void main(String[] args) throws MalformedURLException &#123; URL baseUrl = new URL("http://localhost:8081/manager/"); String path = "rpc/products"; //只有这种是对的 //http://localhost:8081/manager/rpc/products System.out.println(new URL(baseUrl, path).toString()); URL baseUrl = new URL("http://localhost:8081/manager"); String path = "/rpc/products"; //少了manager //http://localhost:8081/rpc/products System.out.println(new URL(baseUrl, path).toString()); URL baseUrl = new URL("http://localhost:8081/manager/"); String path = "/rpc/products"; //http://localhost:8081/rpc/products System.out.println(new URL(baseUrl, path).toString());&#125; 服务端的运行原理123logging: level: com.googlecode.jsonrpc4j: debug 导出bean 注册接口 创建服务 映射到handler12342018-08-30 21:48:37.315 INFO 20852 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : exporting bean [productRpcImpl] ---&gt; [rpc/products]2018-08-30 21:48:37.328 DEBUG 20852 --- [ main] c.g.j.s.AutoJsonRpcServiceImplExporter : Registering interface 'api.ProductRpc' for JSON-RPC bean [productRpcImpl].2018-08-30 21:48:40.683 DEBUG 20852 --- [ main] c.g.jsonrpc4j.JsonRpcBasicServer : created server for interface interface api.ProductRpc with handler class com.sun.proxy.$Proxy892018-08-30 21:48:40.685 INFO 20852 --- [ main] o.s.w.s.h.BeanNameUrlHandlerMapping : Mapped URL path [/rpc/products] onto handler '/rpc/products' 启动客户端收到http请求 参数是 调用方法findOne 1232018-08-30 21:53:22.947 DEBUG 20852 --- [nio-8081-exec-2] com.googlecode.jsonrpc4j.JsonRpcServer : Handling HttpServletRequest org.apache.catalina.connector.RequestFacade@5681e8732018-08-30 21:53:22.962 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Request: &#123;"id":"425662322","jsonrpc":"2.0","method":"findOne","params":["001"]&#125;2018-08-30 21:53:22.964 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Invoking method: findOne with args ["001"] 结果 响应信息122018-08-30 21:53:23.025 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Invoked method: findOne, result entity.Product@1f724803[id=001,name=金融1号,status=AUDITING,thresholdAmount=10.000,stepAmount=1.000,lockTerm=0,rewardRate=3.860,memo=&lt;null&gt;,createAt=2018-08-29 19:38:02.0,updateAt=2018-08-29 19:38:02.0,createUser=&lt;null&gt;,updateUser=&lt;null&gt;]2018-08-30 21:53:23.064 DEBUG 20852 --- [nio-8081-exec-2] c.g.jsonrpc4j.JsonRpcBasicServer : Response: &#123;"jsonrpc":"2.0","id":"425662322","result":&#123;"id":"001","name":"金融1号","status":"AUDITING","thresholdAmount":1E+1,"stepAmount":1,"lockTerm":0,"rewardRate":3.86,"memo":null,"createAt":"2018-08-29T11:38:02.000+0000","updateAt":"2018-08-29T11:38:02.000+0000","createUser":null,"updateUser":null&#125;&#125; 服务端配置类AutoJsonRpcServiceImplExporter实现BeanFactoryPostProcessor的方法12345678public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) beanFactory; //&lt;path,bean名称&gt; Map&lt;String, String&gt; servicePathToBeanName = findServiceBeanDefinitions(defaultListableBeanFactory); for (Entry&lt;String, String&gt; entry : servicePathToBeanName.entrySet()) &#123; registerServiceProxy(defaultListableBeanFactory, makeUrlPath(entry.getKey()), entry.getValue()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041private static Map&lt;String, String&gt; findServiceBeanDefinitions(ConfigurableListableBeanFactory beanFactory) &#123; final Map&lt;String, String&gt; serviceBeanNames = new HashMap&lt;&gt;(); //遍历所有bean for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; //是否添加了auto rpc的注解 AutoJsonRpcServiceImpl autoJsonRpcServiceImplAnnotation = beanFactory.findAnnotationOnBean(beanName, AutoJsonRpcServiceImpl.class); //判断jsonrpcservice的注解 JsonRpcService jsonRpcServiceAnnotation = beanFactory.findAnnotationOnBean(beanName, JsonRpcService.class); //如果有Impl没有jsonrpcservice的注解 就报错 if (null != autoJsonRpcServiceImplAnnotation) &#123; if (null == jsonRpcServiceAnnotation) &#123; throw new IllegalStateException("on the bean [" + beanName + "], @" + AutoJsonRpcServiceImpl.class.getSimpleName() + " was found, but not @" + JsonRpcService.class.getSimpleName() + " -- both are required"); &#125; List&lt;String&gt; paths = new ArrayList&lt;&gt;(); //auto上的注解会作为path，实现类上可以有额外的additionPath //一个rpc服务可以映射到多个服务 Collections.addAll(paths, autoJsonRpcServiceImplAnnotation.additionalPaths()); paths.add(jsonRpcServiceAnnotation.value()); for (String path : paths) &#123; //判断格式是否合法 if (!PATTERN_JSONRPC_PATH.matcher(path).matches()) &#123; throw new RuntimeException("the path [" + path + "] for the bean [" + beanName + "] is not valid"); &#125; logger.info(String.format("exporting bean [%s] ---&gt; [%s]", beanName, path)); //判断是否是重复的服务，放到&lt;路径，名称&gt;的bean目录里 if (isNotDuplicateService(serviceBeanNames, beanName, path)) serviceBeanNames.put(path, beanName); &#125; &#125; &#125; collectFromParentBeans(beanFactory, serviceBeanNames); return serviceBeanNames; &#125; chrome-network-preserve log spring中自建exception类要继承RuntimeException只有RuntimeException才会事务回滚，继承Exception不会。 使用PUT方式body要设置成x-www-from-urlencoded 过滤器：登陆、加密、解密、会话检查、图片转换。 spring通知、事务传播行为 maven依赖子类不用版本号 抓包记得开隐身窗口注意dp[one++][two++]=dp[one-1][two-1];的执行顺序 1,1不会等于0,0 分页 List.subList(,) SQL的limit或者Oraclerownumselect * from t_student limit 0,10从0取10条PostgerSQL：select * from t_student limit 10 offset 0 hibernate:123456String hql = "from Student";//创建Query或者Criteria对象Query q = session.createQuery(hql);q.setFirstResult(0);q.setMaxResults(10);List l = q.list(); 对象123456789public class Pager&lt;T&gt; implements Serializable&#123; //每页显示几条记录 private int pageSize; //当前页 private int currentPage; private int totalPage; private int totalRecord; private List&lt;T&gt; dataList;&#125; InternalResourceViewResolverbean配置页面的jsp路径和后缀名JstlView处理?clouseID=123用12(@RequestParam("courseId") Integer courseId,Model model)model.addAttribute(course); 处理rest风格的/{courseId}123@RequestMapping(value="/view2/&#123;courseId&#125;")(@PathVariable("courseId") Integer courseId,Map&lt;String,Object&gt;model)model.put("course",course); 在SpringMVC中使用HttpServletRequest等对象引入12&lt;groupId&gt;javax.servlet&lt;/groupId&gt;&lt;artifactId&gt;servlet-api&lt;/artifactId&gt; 12request.getParameter("courseId");request.setAttribute("course",course); @ModelAttribute模型自动绑定12//请求重定向return "redirect:view/"+course.getCourseId(); 文件上传表单属性enctype=&quot;multipart/from-dataaction页面拦截12//自动转型(@RequestParam("file") MultipartFile file) common-io中的文件流操作1FileUtils.copyInputStreamToFile(file.getInputStream,new File("")); Json 添加依赖1234@ResponseBody Course getCourseInJson(@PathVariable Integer courseId)ResponseEntity&lt;Course&gt; getCourseInJson(@PathVariable Integer courseId)&#123; return new ResponseEntity&lt;Course&gt;(course,HttpStatus.OK);&#125; 数据绑定 基本类型int当参数不能为空，包装类型可以为null 传数组?name=tom&amp;name=jack&amp;name=lucy用String[] name接收 横向越权不同用户相同权限的数据，A可以查看B的订单 纵向：变成管理员 封装响应对象status,msg,T dataJSP 指令&lt;%@ page属性=&quot;&quot; %&gt;属性 language，import，contentTypeinclude，taglib 脚本元素&lt;% out.println(&quot;&quot;) %&gt; 声明 12&lt;%! String s = " ";int add(int x,int y)&#123;return x+y;&#125;%&gt; 表达式&lt;% =s %&gt;不以分号结束 JSP声明周期 第一次用户请求.jsp，JSP引擎转为Servelet类（.java)，生成字节码文件，执行jspInit()初始化 解析执行字节码文件的jspService() jspService()处理客户端请求每个客户端一个线程。Servlet常驻内存。 JSP9大内置对象 out对象是JspWriter类实例。8k缓冲区 表单get提交数据小于2k action=&quot;.jsp&quot; request是HttpServletRequest的实例，接收action的js：12//修改接收的字符集 与表单页面的编码一致&lt;% request.setCharaterEncoding("utf-8")%&gt; URL传参，但这种方法设置request的字符集无效，要修改tomcat的server.xml的Connetor标签1&lt;a href="接收请求的.jsp?username=a"&gt;接收参数并跳转&lt;/a&gt; response.sendRedirect(&quot;.jsp&quot;)重定向 response中的.getWriter得到的PrintWriter总是先于out对象输出，可以使用out.flush强制刷新输出 session对象是HttpSession类的实例。保存在服务器的内存中，保存一个用户访问一个服务器页面切换仍然是同一个用户。用&lt;a href=&quot;.jsp&quot;&gt;后另一个页面仍能获得相同的session application对象是ServletContext类的实例。服务器的启动和关闭。get/setAttribute(,) page对象就是页面object pageContext对象可以获得所有session，response等对象 Config对象servlet初始化要用到的参数 请求重定向 请求转发重定向.sendRedirect：客户端行为response对象，两次请求，第一次请求对象不被保存（重定向到的页面无法获得原来的request内容。地址栏URL变化。 （登陆失败）转发：服务器行为。request.getRequestDispatcher().forward(req,resp)一次请求，转发后请求对象被保存（把request也转发，再把response传回原jsp），URL地址不变。（登陆成功）登陆成功12session.setAttribute("loginUser",username);request.getRequestDispatcher("success.jsp").forward(request,response); 在success.jsp获取1&lt;%=session.getAttribute("loginUser"); jsp动作标签和javaBean12345&lt;jsp:useBean id="u" class="U" scope="page"/&gt;&lt;jsp:setProperty name="u" property="*"&gt; 根据表单name自动和javabean的类自动匹配传统的表达式方式：&lt;%= u.getUsername()%&gt; &lt;jsp:getProperty name="u" property="username"&gt; 还可以用property+value设置值，可以通过param获得url传的参数 bean的四个作用域：page，request，session，application动作include、forward&lt;jsp:forward page=&quot;url&quot;/&gt;等同于request.getRequestDispatcher(“/url”).forward(request,response); mina创建连接1234//服务端SocketAcceptor acceptor = new NioSocketAcceptor();//客户端NioSocketConnector connector = new NioSocketConnector(); 设定过滤规则123456789101112DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();chain.addLast("obj",new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));//设置消息处理器 服务端acceptor.setHandler(new minaHandler());//服务器acceptor.bind(new InetSocketAddress(port));//客户端连接服务器ConnectFuture cf = connector.connect(new InetSocketAddress("localhost",9999));//客户端等待连接成功cf.awaitUninterruptibly();//客户端 发送cf.getSession().write(msg); 消息处理器extends IoHandlerAdapter重写session接收的方法 Spring配置文件读取bean declarationtx声明式事务配置文件 struts2 加入jar包：asm 替代反射，字节码操控框架；ognl struts2的标签库；xwork和webwork整合的包 sturts.xml放入src负责Action映射和Result定义、拦截器； &lt;include&gt;把每个功能的配置放到不同的xml文件里导入动态方法调用： 解决action太多&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value = &quot;true&quot;&gt; &lt;action name = &quot;addAction&quot; method=&quot;add&quot; class=&quot;&quot;&gt;遇到add.action时调用指定类中的add 方法 通过!add.action访问&lt;action&gt;&lt;result name=&quot;add&quot;&gt;/result.jsp&lt;/result&gt;对应action的方法中return &quot;add&quot;对应result的name字符串 通配符name = &quot;{2}_*&quot; method={1} class=&quot;..{1}Action&quot;访问helloworld_add.action可以匹配add和helloword默认错误路径 &lt;default-action-ref name=&quot;index&gt;并配置名为index的action 参数：&lt;contant name=&quot;struts.action.extension value=&quot;&quot;&gt;不用输入.action后缀 struts.properties 全局属性文件；可以不用，在struts.xml用constant元素 在web.xml配置核心过滤器 core包下的;/*.jsp和.html不拦截12345678&lt;filter&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;filter-class&gt;...dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Struts2Filter&lt;/filter-name&gt; &lt;url-pattern&gt;\*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Struts原理 HttpServltRequest经过ActionContextCleanUp、各种Filter .action的请求会到ActionMapper返回Filter Filter发给ActionProxy 并读取struts的配置文件，找到具体的action类，通过ActionProxy代理创建Action实例 经过拦截器执行到action返回result是字符串对象对应视图（JSP/FreeMaker） 继续经过拦截器 通过HttpServletResponse返回到用户实例进行显示 Action搜索顺序: 顺着不存在的包名向上查，包名存在则查找action 动态方法调用： URL读取html1234567891011121314import java.net.*;import java.io.*;public class URLReader&#123; public static void main(String[] args) throws Exception&#123; URL cs = new URL("http://www.sina.com"); //直接获得inputStream BufferedReader in = new BufferedReader( new InputStreamReader(cs.openStream())); String inputLine; while((inputLine = in.readLine())!= null) sout(inputLine); in.close(); &#125;&#125; 意外处理try{}catch(MalformedURLexception e) 不符合URL常规的url异常-123URL url = new URL("https://baidu.com");HttpURLConnection conn = (HttpURLConnection)url.openConnection();BufferedInputStream in = new BufferedInputStream(conn.getInputStream()); tomcat server.xml 12345678910111213&lt;server&gt; &lt;service&gt; &lt;Connector&gt; &lt;/Connector&gt; &lt;Engine&gt; &lt;host&gt; 可以有多个host虚拟主机 &lt;Context&gt; web应用 &lt;/Context&gt; &lt;/host&gt; &lt;/Engine&gt;&lt;/server&gt; Connector 接收用户请求，Coyote实现(BIO)阻塞式IO adddress只监听的地址 acceptCount 没有空闲线程时的排队长度默认100 maxConnections 线程池的最大值 -1 不限制 线程池：事先创建一定数目的线程，减少了线程创建与销毁的过程12&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="150" minSpareThreads="4"/&gt; Engine 处理Connector接收到的用户请求 mavenpom 项目对象模型 &lt;properties&gt;中配置的常量属性可以用${property}取 子pom和父pom可以继承覆盖 Super POM中有默认设置 user/.m2/repository本地缓存的仓库 中央仓库生命周期clean:清理项目pre-clean clean post-clean default: 构建项目 validate，process-resources运行package会自动运行compile、testsite:生成站点文档&lt;scope&gt;provided&lt;/scope&gt;只在编译和测试时运行 依赖范围：&lt;scope&gt;6种 compile：默认。编译测试运行都有效。 provided在编译和测试时有效，运行无效。例如servlet-api因为web容器已经有api了 runtime：运行、测试有效。例如jdbc驱动api test:测试时有效。例如junit system：编译和测试有效，不可移植，与系统相关联。例如引入本地的JAVA_HOME import:只用在dependencyManagement中，表示从其它pom中继承的依赖。 命令mvn complie编译 test测试 package打包 clean删除target install安装jar包到本地仓库 archetype插件 建立符合规定的目录骨架mvn archetype:generate gitgit push -u origin master Servelet:运行在server端的java程序 1.java类 没有main方法 2.运行于容器 提供请求-响应的web服务 servlet处理流程 pom.xml:tomcat: 123&lt;configuration&gt; &lt;path&gt;/web_project_template&lt;/path&gt;&lt;/configuration&gt; servlet容器的配置文件web.xml找到对应的Servlet,转发到service方法 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;..TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;servlet-mapping&gt; 客户端请求http对象的时候service方法被调用 客户端使用get方法访问时doGet方法被调用TestServlet.java12345678910@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("doGet method"); PrintWriter pw = resp.getWriter(); //设置文件类型 response.setContentType("text/html;charset=utf-8") pw.print("/hello"); pw.close(); &#125; Servlet 生命周期生命周期方法由服务器调用 默认web客户端第一次请求容器，创建servlet实例 调用init(ServletConfig) 请求处理 转发请求 destory get通过header传输数据，post通过body传输 ServletConfig：以servlet为单位 123456789101112&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;data1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;data2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt; 12ServletConfig config = this.getServletConfig();String v1 = config.getInitParameter("data1"); context-param ：全局配置 ServletContext对象 web应用中全局唯一 1234&lt;context-param&gt; &lt;param-name&gt;globalData1&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt;&lt;/context-param&gt; 12ServletContext ctx = this.getServletContext();String v1 = ctx.getInitParameter("data1"); servletContext 可以CLUD共享不是事先知道的动态信息 12//在context中设置属性ctx.setAttribute("attribute1", "111"); 读取外部资源配置文件信息： ServletContext.getResource :URL .getResourceAsStream .getRealPath:File ??? Properties 对象 web.xml 部署描述符为一个servlet配置多个url-pattern、/*模糊匹配 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 匹配优先级规则 监听器 用途： 统计在线人数和在线用户 HttpSession 系统启动时加载初始化信息 缓存、数据库链接ServletContext 统计网站访问量 spring相关 用法： impletemts ServletContextListener 在web.xml注册 1&lt;listener&gt;&lt;listener-class&gt;&lt;/listener-class&gt;&lt;/listener&gt; 上下文对象，web启动时创建，web销毁 销毁 监听器的启动循序按注册顺序。 优先级：监听器&gt;过滤器&gt;servlet加载 监听器种类 ServletContext监听应用程序环境对象 HttpSession用户会话对象 ServletRequest请求消息对象 MIME 多用途 互联网 邮件 扩展 类型设定某种扩展名的文件用什么应用打开 1234&lt;mime-mapping&gt; &lt;extension&gt;java&lt;/extension&gt; 扩展名映射类型 &lt;mime-type&gt;text/plain&lt;/mime-type&gt;&lt;/mime-mapping&gt; Session &amp; Cookie Cookie 短时间，数据频繁访问 保存在客户端 V0: Set-Cookie: userName= “”; Domain= “” V1: Max-Age= 1000 实际： Version= “1” Session NANE为JSESIONID的 Cookie 保存在服务端 Cookie 会话cookie 关闭浏览器消失，保存在内存中 setMaxAge 设置cookie有效期，浏览器会把cookie保存到硬盘上 一个站点最多能保存20个cookie，每个4k以内cookie12345678910111213141516171819202122/***第一次请求把cookie设置好**/Cookie userNameCookie = new Cookie("userName", userName);Cookie pwdCookie = new Cookie("pwd", userPassword);/***设置时间**/userNameCookie.setMaxAge(10 * 60);pwdCookie.setMaxAge(10 * 60);/***把cookie放到响应中**/response.addCookie(userNameCookie);response.addCookie(pwdCookie);/***第二次从请求中获取cookies数组**/Cookie[] cookies = request.getCookies();//第二次if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals("userName")) &#123; userName = cookie.getValue(); &#125; if (cookie.getName().equals("pwd")) &#123; userPassword = cookie.getValue(); &#125; &#125;&#125; Session 默认有效期30分钟 setMaxInactiveInterval设置有效期 部署描述符设置有效期 invalidate Session失效 第一次请求：服务器创建session对象，把SessionID作为cookie发送给浏览器 12345678910//创建Session对象HttpSession session = request.getSession();session.setAttribute("userName", userName);// 第二次请求String name = (String) session.getAttribute("userName");if (name != null) &#123; //服务器已经保存了session System.out.println("second login: " + name); &#125; 第二次 Request:Cookie: JSESSIONID=B2980D3ABAB39EF6EA09F278F261C2A4; Session钝化：不不常使用的session对象序列化到文件/数据库tomcat两种钝化管理器 StandardManger tomcat 关闭重启时，web应用重启时（覆盖了web.xml)，钝化到文件。钝化到/work/Catalina/hostname/applicationname/SESSION.ser重启时加载删除 Persistentmanager Servlet3.0 @WebListner免注册声明为监听器转发与重定向 转发对象：RequestDispatcher(&quot;.jsp&quot;).forward(request,response) 重定向：是两次请求 获取不到原来的req tail -f 监视日志输出 javax.servlet Servlet 所有Servlet必须实现的方法 Config Servlet配置信息 Context 容器信息 GenericServlet底层（实现了5个servlet中的方法） javax.servlet.http HttpSession标识并存储客户端信息 HttpServletRequest getParameter(String key)获得第一个name和key一样的表单控件的数据 getParameterValues同上返回数组 getParameterMap 返回kv getParameterNames 返回所有表单控件的name值 HttpServlet 扩展GenericServlet Cookie 存储Servlet发送给客户端的信息 javax.servlet.annotation 注解 javaWeb域对象：存、取数据（Map） Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mlpractice]]></title>
    <url>%2F2018%2F03%2F09%2Fmlpractice%2F</url>
    <content type="text"><![CDATA[crowdedness 预测随机森林https://www.kaggle.com/nsrose7224/random-forest-regressor-accuracy-0-91 时间戳居中到中午12点1234def time_to_seconds(time): return time.hour * 3600 + time.minute * 60 + time.secondnoon = time_to_seconds(time(12, 0, 0))df.timestamp = df.timestamp.apply(lambda t: abs(noon - t)) 时间序列星期/月/小时 编码月变成1-12列，小时变成0-23列，星期变成0-6列12columns = ["day_of_week", "month", "hour"]df = pd.get_dummies(df, columns=columns) 切分数据集，全部归一化12345678910# Extract the training and test datadata = df.valuesX = data[:, 1:] # all rows, no labely = data[:, 0] # all rows, label onlyX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)# Scale the data to be between -1 and 1scaler = StandardScaler()scaler.fit(X_train)X_train = scaler.transform(X_train)X_test = scaler.transform(X_test) 随机森林调参 并可视化R212345678910estimators = np.arange(10, 200, 10)scores = []for n in estimators: model.set_params(n_estimators=n) model.fit(X_train, y_train) scores.append(model.score(X_test, y_test))plt.title("Effect of n_estimators")plt.xlabel("n_estimator")plt.ylabel("score")plt.plot(estimators, scores) 估计总体的协方差矩阵（数据散点的形状估计）https://scikit-learn.org/stable/modules/covariance.html Empirical covariance 就是最大似然估计。只要数据量比特征量大很多最大似然估计是总体协方差矩阵的无偏估计。（More precisely, the Maximum Likelihood Estimator of a sample is an unbiased estimator of the corresponding population’s covariance matrix.） 注意：训练集和测试集样本需要居中（均值一样）：参数assume_centered=False 则测试集应该和训练集有相同的平均值向量。如果assume_centered=True 应该由用户居中。sklearn.preprocessing.StandardScaler（copy = True，with_mean = True，with_std = True ） with_mean 默认为True，在缩放之前对数据分布居中处理。 缺点：可能因为数学原因不可逆？empirical covariance matrix cannot be inverted for numerical reasons. Shrunk Covariance减小特征的最大值最小值的比率 或者对特征加上一个l2最大似然估计惩罚值。可以设定一个参数 bias/variance 参数 收缩是一个凸变换。 Ledoit-Wolf shrinkage用来计算优化的收敛系数（上面的bias/variance）（？） Oracle Approximating Shrinkage比上面有更小的MSE Sparse inverse covariance用协方差矩阵的逆矩阵 如果两个条件独立则为0，用于学习，方差选择。在数据集小的情况下，大概只有特征数量那么大或者更小，这个比Shrunk Covariance好。而且这个能回复非对角数据。用GraphicalLasso 和GraphicalLassoCV 优化学习。 Robust Covariance Estimation获得素数向量123456789101112def sieve_eratosthenes(n): primes = [False, False] + [True for i in range(n-1)] p = 2 while (p * p &lt;= n): if (primes[p] == True): for i in range(p * 2, n + 1, p): primes[i] = False p += 1 return primesprimes = np.array(sieve_eratosthenes(nb_cities)).astype(int)## 不是素数 +10%penalization = 0.1 * (1 - primes) + 1 2xn向量 n个点坐标，求i到其他n-1个点的距离123456## 所有城市到到当前城市的距离def dist_matrix(coords, i): begin = np.array([df.X[i], df.Y[i]])[:, np.newaxis] print(begin.shape) mat = coords - begin return np.linalg.norm(mat, ord=2, axis=0) pandas array根据index筛选，找到最小的标号12def get_next_city(dist, avail): return avail[np.argmin(dist[avail])] CountVectorizer 词袋模型时间序列分解R语言自带的AirPassengers标记离群点STL 根据稳健回归对时间序列数据进行分解，然后进行离群点识别。STL： 基于局部甲醛回归的季节性趋势分解。 1234567891011&gt; f&lt;-stl(AirPassengers,"periodic",robust=TRUE)&gt; plot(f,set.pars=NULL)&gt; AirPassengers&gt; (outliers &lt;- which(f$weights&lt;1e-8))&gt; &gt; &gt; op&lt;-par(mar=c(0,4,0,3),oma=c(5,0,4,0),mfcol=c(4,1))&gt; plot(f,set.pars=NULL)&gt; sts&lt;-f$time.series&gt; points(time(sts)[outliers],0.8*sts[,"remainder"][outliers],pch="x",col="red")&gt; par(op)&gt; &gt; (outliers &lt;- which(f$weights&lt;1e-8) 时间序列分解为 趋势、季节性、周期性以及不规则。 季节性成分123456789&gt; plot(AirPassengers)&gt; apts&lt;-ts(AirPassengers,frequency=12)&gt; f &lt;- decompose(apts)&gt; f$figure [1] -24.748737 -36.188131 -2.241162 -8.036616 -4.506313 35.402778 [7] 63.830808 62.823232 16.520202 -20.642677 -53.593434 -28.619949&gt; plot(f$figure,type="b",xaxt="n",xlab="")&gt; monthNames&lt;-months(ISOdate(2011,1:12,1))&gt; axis(1,at=1:12,labels=monthNames,las=2) 分解 原图 趋势、季节性 不规则1plot(f) 常用时间序列模型ARMA ARIMAARMA模型拟合： 许仙表示致信度水平95%下的误差边界 123456&gt; fit&lt;-arima(AirPassengers,order=c(1,0,0),list(order=c(2,1,0),period=12))&gt; fore&lt;-predict(fit,n.ahead=24)&gt; U&lt;-fore$pred+2*fore$se&gt; L&lt;-fore$pred-2*fore$se&gt; ts.plot(AirPassengers,fore$pred,U,L,col=c(1,2,4,4),lty=c(1,1,2,2))&gt; legend("topleft",c("Actual","Forecast","Error Bounds(95% confidence)"),col=c(1,2,4),lty=c(1,1,2)) 时间序列聚类 DTW动态时间规整距离foursquare category js提取123456789101112131415161718192021222324252627282930313233343536373839fetch('https://api.foursquare.com/v2/venues/categories?v=20170211&amp;oauth_token=QEJ4AQPTMMNB413HGNZ5YDMJSHTOHZHMLZCAQCCLXIX41OMP&amp;includeSupportedCC=true') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); f = myJson; &#125;);​​​​​​​​​​​​​​​​​​​​for (supercate of cates)&#123;var cnt =0var s = supercate.name +" =[ ";for (subcate of supercate.categories)&#123; s+=("\""+subcate.id+"\",") cnt ++; if(subcate.categories.length &gt; 0)&#123; for(subsubcate of subcate.categories)&#123; s+=("\""+subsubcate.id+"\",") cnt++; if(subsubcate.categories.length &gt; 0)&#123; for(c of subsubcate.categories)&#123; s+=("\""+c.id+"\",") cnt++; if(c.categories.length&gt;0)&#123; for(cc of c.categories)&#123; s+=("\""+cc.id+"\",") cnt++ if(cc.categories.length&gt;0)&#123; console.log("特么还有") &#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;console.log(s)console.log(cnt)&#125;s 张量分解代码http://tensorly.org/stable/user_guide/quickstart.html#tensor-decomposition NMF的评价basline用平均? 训练数据处理：打乱样本12345def _shuffle_data(self): # [0,1,2,3,4,5] -&gt; [5,3,2,4,0,1] p = np.random.permutation(self._num_examples) self._data = self._data[p] self._labels = self._labels[p] z-score标准化变成正太分布原始值和平均值之间的距离，以标准差为单位计算。 相关性分析散点矩阵 看是不是线性相关12data = pd.DataFrame(np.random.randn(200,4)*100,columns = ['A','B','C','D'])pd.scatter_matrix(testUser,figsize = (8,5),c = 'k',marker='.',diagonal="hist",alpha=0.8,range_padding=.1) https://blog.csdn.net/v_JULY_v/article/details/78121924 皮尔逊相关系数：服从正态分布的连续变量df.corr() 如果cosine相似度是0.97 pearson可能是1，与加减乘除无关，只看趋势。使用之前先要检验是否正太分布p?0.05 Sperman相关系数：不正太分布的 等级相关系数，按rank计算 https://baike.baidu.com/item/%E7%9A%AE%E5%B0%94%E6%A3%AE%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0 kaggle 方案索引https://mp.weixin.qq.com/s?__biz=MzIzMzgzOTUxNA==&amp;mid=2247483678&amp;idx=1&amp;sn=5f044dabfaa726e292686287a1dd5ca4&amp;chksm=e8fecfebdf8946fdabf71fd5c4c0e019144f105da993c12fa257c64f281ecfb3a7557f16b79e&amp;scene=21#wechat_redirect ARIMA网站流量预测 AR是autoregressive的缩写，表示自回归模型，含义是当前时间点的值等于过去若干个时间点的值的回归I(d)将不平稳序列差分得到平稳序列，略过不表。假设我们现在的时间序列已经是平稳的了。t时刻的值减去t-1时刻的值，得到新的时间序列称为1阶差分序列；1阶差分序列的1阶差分序列称为2阶差分序列MA(q)：MA是moving average的缩写，表示移动平均模型，含义是当前时间点的值等于过去若干个时间点的预测误差的回归； 1 日期数据变成week day 0的一组和week end 1的一组2 用0,1当一列特征，总体趋势假设是1-28线性递增的一列 用一元线性回归拟合出两条曲线方程得到预测流量的一列。3 用4天做滑动平均一列4 时间序列乘法分解模型 得到 实际值/移动平均列 = 周因素x波动 fix Effect Ramdom effectKDE回归https://rstudio-pubs-static.s3.amazonaws.com/238698_f5c485e2a4f2441dbc9a52ebda0fe8c0.htmlhttp://nbviewer.jupyter.org/url/jakevdp.github.com/downloads/notebooks/KDEBench.ipynbhttps://jakevdp.github.io/blog/2013/12/01/kernel-density-estimation/ 推荐系统 全局流行度 分类模型 协同过滤 1）同现矩阵：每个格表示同时买了x物品和y物品的次数（是对称矩阵） 找一行里的最大几个做推荐2）同现矩阵正规化，去除流行商品的影响Jaccard相似度： 同时买i和j的人数/买i或j的人数3）算上历史数据的加权平均 如果用户买过x和y商品，推荐z商品的分数是1/2（matrix[x][z]+matrix[y][z]) 可以让最近购买的权重变大。对所有z商品排序，推荐最高的几个。4）矩阵分解：从当前稀疏矩阵求L和R向量（回归问题） 填补缺失值R描述物品 的所属 category 相关度向量L用户对category的score向量R x L 将所有R与一个用户L相乘取其中最大的几个推荐 https://software.intel.com/zh-cn/ai-academy/students/kits 动量梯度下降vt 是之前梯度的均值，是梯度的积累值 之前积累的梯度方向是momentum step,当前梯度是gradient step,这次的更新梯度是actual step1 模型刚开始 两个夹角小，则actual step 是2倍 可以加快训练2 当梯度为0的时候 有动量3 梯度改变方向 动量可以缓解动荡 卷积计算是对应位置相乘每次卷积的输出size = 输入size - 卷积核size + 1多个卷积层图像size变成1或者非整数 所以加padding。使输入和输出size一样。每个通道独立做卷积，最后3个通道相加P = 边距(padding)S = 步长(stride)输出尺寸：(n-p)/s + 1 参数数目 = kw x kh x ci x cokw,kh 卷积核长宽ci 输入通道数co 输出通道数 池化 对应区域内的最大值 不用相乘还有平均值池化 不是求对应区域最大值 而是求平均 步长和卷积核一样，每次移动的区域不重叠。不补0，不padding，多余的区域直接丢掉没有用于求导的参数池化层 参数为步长和池化核大小。先池化 有利于减少图片大小 然后再卷积。 全连接层输出展开成一维连接到下一层每个神经元上。 之后就不能做卷积、池化了，已经是一维的了是普通神经网络的层参数数目为 输入通道数目/输出通道数目可以droupout 因为参数太多容易过拟合 随机丢掉几个不连接相当于训练了子网络并且进行组合 激活函数为什么激活函数不用线性函数？因为高层和低层是全连接(参数矩阵W).如果不用激活函数，相当于每个层次进行矩阵操作，深层神经网络也相当于单层 !!!todo混淆矩阵 准确度,精准率，召回率F1调和平均值，PR曲线ROC曲线对于极度偏斜Skewed Data正确率accuracy rate (TP+TN) / (TP+TN+FN+FP)如果癌症概率只有0.1%如果全部预测没病 就可以达到99.9%的准确率 1混淆矩阵 TF是真实值 PN是预测值1234567891011121314151617181920212223242526#真的不是def TN(y_true,y_predict): return np.sum((y_true==0)&amp;(y_predict==0))# 预测为1 错了def FP(y_true,y_predict): return np.sum((y_true==0)&amp;(y_predict==1))#其实是真的def FN(y_true,y_predict): return np.sum((y_true==1)&amp;(y_predict==0))#真的是真的def TP(y_true,y_predict): return np.sum((y_true==1)&amp;(y_predict==1))#混淆矩阵def confusion_matrix(y_true,y_predict): return np.array([ [TN(y_test,y_log_predict),FP(y_test,y_log_predict)], [FN(y_test,y_log_predict),TP(y_test,y_log_predict)] ])confusion_matrix(y_test,y_log_predict)## 直接调库 顺序一样的from sklearn.metrics import confusion_matrixconfusion_matrix(y_test,y_log_predict) 混淆矩阵可视化123from sklearn.metrics import confusion_matrixconfusion_matrix(y_test,y_predict)plt.matshow(confusion_matrix(y_test,y_predict),cmap=plt.cm.gray)#越亮数字越大 2.精准率presision_score tp/(tp+fp)//the ability of the classifier not to label as positive a sample that is negative. 别把错的当对的的能力应用场景：股票预测 精准率 对于FP敏感 对于上升的但是没有预测出来FN的漏掉了不是很在意判断为刷单的用户里，真的是刷单的有多少 但是FN也是刷单的 漏判数据不在乎1234567def precision_score(y_true,y_predict): tp = TP(y_test,y_log_predict) fp = FP(y_test,y_log_predict) return tp/(tp+fp)## 直接调库from sklearn.metrics import precision_scoreprecision_score(y_test,y_log_predict) 3.TPR 召回率recall_score tp/(tp+fn)//he ability of the classifier to find all the positive samples. 找到所有正确的的能力（找全）应用场景 : 医疗领域 召回率 希望所有有病的都要检查出来。FP没关系，即使没病说有病FN也没关系。1234567def recall_score(y_true,y_predict): tp = TP(y_test,y_log_predict) fn = FN(y_test,y_log_predict) return tp/(tp+fn)## 直接调库from sklearn.metrics import recall_scorerecall_score(y_test,y_log_predict) 4.F1调和平均值：两个不平衡的话很低，只有两个都很高才会高[0~1]12345678def F1(precision,recall): try: return 2*precision*recall/(precision+recall) except: return 0.0## 直接调库from sklxearn.metrics import f1_scoref1=f1_score(y_test,y_predict) 5.多分类的混淆矩阵http://scikit-learn.org/stable/modules/generated/sklearn.metrics.recall_score.html召回率和F值 ： 计算所有的TP和FN再二值方法计算average : string, [None, ‘binary’ (default), ‘micro’, ‘macro’, ‘samples’, ‘weighted’]binary 二值分类micromacro 不加权平均 5.PR曲线precision_recall_curve 用于比较两个模型和不同的超参数threadholds？ 6.TPR == recall #真的是1/真实为1的所有预测FPR 错误接受率FP/(FP+TN) # 多少正类被划分为负类的比例FRR 错误拒绝率 FN/(TP+FN) # 多少正类没被判成正类1234567891011121314def TPR(y_true,y_predict): tp = TP(y_true,y_predict) fn = FN(y_true,y_predict) try: return tp/(tp+fn) except: return 0def FPR(y_true,y_predict):#预测为1，预测错了 站真实值为0的百分比 fp = FP(y_true,y_predict) tn = TN(y_true,y_predict) try: return fp/(fp+tn) except: return 0 7.ROC和AUC 用于确定predict概率的阈值y_test = [0,1,0,0,0,1]y_pre = [0.1,0.8,0.6…] 是概率值确定一个阈值 超过才被判为正 ROC ： x轴：FPR y轴：TPR https://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p01_start_stop_thread.html https://jdtech.jd.com/#/more python 二维list转置星 解包12&gt;&gt;&gt; list(zip(*[[1,2],[3,4]]))[(1, 3), (2, 4)] list 平均值12345def averagenum(num): nsum = 0 for i in range(len(num)): nsum += num[i] return nsum / len(num) 列求和waitTime.apply(sum) pandas 行求和df[&#39;Col_sum&#39;] = df.apply(lambda x: x.sum(), axis=1) 矩阵乘法12345678&gt;&gt;&gt; a = np.array([[1,1],[1,0]])# 对应元素相乘&gt;&gt;&gt; np.multiply(a,a)array([[1, 1], [1, 0]])&gt;&gt;&gt; np.dot(a,a) #线代的乘积array([[2, 1], [1, 1]]) standardscaler（x-列均值）/ 列标准差 hausdorff距离衡量2个点集的距离度量了两个点集间的最大不匹配程度 location相关数据和数据处理关于time/location 数据处理https://www.kaggle.com/bqlearner/location-based-recommendation-systemGowalla数据集：https://snap.stanford.edu/data/loc-gowalla.html 垃圾短信分类 练习TODOhttps://blog.csdn.net/github_36922345/article/details/53455401 很详细的中文泰坦尼克号 pandas操作： 读csv多了一列unname pd.read_csv(&quot;Osaka_user_localtime.csv&quot;,index_col=0) 1.userpd.columns=userpd.columns.droplevel([0,1])2.df.set_index(&#39;date&#39;, inplace=True)列 -&gt;索引3.df[&#39;index&#39;] = df.index,df.reset_index(level=0, inplace=True)4.user_ca_ph.unstack(level=1)5.去掉不用的复合索引user_ca_ph_cnt.columns=user_ca_ph_cnt.columns.droplevel([0,1])6.填空user_ca_ph_cnt=user_ca_ph_cnt.fillna(0.)7.train_data[[&quot;Age_int&quot;, &quot;Survived&quot;]].groupby([&#39;Age_int&#39;],as_index=False).mean()8.找nullage_df_isnull = age_df.loc[(train_data[&#39;Age&#39;].isnull())]9.用dict替换掉一列123user_weight =[i/sum([30,53,334,16]) for i in [30,53,334,16]]dict(zip(["Amusement","Entertainment","Historical","Park"],user_weight))Osaka_cost["userweight"]=Osaka_cost["category"].map(usr_weight) 10.全部onehotpd.get_dummies(df)11.离散化，分桶,再向量化/onehot123456789101112train_data['Fare_bin'] = pd.qcut(train_data['Fare'], 5)0 (-0.001, 7.854]1 (39.688, 512.329]2 (7.854, 10.5]3 (39.688, 512.329]4 (7.854, 10.5] # factorizetrain_data['Fare_bin_id'] = pd.factorize(train_data['Fare_bin'])[0]# dummiesfare_bin_dummies_df = pd.get_dummies(train_data['Fare_bin']).rename(columns=lambda x: 'Fare_' + str(x))train_data = pd.concat([train_data, fare_bin_dummies_df], axis=1) pip镜像1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyclustering UTC 时间戳转localtime123456# 1346844688 -&gt; 2012-09-05 11:31:28Tor_user["UTCtime"] = pd.to_datetime(Tor_user['dateTaken'],unit='s')# 2012-09-05 11:31:28 -&gt; 2012-09-05 07:31:28-04:00Tor_user["Localtime"]=Tor_user.UTCtime.dt.tz_localize('UTC').dt.tz_convert('America/Toronto')# 2012-09-05 07:31:28-04:00 -&gt; 2012-09-05 07:31:28Tor_user["Localtime"]=Tor_user["Localtime"].apply(lambda x:x.strftime("%Y-%m-%d %H:%M:%S")) 标签传播LP算法（基于图）1.半监督学习的假设： 1）Smoothness平滑假设：相似的数据具有相同的label。 2）Cluster聚类假设：处于同一个聚类下的数据具有相同label。 3）Manifold流形假设：处于同一流形结构下的数据具有相同label。 2.相似度矩阵数据点为节点，包括labeled和unlabeled数据。边表示两点的相似度。假设图是全连接.边ij的权重$W_{ij}=exp(\frac{-||x_i-x_j||^2}{α^2})$ α是超参。另外可以构建KNN图 稀疏相似矩阵，指保留每个节点的k近邻权重，其它为0。 3.传播，权重越大传播概率越高 转移概率$P_{ij}=P(i-&gt;j)=\frac{w_{ij}}{\sum_{k=1}^nw_{ik}}$ 假设C个类，L个labeled的样本，则LxC矩阵$Y_L$i行是第i个样本的标签指示向量。如果第i个样本类别是j，则[i][j]为1，其它为0。 建立unlabeled的矩阵$Y_U$UxC同理。 合并得到NxC句矩阵。F=[Y_L;Y_U] (L+U=N行）保留样本i属于每个类别的概率。 4.算法步骤 F=PF：每个节点以P的概率传播给其它节点。 $F_L=Y_L$ (Y_L的标签是已知的，要保留，覆盖回原来的值) 重复以上两步直到F收敛。5.优化算法。$F_L$部分是不变的.浪费的计算。将概率转移矩阵变成$$P=\begin{bmatrix} P_{LL} &amp; P_{LU} \\ P_{UL} &amp; P_{uU} \\\end{bmatrix}$$只计算$F_U=P_{UU}F_U+P_{UL}Y_{L}$ 取决于无标签转移概率、有标签的相似度矩阵、无标签当前标签的转移概率。算法可以优化成并行的，切分F_U 1. Logistic 损失函数L：单个训练样本 $\hat{y}=p(y=1|x)$ 给定样本x的条件下，输出y=1的概率 成本(cost)函数J:全体训练样本$\frac{1}{m}\sum_{i=1}^mL(\hat{y}^{(i)},y^{(i)})$ cost：每个样本的乘积的最大似然估计 *1/m Logistic损失函数 $L(\hat{y},y) = -(ylog\hat{y}+(1-y)log(1-\hat{y}))$ 当y=1,$L =-log\hat{y}$ 让误差最小，则让$\hat{y}$大，$\hat{y}$经过sigmoid小于1 当y=0,$L = -log(1-\hat{y})$,则$\hat{y}=0$ 矩阵乘法：左向量组，列数是向量的维度；右线性空间；相乘：将向量组线性变换到新的线性空间。 右边的行数最少要满足由基地向量构成的线性空间维度。 特征向量：向量值发生了伸缩变换，没有旋转。伸缩比例是特征值。 梯度下降 $w=w-\alpha\frac{dJ(w,b)}{dw}$ $b=b-\alpha\frac{dJ(w,b)}{db}$ 反向传播 计算loss对每个变量的梯度，通过链式法则)a=sigmoid($\hat{y}$)正向传播:1.计算wx+b 2.经过sigmoid求出$\hat{y}$ 3.计算loss反向传播: da=loss对$\hat{y}$求导 dz = da*sigmoid求导 dw1 =dz*z对w1求导 向量化：不用一个for循环 正向传播 1.$z=w^Tx+b$ 2.np.dot(w.T,x)+b 3.$\hat{y}$=simgmoid(z) 反向传播 4.$dz = \hat{y} - y$ 5.dw = 1/m*np.dot(x,dz.T) 6.db = 1/m*np.sum(dz) 梯度下降 7.w = w-αdw 8.b = b-αdb以上for 梯度下降多少次 dcost = 1/m*np.sum(dz)- 创建一维向量不用要np.random.randn(5)因为a.shape=(5,)用： 列向量np.random.randn(5,1);行向量np.random.randn(1,5) 2. 浅层NNtanh是sigmoid的平移tanh效果好因为 激活函数平均值接近0，tanh在所有场景几乎最优 不用sigmoid了输出层用sigmoid：因为（0，1）之间的二分类问题 tanh和sigmoid的问题是z很大时，梯度很小，梯度下降效率低 $g’(tanh(z))=1-(tanh(z))^2$ ,$1-a^2$ ReLu:修正线性单元(rectified linear unit):ReLU:= $a=max(0,z)$ 只要z&gt;0,导数=1；z&lt;0,导数=0除了输出层，都用ReLU为激活函数 Leaky-ReLU：z&lt;0时让导数不为零，有一个很小低梯度max(0.01*z,z) 虽然有一半导数=0，但因为有足够多的隐藏单元另z&gt;0 $g’=1 if z&gt;0$ 神经网络初始化：不能初始化为0，这样两个隐藏单元会相同。$W^{[1]}$ = np.random.randn((2,2))0.01 使梯度较大$b^{[1]}$ = np.zero((2,1))$W^{[1]}$ = np.random.randn((2,2))0.01 二分类问题时da 最后一层$L(a,y) = -(ylog(a)+(1-y)log(1-a))$$da^{[1]} = -y/a + (1-y)/(1-a)$ bias偏差/variance方差 high bias -&gt; 欠拟合 -&gt;选择新的网络直到至少可以拟合训练集 high variance -&gt; 过拟合 -&gt;更多数据/正则化/回到1换模型 正则化- 高variance 过拟合 L2正则:w通常是一个高维参数矢量已经可以表达high variance 问题$+\frac{λ}2m||w||_2^2$ L1正则:$\frac{λ}m||w||_1$ 使用L1正则化，w最终会稀疏,w向量有很多0 Dropout随机失活 多用于图像 a3 表示三层网络各节点的值, $a3=[a^{[1]},a^{[2]},a^{[3]}]$ 权重转成0或1：d3=np.random.rand(a3.shape[0], a3.shape[1]) &lt; keepProb 删除节点：a3 = np.multiply(a3, d3) 为了不影响原来Z的期望，a3 /= keepProb http://archive.ics.uci.edu/ml/——最有名的机器学习数据资源来自美国加州大学欧文分校 http://aws.amazon.com/publicdatasets/美国人口普查数据、人类基因组注释的数据\维基百科的页面流量\维基百科的链接数据 http://www.data.gov——Data.gov启动于2009年，目的是使公众可以更加方便地访问政府的数据flavor 中加时间向量，对每一个flavor进行时序预测，sumflavor 有序字典 预测目标变量的值，则可以选择监督学习算法,需要进一步确定目标变量类型，如果目标变量是离散型，如是/否、1/2/3、A/B/C或者红/黄/黑等，则可以选择分类算法.k-近邻算法 线性回归 朴素贝叶斯算法 局部加权线性回归支持向量机 Ridge 回归决策树 Lasso 最小回归系数估计 科学函数库SciPy和NumPy使用底层语言（C和Fortran）编写，提高了相关应用程序的计算性能。 8.1 NumPy提供一个线性代数的库linalg，其中包含很多有用的函数。可以直接调用linalg.det()来计算行列式第9章 用分类算法来处理回归问题 15 MapReduce:数值型和标称型数据。 过去100年国内最高气温：每个mapper将产生一个温度，形如&lt;”max”&gt;，也就是所有的mapper都会产生相同的key：”max”字符串)集成算法生成多个分类器再集成 全选分类器 求平均 pandas 时间序列关键点：极大值，极小值or拐点 用关键点代替原始时间序列。 合并关键点序列时间下标 得到等长序列 Lance距离 无量纲。欧式距离缺点L:有量纲，变差大的变量在距离中贡献大。 FCM算法 每条时间序列属于各个类的程度。 ARIMA自回归综合移动平均Auto-Regressive Integrated Moving Averages. Number of AR (Auto-Regressive) terms (p)： 现在点使用多少个过往数据计算。 Number of MA (Moving Average) terms (q)：使用多少个过往的残余错误值。 Number of Differences (d)：非季节性的个数（小编：其实是否求导数）。 日期范围 pd.date_range(‘4/1/2012’,’6/1/2022’) 默认按天 pd.date_range(start=’4/1/2012’,periods=20) 每个月最后一个工作日 “BM”频率pd.date_range(‘1/1/200’,’12/1/2000’,ferq=’BM’) 规范化到午夜 WOM日期 Week of Month freq=’WOM-3FRI’每月第3个星期五5 时区 numpy random.rand(4,4) -&gt; 4x4的 array 12arr_alice = arr[5:8]arr_alice[0] =11 arr的值也会改变np 的切片和赋值不会copy arr[5:8].copy()arr_alice = arr[5:8].copy()显示复制，arr不会被改变 多维数组 arr2d[0][2] == arr2d[0,2] np.random.randn(7,4)生成正态分布的随机数names==&#39;bob&#39; [True,Fales] list,data[names==&#39;bob] boolean数组可以用于索引data[-(names==&#39;bob&#39;)] 花式索引arr[[4,3,0,6]] 获取第4、3、0、6 行 array([1,2,3]) from numpy import array list对应元素相乘：某个向量沿着另一个向量的移动量。array(list)*array(list2)对应元素相乘 .dtype 同构数据元素的类型 zeros(10) ones(10) 全0or全1数组 empty((2,3,2)) 创建没有任何具体值的数组 np.dot(arr.T,arr) 内积 nonzero(array) nonzeros(a)返回数组a中值不为零(Flase)的元素的下标 transpose([])转成array linspace(start,stop,num，endpoint=False)返回长为num的array 数值从start到stop渐变，endpoint=False递增 mat,matrix123- from numpy import mat, matrixmat([1,2,3])/matrix([1,3,4])mat([1,3,4])[0,1] #=3 矩阵相乘:矩阵相乘，multiply内积`mat(list)mat(list2).T` 内积 from numpy import shape 查看矩阵or数组的维数矩阵第一行元素jj[1,:]矩阵对应元素相乘:矩阵相乘还可以看成是列的加权求和矩阵相乘的MapReduce版本。??from numpy import multiply 1234multiply(mat(list),mat(list2))matrix([[ 2, 6, 12]])array(list)*array(list2)array([ 2, 6, 12]) 矩阵数组排序 .sort() 原地排序 结果占用原始存储空间 每个元素的排序序号： 123&gt;&gt;&gt; dd=mat([4, 5, 1])&gt;&gt;&gt; dd.argsort()matrix([[2, 0, 1]]) 数组/矩阵均值 .mean() 矩阵的逆.Ilinalg.inv(A) 矩阵要可逆必须要是方阵。如果某个矩阵不可逆，则称它为奇异（singular）或退化（degenerate）矩阵。 一种方法是对矩阵进行重排然后每个元素除以行列式。如果行列式为0，就无逆矩阵。 mat()*mat().I ≠1 计算机处理误差产生的结果 4×4的单位矩阵eye(4)/identity(4) 矩阵相关 行列式det(A) 秩 linalg.matrix_rank(A) 可逆矩阵求解 矩阵范数: 给向量赋予一个正标量值 到原点的距离 L1：Manhattan distance。z=[3,4] $||z||_1=3+4=7$各元素绝对值之和 任意阶范数公式) 二阶linalg.norm([8,1,6]) 欧式距离 sqrt((v1-v2)*(v1-v2.T)) 曼哈顿距离 sum(abs(v1-v2)) 切比雪夫距离：国际象棋国王的步数abs(v1-v2).max() 夹角cosθcos = dot(v1,v2)/(linalg.norm(v1)*linalg.norm(v2)) 汉明距离 汉明距离：shape(nonzero(v1-v2)[1])[0] ？编辑距离：A=”909”，B=”090”。A与B的汉明距离H(A, B) = 3，编辑距离ED(A, B) =2。 ？文本相似度simHash Jaccard(杰卡德) 集合 相似性系数：样本集交集与样本集并集的比值，即J = |A∩B| ÷ |A∪B|：两个文档的共同都有的词除以两个文档所有的词 杰卡德距离 1-J=（并-交）/并：12import scipy.spatial.distance as distdist.pdist(mat,'jaccard') 相关系数 相关距离（线性相关）coefficient 系数；12345mv1= mean(mat[0])mv2= mean(mat[1])std1= std(mat[0])std2= std(mat[1])cor= mean(multiply(mat[0]-mv1,mat[1]-mv2))/(std1*std2) 马氏距离 协方差是对角阵、单位矩阵（两个样本向量之间独立同分布） 马氏距离为欧式距离 马氏距离 量纲无关 协方差矩阵的逆：linalg.inv(cov(mat))inv()矩阵求逆 tp =mat.T[0]-mat.T[1] dis = sqrt(dot(dot(tp,covinv),tp.T)) 特征向量特征值 evals(特征值）,evecs（特征向量） = linalg.eig(mat) ?手工求特征值 12#求方程根roots(A) 还原矩阵 $A=Q∑Q^-1$ 123#特征值构成的对角阵sigma = 特征值*eye(m)特征向量*sigma*linalg.inv(特征向量) 矩阵求导:A向量（2·1）对B（3·1）求导，得到3·2的矩阵 model = ARIMA(ts_log, order=(2, 1, 2))！qiudaoresults_ARIMA = model.fit(disp=-1)plt.plot(ts_log_diff)plt.plot(results_ARIMA.fittedvalues, color=’red’)plt.title(‘RSS: %.4f’% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))plt.show()dic:key不存在，就会触发KeyError错误 假设验证 实验结果是否有统计显著性或随机性 归一化：转换成无量纲 标准化后的值= （标准化前的值-分量的均值）/分量的标准差 标准化欧氏距离方差的倒数为权重的加权欧氏距离123456789101112# 欧氏距离mat([[1,2,3],[4,5,6]])v12 = vmat[0]-vmat[1]sqrt(v12*v12.T)# 标准化#1.方差vstd = std(mat.T,axis=0)#2.（标准化前的值-所有值的均值/方差norm = (mat-mean(mat))/vstd.T#3.欧式距离normv12 = norm[0]-norm[1]sqrt(normv12*nromv12.T)]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>alg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[problems]]></title>
    <url>%2F2018%2F03%2F09%2Fproblems%2F</url>
    <content type="text"><![CDATA[跳转到文件sublime快捷键 Ctrl + P：跳转到指定文件，输入文件名后可以：idea：Crtl+N：定位到Java类，默认为定位项目中的java文件，如果你设置了开发包的Source，也可以定位到项目外的Java文件，如Jdk的原文件。Crtl+Shift+N：定位到文件，也包含项目的Java文件，所有项目中的其他文件，如xml，jsp，poperty文件均可以使用改方法定位。 windows bat定时自动提交123456789101112131415schtasks /create /tn autoPush /tr "cmd /cD:\iotacecil.github.io\pushBlog\_pushBlog.bat" /sc DAILY /st 10:31:00# _pushBlog.batcall D:call cd D:\iotacecil.github.iocall hexo g -dcall git fetchcall git mergecall git add .call git commit -m"windows自动提交定时任务"call git push#pause# call chcp 437 javaC 编码错误: 编码GBK的不可映射字符 //todo 鍐欑殑鐪熸槸闅剧湅 娓呴啋浜嗗啀鍐?Linux下为UTF-8编码，javac编译gbk编码的java文件时，容易出现“错误: 编码UTF8的不可映射字符”解决方法是添加encoding 参数：javac -encoding gbk WordCount.java Windows下为GBK编码，javac编译utf-8编码的java文件时，容易出现“错误: 编码GBK的不可映射字符”解决方法是添加encoding 参数：javac -encoding utf-8 WordCount.java javac -encoding UTF-8 xxx.javaidea ctrl+Q document git config –global gui.encoding utf-8 GC overhead limit exceeded 0x7fffffff指的不是单个数组的字间，而是整个用户态程序的寻址空间 32位的处理器的地址长度是32位,所以他能表示大最大地址是 2^32， 指针表示的是地址，所以指针也是32位的， 但是 windows 对内存做了分区, 进程可用的内存地址范围是 0x00010000 ~ 0x7FFFFFFF， 虚拟机traceroute超时没回应 不要把xshell的ctrl-c变成复制，不然没办法结束程序 IBM的文档总是跳转登录页面，左上角禁用js。 tampermonkey一直在向//cr-input.mxpnl.net发请求 fallthrough 是什么idea提示代码过长怎么办？ docker toolo安装 vb环境变量后面要加’\’ 获取不到ip 等 加速器DaoCloud 要在etc/docker/deamon.json里去掉最后的逗号 并且要service docker restart netty in action&gt;&gt;The POM for nia:utils:jar:2.0-SNAPSHOT is missing, no dependency information availablemvn install -pl utils java ASM coding=UTF-8 IDEA Push failed: Failed with error: fatal: Could not read from remote repositoryIDEA-&gt;setting-&gt;git -&gt; ssh executable -&gt;native PYDEVD_LOAD_VALUES_ASYNC=True; disable “Show command line afterwards”https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000749030-How-to-stop-interactive-console-running Intel MKL FATAL ERROR: Cannot load mkl_intel_thread.dll. hexo markdown的坑小胡子语法两个大括号会报错！！！！二维数组！！ windows 启动zookeeper Server闪退；环境变量里要设置JAVA_HOME变量]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS231]]></title>
    <url>%2F2018%2F03%2F09%2FCS231%2F</url>
    <content type="text"><![CDATA[4.1 backprop反向传播 链式法则的递归调用反向传播可以得到损失函数L因为$\frac{\partial L}{\partial x} = \frac{\partial L}{\partial z}\frac{\partial z}{\partial x}$利用上游传回的梯度 反向计算每个节点的本地梯度 最后一个节点的梯度总是1？ 加法门是gradient distributor加法节点之前的本地梯度是1,分支与上游又相同梯度 max门通过后本地梯度分别是0，1 （max只有一个值可以影响上游） mul乘法门 对上游值缩放]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About CentOS]]></title>
    <url>%2F2018%2F03%2F08%2FAbout-CentOS%2F</url>
    <content type="text"><![CDATA[重装mysql123456789101112131 删除Mysql yum remove mysql mysql-server mysql-libs mysql-server; find / -name mysql 将找到的相关东西delete掉； rpm -qa|grep mysql(查询出来的东东yum remove掉)2 安装Mysql yum install mysql mysql-server mysql-libs mysql-server; mysql远程连接1234567891011121314mysql&gt;update user set password=PASSWORD(‘123456’) where User='root';mysql -u root –pmysql&gt;use mysql;mysql&gt;update user set host = '%' where user = 'root';mysql&gt;select host, user from user;mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'jack'@’10.10.50.127’ IDENTIFIED BY '654321' WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGESmysql&gt;FLUSH PRIVILEGES#退出MySQL服务器mysql&gt;EXIT tophttp://www.cnblogs.com/peida/archive/2012/12/24/2831353.html coscmd1coscmd config -a k -s k -b iota-1254040271 -r ap-shanghai git 撤销commit1234567$ git logcommit 919a7ff091d04c9e4ec74124650ab82f2e68632f (HEAD -&gt; master)Author: cloudPC &lt;iotacecil@gmail.com&gt;Date: Sat Jan 26 16:59:27 2019 +0800 添加readmegit reset --hard 7fc926f89eb823608e9b63a6472120c7291d3457 虚拟机jupyter notebook建立ssh通道1ssh root@10.1.18.15 -L 127.0.0.1:1234:127.0.0.1:8888 权限 7种文件类型（-文件 d目录 l软链接） 文件a的访问权限为rw-r–r–，现要增加所有用户的执行权限和同组用户的写权限，下列哪些命令正确的是？正确答案: A C 你的答案: D (错误)A.chmod a+x g+w aaaB.chmod 764 aaaC.chmod 775 aaaD.chmod o+x g+w aaa chmod [] 模式 文件名 修改权限chmod u+x,g+w xxx.avi赋予执行chmod u=rwx file所有人chmod a=rwx filechomd 777 fild lsofLinux 系统中列出当前占用8080端口进程的命令()lsof -i:8080 123456789101112-a：列出打开文件存在的进程；-c&lt;进程名&gt;：列出指定进程所打开的文件；-g：列出GID号进程详情；-d&lt;文件号&gt;：列出占用该文件号的进程；+d&lt;目录&gt;：列出目录下被打开的文件；+D&lt;目录&gt;：递归列出目录下被打开的文件；-n&lt;目录&gt;：列出使用NFS的文件；-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）-p&lt;进程号&gt;：列出指定进程号所打开的文件；-u：列出UID号进程详情；-h：显示帮助信息；-v：显示版本信息。 netstat -tunplss -t tcp连接 fusion IOsourcesource: source 文件名 [参数] 在当前 shell 中执行一个文件中的命令。 网络模拟器？NS-3https://cloud.tencent.com/info/876b157473953159b1d582b9acec8d88.html localhost 免密访问：123$ ssh localhost$ ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa$ cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 静态ip 固定iphttps://blog.csdn.net/hzhsan/article/details/45224371123cd /etc/sysconfig/network-scripts/service network restart centos 安装GLPKtar -xzvf glpk-4.60.tar.gzconfiguremakemake installglpsol --math orienteering_problem.mod --data a8.dat --output &quot;./out&quot; kill -s 9 1827 Linux终止一个前台进程可能用到的命令和操作:正确答案: B 你的答案: A (错误)A.kill (后台进程)B.ctrl+cC.stopD.halt 查文件123456789find / -size 1500c，字符 c 表明这个要查找的文件的大小是以bytes为单位find / -amin -10 # 查找在系统中最后10分钟访问的文件find / -atime -2 # 查找在系统中最后48小时访问的文件find / -empty # 查找在系统中为空的文件或者文件夹find / -group cat # 查找在系统中属于 groupcat的文件find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件find / -mtime -1 #查找在系统中最后24小时里修改过的文件find / -nouser #查找在系统中属于作废用户的文件find / -user fred #查找在系统中属于FRED这个用户的文件 mysql -u root -p -h 192.168.3.109 -P 3306 -D lbs 验证redisps-ef |grep redisnetstat -antpl|grep redisredis-cli -h ip -p port ping shell wordcount:1cat wordcount.txt |sed 's/[,.:;/!?]/ /g'|awk '&#123;for(i=1;i&lt;=NF;i++)array[$i]++;&#125;END&#123;for(i in array) print i,array[i]&#125;' centos装python3123456789101112131415161718192021222324yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc makeyum -y install epel-releaseyum install python-pipwget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz#解压xz -d Python-3.6.4.tar.xztar -xf Python-3.6.4.tar#进入解压后的目录，依次执行下面命令进行手动编译./configure prefix=/usr/local/python3make &amp;&amp; make install#将原来的链接备份mv /usr/bin/python /usr/bin/python.bak#添加python3的软链接ln -s /usr/local/python3/bin/python3.6 /usr/bin/python#测试是否安装成功了python -Vvi /usr/bin/yum把#! /usr/bin/python修改为#! /usr/bin/python2vi /usr/libexec/urlgrabber-ext-down把#! /usr/bin/python 修改为#! /usr/bin/python2 visualbox扩容全局工具-虚拟硬盘df -lh 查看磁盘使用删掉一个dockerdocker imagesdocker ps -adocker stop j1docker rm j1docker rmi d23bdf5b1b1b 如果有图形界面可以安装分区工具？12yum install epel-releaseyum install gparted 新建硬盘 新建分区 1234567fdisk -lfdisk /dev/sda n #...一直回车 p #查看 w #保存rebootfdisk -l 设备 Boot Start End Blocks Id System/dev/sda1 * 2048 2099199 1048576 83 Linux/dev/sda2 2099200 16777215 7339008 8e Linux LVM/dev/sda3 16777216 67108863 25165824 83 Linux 创建卷 合并卷 1234567891011121314151617pvcreate /dev/sda3vgcreate sda333 /dev/sda3vgscan Reading volume groups from cache. Found volume group "sda333" using metadata type lvm2 Found volume group "centos" using metadata type lvm2vgmerge centos sda333df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 6.2G 5.7G 526M 92% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sdb1 16G 227M 15G 2% /data/dev/sda1 1014M 129M 885M 13% /boottmpfs 100M 0 100M 0% /run/user/0 调整逻辑卷大小 123456789101112131415161718lvextend -l+100%FREE /dev/mapper/centos-root Size of logical volume centos/root changed from &lt;6.20 GiB (1586 extents) to 30.19 GiB (7729 extents). Logical volume centos/root successfully resized.lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 30.19g swap centos -wi-ao---- 820.00m xfs_growfs /dev/mapper/centos-rootdf -lh文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 31G 5.7G 25G 19% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sdb1 16G 227M 15G 2% /data/dev/sda1 1014M 129M 885M 13% /boottmpfs 100M 0 100M 0% /run/user/0 ip -br addr ip太多VB显示不下 perf 监视java程序上下文切换情况 windows perfmon性能监视器 JDK自带的jvisualvm、jstack 修改主机名cat /ect/hostname 查找命令which ls ll tty终端 /dev/zero 零设备文件 /dev/null回收站 /dev/random 产生随机数 useradd tmpuser会在home下创建用户文件夹 df -h 查看存储容量 du -sh /usr 80%的空间占用是/usr tree -L 1树型显示一层 yum -y install tree 创建文件touch /home/{f1,f2}用集合创建两个文件{1..20}范围 copy -v-v, –verbose explain what is being done wc -l /var/log/messages显示文件行数 head tail查看头尾 less分页显示 grep &#39;root&#39; /etc/passwd在文件中用正则查找关键字的行 ll -a &gt;list.txt重定向到文件 RPM查找文件 r:读(cat,more head,tail) 目录(ls)w:写，追加(vi,echo 111&gt;file)但是不能删除 删除是上一级的权限 目录(touch新建目录，rm，mv，cp)x： 对目录可以(cd)目录的最高权限是x，文件最高权限是w 运行javajava xxx.class要在/etc/profile加入CLASSPATH=.:$JAVA_HOME/jre/lib/ext:source /etc/profile 文件系统 FHS文件层次结构标准颜色 黄色：表示设备文件 浅蓝色：链接（快捷方式） /usr(Unix Software Resource)软件/usr里面放置的数据属于可分享的与不可变动的(shareable, static) 相当于C:/windows /usr/local相当于c:/program/opt三方协力软件/etc配置文件/var系统运作相关/proc 进程：系统内存的映射/selinux：防火墙 ls -lh 查看文件属性pwd 当键目录ls -al --full-time完整显示文件修改时间 12345678# 查看 cpu 型号sudo dmidecode -s processor-version# 查看 cpu 个数grep 'physical id' /proc/cpuinfo | sort -u | wc -l# 查看核心数grep 'core id' /proc/cpuinfo | sort -u | wc -l# 查看线程数grep 'processor' /proc/cpuinfo | sort -u | wc -l fork 启动后台进程环境变量vi /etc/profile 软连接： 零拷贝：文件传输只通过内核空间传输给socket vi :q! 备份：cp server.xml server.xml.bak]]></content>
      <categories>
        <category>JVMlinux常用备注nginxredis配置</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python modules]]></title>
    <url>%2F2018%2F03%2F08%2FPython-models%2F</url>
    <content type="text"><![CDATA[方法默认参数是不可变对象12345678&gt;&gt;&gt; def add_end(L=[]):... L.append('END')... return L...&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END', 'END'] 正确方法：12345def add_end(L=None): if L is None: L = [] L.append('END') return L 协程和异步iodeque GIL线程安全的 list不安全copy：shallow copy 浅拷贝 id不一样。看起来隔离了，但是如果deque里[2]是一个可变对象list，拷贝的是索引 深拷贝：12import copyuser_deque2 = copy.deepcopy(user_deque) 多线程 global interpreter lock 全局解释器锁，python线程对应c中的线程一次只有一个线程在一个cpu上同一时刻只有一个线程在一个cpu上执行字节码。无法将多个线程映射到多个cpu上，并发受限 同时修改global变量的两个线程会不安全 py2和3不同。 按字节码行数/时间片，!!!!会释放全局解释器锁。io操作也会释放 123def add(a): a=a+1 return a 12345678&gt;&gt;&gt;dis.dis(add)2 0 LOAD_FAST 加载a 0 (a) 2 LOAD_CONST 加载1 1 (1) 4 BINARY_ADD 6 STORE_FAST 0 (a)3 8 LOAD_FAST 0 (a) 10 RETURN_VALUE Condition 条件变量两层锁：底层调用wait释放就能acquire。wait分配放入等待队列的锁，等notify。实现了__enter__和__exit__可以用with语句wait： 获得waitter锁 放到Condition的waiters双端队列里 会释放Condition的锁notify:从waiters队列弹出一个，释放waiter锁 Semaphore控制进入数量socketAF_IPX：linux进程间通信 SOCK_DGRAM：UDP 服务端.bind((&quot;0.0.0.0&quot;,8888))而不是127.0.0.1（本机局域网ip访问不到）客户端直接访问.connect((&#39;127.0.0.1&#39;,8888))并且send(&quot;&quot;.encode(&quot;utf-8&quot;))send的时候一定要发送byte类型 socket模拟http请求1234client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect((host,80))client.sent("GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection:close\r\n\r\n" .format(path,host).encode("utf8")) 装饰器 LEGB： encloseing函数内部与内嵌函数之间 【闭包】 装饰器与AOP reload 1. 函数元数据123456def f(): cc = 2 return lambda kk:cc**kk #不会因为f退出以后lambda访问不到ag = f()g.__closure__[0].cell_contents### 输出2 可以访问到cc 2. nonlocal嵌套的def中。允许修改修改嵌套作用域变量。把信息和回调函数联系起来：lambda or call timeout 是闭包内的一个自由变量，在setTimeout中timeout = k会创建本地timeout.nonlocal声明嵌套作用域下的变量 可修改参数的装饰器 为包裹函数添加一个属性函数，修改自由变量123456789101112131415161718192021from functools import wrapsimport timeimport loggingdef warn(timeout): def decorator(func): def wrapper(*args,**kargs): start = time.time() res = func(*args,**kargs) used = time.time() -start if used &gt;timeout: msg = '%s:%s&gt;%s' % (func.__name__,used,timeout) logging.warn(msg) return res #作为wrapper的一个属性 def setTimeout(k): nonlocal timeout timeout = k # 可以被调用 wrapper.setTimeout = setTimeout return wrapper return decorator 测试：123456789from random import randint@warn(1.5)def test(): print('int test') while randint(0,1): time.sleep(0.5)test.setTimeout(1)for _ in range(30): test() py2中没有nonnocal不能修改变量的引用，将timeout实现成一个可变对象12345def warn(timeout): timeout = [timeout] ... def setTimeout (k): timeout[0]=k hashable 不可哈希的元素有：list、set、dict可哈希的元素有：int、float、str、tuple unhashable type: ‘set’ ，dicc = {set([1]):222} set 不能当字典键 用frozenset12345#输出交集 if item&amp;frozenset(['2']): print item if item.intersection('2'): print item frozenset不可变 存在hash值 没用add\remove将集合作为字典的键值dict.update() 求并 123456a =frozenset([3])b =frozenset([2])list=[]list.append(a|b)listOut[12]: [frozenset(&#123;2, 3&#125;)] s.issuperset(t) 测试是否 t 中的每一个元素都在 s 中 Python虚拟机是单线程（GIL）只有I/O密集型才能发挥Py的并发行，计算密集型值需要轮询。 配置utf-8输出环境reload(sys)sys.setdefaultencoding(‘utf-8’) stringsplitlines() 按照行(‘\r’, ‘\r\n’, \n’)分隔splitlines(True)保留换行符 内置函数12345row = [p == '+' for p in line.split()[0]]#转换成T,F序列#对一个区间更改值row[i:j]=[not p for p in row[i:j]]all(row)#如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False； 返回对象的内存地址。 id(a)==id(b) issubclass(AA,A) AA是否是A的子类 python的=是引用 a=1,a=2 右值是int对象 id(a)改变数字&#39;{0:o},{1:x},{2:b}&#39;.format(64,64,64)八进制、16进制、2进制 enumerate 偏移值(index,value)for (offset,item) in enumerate(&#39;apple&#39;):print(item,offset)help(enumerate) 模块import syssys.path #模块搜索路径 roloadcopypython3 copy源码分析 immutable类型: int,float,complex |string tuple frozen set mutable: list,dict,set,byte arry copy使用各自的copy函数 12345copy.pyd[list] = list.copyd[dict] = dict.copyd[set] = set.copyd[bytearray] = bytearray.copy a= (1,2,[3]) tuple中的list可变a[1]=10 id(a) list的地址空间不变 12x= [[1,2,3]] y= x.copy(x)//y=copy.deepcopy(x) .copy(x) 浅id(x)!=id(y) id(x[0])==id(y[0]) .deepcopy(x) 深id(x[0])==id(y[0])递归调用 生成器 g = (x * x for x in range(10)) 每次调用next()遇到下一个yield返回 运算符重载 __getattr__ 点号运算 __getattribute__属性获取 __getitem__ 列表解析、元组赋值，map、for循环，索引、分片运算；L[::]分片是L(slice(,,)分片对象)的语法糖，getitem接收了slice对象 __get/setslice__已移除 __iter__ 迭代环境优先尝试iter 读文件 读文件的最佳方式for line in open(),readlines将整个文件加载到内存 while True：line = f.readline()比迭代器的for慢，因为迭代器以C语言速度运行，while循环版本通过py虚拟机运行python字节码迭代 for循环开始时，通过iter内置函数从迭代对象获得一个迭代器。返回的对象有next方法。 文件对象就是自己的迭代器。有自己的next方法 iter()启动迭代注解内置作用域 import builtins dir(builtins)前一半是内置的异常，后一半是内置的函数 LEGB法则python将最后扫描B模块 所以不需要导入 global123b=0def update(item): global w 在函数和类中对全局变量赋值，必须在该函数或者类中声明该变量为全局变量，否则经过赋值操作后，变量为本地变量。 第二章 .pyc保存py编译后的字节码（不是二进制码，py特定） PVM 虚拟机 py引擎编译得到的代码 pandas.Series是以时间戳为索引的 差分计算series.diff()切片 滞后观察（lag observation）列以及预测观察（forecast observation）resample 重采样、频率推断、生成固定频率日期范围 matplotlib动画lambda 匿名函数返回函数对象 列表解析mapord()返回单个字符的ASCII整数编码 map(f,list)将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 123456789101112131415161718192021res = list(map(ord,'spam'))res = [ord(x) for x in 'spam']#res =[115, 112, 97, 109][line.rstrip() for line in open('file').readlines()]list(map((lambda line:line.rstrip()),open('file')))#['aaa','bbb']listoftuple=[('bob',35,'mgr'),('amy',40,'dev')]list(map(lambda row:row[1]),listoftuple)#[35,40]#自己实现map def mymap(func,*seqs): res=[] for args in zip(*seqs): # *args 参数传递语法 可以收集多个序列 res.append(func(*args)) return resdef mymap(func,*seqs): return [func(*args) for args in zip(*seqs)] reduce:累积求和:sum(list)string2int zipzip是map的一个基本嵌套操作12list[zip([1,2,3],[2,3,4,5])]#[(1,2),(2,3),(3,4)] 列表中是表；元组为行，列是元组中的元素 cmp已经移除12345678910def tester(start): state = start #赋值过 def nested(lasted): nonlocal state #允许改变 必须已经在def作用域中赋值过 print(label,state) state+=1 return nestedF= tester(0)F('abc') #abc 0#每次调用F state都会+1 用函数属性实现nonlocal??P44012def tester(start): def nested(label): call让类看起来是一个可调用的函数123456789class tester: def __init__(self,start): self.state = start def __call__(self,lable): print(label,self,state) self.state+=1M = tester(99)M('juice')#juice 99#每次调用M state+1 operator b=operator.itemgetter(1) 获取对象的1索引 b(a) 获取 list a 的1索引 operator.itemgetter 定义了一个函数，作用到对象上获取值 与sorted一起用：sorted(dict,key = lambda x:x.values())按字典的values排序 按二维list中子元素的第三项排序 key = lambda student:student[2]/key = operator.itemgetter(2) operator.itemgetter(1,2) 第二项和第三项 panda 坑data = pd.read_csv(&#39;.\a.csv&#39;, parse_dates=[&#39;Month&#39;], index_col=&#39;Month&#39;,date_parser=dateparse) Only booleans, lists, and dictionaries are accepted for the ‘parse_dates’ parameter parse_dates=[&#39;Date&#39;] instead of parse_dates=&#39;Date&#39;]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java风格练习]]></title>
    <url>%2F2018%2F03%2F07%2Fjavastyle%2F</url>
    <content type="text"><![CDATA[BigIntegernumberOfTrailingZeros 二进制末尾0的个数 用时27比&gt;&gt;=2，while(i&amp;1==0)快很多 用时1721234567891011public static int numberOfTrailingZeros(int i) &#123; // HD, Figure 5-14 int y; if (i == 0) return 32; int n = 31; y = i &lt;&lt;16; if (y != 0) &#123; n = n -16; i = y; &#125; y = i &lt;&lt; 8; if (y != 0) &#123; n = n - 8; i = y; &#125; y = i &lt;&lt; 4; if (y != 0) &#123; n = n - 4; i = y; &#125; y = i &lt;&lt; 2; if (y != 0) &#123; n = n - 2; i = y; &#125; return n - ((i &lt;&lt; 1) &gt;&gt;&gt; 31);&#125; LinkedHashMap:LRU的写法123456@param accessOrder the ordering mode true for access-order访问顺序, false for insertion-order插入顺序public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) StringString+” “原来的string还是在的 要等垃圾回收必用方法：1.char[] toCharArray()123456 public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result;&#125; 2.String(char[]value) //offset,count123public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125; 3.每个字节对应的ASCII码1Arrays.toString(str.getBytes()) 4.startsWith(String prefix,int toffset)指定位置开始是否是prefix开头5.str.replaceAll(&quot;[0-9]&quot;,&quot;*&quot;),str.replaceAll(&quot;\\d&quot;,&quot;*&quot;)6.拆分返回String[]System.out.println(Arrays.toString(c1.split(&quot;\\d&quot;,4)));7.静态方法valueOf()转换各种类型为String 源码：1.final 的常量只能定义时赋值或在【默认】构造器里赋值一次12345private final char value[];public String(String original) &#123; this.value = original.value;//将常量池中的值赋值给新创建的String this.hash = original.hash;&#125; Object1.finalize 对象被回收时调用 不建议重写2.public final native Class&lt;?&gt; getClass(); 获取对象的方法区的类信息 Math.abs(Integer.MIN_VALUE+10085)=-2147473563 DecimalFormat保留两位小数System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi));百分比new DecimalFormat(&quot;#.##%&quot;).format(pi) 字符串存储 紧凑字符串Java 中的 char 是两个 bytes 大小.Java 9 中，引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改。所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。 字符串也出现了一些能力退化，比如最大字符串的大小。原来 char 数组的实现，字符串的最大长度就是数组本身的长度限制，但是替换成 byte 数组，同样数组长度下，存储能力是退化了一倍的！ 理论中的极限。 编码getBytes()/String (byte[] bytes) 等都是隐含着使用平台默认编码 字符串拼接在 JDK 8 中，字符串拼接操作会自动被 javac 转换为 StringBuilder 操作.JDK 9 里面则是因为 Java 9 为了更加统一字符串操作优化，提供了 StringConcatFactory，作为一个统一的入口。 StringBuffer 线程安全public synchronized StringBuffer append(String str) CharSequence字符序列类 12String c = a+b+1;//常量变量相加会产生5个对象 编译器会优化String d = "a"+1+2+"b";//常量相加只有一个对象 123StringBuffer sb = new StringBuffer(32);sb.append(a).append(b).append(1);//解决常量变量相加 产生3个对象sb.toString(); StringBuilder StingBuilder线程不安全 连接大量字符串 .append .toString() javap -c查看编译后的指令1.String a =&quot;a&quot;+1;会生成builder加入a12.String b = a+&quot;b&quot;;执行一次append1234String c=null;for(i in 5)&#123; c+=i;//会创建5个StringBuilder 应该用append拼接&#125; 字符串缓存String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。 一般使用 Java 6 这种历史版本，并不推荐大量使用intern，为什么呢？被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，就会OOM。 在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。 1-XX:+PrintStringTableStatistics Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。 使用下面参数开启，并且记得指定使用 G1 GC：-XX:+UseStringDeduplication JVM的 Intrinsic在运行时，字符串的一些基础操作会直接利用 JVM 内部的 Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是 Java 代码生成的字节码。-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining Intrinsic 机制 ：利用 native 方式hard-coded的逻辑，算是一种特别的内联，很多优化还是需要直接使用特定的 CPU 指令. clone 不用创建过程 不用重新计算对象的大小必须重写12345678910@Overridepublic Object clone()&#123; TreeNode newT = null; try&#123; newT = (TreeNode)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return newT;&#125; Comparable Comparator1.Arrys.sort:底层实现12Comparable pivot = (Comparable) a[start];if (pivot.compareTo(a[mid]) &lt; 0) 2.Comparator面向对象，对修改关闭对扩展开放新建类123xxxComparator implements Comparator&lt;T&gt;&#123; compare(T o1,T o2)&#123;&#125;&#125; sort传入比较器Arrays.sort(t1,new xxxComparator()) System1.时间123Date nowtime = new Date(System.currentTimeMillis());DateFormat df = new SimpleDateFormat("HH:mm:ss");String now = df.format(nowtime); 2..exit()退出JVM3.当前工作目录System.getProperty(&quot;user.dir&quot;) os.name/os.version/user.name/user.home/java.home/java.version4.安卓加载三方类库System.loadLibrary Runtime 不new靠静态方法获取对象 Runtime rt = Runtime.getRuntime();可用处理器数量rt.availableProcessors()jvm总内存数rt.totalMemory()jvm空间内存rt.freeMemory()jvm最大可用内存rt.maxMemory() 执行命令行命令rt.exec(&quot;notepad&quot;) java那些事ava API: Holder 对象 1000_000编译器会直接删除_ 十六进制p表示指数 $专门出现在自动产生的变量名中 方法外声明常量 static final （因为和对象无关，声明成类变量） 负数小心用% 浮点寄存器优化 strictfp修饰符 (int).. cast操作符警告 用Math.toIntExact会异常（越界or丢精度） java不允许对象使用操作符 必须调用方法 input.split(“\s+”)以空格分割 在null上调用方法会空指针异常，所以与字面量比较要将文字串放前&quot;word&quot;.equals(word) code point 有效的unicode值 Random (1L &lt;&lt; 48) - 1 Character也有cache1234567891011121314151617private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125;//This method will always cache values in the range '\u0000' to '\u007F', inclusive,public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; IntegerSIZE,BYTES常量 为了统一整数的位数Java 语言规范里面，不管是 32 位还是 64 位环境，开发者无需担心数据的位数差异。1234567891011121314151617// Bit twiddling/** * The number of bits used to represent an &#123;@code int&#125; value in two's * complement binary form. * * @since 1.5 */@Native public static final int SIZE = 32;/** * The number of bytes used to represent a &#123;@code int&#125; value in two's * complement binary form. * * @since 1.8 */public static final int BYTES = SIZE / Byte.SIZE; 缓存缓存机制并不是只有 Integer 才有，同样存在于其他的一些包装类缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：-XX:AutoBoxCacheMax=N Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例Boolean.TRUE/FALSE。 Short，同样是缓存了 -128 到 127 之间的数值。 Byte，数值有限，所以全部都被缓存。 Character，缓存范围 ‘\u0000’ 到 ‘\u007F’。 12Integer i3 =100;Integer i4= 100;i3==i4;//(true)同一个对象 享元模式：共享对象 将1字节以内的数缓存 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，这个值默认缓存是 -128 到 127 之间。 IntegerCache缓存数组 为避免重复创建对象 private static 内部静态类 只能在该类中访问,static用来做缓存new Integer(2)==new Integer(2) falseInteger.valueOf(2)==Integer.valueOf(2) true 变成1000的时候因为缓存不一样Integer.valueOf(2).intValue()==2 truenew Integer(2).equals(new Integer(2)) true 12345//缓存-128到127之间的值 cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); 展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 12Integer i3 =1000;Integer i4= 1000;i3==i4;//(false)new了两个对象 123456public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //没用cache返回了新对象 return new Integer(i); &#125; 结论：Integer要用equals char2int: b.charAt(i–)-‘0’; 自动装箱 / 自动拆箱是发生在什么阶段自动装箱是一种语法糖。保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。 javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为Integer.intValue() 性能优化建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。 使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势 euqals 没有实现equals的类：继承Object 1234public boolean equals(Object obj) &#123; //是否指向同一对象，equal和==相同 return (this == obj); &#125; Integer的实现 1234567891011public boolean equals(Object obj) &#123; //判断类型 if (obj instanceof Integer) &#123; //？？强制转型 return value == ((Integer)obj).intValue(); &#125; return false; &#125;public int intValue() &#123; return value; &#125; String实现 123456789101112131415161718192021222324public boolean equals(Object anObject) &#123; //指向引用 if (this == anObject) &#123; return true; &#125; //类型 写法注意！！ if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; //长度？？可以调用private的value if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; native native是由操作系统实现的，C/C++实现，java去调用。 Arrays.copyOf-&gt;System.arraycopy(org,0,copy,0,len) Java8 default方法：接口内部有方法实现；实现两个接口有同名default名字冲突-&gt;报错 synchronized JVM实现泛型和原始数据类型Java 的对象都是引用类型，如果是一个 原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。 导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。 java对象的内存结构对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头8字节 Mark Word:标记位 4字节：第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为”Mark Word”。 前4保存对象hash(3)，锁状态(1)后4存储对象所属类的引用。 数组还有4字节保存数组大小。 Integer Mark Word:标记位 4字节，类似轻量级锁标记位，偏向锁标记位等。 Class对象指针:4字节，指向对象对应class对象的内存地址。 对象实际数据:对象所有成员变量。 对齐:对齐填充字节，按照8个字节填充。 Integer占用内存大小，4+4+4+4=16字节。 java内存https://algs4.cs.princeton.edu/14analysis/http://yueyemaitian.iteye.com/blog/2034305https://blog.csdn.net/zhxdick/article/details/52003123 objectobject overhead 16+int 4 padded到4的倍数(-XX:-UseCompressedOops:)如果用压缩则-XX:+UseCompressedOops: mark/4 + metedata/8 + 4 = 16默认是启动压缩的 Objects. To determine the memory usage of an object, we add the amount of memory used by each instance variable to the overhead associated with each object, typically 16 bytes. Moreover, the memory usage is typically padded to be a multiple of 8 bytes (on a 64-bit machine). paddingThis can waste some memory but it speeds up memory access and garbage collection. reference// todo引用类型是内存地址，8字节2*ref(8)+enclosing(8)+16head = 40非静态有encolsing instance？指针的大小在bit模式下或64bit开启指针压缩下默认为4byte UseCompressOops开启和关闭，对对象头大小是有影响的，开启压缩，对象头是4+8=12byte；关闭压缩，对象头是8+8=16bytes。java -Xmx31g -XX:+PrintFlagsFinal |findstr Compress123uintx CompressedClassSpaceSize = 1073741824 &#123;product&#125;bool UseCompressedClassPointers := true &#123;lp64_product&#125;bool UseCompressedOops := true &#123;lp64_product&#125; References. A reference to an object typically is a memory address and thus uses 8 bytes of memory (on a 64-bit machine). arrays Arrays. Arrays in Java are implemented as objects, typically with extra overhead for the length. An array of primitive-type values typically requires 24 bytes of header information (16 bytes of object overhead, 4 bytes for the length, and 4 bytes of padding) plus the memory needed to store the values. 基本类型 16的obj head+4(len)+4padding = 24 +存的类型*长度 stringchar[] ref(8)+int(4)+head(16)+padding-&gt;32+char)=56+2N]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Front-end questions]]></title>
    <url>%2F2018%2F03%2F07%2FFront-end-questions%2F</url>
    <content type="text"><![CDATA[！当你在浏览器中输入 google.com 并且按下回车之后发生了什么https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst html元素&lt;base href=&quot;/&quot;&gt; 基础路径a[href,target] 默认target是当前页面（在新窗口打开）img[src,alt] alt图片显示失败的字label[for] 加上点单选框复选框的文字也可以选中框 queryURLParameter字符串拆分法熟练掌握 字符串方法 substr substring slice match展开代码 12345678910111213function queryURLParameter(url) &#123; let obj = &#123;&#125;; if (url.indexOf('?') &lt; 0) return obj; let ary = url.split('?'); url = ary[1]; ary = url.split('&amp;'); for (let i = 0; i &lt; ary.length; i++) &#123; let cur = ary[i]; curAry = cur.split('='); obj[curAry[0]]=curAry[1]; &#125; return obj;&#125; 正则12345678String.prototype.MyURLquery=function()&#123; let reg=/([^=&amp;?]+)=([^=&amp;?]+)/g, obj=&#123;&#125; this.replace(reg,(...arg)=&gt;&#123; obj[arg[1]]=arg[2]; &#125;) return obj;&#125; 闭包相关123456var a = 12;function fn()&#123;//变量提升声明var a但没有赋值 console.log(a); var a = 13;&#125;fn() //输出undefine 123//报错并不继续执行console.log(a);a=12;//没有声明var 不会变量提升 12345678var foo=1;function bar()&#123; if(!foo)&#123;//2.!undefined-&gt;true var foo=10;//1.变量提升 &#125; console.log(foo);&#125;bar()//输出10 1234567891011var n =0;function a()&#123; var n =10; function b()&#123;n++;console.log(n)&#125;&#125; b()//内部执行了一次 return b;&#125;var c=a()//执行输出11c()//输出12console.log(n)//输出0 123456function b(x,y,a)&#123; arguments[2]=10 console.log(a)&#125;c=b(1,2,3)console.log(a)//10 123456789101112var ary=[1,2,3,4]function fn(ary)&#123; //arr得到了全局arr的地址，可以改变全局 ary[0]=0 //变成另一个地址 ary=[0]//[0]是一个地址，arr指向了新的堆内存 ary[0]=100 return ary&#125;var res = fn(ary)console.log(ary)//输出(4) [0, 2, 3, 4]console.log(res)//输出[100] 12345678function fn(i)&#123; return function(n)&#123; console.log(n+(--i)) &#125;&#125;var f = fn(2)//输出f(3)//输出4f(4)//4 1234567891011121314151617var num = 10var obj = &#123;num:20&#125;//&#123;num: 30, fn: ƒ&#125;obj.fn=(function(num)&#123; console.log(this)//window this.num=num*3//自执行函数this是window num++//21 return function(n)&#123; console.log("内"+this)//window this.num+=n; num++//向上级作用域找//22 console.log(num) &#125;&#125;)(obj.num)var fn = obj.fnfn(5)//22 //this是windowobj.fn(10)//23 此时fn的this是objconsole.log(num,obj.num)//65，30 1234567891011121314151617181920function Fn()&#123; this.x=100; this.y=200; this.getX=function()&#123; console.log(this.x); &#125;&#125;;Fn.prototype=&#123; y:400, getX:function()&#123; console.log(this.x); &#125;, getY:function()&#123; console.log(this.y); &#125;, sum:function()&#123; console.log(this.x+this.y); &#125;&#125;;Fn.prototype.sum()//undefined+400=NaN 12345678910111213var name = 'window'var Tom =&#123; name:"Tom", show:function()&#123; console.log(this.name) &#125;, wait:function()&#123; var fun = this.show//Tom.show fun()//前面没有. &#125;&#125;Tom.wait()//windowTom.show()//Tom front-end @import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; H5 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; 表单控件 geolocation 对象 Web Worker js多线程:专用线程Dedicated Worker和共享线程 Shared Worker;Dedicated Worker只能为一个页面所使用，而Shared Worker则可以被多个页面所共享 离线缓存manifest 新建的.appcache文件的缓存机制(不是存储技术)像cookie一样缓存清单上的资源。 如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 html5shim HTML5 styling for Internet Explorer 6-9, Safari 4.x (and iPhone 3.x), and Firefox 3.x.123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; &lt;![endif]--&gt;]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2F2018%2F03%2F06%2FMathJax%2F</url>
    <content type="text"><![CDATA[变量MATH$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$`$$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[About SpringBoot]]></title>
    <url>%2F2018%2F03%2F06%2FAbout-SpringBoot%2F</url>
    <content type="text"><![CDATA[@Configuration注解的类通过简单地在调用同一个类中其他的@Bean方法来定义bean之间的依赖关系。 schedule常用cron表达式http://www.bejson.com/othertools/cron/123450 0 0 * * ? 每天0点一次0 0 23 * * ? 每天23点一次0 */1 * * * ? 每1分钟一次0 0 */6 * * ? 每6小时一次0 0 */1 * * ? 每1小时一次 MVC ViewResolver View 接口测试网络https://httpbin.org/#/ 打车app APIhttps://www.easyapi.com/api/?documentId=8067 spring自动装配context.getBean(.class)获取对象 AnnotationConfigApplicationContext(App.class)注解形式上下文，用component标识bean,scan扫描自动执行component的构造函数,@Autowire加在有参构造函数上，自动装配参数到当前类，实现类的关联 ClassPathXmlApplicationContext(&quot;.xml&quot;)不用注解，用&lt;bean&gt;,和ref在maven下resources和java都是源码的根目录，所以在java里面读resources里的文件可以直接.xml 将组件扫描ComponentScan与启动类分离 范围是所在包和子包，可以加(“”)相当于在xml里配置&lt;context:component-scan base-package=&quot;&quot;/&gt; 1234ApplicationContext context = new ApplicationConfigApplicationContext(AppCfg.class);//AppCfg.java@Configuration@ComponentScan 引入spring test 基于junit自动引入上下文12345@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes=AppConfig.class)//不用再创建context，也不用getBean,自动注入直接用@Autowiredprivate CDplayer cdplayer; @Autowired 使用 有参构造函数 成员变量 反射 效率低 setCD(CD cd)等setter方法上 @Autowired(required=false)用接口注入成员对象时有两个实现类时，使用@Primary或者使用限定符Qualifier(&quot;&quot;)相互对应，或者把限定符写在@Component(&quot;&quot;)里。默认的限定符是类名小写使用Resource(name=&quot;&quot;) = @Autowired+@Qualifier 是jdk自带的标准 配置文件详解公共配置 DispatcherServlet 需要定义一个[servlet-name]-servlet.xml配置文件 HandlerMapping Controllers view解析相关的 定义ContextLoaderListerner 并指定配置文件 @RequestMapping:consumes:处理特定请求类型，’Content-Type’RestAPI 12@RequestMapping(Path="/users/&#123;userId&#125;")public String webMethod(@PathVariable String userId) 登陆场景表单 12public void login(@ModelAttribute User user, Writer writer)&#123; &#125; 123@RequestMapping("/user/login")@ResponseBodypublic String login(@RequestParam("name") String name,@RequestParam("password")String password)throws IOexception&#123;&#125; 上传文件定义bean1&lt;bean id = "multipartResolver"class="...CommonsMultipartResolver"&gt; 123@RequestMapping(path="/form",method = RequestMethod.POST) public String handleForm(@RequestParam("file"), MultipartFile file)&#123; &#125; IOC容器：ApplicationContext类一个ApplicationContext对象就是一个容器。属于spring-context模块 初始化 WebApplicationContext:在web应用中初始化 web.xml 1.全局参数配置 12345&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:application-context.xml &lt;/param-value&gt;&lt;/context-param&gt; 2.加载上下文环境配置 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 3.servlet入口 12345678&lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4.添加servlet配置文件example-servlet.xml 名称符合spring标准：servletname-servlet &lt;bean &lt;context:component-scan base-package=&quot;&quot;/&gt;&gt; 5.@Controller @RequestMap(value=) `response.getWriter().write(&quot;&quot;);` 在测试.java的psvm中使用ApplicationContext context = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;); ApplicationContext context = new FileSystemXmlApplicationContext(&quot;.xml&quot;); Bean定义：&lt;bean id = &quot;bean类名&quot; class=&quot;类&quot;&gt; 获取对象 类名 a = context.getBean(&quot;bean类名&quot;,类.class） Bean作用域： singleton 默认&lt;bean scope=&quot;singleton&quot;&gt; prototype 每次引用创建一个实例web里仅有 Bean生命周期回调 创建&lt;bean init-method=&quot;init&gt; 销毁&lt;bean destory-method=&quot;cleanup&quot;&gt; 容器关闭:转换成支持close的子类 ((ConfigurableApplicationContext)context).close() 依赖注入 面向对象封装数据和方法，对象的依赖关系体现在对数据和方法的依赖上。把依赖注入交给框架or IOC完成，从具体对象手中交出控制（依赖关系）。Ioc容器是实现依赖控制反转的载体。在对象生成or初始化时直接将数据注入对象；？？注入对方法的调用的依赖：通过将对象引用注入对象数据域中的方法处理数据的对象和对象之间的相互依赖关系比较稳定。 强依赖（螺丝刀必须有刀头）：构造函数 可选依赖（可配置 颜色）：Setter方法 定义抽象接口，实现接口，以接口为基础注入 实现类有构造函数参数123456&lt;bean&gt; &lt;constructor-arg value = "值"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" vlaue =""&gt; &lt;constructor-arg type="java.lang.String" value=""&gt; &lt;constructor-arg name="color" value="red"&gt;&lt;/bean&gt; 注入集合Map&lt;String,String&gt; paras 每个key,value都是entry 123456&lt;constructor-arg&gt; &lt;map&gt; &lt;entry key = "color" value = "red"&gt;&lt;/entry&gt; &lt;entry key = "size" value = "15"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/constructor-arg&gt; 注入List &lt;list&gt;&lt;value&gt;14&lt;/value&gt;&lt;list&gt; &lt;set&gt;&lt;value&gt; 注入Properties对象 &lt;props&gt;&lt;prop key = &quot;color&quot;&gt;red&lt;/prop&gt; 配置文件 1234&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt;&lt;bean id = "headerProperties" class = "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name = "location" value = "classpath:header.properties"/&gt;&lt;/bean&gt; header-property: colr =green size =16 12Header heaer = context.getBean("header",子类.class);sout(header.getInfo()); bean 依赖 12345&lt;bean&gt; &lt;constructor-arg&gt; &lt;ref bean = "header"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 自动装配 不用构造函数&lt;constructor-arg&gt; &lt;bean autowire=&quot;byName&quot;&gt;/byType/constructor 使用setter方法 123public void setHeader(Header header)&#123; this.header = header;&#125; 用context.getBean(,.class)获取对象 注解 @Component定义Bean @Valueproperties注入Bean @Autowired&amp;@Resource自动装配依赖 如果后续会把springIOC去掉用后者(java标准javax.annotation.Resource) @PostConstruct&amp;PreDestroyBean的生命周期回调 使用注解 添加&lt;comtext:component-scan base-package=&quot;&quot;/&gt; @Component(“header”)和@value(“${color}”)替换 12&lt;bean id = "header"&gt;&lt;constructor-arg name = "color" value = "$&#123;color&#125;"&gt; 也不再需要setter函数 @Autowired 替换 &lt;bean autowire=&quot;byName&quot;&gt;不需要setter AOP完整的aop框架AspectJ Aspect非业务逻辑（日志、安全） Join point业务函数执行 Advice：切面在函数实现的功能。Aspect对函数打日志 5种类型 @Before 函数执行之前 @After returning 正常返回之后 @Around 函数执行前后 @After throwing 抛出异常之后 @After finally 函数返回之后 pointcut：匹配AOP目标函数的表达式+名称。哪些业务方法需要AOPexecution 匹配函数within 某个包某个类下面的函数*匹配所有 save*表示save开头的所有函数 所有public函数execution(public**(..)) 组合两个表达式execution(表达式1()&amp;&amp;表达式2() Aspectj使用 添加依赖 aspectjweaver.jar spring容器spring-context xml添加 xmlns:xml link space 类似于包 &lt;beans xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; http://www.springframework.org/schema/aop xsd:xml schema defination http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt; &lt;aop:aspectj-autoproxy /&gt; 新建Aspect类，定义类级别的@Aspect 添加&lt;bean&gt;配制（两个bean 切面和业务类） 定义Pointcut范围 匹配Caculator下的所有函数 123456@Aspectpublic class LoggingAspect &#123; @PointCut("execution(* ..Caculator.*(..)) &amp;&amp; args(a, ..)") private void arithmetic() &#123;//表达式的名称 &#125;&#125; 定义Advice：添加函数级别@Before(pointcut表达式/pointcut名称) Advice参数 获得上下文信息JoinPoint jp1234@Before("pointcut()")public void doLog(JoinPoint jp)&#123; //获得函数签名、函数参数 都是无类型的Object sout(jp.getSignature+","+jp.getArgs())&#125; @Around需要注入的是ProceedingJoinPoint pjp 获得函数的返回值 12@AfterReturning(pointcut="()",returning = retVal)public void doLog(Object retVal) 获得异常 是有类型的不是Exception 123@AfterThrowing(pointcut="()",throwing = "ex")public void doLog(IllegalArgumentException ex)&#123;&#125;&#125; 获得目标函数第一个参数 &amp;&amp;args(a,..) 12@Before("pc() &amp;&amp; args(a,..)")public void doLog(JoinPoint jp,int a)&#123;sout(a)&#125; Schema-based AOPaop:aspectJdbcTemplate DAO Data Access Object 数据访问接口由JDBC/Mybatis等ORM框架实现 spring-jdbc: 加载db配置文件&lt;context:property-placeholder location=&quot;db.properties&quot; /&gt; jdbc.driverClassName= com.mysql.jdbc.Driver jdbc.url= jdbc:mysql://:3306/example jdbc.username= jdbc.password= 配置数据源 1234567&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; 创建DAO类@Repository @Repository 定义一个Bean 代表DAO的bean,创建JDBC实例 1234567public class JdbcTemplateDao &#123;private JdbcTemplate jdbcTemplate;@Autowiredpublic void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource);&#125;&#125; application-context添加Autowired的搜索 1&lt;context:component-scan base-package="com.netease.course" /&gt; 数据转换成对象RowMapper 123456789new RowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setFirstName(rs.getString("first_name")); user.setLastName(rs.getString("last_name")); return user; &#125;&#125; NamedParameterJdbcTemplate JdbcTemplate 通过？传参，很多列的时候不明确this.jdbcTemplate.update(&quot;insert into user values (2, ?, ?)&quot;, &quot;Lei&quot;, &quot;Li&quot;); named where firest_name=:first_namequeryForObject(sql,Map&lt;Sting,?&gt;paramMap,RowMapper&lt;T&gt; rowMapper) SqlParameterSource在spring中用MapSqlParameterSource/BeanPropertySqlParameterSource(java对象（bean)) 异常处理SQLException是checked异常：需要捕获Spring的DataAccessException是unchecked异常 事务管理 MyBatisAOP 一组类共享相同行为（继承 @AspectAspectJ注解式切面 @Transcational 事务处理 @Cacheable 数据缓存 规则注解@interface 注解拦截类 @Action(name=””) 被拦截类 与（2）相同但是没有@Action 切面 @Aspect @PointCut声明切点：(“@annotation(注解(1))”) @After声明建言 反射： 电影例子 IoC控制反转 某一接口的实现控制权，从调用类中移除，由第三方决定 （导演选角色扮演者（具体实现类），放到电影中） DI 依赖注入 让调用类对某一实现类的依赖由第三方来注入。移除调用类对某一实现接口的依赖。 构造函数注入（构造函数的参数）:传入扮演者 1234567//电影 ljm; 构造函数（ljm)&#123;this.ljm = ljm&#125;//导演ljm = ldh；//(角色=演员)电影= 电影（ljm）wjd.action Setter并不是电影每个场景都要用到LJM-&gt;属性注入 123456//电影ljm;set(ljm)&#123;this.ljm=ljm;&#125;//导演电影.set(ljm)电影.action 接口注入 与属性注入没用本质区别 123456789interface&#123; void inject(ljm);&#125;电影 implements interface&#123; inject(ljm)&#123;this.ljm = ljm;&#125;&#125;导演&#123; 电影.inject(ljm)&#125; 注解 描述类和类之间的依赖关系自动完成类的初始化和依赖注入 1234//实例化&lt;bean id ="ljm" class = "ldh"/&gt; //ljm = new ldh;//建立依赖&lt;bean id ="wjd" class = "wjd" p:ljm-ref ="ljm"/&gt; 从容器中返回bean实例 SpringMVC前端调度器把请求分发给业务控制器，把生成的数据分发给视图模板。 js deguggger watch springboot遇到过的注解创建API@ResponseBody 标注返回值是json：在response的header中塞入contentType @Controller 修饰class创建http请求 @ResController -&gt; @RequestMapping(“/hello”)返回json method=RequestMethod.GET @Component -&gt; @Value(“${application.properties(属性名)}”) 单元测试： 随机数 1$&#123;random.value&#125; + $&#123;random.long&#125; + $&#123;random.int(10)&#125; + $&#123;random.int[10,20]&#125; --是对application.properties 中属性的标识-屏蔽命令行访问属性设置SpringApplication.setAddCommandLineProperties(false) -多环境配置文件格式application-{profile}.properties-激活spring.profiles.active = dev @RestController -&gt; @RequestMappint(value=”users”)等于@controller+ResponseBody 将java类用Jackason转换为JSON RequestMapping(“/“) GetMapping(“/get1”) PostMapping(“/postJson”) @RequestBody 对象 @RequestParam 接收?后的query参数 @ModelAttribute User user 绑定参数 @PathVariable url路径中的参数 绑定value=”/{id}” 12345@GetMapping("/hotels/&#123;htid&#125;/rooms/&#123;roomId&#125;")public Room getRoomById( @PathVariable String htid, @PathVariable Integer roomId)&#123;&#125; map.addAttribute(“host”,””) -&gt; th:text =”${host}” 使用Swagger2mvn依赖写法检索 mvnrepository12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; @Configuration 加载类配置 @Bean 标记的方法会在容器启动自动执行，并且创建的对象是单例的 跨域问题cors 协议、域名、端口不同 浏览器对ajax xhr的限制 jsonp 动态创建script 在script里发出请求（现在不用 只能get 原理：后台约定super(“callback”)=&gt;前台?callback=Jquery 函数名 参数值 12345678910111213$.ajax(&#123; url: base+"/get1", dataType: "jsonp", 后台约定 jsonp:"callback2", //结果可以被缓存 缓存-&gt;无&amp;_ cache: true, //返回的结果保存到result字段 success: function(json)&#123; //要求返回js代码。但是普通ajax请求，后台返回了json对象。加切面 result= json; &#125; &#125;) 查看返回类型：Network-&gt;右键-&gt;Response Headers-&gt;Content-Type ?calLback= json对象-&gt;函数调用 被调用方，返回允许调用client-&gt;另一个http服务器 在http服务器添加响应头 在应用服务器上添加跨域请求多了Origin:当前域名 @Bean FilterRegistrationBean 12bean.addUrlPatterns("/*")//所有请求都经过filterbean.setFilter(new CrosFilter()) doFilter 1234res.addHeader("Access-Control-Allow-Origin","http::")//,"*"允许所有域res.addHeader("Access-Control-Allow-Methods","GET")//,"*"//filter链chain.doFilter(,) 简单请求：GET/HEAD/POST；无自定义头；Content-Type 为&quot;text/plain&quot;`multipart/form-dataapplication/x-www-form-urlencoded` 非简单：put,delete、发送json、带自定义头的ajax； 调用方 代理，隐藏跨域http服务器-&gt;http服务器 Spring解决跨域 @CrossOrigin +类or方法上面 反向代理： 访问同一个域名的两个URL,去两个不同的服务器 J2EE架构 Apache/Nginx(处理静态请求、负载均衡）判断静态请求（js\css-&gt;直接返回给客户端； 动态请求（与用户数据有关的）客户端-&gt;http服务器-&gt;后台应用服务器(tomcat) IOC控制翻转 通过 DI依赖注入 实现spring-contextIOC容器创建Bean，将功能类Bean注入到Bean中。 配置元数据：xml配置、注解、java配置Spring容器解析配置元数据 Bean初始化、配置和管理依赖。 声明Bean的注解： @Component @Service @Repository @Controller 注入Bean @Autowired @Inject @Resource 用在set方法or属性上 编写功能类业务Bean的注解配置@Service，@Component，@Service，@Repository，@Controller 声明是Spring管理的Bean 使用功能类 @Autowired 注入Bean 添加功能 配置类（空的） @Configuration。@ComponentScan 自动扫描@Service，@Component,@Repository,@Controller的类 注册为Bean 运行 AnnotationConfigApplicationContext是Spring容器，参数：配置类(3).class 使用功能类（2） = 容器.getBean((2).class) 容器context.close() Java 配置 （1）、（2）不适用@Service和@Autowired;(2)+set (3)配置类不使用Scan包扫描 @Bean @Bean（1）返回名称为方法名（type:功能类）的Bean 法1：@Bean (2).set(1) 注入并直接调用(1) 法2：（2）直接传参(1) 123456789101112131415@Configuration //1public class JavaConfig &#123; @Bean //2 public FunctionService functionService()&#123; return new FunctionService(); &#125; @Bean public UseFunctionService useFunctionService()&#123; UseFunctionService useFunctionService = new UseFunctionService(); useFunctionService.setFunctionService(functionService()); //3 return useFunctionService; &#125;&#125; 只要容器中有Bean就可以在另一个Bean的方法参数中传入全局配置使用Java配置（数据库，MVC）]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射&静态代理&动态代理]]></title>
    <url>%2F2018%2F03%2F06%2FjavaAnnotation%2F</url>
    <content type="text"><![CDATA[反射 java.lang.reflect.* 反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。 在运行中分析类能力；运行中查看对象；Method对象 Class 是java基础类。虚拟机创建Class的实例。 三种方法获取class：对象.getClass。类.class。Class.forName（抛异常） 实例化对象： Class cls = Class.forName(className) （静态方法）获得类名的Class对象 cls.newInstance()调用className的默认无参构造方法，返回className类型) 获取所有构造方法 1Constructor&lt;?&gt;[] cs = acla.getDeclaredConstructors(); getModifiers()获得修饰符 获得指定参数的构造方法 会抛异常 1Constructor&lt;Bank&gt; c = b.getConstructor(Integer.class,Integer.class); 通过构造器得到实例 抛异常 1c.newInstance(1,3); 获取类的所有成员变量，get/set设置获取属性 1234//获取publicField[] fi = bb.getFields();//获取所有属性包括私有属性Field[] dd = bb.getDeclaredFields(); 获取修饰符 12int modifiers = f.getModifiers();System.out.println(Modifier.toString(modifiers)); 获取所在的包Package getPackage() 获取公共方法（包括继承Object的 123Method[] methods = bb.getMethods();//调用方法methods[0].invoke(对象,参数); getDeclaredFields()不包含父类方法，包括私有方法。 但是私有方法不能invoke 调用私有方法:去除修饰符检查 12methods[3].setAccessible(true);methods[3].invoke(b); AccessibleObject反射提供的 AccessibleObject.setAccessible (boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员访问限制！ setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。 比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。 绕过 API 访问控制。我们日常开发时可能被迫要调用内部 API 去做些事情，比如，自定义的高性能NIO框架需要显式地释放DirectBuffer，使用反射绕开限制是一种常见办法。 在 Java 9 以后 引入了 Open 的概念，只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible； 注解12345@Target(ElementType.TYPE)//类注解@Retention(RetentionPolicy.SOURCE)//编译时会被忽略public @interface ThreadSafe &#123; String value() default "";&#125; 代理模式：为其他对象 提供一种代理以控制对这个对象的访问。代理类负责为委托类进行预处理 （安全检查、权限检查）或执行完转发给其它代理。 静态代理：为对象提供一种代理，控制这个对象的访问 对一个方法添加计算时间的业务 静态代理在于在运行期之前就有已经写好的actionProxy implements Action代理类展开代码 123456789101112131415161718192021222324252627282930313233//3.在真正的业务方法之前取一下时间，计算耗时//分离业务逻辑 同时实现相同的接口 代理使用（当作一个属性）业务类class actionProxy implements Action&#123; public Action action;//被代理对象 public actionProxy(Action action)&#123; this.action= action; &#125; public void doAction()&#123; //可以添加权限操作 long start = System.currentTimeMillis(); action.doAction(); long end = System.currentTimeMillis(); System.out.println("耗时"+(end-start)); &#125;&#125;//1.通过一个接口interface Action&#123; public void doAction();&#125;//2. 接口的实现类是具体的工作//没有代理的时候这个类依然能正常使用class UserAction implements Action&#123; public void doAction()&#123; System.out.println("用户工作逻辑"); &#125;&#125;public class staticproxy &#123; public static void main(String[] args) &#123; Action action = new UserAction(); actionProxy pro = new actionProxy(action); pro.doAction(); &#125;&#125; 动态代理 动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。 通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。 简单指定一组接口及委托类对象，动态获得代理类。 动态代理是基于什么原理？ 实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。 .reflect.Proxy 静态方法，动态生成代理类及其对象 .reflect.InvocationHandler//代理类实例、被调用的方法对象、调用参数。进行预处理或分配到委托类实例上执行。public Object invoke(Object proxy, Method method, Object[] args) 动态代理创建对象的4步1.实现InvocationHandler 创建调用处理器2.指定ClassLoader对象和一组interface创建动态代理类。Class clazz = Proxy.getProxyClass(classLoader,new Class[]{});3.通过反射获得动态代理类的构造函数，参数类型是调用处理器接口Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});4.通过构造函数创建动态代理类实例，将调用处理器作为参数Interface Proxy = (Interface)construct.newInstance(new Object[]{handle}); JDK实现这种实现仍然有局限性，因为它是以接口为中心的，相当于添加了一种对于被调用者没有太大意义的限制。我们实例化的是Proxy对象，而不是真正的被调用类型，这在实践中还是可能带来各种不便和能力退化。 Spring代理 Bean有实现接口：用JDK动态代理 没有实现接口用CGlib 对接口的依赖被克服了 强制使用CGlibhttps://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; cglib和jdkproxycglib 动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。 JDK Proxy 的优势：最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。代码实现简单。 基于类似 cglib 框架的优势：有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。只操作我们关心的类，而不必为其他相关类增加工作量。高性能。 Proxy中的newInstance封装了2-4直接返回了4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; 可以代理多个接口 展开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//1.生成代理类的类class CreateProxy implements InvocationHandler&#123; //2.被代理的对象 private Object target; //3 创建代理的方法 public Object create(Object target)&#123; this.target=target; //获得所有的接口getInterfaces Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); return proxy; &#125; //4.业务代码 @Override //代理类，被代理的方法，方法的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始"); method.invoke(target,args); System.out.println("结束"); return null; &#125;&#125;class Person implements Subject&#123; public void shopping()&#123; System.out.println("买东西"); &#125;&#125;interface Subject&#123; public void shopping();&#125;public class dynamicProxy &#123; public static void main(String[] args) &#123; //创建代理对象的对象 CreateProxy cp = new CreateProxy(); //被代理的对象 Subject person = new Person(); //代理 强制转换成被代理的类型 Subject proxy = (Subject)cp.create(person); //会调用invoke proxy.shopping(); &#125;&#125; 多一个接口,使用同一个代理对象1234567interface Hotel&#123;public void live();&#125;class Person implements Subject,Hotel&#123;live()&#123;&#125;&#125;@TestCreateProxy cp = new CreateProxy();Person person = new Person();Hotel proxy = (Hotel) cp.create(person);proxy.live(); proxy.getClass().getName() 是$Proxy0 不是InvocationHandler类型，是运行时动态生成的一个对象。1234Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); .newProxyInstance实现JavaCompiler编译器cglib动态代理（类）底层使用SM字节码生成比java反射效率高，但是要注意final通过继承和重写 类加载器类加载器类加载：.class文件中的二进制数据，读入内存方法区，在堆中创建Class对象，封装方法区中的对象。主动引用被动引用 JavaBean规范 private,get/set能被IDE识别Apache BeanUtils 内省Java探针agent注解编译时注解 JDK：@Override，@Deprecated，@Suppvisewarnings@Autowired 自动注入 异常 未检查异常:访问null引用 不查看异常处理器（handler) 已检查异常：编译器检查是否提供了处理器&gt; 无处理器&gt; 终止 Throwable 是Exception类的超类 123catch(Exception e)&#123; e.printStackTrace()&#125;]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS224]]></title>
    <url>%2F2018%2F03%2F05%2FCS224%2F</url>
    <content type="text"><![CDATA[Word2Vec 词向量 one-hot p=[0,.,0,1,0,..0]用 Hash 表给每个词分配一个编号 维数灾难;词汇鸿沟”现象：任意两个词之间都是孤立的。 deeplearning：Distributed Representation实数向量[0.792, −0.177, −0.107, 0.109, −0.542, …]维度以 50 维和 100 维比较常见。相似的词可以计算距离or Cos Distributed representation 用来表示词，通常被称为“Word Representation”或“Word Embedding”，中文俗称“词向量”。相似词的词向量距离相近，这就让基于词向量设计的一些模型自带平滑功能，让模型看起来非常的漂亮。σ() softmax number -&gt; 分布 ??证明σ(-x) = 1-σ(x) skip gram一个词有两个向量，v 中心词向量 u 上下文向量U(like)’V(deep) 两个词共同出现的概率（max)分母是词汇表 binary logistic regression J(θ)：T窗口;j~P(w)随机抽取语料库的单词（min) 随机 unigram distribution U(w) 3/4 Stochastic gradients continuous bag of words(CBOW)：通过周围词向量的和来预测中心词而不是单个邻接词（skip gram) Cross entropy 交叉熵（loss for softmax) Context({})向模板提供数据 对co-occurrence矩阵降维： ！！！SVD singular value decomposition 奇异值分解$A=UΣV^T$ m*n的矩阵对角化-&gt;特征值、行列式、幂、指数函数 n阶矩阵相似于对角阵 &lt;=&gt;有n个线性无关的特征向量 实对称正交相似于对角阵 $Q^TAQ=Λ=diag(λ1…λn)$（特征值） 正交矩阵$Q=(v_1…v_n)$：$Av_i=λ_iv_i$ $Q^TQ=E$ $AV = UΣ$-&gt;V和U展开-&gt;Σ展开-&gt;r=rank(A)-&gt;$Av_i=σ_iu_i(i∈（1,r));Av_j=0$-&gt;两边转置-&gt;$A^TU=VΣ^T$-&gt;$A^Tu_i=σ_iv_i$ $A^TAv_i = σ_i^2v_i$(特，特向) $AA^Tu_i = σ_i^2u_i$原理 A(mxn)-&gt;$AA^T$为m阶实对称$A^TA$n阶实对称 特征值非负 证明：$x^TA^TAx = λx^Tx$-&gt;$||Ax||^2(&gt;=0)=λ||x||^2(&gt;0)$ $A^TA$与$AA^T$非零特征集合相同 证明:$r(AA^T)=r(A^T),r(A^TA)=r(A)$-&gt; $r(AA^T)=r(A^TA)=r(A)=R$几何意义：旋转、伸缩、旋转 $R^n-&gt;R^m x-&gt;Ax$变换 $x-V^Tx$旋转 $Σ$ 对前r个分量做伸缩 ??交叉熵与Kullback-Leibler derivative导数，gradient梯度 $timeit max-margin sigmoid函数求导:$ \frac{σ(y)}{dy}=σ(y)·(1-σ(y))$,接近0 梯度最大 语言模型Dynamic Memory NetworkDynamic Memory NetworkA Joint Many-Task Model:Growing a Neural Network for Multiple NLP Tasks 统计学习方法学习策略 感知机： $w·x+b=0$是平面 误分点到平面距离$(w·x_i+b)$,乘错误点的输出$·y_i$ 正确的点 输出和平面函数是一样的。 损失函数：所有误分点距离取正 min损失函数，对w,b求导；梯度下降 w+学习率(0,1]·对w求导；同理b。 损失函数3种： 结构风险函数： 正则化]]></content>
      <categories>
        <category>机器学习和数据处理python备忘</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统+内存知识]]></title>
    <url>%2F2018%2F03%2F05%2Fmemory%2F</url>
    <content type="text"><![CDATA[7200rpm的机械硬盘平均寻道时间是 9ms? 奇校验：原始码流+校验位 总共有奇数个1 偶校验：原始码流+校验位 总共有偶数个1 虚拟内存下列关于虚拟内存的描述正确的是：正确答案: A B D 你的答案: A (错误)A解放物理空间的存储管理, 使得数据被分配的地址与逻辑上程序执行的上下文解耦。B提供进程之间的地址空间隔离，防止进程访问地址越界或非法。C在多进程中，应避免进程的虚拟空间地址映射到相同的物理空间地址。D简化在链接阶段分配地址空间。 打印机某计算机系统中有8台打印机，有K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值是：正确答案: C 你的答案: B (错误)A 2B 3C 4D 5 假设每个进程已经占有了两个打印机，那么只要还有多的打印机，总能满足达到3台的条件。将8台打印机分给k个进程，每个进程有2台打印机。 这种情况是极端情况，k为4，不死锁需要2k+1&lt;8，最多支持3个进程并发。 程序访问文件的方式1.利用操作系统内核缓冲区2.直接IO：不经过内核缓冲区，数据库系统。缓存由应用程序实现。3.同步4.异步5.内存映射。内存与磁盘共享，减少从内核到用户缓存的数据复制。 文件描述符FileDescriptor.sync()可以将操作系统缓冲强制刷新到物理磁盘。 从磁盘读取文件的过程 块特殊文件块特殊文件和字符特殊文件的基本差别是什么？ 答：块特殊文件包含被编号的块，每一块都可以独立地读取或者写入。而且可以定位于任何块，并且开始读出或写入。这些对于字符特殊文件是不可能的。 lseek有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用：lseek(fd,3,SEEK_SET);read(fd,&amp;buffer,4);其中lseek调用寻找文件中的字节3。在读取操作完成之后，buffer中的内容是什么？答：包含字节：1，5，9，2. 中断和陷入陷阱是由程序造成的，并且与它同步。如果程序一而再地被运行，陷阱将总在指令流中相同的位置的精确发生。而中断则是由外部事件和其他时钟造成的，不具有重复性。 流水线 指令数一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns。这台机器每秒可执行多少条指令？答：从管道中每纳秒出现一条指令。意味着该机器每秒执行十亿条指令。它对于管道有多少个阶段不予理睬，即使是10-阶段管道，每阶段1nsec，也将执行对每秒十亿条指令。因为无论哪种情况，管道末端输出的指令数都是一样的。 4级存储 读取平均时间假设一个计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要2ns，RAM需要10ns，硬盘需要10ms。如果缓存的命中率是95%，内存的是（缓存失效时）99%，读取一个词的平均时间是多少？答：平均访问时间 = 2ns 0.95 + 10ns 0.99 (1-0.95) + 10ms (1-0.99) *(1-0.95) = 5002.395ns . 内核态下面哪一条指令只能在内核态使用？ a 禁止所有的中断b 读日期-时间时钟c 设置日期-时间时钟d 改变存储器映像 选择 a、c、d 扇区读取时间？ 寻道时间+旋转延迟+传输时间一个255GB大小的磁盘有65535个柱面，每个柱面255个扇区。每个扇区512字节。这个磁盘有多少盘片和磁头？假设平均寻道时间为11ms,平均旋转延迟为7ms,读取速度100MB/s,计算从一个扇区读取400kb需要的平均时间。 磁头数= 255 GB /（65536 255 512）= 16盘片数量= 16/2 = 8读取操作完成的时间是寻道时间+旋转延迟+传输时间。 寻道时间为11 ms，旋转延迟为7 ms，传输时间为4 ms，因此平均传输时间为22 ms。 假设一个10MB的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是100MB/s。 找到文件需要的时间=1 50 ms (移动到50轨道号的时间) + 5 ms (旋转到文件开始部分存储在的扇区的时间) + 10/100 1000 ms (读取10MB的时间) = 155 ms cache行的原因4.为了使用高速缓存，主存被划分为若干cache行，同城每行长32或64字节。每次缓存一整个cache行，每次缓存一整行而不是一个字节或一个字，这样的优点是什么？ 经验证据表明，存储器访问表现出引用局部原则，即如果读取某一个位置，则接下来访问这个位置的概率非常高，尤其是紧随其后的内存位置。 因此，通过缓存整个缓存行，接下来缓存命中的概率会增加。 此外，现代的硬件可以将32或64字节块整个传输到高速缓存行，比单个字节读取，总共读32或64字节的速度要快得多。 进程从运行状态进入就绪状态的原因可能是?正确答案: D 你的答案: B (错误)A被选中占有处理机B等待某一事件C等待的事件已发生D时间片用完 假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1,2,3,1,2,4,2,3,5,3,4,5,6会产生()次缺页6注意：缺页定义为所有内存块最初都是空的，所以第一次用到的页面都产生一次缺页。 多道程序：多道宏观上并行微观上串行充分利用CPU。减少CPU等待时间。 分时操作系统：可以人机交互 以时间片为单位轮流为各个用户/作业服务。 链接 文件共享https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html#fig2 链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。12345678# 查找 软链接[root@localhost ~]# find -lname wordcount.sh./wdc.link# 查找硬链接[root@localhost ~]# find -samefile wordcount.sh./wordcount.sh./wdc VFS Linux的文件系统 1.网络文件系统，如 nfs、cifs 等；2.磁盘文件系统，如 ext4、ext3 等；3.特殊文件系统，如 proc、sysfs、ramfs、tmpfs 等。 实现以上这些文件系统并在 Linux 下共存的基础就是 Linux VFS（Virtual File System 又称 Virtual Filesystem Switch），即虚拟文件系统。VFS 作为一个通用的文件系统，抽象了文件系统的四个基本概念：文件、目录项 (dentry)、索引节点 (inode) 及 挂载点其在内核中为用户空间层的文件系统提供了相关的接口。 VFS 实现了 open()、read() 等系统调并使得 cp 等用户空间程序可跨文件系统。VFS 真正实现了上述内容中：在 Linux 中除进程之外一切皆是文件。 Linux VFS 存在四个基本对象：超级块对象 (superblock object)、索引节点对象 (inode object)、目录项对象 (dentry object) 及文件对象 (file object)。 超级块对象代表一个已安装的文件系统；索引节点对象代表一个文件；目录项对象代表一个目录项，如设备文件 event5 在路径 /dev/input/event5 中，其存在四个目录项对象：/ 、dev/ 、input/ 及 event5。文件对象代表由进程打开的文件。 1超级块2索引节点3目录项4文件对象 与 进程 及 磁盘文件 间的关系: 其中 d_inode 即为硬链接。为文件路径的快速解析，Linux VFS 设计了目录项缓存（Directory Entry Cache，即 dcache）。 innode移动或重命名文件 不影响inode 文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。 用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方； 元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。123456789101112[root@localhost ~]# ls -i workcount.sh 8705899 workcount.sh[root@localhost ~]# stat workcount.sh 文件："workcount.sh" 大小：117 块：8 IO 块：4096 普通文件设备：fd00h/64768d Inode：8705899 硬链接：1权限：(0777/-rwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2018-08-09 20:39:34.052284568 +0800最近更改：2018-08-09 20:35:25.159457149 +0800最近改动：2018-08-09 20:39:28.363357082 +0800创建时间：- 索引节点 VFS/ext4 innode索引节点结构存在于系统内存及磁盘，其可区分成 VFS inode 与实际文件系统的 inode。 VFS 中的 inode 与 inode_operations 结构体VFS inode 作为实际文件系统中 inode 的抽象，定义了结构体 inode 与其相关的操作 inode_operations（见内核源码 include/linux/fs.h）。 i_count i_nlink每个文件存在两个计数器：i_count 与 i_nlink，即引用计数(i_count 用于跟踪文件被访问的数量)与硬链接计数。i_count 用于跟踪文件被访问的数量 12345678910111213141516171819struct inode &#123; ... const struct inode_operations *i_op; // 索引节点操作 unsigned long i_ino; // 索引节点号 atomic_t i_count; // 引用计数器 unsigned int i_nlink; // 硬链接数目 ... &#125; struct inode_operations &#123; ... int (*create) (struct inode *,struct dentry *,int, struct nameidata *); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct inode *,struct dentry *,const char *); int (*mkdir) (struct inode *,struct dentry *,int); int (*rmdir) (struct inode *,struct dentry *); ... &#125; ext4 inodei_links_count 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数12345678910struct ext4_inode &#123; ... __le32 i_atime; // 文件内容最后一次访问时间 __le32 i_ctime; // inode 修改时间 __le32 i_mtime; // 文件内容最后一次修改时间 __le16 i_links_count; // 硬链接计数 __le32 i_blocks_lo; // Block 计数 __le32 i_block[EXT4_N_BLOCKS]; // 指向具体的 block ... &#125;; 硬链接 ： 一个 inode 号对应多个文件名，则称这些文件为硬链接。硬链接就是同一个文件使用了多个别名,有共同的inode硬链接可由命令 link 或 ln 创建123456789[root@localhost ~]# stat wdc 文件："wdc" 大小：117 块：8 IO 块：4096 普通文件设备：fd00h/64768d Inode：8705899 硬链接：2权限：(0777/-rwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root)环境：unconfined_u:object_r:admin_home_t:s0最近访问：2018-08-09 20:39:34.052284568 +0800最近更改：2018-08-09 20:35:25.159457149 +0800最近改动：2018-12-10 09:37:11.206523214 +0800 硬链接是有着相同 inode 号仅文件名不同的文件 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。 跨文件系统不能创建inode 号仅在各文件系统下是唯一的，当 Linux 挂载多个文件系统后将出现 inode 号重复的现象.123456789[root@localhost /]# df -i --print-type文件系统 类型 Inode 已用(I) 可用(I) 已用(I)% 挂载点/dev/mapper/centos-root xfs 15828992 188789 15640203 2% /devtmpfs devtmpfs 123919 370 123549 1% /devtmpfs tmpfs 126938 1 126937 1% /dev/shmtmpfs tmpfs 126938 548 126390 1% /runtmpfs tmpfs 126938 16 126922 1% /sys/fs/cgroup/dev/sda1 xfs 524288 326 523962 1% /boot/dev/sdb1 ext3 1048576 77 1048499 1% /data 目录不能硬链接硬链接不能对目录创建是受限于文件系统的设计Linux 文件系统中的目录均隐藏了两个个特殊的目录：当前目录（.）与父目录（..）。查看这两个特殊目录的 inode 号可知其实这两目录就是两个硬链接。若系统允许对目录创建硬链接，则会产生目录环。1234[root@localhost /]# ls -aliF /mnt总用量 04213723 drwxr-xr-x. 2 root root 6 4月 11 2018 ./ 64 dr-xr-xr-x. 19 root root 274 9月 15 15:12 ../ inode用完 但磁盘还有剩余Linux 系统存在 inode 号被用完但磁盘空间还有剩余的情况。 软连接(符号链接）： 文件用户数据块中存放的内容是另一文件的路径名的指向12345[root@localhost ~]# ln -s wordcount.sh wdc.link[root@localhost ~]# ls -li9063386 lrwxrwxrwx. 1 root root 12 12月 10 09:56 wdc.link -&gt; wordcount.sh8705899 -rwxrwxrwx. 2 root root 117 8月 9 20:35 wordcount.sh 软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制： 软链接有自己的文件属性及权限等；-可对不存在的文件或目录创建软链接；-软链接可交叉文件系统；-软链接可对文件或目录创建；-创建软链接时，链接计数 i_nlink 不会增加；-删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接） tasklet 软中断软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保其数据结构。 备份算法rdiff 原理rsync增量传输算法原理 安全序列https://www.nowcoder.com/ta/nine-chapter?query=&amp;asc=true&amp;order=&amp;page=3 软中断 和 硬中断中断和异常是随机发生、自动处理、可恢复的。 中断： 操作系统 是中断（事件）驱动的中断引入是为了支持CPU和外部设备并行操作：cpu启动输入输出设备后，设备独立工作，cpu处理其他任务。当输入/输出完成，向CPU发送中断。 异常： cpu执行指令时自身出现的问题。（算术溢出、地址越界、陷入指令）异常分3类：陷入，故障，终止事件的发生改变了处理器的控制流： cpu暂停正在执行的程序， 保留现场， 自动转去执行相应事件的处理程序， 完成后返回断点，继续执行被打断的程序。 硬件：中断/异常响应：捕获中断/异常请求，响应，交给特定处理程序 。软件：中断/异常处理程序：识别中断/异常类型 并完成处理。 中断响应： 发现中断、接受中断的过程。由中断硬件部件完成。处理器控制部件中有 中断寄存器。 CPU在每条指令执行周期的最后，会扫描 中断寄存器。中断硬件会将触发内容规定变法送入PSW程序状态字相应位，称 中断编码。硬件会去查中断向量表，调出中断处理程序。 中断向量表：操作系统设计好的一条中断向量是一个内存单元。存放：中断处理程序入口地址和程序运行时所需的处理机状态字。Linux中断向量表0~255个中断向量c 中断处理程序： 软件提前设置好，硬件执行 保存相关寄存器信息 分析中断/异常的具体原因 执行处理程序 回复现场，返回被打断的程序 I/O中断处理程序分两类处理：正常结束，唤醒等待的程序，或者继续IO出现错误：重新执行失败IO，直到判断为硬件故障 （硬件）CPU 切换到内核态 在系统栈保留上下文 PC,PSW。 X86处理器中断：硬件信号。异常：指令执行引发。 系统调用：用户态到内核态的唯一入口。 中断控制器:硬件中断信号-&gt;中断向量 引发CPU中断 实模式没有CPU状态的转换。现在一般我们是在保护模式。叫中断描述符表。用门(gate) 保护模式： 用来增强多工和系统稳定度，像是 内存保护，分页 系统，以及硬件支援的 虚拟内存 实模式下的各种代码段、数据段、堆栈段、中断服务程序仍然存在，统称为“数据段”引入描述符来描述各种数据段，所有的描述符均为8个字节（0-7)，由第5个字节说明描述符的类型，类型不同，描述符的结构也有所不同。描述符表是一张地址转换函数表。 描述符数据结构表示中断向量。中断描述符表(IDT)通过IDTR寄存器获得IDT的地址段选择符是索引，显示是GDT表还是LDT表，还有特权级，用索引查全局描述符表（GDT），得到段描述符，得到段基地址+偏移量 = 中断服务程序入口地址 要做特权级检查，要切换堆栈，用户态进内核态，堆栈指针到内核态硬件压栈，保存上下文，如果异常产生了硬件出错码 保存在栈中。 系统调用：操作系统功能调用 //todo每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护） 应用程序可以直接使用系统调用，但是一般都是通过C函数库/API接口使用系统调用。内核函数是系统调用的处理程序 经过封装，提供到了C库函数和API接口。 https://www.polarxiong.com/archives/%E8%AF%BB-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%9A%84%E6%80%BB%E7%BB%93.html 伙伴系统：Linux内存分配方案，空闲块链表伙伴：如果需要的空间s需要2^(n-1)&lt;s&lt;2^n则空间/2，两个叫伙伴。 伙伴分割与合并（每次分割小的空闲块，系统中始终保持大的空闲快） 内存管理方案装载单位： 进程1.单一连续区域:只有一个进程在内存 2.固定分区：内存分区，每个分区只装1个进程，进程在各个分区排队 3.可变分区：内存按需分配给进程外碎片：进程和进程之间的空隙memory compaction:在内存移动程序，合并空闲区域进程IO时不能移动。 进程进入内存不是连续区域，而是进入内存若干个不连续区域。//todohttps://www.coursera.org/lecture/os-pku/ji-ben-nei-cun-guan-li-fang-an-2-p4N0u1.页式如果是32位的计算机,如果页面大小4k,0~11 12位为偏移 页表项记录了逻辑页号 到页框号的一个映射关系 每个进程都有一张页表，页表放在内存，一个进程上CPU之后 这个进程的页表的起始地址要推送到某一个寄存器 页表的起始地址在哪个数据结构？用 bitmap 位图管理物理内存 Windows API让cpu使用率划出一条直线一个时钟周期可以执行多少条指令？ CPU流水线？CPU每个时钟周期可以执行两条以上代码2.4Ghz主频则1秒可以执行2.4G*2行汇编指令10毫秒接近Windows调度时间片，1毫秒会导致线程频繁被唤醒挂起资源管理器大约是1秒更新一次4核cpu一个线程死循环占用大概是25%SetThreadAffinityMask() https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html IO多路复用http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html 磁盘驱动https://my.oschina.net/manmao/blog/746492 移动磁头到磁道 转动磁盘到扇区 磁生电和内存读，电生磁 内存写 总线倒用技术DMA 扇区和内存 算出柱面磁头扇区和读写的缓冲区直接out 抽象1：通过盘块号 操作系统 计算出柱面磁头扇区CHS 磁盘调度算法电梯调度算法？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 100;int n, now, s, sum, nnow, everage, p[maxn], b[maxn], sp[maxn], lenp[maxn];//显示结果void show()&#123; sum = 0; cout &lt;&lt;" 被访问的下一磁道号 移动距离（磁道数）\n"; for(int i = 0;i &lt; n; ++i) &#123; printf(" %3d %3d\n", sp[i], lenp[i]); sum += lenp[i]; &#125; cout &lt;&lt;" 平均寻道长度： "&lt;&lt;(double)sum/n &lt;&lt;"\n";&#125;//先来先服务void FCFS()&#123; for(int i = 0;i &lt; n; ++i) &#123; sp[i] = p[i]; if(i) lenp[i] = abs(sp[i-1] - sp[i]); else lenp[i] = abs(now - sp[i]); &#125;&#125;//最短寻道优先void SSTF()&#123; nnow = now; int fl[maxn] = &#123;0&#125;; for(int i = 0;i &lt; n; ++i) &#123; int minx = 999999, pp; for(int j = 0;j &lt; n; ++j) &#123; if(!fl[j] &amp;&amp; abs(nnow - p[j]) &lt; minx) &#123; minx = abs(nnow - p[j]); pp = j; &#125; &#125; sp[i] = p[pp]; lenp[i] = minx; nnow = p[pp]; fl[pp] = 1; &#125;&#125;//扫描算法bool cmp(int a, int b)&#123; return a &gt; b;&#125;void SCAN()&#123; nnow = now; int aa[maxn], bb[maxn], ak = 0, bk = 0; for(int i = 0;i &lt; n; ++i) &#123; if(p[i] &lt; nnow) aa[ak++] = p[i]; else bb[bk++] = p[i]; &#125; sort(aa, aa+ak,cmp); sort(bb, bb+bk); int i = 0; for(int j = 0;j &lt; bk; ++j) &#123; sp[i] = bb[j]; lenp[i++] = bb[j] - nnow; nnow = bb[j]; &#125; for(int j = 0;j &lt; ak; ++j) &#123; sp[i] = aa[j]; lenp[i++] = nnow - aa[j]; nnow = aa[j]; &#125;&#125;//循环扫描算法void CSCAN()&#123; nnow = now; int aa[maxn], bb[maxn], ak = 0, bk = 0; for(int i = 0;i &lt; n; ++i) &#123; if(p[i] &lt; nnow) aa[ak++] = p[i]; else bb[bk++] = p[i]; &#125; sort(aa, aa+ak); sort(bb, bb+bk); int i = 0; for(int j = 0;j &lt; bk; ++j) &#123; sp[i] = bb[j]; lenp[i++] = bb[j] - nnow; nnow = bb[j]; &#125; for(int j = 0;j &lt; ak; ++j) &#123; sp[i] = aa[j]; lenp[i++] = abs(aa[j] - nnow); nnow = aa[j]; &#125;&#125;int main()&#123; xbegin: cout&lt;&lt;"请输入被访问的总磁道数： "; cin &gt;&gt; n; if(n &lt;= 0 || n &gt; 100) &#123; cout &lt;&lt;"输入不合法，请重新输入！\n"; goto xbegin; &#125; nowCD: cout &lt;&lt;"请输入当前磁道： "; cin &gt;&gt; now; if(now &lt; 0) &#123; cout &lt;&lt;"磁道不存在，请重新输入！"; goto nowCD; &#125; pCD: cout &lt;&lt;"请按顺序输入所有需要访问的磁道："; for(int i = 0;i &lt; n; ++i) cin &gt;&gt; p[i]; for(int i = 0;i &lt; n; ++i) &#123; b[i] = p[i]; if(p[i] &lt; 0) &#123; cout &lt;&lt;"输入中有不存在的磁道，请重新输入！\n"; goto pCD; &#125; &#125; serve: cout &lt;&lt;" 1、先来先服务算法（FCFS）\n"; cout &lt;&lt;" 2、最短寻道优先算法（SSTF）\n"; cout &lt;&lt;" 3、扫描算法（SCAN）\n"; cout &lt;&lt;" 4、循环扫描算法（CSCAN）\n"; cout &lt;&lt;"请输入所用磁盘调度的算法： "; cin &gt;&gt; s; if(s &lt; 1 || s &gt; 4) &#123; cout &lt;&lt;"输入有误，请重新输入！\n"; goto serve; &#125; work: for(int i = 0;i &lt; n; ++i) p[i] = b[i]; if(s == 1) FCFS(); else if(s == 2) SSTF(); else if(s == 3) SCAN(); else CSCAN(); show(); xend: char ch; cout &lt;&lt;"重新选择算法或重新输入数据？（输入Y选择算法，输入y重新输入数据）: "; cin &gt;&gt; ch; if(ch == 'Y') goto serve; else if(ch == 'y') goto xbegin; else cout &lt;&lt;"程序结束，谢谢使用！\n"; return 0;&#125; https://www.shiyanlou.com/courses/115 进程调度就绪队列改变-&gt;重新调度进程调度的时机4个：1.进程正常/错误终止2.创建新进程/等待进程-&gt;就绪3.进程从运行-&gt;阻塞（等待）4.进程从运行-&gt;就绪（时间片到）重新调度的时机：内核对 【中断/陷入（异常）/系统调用】等处理之后【返回用户态】需要重新调度。 调度程序从就绪队列里选择进程可以是刚刚被暂停的，也可以是新的进程，新的就发生进程切换。新的进程上cpu要用自己的地址空间 高速缓存：刚才执行进程的指令和数据TLB存放了进程的页表表项 新的进程的指令、数据、表项也要放入高速缓存和TLB 调度算法 FC: Fibre Channel集群的磁盘阵列通过驱动接口同步磁盘块 1.获得linux文件的访问次数2.获得文件和磁盘块的映射 银行家算法https://blog.csdn.net/yaopeng_2005/article/details/6935235条件：1.固定进程数2.每个进程预先申请最大需要资源数量3.不能申请比系统可用资源总数还多的资源4.进程等待资源时间有限5.进程用完会还数据结构：n：进程数m：资源类数量Avaliable[1..m]Max[1..n,1..m]每个进程对某一资源最大需求量Allocation[1..n,1..m]当前进程分配到的 资源Need[1..n,1..m]当前进程还需要多少资源Request[1..n,1..m]本次申请多少资源 系统状态：当前可用资源的数量Work[1..m]=AvailableFinish[1..n]=False//to-do遍历查找进程i：Finish[i]==false&amp;Need[i]&lt;=Work Linux IO模式及 select、poll、epoll详解https://segmentfault.com/a/1190000003063859 为什么要用反码0如果是正数000…00如果是负数100…0-1:原码：10..01-&gt;反码11..10-&gt;补码11…11用反码0-&gt;正数反码是本身000用补码0-&gt;11…1(符号位不变)+1-&gt;0..0 而且符号位可以参与运算。 内核缓冲区？运行时重定位，进程血环根据pcb切换换基地址因为进程在执行时可以换入换出内存，基地址不一样，所以每次找到空闲内存，将空闲基地址写到pcb。每次取出指令放到cpu的IR执行一条指令都要地址翻译：因为执行过程中会有上下文切换，pcb基址放到基址寄存器（cpu)，执行完switch进程时基地址寄存器写回pcb。进程切换，将当前pcb的基地址更新给基址寄存器 程序分段一个程序会将主程序、变量、函数等在内存中是分段存放，都从自己的0地址开始存放。放入内存时是分段放入，这样每一段，比如动态数组、栈可以很方便扩容。所以定位的基地址是 &lt;段号，段内偏移&gt;:move [es:bx],ax段： cs代码寄存器，ds数据寄存器 ss栈寄存器 es扩展段寄存器PCB需要记录每个段的基地址和长度假设cs是0段 GDT表 根据cs查GDT表jmpi0,8操作系统内核的段表是GDT表每个进程的段表是LDT表 流程：1.程序分成多个段，每个段在内存中找到空闲基址2.将基址写到LDT表，LDT表赋给PCB，PC指针设为初始地址，每次执行都查LDT表找物理地址。 管程：一种同步机制用一种数据结构管理共享资源，并且提供一组操作过程 进程与管程：进程只能通过管程提供的过程间接访问管程中的数据结构。 管程是互斥进入的 ！编译器保证(???) 管程通过 条件变量+wait/notify操作解决同步问题。可以让进程/线程在条件变量上 等待（同时释放管程使用权，允许其他线程进入管程），也可以唤醒等待的线程/进程。 多个进程同时在管程里出现：a进入管程，wait并释放，b进入，唤醒a，则同时两个进程。三种解决方案：1.并发pascal：规定唤醒作为管程中最后一个可执行操作-&gt;唤醒完了这个进程就出管程2.Hoare：a（被唤醒的）先执行，b等待 入口等待队列：在管程外等待的 如果进入管程的发现资源不够不能操作（生产者想insert，但是缓冲区(资源)满了)则进程wait进入不同的条件变量队列。释放，并让入口等待队列的进入管程。 后进入的进程p发现资源够了会signal条件变量队列中的进程q。 p唤醒q，p进入紧急等待队列(比入口等待队列优先级高)，q进程从条件变量队列中出来继续执行 条件变量 c链：条件变量队列可以用信号量和pv操作构造管程。用管程解决生产者消费者问题： hoare的缺点：2次额外的进程切换 3.MESA：a等待(本来在条件变量等待，现在在另一个队列等待)，b继续从hoare的signal-&gt;notify notify(x) x是条件变量，x条件变量队列上的进程得到通知，发信号的继续执行。问题：不能保证将来x条件还成立 所以notify的进程上cpu执行还要重新检查条件 用while取代if改进：给条件队列等待+计时器，自动变成就绪态(因为被调度的时候还是会检查条件)改进：broadcast 释放所有等待条件变量的进程 Pthread互斥(lock操作互斥量)同步(wait/signal条件变量)pthread线程库实现条件变量的signal 是mesa管程的语义 进程通信信号量和管程不能多处理器，也不能传大量信息（大数组） 消息传递发送进程准备好消息，但是发送进程只能在自己的地址空间，不能去接收进程的地址空间操作，必须靠操作系统的消息缓冲区。1)发送进程准备好消息，调用send2)内核，操作系统复制消息,将消息放到接受进程pcb消息队列队尾3)接收进程上cpu执行到receive4)陷入内核，操作系统复制消息到接受进程地址空间 用p,v操作实现send原语 共享内存1.物理地址空间映射到2个进程内地址空间2.通过读者写问题的方法解决互斥问题 管道通信PIPE linux，windows常用通信机制 屏障barrier一组线程完成任务到达汇合点再继续 CPU型进程和IO型进程的调度IO型进程让出CPU进入等待队列，从等待-&gt;就绪不是进入原来的就绪队列，而是进入辅助队列。调度算法首先从辅助队列里选择进程，直到辅助队列为空，去就绪队列选进程。 磁盘IO的代价主要是查找时间（磁头找到柱面）减少磁头查找的时间就把数据放在同一个盘块里。b树每个节点（关键字个数）不超过一个磁盘块。中序遍历扫库每次查找关键字，从树根读一个节点到内存，直到找到，层数就是读入内存的次数。内存查找是有序表包含n个关键字，高度为h（树根为0）,最小度数为t的B树 $ h&lt; log_t{(n+1)/2} $ 树根2只有2个孩子 B+树只要遍历叶子节点就能实现整棵树的遍历。 VSAM虚拟存储存取法。支持range-query。B*树，非叶子节点加上了兄弟指针。 R树，多维B树，解决经纬度查询。Minimal Bounding Rectangle算法。从叶子节点开始表示一个空间，越往上表示的空间越大。 并行和并发的区别并发：进程的执行是间断的。并行parallelism是并发concurrency的特例/子集。并发是一种逻辑结构的设计模式。并发是指逻辑上可以并行，并行是物理运行状态。编写一个多线程/进程的并发程序，没有多核处理器就不能并行。并行的两个进程一定是并发的。 文件/网络句柄handle 所有进程共有进程是容器 进程无法共享内存，通信通过TCP/IP端口实现/其它操作系统的方案线程：没有独立的地址空间，栈线程：PC指向进程的内存缓冲区溢出：用户名过长没有判断就放进内存，写入程序的内存部分TLS：Thread local strategy 线程的独立内存 虚拟内存 缺页中断MMU访问虚拟内存时，这页虚拟内存还没有分配物理内存。向cpu发出缺页中断。cpu初始化物理页的内容分配，在进程页表添加映射。int n = *p当p所指向的地址在虚拟内存中，不是将p的值复制给内存，而是将p所在的虚拟内存的分页放入物理内存 内存虚拟化方案 影子页表(shadow Page Table) VMM(KVM)在宿主机内核中保存 虚拟机虚拟地址到宿主机物理地址。代价在于保持影子页表和虚拟机页表同步 EPT两次页表查找 不用同步。 可执行文件格式通过file 查看文件类型 进程的虚地址空间C语言指针的大小位数与虚拟空间的位数相同0x000000000062FE44123456#include&lt;stdio.h&gt;int main()&#123; int i =0; int *p = &amp;i; printf("0x%p",p); return 0;&#125; 进程访问了非法地址windows”进程因非法操作需要关闭”，linux “Segmentation fault” Linux内存布局windows默认将高2G分配给内核.Linux默认1G栈：函数调用上下文可执行文件映像 装载器共享库 装载地址在linux2.6挪到了靠近栈的0xbfxxxxxx 栈ulimit –s 8Mesp栈顶 esb活动记录（帧指针(frame pointer))不随函数执行变化，用于定位数据，函数返回时恢复 设置好ebp esp栈指针后 开辟栈空间，保存ebx（基地址(base)寄存器） esi, edi（源/目标索引寄存器”(source/destination index)）三个寄存器 将开辟出的空间初始化为0xCC 通过eax（累加器”(accumulator)）返回 恢复5个寄存器 ret返回 ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。 1int main()&#123;char p[12];&#125; 0xCCCC（即两个连续排列的0xCC）的汉字编码就是烫，所以0xCCCC如果被当作文本就是“烫”。如果一个指针变量的值是0xCCCCCCCC就是没初始化 堆原因：1.栈上数据在函数返回时被释放，无法将数据传递函数外。2.全局变量无法动态产生。 malloc的实现程序向操作系统申请堆空间，由程序运行库自己管理。linux两种堆空间分配的系统调用 int brk(void* end_data_segment) 设置进程数据段的结束地址, mmap()与windows的VirtualAlloc相似 起始地址和大小必须是系统页的整数倍 1void *mmp(void *start,size_t length,int prot,int flags,int fd,off_t offset); flag映射类型（文件映射/匿名映射） 匿名映射可以作为堆空间小于128k会在现有堆空间中分配，大于则使用mmap申请匿名空间 用mmap实现malloc12345void *malloc(size_t nbytes)&#123; void* ret = mmap(0,nbytes,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,0,0);//可读可写，匿名 if(ret == MAP_FAILED)return 0; return ret;&#125; mmap申请空间不能超过 空闲内存+空闲swap空间 windows 虚拟地址空间虚拟地址空间windows 每个线程默认栈大小1MNTDLL.DLL堆管理器APIwindows的堆不是向上增长 堆分配算法 空闲链表pre,next并有4个字节存储大小 位图，划分成大小相同的块。用2位11表示head，10表示body，00表示空闲 int32个字节，2个字节表示一个块的状态，假设1M堆，一块128字节=&gt;1M/128=8K个块 8K/(32/2)=512个int的数组存储 Head表示已分配区的头 对象池 io指令至少是没io的10^6倍并发：一个cpu上程序交替执行只有一个cpu只能执行一个进程进程：运行中的程序 内存原理 cpp返回对象的临时对象 输出： 经过了两次构造函数1次拷贝到栈上临时对象，1次拷贝到返回值ctor（create）ctorbefore return //已经被优化了，本来之后会输出copy ctoroperator=dtordtor（销毁）展开代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct cpp_obj&#123; cpp_obj()&#123; cout&lt;&lt;"ctor\n"; &#125; cpp_obj(const cpp_obj&amp; c)&#123; cout&lt;&lt;"copy ctor\n"; &#125; cpp_obj&amp; operator=(const cpp_obj&amp; rhs)&#123; cout&lt;&lt;"operator=\n"; return *this; &#125; ~cpp_obj()&#123; cout&lt;&lt;"dtor\n"; &#125;&#125;;cpp_obj return_test()&#123; cpp_obj b; cout&lt;&lt;"before return\n"; return b; //return cpp_obj() &#125;int main()&#123; cpp_obj n; n = return_test(); return 0;&#125; 汇编寄存器 gcc hellow.c -&gt;./a.out 预编译：gcc -E .\bigthingg.c -o .\bigthingg.i 展开宏 编译：链接生成汇编 gcc -S hello.i -o hello.s 汇编gcc -c hello.s -o hello.o 链接ld….64位汇编寄存器 虚拟内存CPU通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、IO设备等等，但从CPU发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由MMU将虚拟地址转换成物理地址再从地址总线上发出.CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。虚拟内存空间被组织为一个存放在硬盘上的M个连续的字节大小的单元组成的数组。页表是一个元素为页表条目（Page Table Entry, PTE）的集合，有效位代表这个虚拟页是否被缓存在物理内存中。处理缺页异常do_page_fault() inode文件读取磁盘的最小单位是多个扇区sector组成的 块block。一般4kb,8个sectorinode：文件系统的数据结构，文件元信息查看inodestat example.txt 系统调用、POSIX、C库、系统命令和内核函数 POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准基于UNIX的可移植 操作系统标准 内核提供的每个系统调用在C库中都具有相应的封装函数。 比如malloc函数和free函数都是通过brk系统调用来扩大或缩小进程的堆栈，execl、execlp、execle、 execv、execvp和execve函数都是通过execve系统调用来执行一个可执行文件。)-系统命令位于C库的更上层，是利用C库实现的可执行程序，比如最为常用的ls、cd等命令。$trace pwd pwd调用了那些系统调用 2类寄存器：用户可见/控制和状态 寄存器 ？？3种I/O操作技术：可编程：处理器忙；中断驱动：；直接存储访问DMA 空间局部性 ： 更大的缓冲块，存储器控制逻辑+预处理 多道： 交错进程 进程状态： 执行上下文； 操作系统信息不允许被进程直接访问 上下文包括操作系统管理进程以及处理器正确执行进程所需要的所有信息，包括各种处理器寄存器的内容，如程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级以及进程是否在等待特定I/O事件的完成。 虚地址指的是存在于虚拟内存中的地址，它有时候在磁盘中有时候在主存中。 实地址指的是主存中的地址。 ??单体内核和微内核 os维护信息表： 内存,I/O,文件，进程 进程控制块：标识，？？处理器状态，进程控制信息 陷阱： 当面进程的错误or异常 中断例子： 时钟，I/O，内存失效 线程模式切换：？包含状态信息少 第4章 线程、对称多处理和微内核第7章 内存管理 内存管理 ： 重定位进程-&gt;就绪进程池-&gt;处理器利用率 运行时内存保护 进程共享内存 内部碎片、外部碎片：数据&lt;分区-&gt;浪费；？动态分区，分区外存储空间变多。 页： 进程和磁盘划分块；帧：主存划分块；一页装入一帧。 段： 长度可变 第8章 虚拟内存第10章 多处理器和实时调度第11章 I/O管理和磁盘调度]]></content>
      <categories>
        <category>cpp学习操作系统</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown Syntax]]></title>
    <url>%2F2018%2F03%2F03%2Fmarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[将 markdown 的图片标签全部换成七牛云的大括号正则!\[.*\]\(\/images\/(.*)\) 替换成 { % q n i m g $1 %} 网页字体颜色 将七牛云图片换成腾讯云1&#123; % q n i m g ((\w)*.(\w)*) %&#125; 换成 1![$1](https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/$1) 后面加括号补救(!\[(\w)*.(\w)*\]\((\S)*) 换成 $1) 浅红色文字：浅红色文字：blah blah blah Content (md partial supported)]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Vue&JS]]></title>
    <url>%2F2018%2F03%2F03%2FAbout-Vue%2F</url>
    <content type="text"><![CDATA[123app.$watch("text",(newV,oldV)=&gt;&#123; console.log(`$&#123;newV&#125;,``)&#125; value、selected、checked默认情况下会被忽略 data是函数因为这样多次引用一个组件都创建新的的data实例 钩子函数create在 data初始化后调用，this指向vm，专门用来发送ajax axios基于promise1root["axios"] = factory(); axios挂在window上 promise 回调函数：将【后续】处理逻辑传入当前函数，当前事件完成后自动执行 12345678let a = ''function buy(callback) &#123; setTimeout(()=&gt;&#123; a="蘑菇" callback(a) &#125;,2000)&#125;buy((val)=&gt;&#123;console.log(val)&#125;) promise的三个状态：等待-&gt;成功/失败 12//ES6.JSfunction Promise(executor) &#123;&#125; 传入一个执行函数1Promise.prototype.then = function(onFulfilled,onRejected) &#123;&#125;; 不用传入回调函数，自动把值传入回调函数123456789101112131415function buyPack() &#123; //回调（成功函数，失败函数） return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5)&#123; resolve('买') &#125;else&#123; reject('不买') &#125; &#125;,1000); &#125;)&#125;//then(成功函数，失败函数)buyPack().then((data)=&gt;&#123;console.log(data);&#125;, (data)=&gt;console.log(data)) promise解决异步ajax 4步实现ajax 12345678910function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// 相当于readState=4 //防止404还是要： if（xhr.status==200） &#125; xhr.send()&#125;ajax(&#123;url:'./.json'&#125;).then 使用Promise 1234567891011121314151617function ajax(&#123;url='',type='get',dataType='json'&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let xhr = new XMLHttpRequest() xhr.open(type,url,true)//是否异步 xhr.responseType=dataType;//后台响应的类型 xhr.onload = function()&#123;// h5的新方法，等于xhr.readState=4 xhr.status=200 resolve(xhr.response) &#125;; xhr.onerror = function(err)&#123; reject(err) &#125; xhr.send() &#125;)&#125;ajax(&#123;url:'http://localhost:8089/getUser'&#125;).then( (res)=&gt;&#123;console.log(res)&#125;, (err)=&gt;&#123;console.log(err)&#125;) fetch完全基于promiseasync await 异步的终极解决方案 call和apply的区别是apply第2个参数传数组 var vm = new Vue({el:&#39;#app&#39;})给body加#app表示body里面的dom都是vue的管理区域 弹窗效果=两个div嵌套，遮罩div width整个屏幕，显示在所有图层上，现在body最上或最上，v-if=&quot;!modal.show v-on:click=&quot;modal.show=!modal.show&quot; ready:function(){this.getData()}与methods\data同级，对象加载好执行 ,this.methods中的方法（ajax请求更新data） getData函数中的reqwest函数中的this已经不是实例本身了，取不到data数据，指的是窗口12345678910111213methods:&#123; var self = this getData:function()&#123; reqwest(&#123; url: type: method: success:function(resp)&#123; self.comments = resp.results &#125; &#125;) &#125;&#125; computed：与methods写法基本相同，有缓存并且可以绑定数据class=&quot;&quot; 12345678computed:&#123; loadingOrNot:function()&#123; if(this.comments.length==0)return 'loading' &#125;else&#123; return "" &#125; &#125;&#125; [1,2,3].filter(isBigEnough)在computed中写过滤、验证表单 1234567filterdList:function()&#123; function useRuler(people)&#123; return people.heigh&gt;100 &#125; var newList = this.comments.filter(useRuler) return newList&#125; RESTful API PUT修改已有的某个资源 get是查 post增 返回响应码：201：删除、修改、创建成功； 400：失败 tokencookie.js token认证不能在加data里1234567891011getDate:function()&#123; var self = this reqwest(&#123; url: type:'json', headers:Cookies.get&#123;'token'&#125;?&#123;'Authorization':'Token '+Cookies.get('token')&#125;:&#123;&#125; success:function(resp)&#123; &#125; &#125;)&#125; vue难点 $emit() this.$nextTick() directive 自定义指令 vuex难点dom上的行间属性1234567891011121314// 注册Vue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// 注册 (指令函数)Vue.directive('my-directive', function () &#123; // 这里将会被 `bind` 和 `update` 调用&#125;)// getter，返回已注册的指令var myDirective = Vue.directive('my-directive') minxins 混入123456789101112131415161718// 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // =&gt; "hello from mixin!" vue123var message = ` hello $&#123;name&#125;! the answer is $&#123;40+2&#125;`.toUperCase() :root 选择器匹配文档根元素。 响应式布局@media screen and (min-width: 768px)@media 的媒介查询方式根据屏幕尺寸判断手机端还是PC端 不用history模式路径会有#（hasj模式）history.pushState API完成URL跳转不需要重新加载页面 微信history push注意 npm 缺少python2.7npm pythonnpm –add-python-to-path=’true’ –debug install –global windows-build-tools Weex 适配750px， 缩略 border，background 定位： 不支持z-index ，Android的overflow为hidden 渐变：不支持 radial-gradient；box-shadow只支持ios border-top-left-radius可以，安卓不可以 所有元素默认display:flex Ajax readyState 0-4请求初始化 服务器连接已建立 请求已接收 请求处理中 请求已完成request.onreadystatechange=function(){ } post 要用Content-Type：application/x-www-form-urlencoded9 post 参数用&amp;隔开 data=”name=” .value+”&amp;number=” ; request.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”) request.send(data) request.responseText请求参数：Request Payload eval 解析json字符串 eval(‘(‘+json+”)”); eval 中 值为alert() 会被执行Json.parse(request.responseText)JSONLint 格式化校验工具标记约定 “success”:true 产生跨域 localhost-&gt;127.0.0.1 方法1： 代理 后台 JSONP解决get请求跨域访问 dataType:”json”-&gt;”jsonp” jsonp:”参数名” 后台约定 H5 XHR2 “Access-Control-Allow-Oringin：*””Navigator Chrome浏览器信息 navigator.appVersion 用userAgent判断什么浏览器123navigatior.userAgent.indexOf("Chrome")&gt;-1//IE(8-10)indexOf("MSIE") Screen 对象screen.width/.height一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 元素尺寸var w= document.documentElement.clientWidth|| document.body.clientWidth; var h= document.documentElement.clientHeight|| document.body.clientHeight; scrollTop 可见内容相对顶部高度 offsetTop相对与页面的位置]]></content>
      <categories>
        <category>js前端常用svgcanvasVue框架jquery源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Java]]></title>
    <url>%2F2018%2F03%2F02%2FAbout-Java%2F</url>
    <content type="text"><![CDATA[在64bit JVM（关闭压缩指针）下，一个Integer对象占用的内存空间为24Byte = 8Byte mark_header + 8Byte Klass 指针 + 4Byte int（用于存储数值）+ 4Byte（Padding，Java对象必须以8Byte为界对齐）CPU每次读内存时都可以一次性读取1个Cache Line（一般是64Byte）的内容，而一个boolean只占1Byte，所以达到很高的遍历速度。 String的hashCode也是通过对该字符串每个字符的ASC码简单的算术运算所得，这样就可以保证相同的字符串的hashCode相同且equals()为真。 List不是List的父类关于Java中泛型错误的是：正确答案: C D 你的答案: D (错误)A List&lt;? extends T&gt;为可以接受任何继承自T类型的ListB 方法可以返回泛型类型C 可以把List传递给一个接受List参数的方法D Array中可以用泛型 系统在运行的时候会为每个【进程】分配不同的内存区域下列说法错误的是：正确答案: C 你的答案: A (错误)进程是系统进行资源调度的基本单位。线程是CPU分派的基本单位系统在运行的时候会为每个线程分配不同的内存区域进程具有控制表PCB，而线程也有自己的控制表TCB 属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态； 向上转型下列代码的输出结果是：a - function in B12345678910111213141516public class A &#123; String name="a"; String go()&#123; return "- function in A"; &#125; &#125; public class B extends A &#123; String name="b"; String go()&#123; return "- function in B"; &#125; public static void main(String[] args) &#123; A a= new B(); System.out.println(a.name+a.go()); &#125; &#125; 下列说法正确的是：正确答案: D 你的答案: C (错误)Java语言中，对于任意的整数i，i+1&gt;i都成立C++和Java都是面向对象的语言，都支持多继承在调用System.gc()后，Java虚拟机会立即进行垃圾回收Java语言中，Math.abs(Integer.MIN_VALUE)的值等于Integer.MIN_VALUE http://www.cnblogs.com/lanxuezaipiao/p/4153070.html 序列化符号引用 直接引用符号引用：符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。 直接引用：同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。 集合遍历并删除！！迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。void remove()：删除迭代器刚越过的元素保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然 remove 方法除外）用迭代器12345678Iterator&lt;Integer&gt; it = candy.iterator();while (it.hasNext())&#123; int tmp = it.next(); if(b.hungry &gt;= tmp)&#123; b.hungry-= tmp; it.remove(); &#125;&#125; 用静态工厂方法替代构造器123public static Boolean valueOf(boolean b)&#123; return b?Boolean.TRUE:Boolean.FALSE;&#125; 1.对于特定参数的构造函数返回的特定对象，能有名字.（而不是用不同参数类型顺序的构造器）2.缓存调用重复对象。实例受控类。客户端就能用==不用equals。3.API隐藏实现类。Collections的集合接口有32个便利实现，不可修改、同步集合等。这些对象的类都是私有类。EnumSet 没有公有构造器，只有静态工厂方法，根据元素大小返回两种类。12345678910public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + " not an enum"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe);&#125; 服务提供者框架：http://www.importnew.com/27291.htmlJDBC：服务Service接口：Connection 提供者实现的1234567public interface Connection extends Wrapper, AutoCloseable &#123; Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; void commit() throws SQLException; void setAutoCommit(boolean autoCommit) throws SQLException;&#125; 提供者Provider注册API方法 DriverManager.registerDriver 服务访问API方法：DriverManger.get Connection 可选：服务提供者接口:Driver 静态广场方法的管用名：valeOf,of,getInstance, newInstance,getType,newTye 多个构造器参数重叠构造器：重新1、2、3参数的构造方法，不可行。12345public class NurtitionFacts&#123; private final int servingSize; // require private final int fat; // optional private final int sodium; // optional&#125; JavaBeans模式：无参构造器创建对象，然后setter方法。缺点：线程不安全。构造过程分成了几个调用，构造过程中JavaBeans可能不一致，而且不能做成变成不可变对象。12345private final int ser = -1;// 不行public void setSer(int ser)&#123; this.ser = 1;&#125; Builder模式： 0.1奇偶性用==1 判断会有负数的问题，正确写法1234boolean isOdd(int i)&#123; i % 2 !=0; (i &amp; 1) != 0&#125; 0.3长整除1234567final long MICROS_PER_DAY = 24 * 60 * 60 *1000 *1000;final long MICROS_PER_DAY3 = 24l * 60 * 60 *1000 *1000;final long MICROS_PER_DAY2 = 86400000000l;final long MILLIS_PER_DAY = 24*60*60*1000;System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);//5System.out.println(MICROS_PER_DAY3/MILLIS_PER_DAY);//1000System.out.println(MICROS_PER_DAY2/MILLIS_PER_DAY);//1000 第一行报错：计算溢出。计算过程完全以int运算执行的，完成运算后才提升到long。 0.4 long字面量 一定要用大写L1System.out.println(12345+5432l);//会看成1 0.5 十六进制int扩展成long的高位12//cafebabe （第33位丢了）System.out.println(Long.toHexString(0x100000000L+0xcafebabe)); 左边是long 右边是32位int，十六进制32位int ，c的高位为1，负数，扩展为补1（F）1234567//0xcafebabe被提升成0xffffffffcafebabe 等于十进制数‭-889275714‬System.out.println(Long.toHexString(0xcafebabe)); 1111111 0xffffffffcafebabeL + 0x0000000100000000L --------------------- 0x00000000cafebabeL 改正1System.out.println(Long.toHexString(0x100000000L+0xcafebabeL)); 0.6 转型的零扩展和符号位扩展12//65536System.out.println((int)(char)(byte)-1); 1 转byte是只取低8位1111 1111 还是-1，2 byte-&gt;（符号扩展）char是无符号16位 扩展成16个13 char扩展都是零扩展 就是16个1 65536没有符号位扩展：1int i = c &amp; 0xffff; 如果byte转char不希望符号位扩展1char c = (char) (b &amp; 0xff); 0.7创建泛型数组从List分ArrayList和LinkedList根据结构，根据元素的类型又可以分String/Int的ArrayList，乘法组合数量太多。 (E[]) new Object[n]; E 到底是什么属于对象的一部分 不是类的一部分new Node&lt;Integer&gt;(value); toArray(new String[0])官方推荐写法https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.htmlOtherwise, a new array is allocated with the runtime type of the specified array and the size of this list.如果指定的数组能容纳该 collection，则返回包含此 collection 元素的数组。否则，将根据指定数组的运行时类型和此 collection 的大小分配一个新数组。这里给的参数的数组长度是0，因此就会返回包含此 collection 中所有元素的数组，并且返回数组的类型与指定数组的运行时类型相同。 BinarySearchArrays.binarySearch() method returns index of the search key, if it is contained in the array,else it returns (-(insertion point) - 1). 动态分配JVM虚拟机在方法分派前会为当前相关类（自身类、接口、父类、子类）生成一个方法表JVM 首先查看常量池，确定方法调用的符号引用（名称、返回值等等），然后利用 this 指向的实例得到该实例的方法表，进而搜索方法表来找到合适的方法地址。 多态 Java中除了static方法和final方法（private方法本质上属于final方法，因为不能被子类访问）之外，其它所有的方法都是动态绑定 构造函数并不具有多态性，它们实际上是static方法，只不过该static声明是隐式的。因此，构造函数不能够被override。 在父类构造函数内部调用具有多态行为的函数将导致无法预测的结果，因为此时子类对象还没初始化，此时调用子类方法不会得到我们想要的结果。1234567891011121314151617181920212223242526class Glyph &#123; void draw() &#123; System.out.println("Glyph.draw()"); &#125; Glyph() &#123; System.out.println("Glyph() before draw()"); draw(); System.out.println("Glyph() after draw()"); &#125;&#125;class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println("RoundGlyph.RoundGlyph(). radius = " + radius); &#125; void draw() &#123; System.out.println("RoundGlyph.draw(). radius = " + radius); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125; 输出：Glyph() before draw()RoundGlyph.draw(). radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(). radius = 5 序列化字段静态变量不管是否被transient修饰，均不能被序列化 Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。 Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ ( )123456789class Shape &#123; public String name;&#125;class Circle extends Shape implements Serializable&#123; private float radius; transient int color; public static String type = "Circle";&#125; A nameB radiusC colorD type答案：B 抽象类1234567public abstract class MyClass &#123; public int constInt = 5; //add code here public void method() &#123; &#125;&#125; A public abstract void method(int a);B constInt = constInt + 5; 变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。 C public int method(); 普通方法一定要实现 D public abstract void anotherMethod() {} 抽象类中的抽象方法（加了abstract关键字的方法）不能实现。 答案：A 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。 静态块构造块1234567891011121314151617181920212223242526class HelloA &#123; public HelloA() &#123; System.out.println("HelloA"); &#125; &#123; System.out.println("I'm A class"); &#125; static &#123; System.out.println("static A"); &#125;&#125;public class HelloB extends HelloA &#123; public HelloB() &#123; System.out.println("HelloB"); &#125; &#123; System.out.println("I'm B class"); &#125; static &#123; System.out.println("static B"); &#125; public static void main(String[] args) &#123; new HelloB(); &#125;&#125; static Astatic BI’m A classHelloAI’m B classHelloB 对象的初始化顺序：（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；（2）当static语句执行完之后,再执行main方法；（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器。 IO用法要从文件”file.dat”中读出第10个字节到变量c中,下列哪个方法适合? （）A FileInputStream in=new FileInputStream(&quot;file.dat&quot;); in.skip(9); int c=in.read(); B FileInputStream in=new FileInputStream(&quot;file.dat&quot;); in.skip(10); int c=in.read(); C FileInputStream in=new FileInputStream(&quot;file.dat&quot;); int c=in.read(); D RandomAccessFile in=new RandomAccessFile(&quot;file.dat&quot;); in.skip(9); int c=in.readByte(); D语法错 应该123RandomAccessFile in = new RandomAccessFile("file.dat", "r");in.skipBytes(9);int c = in.readByte(); case 没有break123456789101112public static int getValue(int i) &#123; int result = 0; switch (i) &#123; case 1: result = result + i; case 2: result = result + i * 2; case 3: result = result + i * 3; &#125; return result; &#125; A0 B2 C4 D10 答案：D 解析：注意这里case后面没有加break，所以从case 2开始一直往下运行。 初始化123456789import java.io.*;import java.util.*;public class foo&#123; public static void main (String[] args)&#123; String s; System.out.println("s=" + s); &#125;&#125; A 代码得到编译，并输出“s=”B 代码得到编译，并输出“s=null”C 由于String s没有初始化，代码不能编译通过D 代码得到编译，但捕获到 NullPointException异常答案：C解析：Java中所有定义的基本类型或对象都必须初始化才能输出值。 引用和值传递1234567891011121314151617181920212223242526public class Example &#123; String str = new String("good"); char[] ch = &#123; 'a', 'b', 'c' &#125;; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + " and "); System.out.print(ex.ch); &#125; public void change(String str, char ch[]) &#123; str = "test ok"; ch[0] = 'g'; &#125;&#125; A、 good and abc B、 good and gbc C、 test ok and abc D、 test ok and gbc答案：B 创建对象 不通过构造函数也能创建对象吗（） A 是 B 否 答案：A 解析：Java创建对象的几种方式（重要）： (1) 用new语句创建对象，这是最常见的创建对象的方法。(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。(3) 调用对象的clone()方法。(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 (1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。 我们知道 Java 已经支持所谓的可变参数（varargs），但是官方类库还是提供了一系列特定参数长度的方法，看起来似乎非常不优雅，为什么呢？这其实是为了最优的性能，JVM在处理变长参数的时候会有明显的额外开销，如果你需要实现性能敏感的 API，也可以进行参考。 反编译javap -v xx.class interface里面的变量都是public static final 以下说法中正确的有正确答案: A D 你的答案: A B D (错误)A.StringBuilder是线程不安全的B.HashMap中，使用 get(key)==null可以判断这个HashMap是否包含这个key(key存在，值是null)C.Java类可以同时用abstract和final声明D.volatile关键字不保证对变量操作的原子性 Java 中堆和栈有什么区别?正确答案: A B 你的答案: A B D (错误)A.堆是整个JVM共享的B.栈是每个线程独有的C.栈是整个JVM共享的D.对象可以分配在堆上也可以分配在栈上 PermGen Space-XX:PermSize，表示程序启动时，JVM 方法区的初始化最小尺寸参数；-XX:MaxPermSize，表示程序启动时，JVM 方法区的初始化最大尺寸参数。 Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,‑XX:MaxPermSize 参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。 方法区（method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。 内存溢出错误。更具体的说，是指方法区（永久代）内存溢出！java.lang.OutOfMemoryError: PermGen Space表示正确答案: C 你的答案: A (错误)Java heap内存已经用完Java 堆外内存已经用完Java 类对象(class)存储区域已经用完Java 栈空间已经用完 强引用、软引用、弱引用、幻象引用 12345678910111213public abstract class Reference&lt;T&gt; &#123; /** * Returns this reference object's referent. If this reference object has * been cleared, either by the program or by the garbage collector, then * this method returns &lt;code&gt;null&lt;/code&gt;. * * @return The object to which this reference refers, or * &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared */ public T get() &#123; return this.referent; &#125;&#125; 对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。 如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。 幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态 SoftReference:软引用，缓存，配合引用队列让对象豁免一些垃圾收集，只有当 JVM 认为【内存不足】时，才会去试图回收软引用指向的对象。are cleared at the discretion（斟酌） of the garbage collector in response to memory demand.软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。Soft references are most often used to implement memory-sensitive caches. WeakReference：弱引用，配合引用队列每次垃圾回收都回收掉。下面关于Java中weak reference的说法，哪个是正确的?正确答案: B 你的答案: B (正确)Weak reference指向的对象不会被GC回收。Weak reference指向的对象可以被GC回收。Weak reference 指向的对象肯定会被GC回收Weak reference 指向的对象如果被回收，那么weak reference会收到通知 维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。Weak references are most often used to implement canonicalizing mappings 幻象引用Phantom ：虚引用，GC的哨兵，必须和引用队列一起用123String str = new String("abc");ReferenceQueue queue = new ReferenceQueue();PhantomReference ref = new PhantomReference(str,queue); 幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制 引用队列 ReferenceQueue是链表，就是头节点private volatile Reference&lt;? extends T&gt; head = null;123456789volatile ReferenceQueue&lt;? super T&gt; queue; /* When active: NULL * pending: this * Enqueued: next reference in queue (or this if last) * Inactive: this */@SuppressWarnings("rawtypes")Reference next; 创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里。幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。 final、finally、 finalizefinalfinal 修饰的 class 代表不可以继承扩展.避免 API 使用者更改基础功能final 的变量是不可以修改的.，利用final 可能有助于 JVM 将方法进行内联(现代高性能 JVM（如 HotSpot）判断内联未必依赖final 的提示)，可以改善编译器进行条件编译的能力.final 的方法也是不可以重写的（override） 一个类的private方法会被隐式声明为final方法。 final 并不等同于 immutable123456final List&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("Hello"); strList.add("world"); //List.of 方法创建的本身就是不可变 List，会抛运行异常List&lt;String&gt; unmodifiableStrList = List.of("hello", "world"); unmodifiableStrList.add("again"); finalizefinalize 是基础类 java.lang.Object 的一个方法.保证对象在被垃圾收集前完成特定资源的回收. JDK 9 开始被标记为deprecated. 无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。 跟c++的析构函数不同，垃圾回收要标记两次垃圾回收才回收 ，没引用的对象被放到F-Queue队列中 可以用于对象重生123456789101112131415161718192021222324252627public class Finalization &#123; public static Finalization finalization; @Override protected void finalize() throws Throwable &#123; System.out.println("Finalize"); finalization = this; &#125; public static void main(String[] args) &#123; Finalization f = new Finalization(); System.out.println("初始化完成：" + f); f = null; // 会触发finalize() System.gc(); try &#123; // 为了等垃圾回收线程完成 执行到finalization = this; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("完成GC："+f); System.out.println(finalization); System.out.println(f+" "+finalization); &#125;&#125; post-mortemJava 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（Phantom Reference），这是一种常见的所谓 post-mortem 清理机制。 每个 Cleaner 的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。 为自己的模块构建一个 Cleaner，然后实现相应的清理逻辑 幻象引用定制资源收集MySQL JDBC driver 之一的 ysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。 代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。 123456789101112131415161718192021public class CleaningExample implements AutoCloseable &#123; // A cleaner, preferably one shared within a library private static final Cleaner cleaner = &lt;cleaner&gt;; static class State implements Runnable &#123; State(...) &#123; // initialize State needed for cleaning action &#125; public void run() &#123; // cleanup action accessing State, executed at most once &#125; &#125; private final State; private final Cleaner.Cleanable cleanable public CleaningExample() &#123; this.state = new State(...); this.cleanable = cleaner.register(this, state); &#125; public void close() &#123; cleanable.clean(); &#125; &#125; 上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。 finally不会被执行的特例123456try &#123; // do something System.exit(1); &#125; finally&#123; System.out.println(“Print from finally”); &#125; Exception Error 运行时异常 尽量不要捕获类似 Exception 这样的通用异常,Thread.sleep() 应该抛出InterruptedException Exception 和 Error 都 继承Throwable ThrowableThrowable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。Only objects that are instances of this（Throwable) class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement. only this class or one of its subclasses can be the argument type in a catch clause. 已检查的异常Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.checked exceptions 可检查异常应该捕获不检查异常（运行时异常）：NullPointerException ArrayIndexOutOfBoundsException Java 语言的 Checked Exception 也许是个设计错误: Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。 Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。 异常 Exception 和 ErrorJava 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作A throwable contains a snapshot of the execution stack of its thread at the time it was created.12345public class Throwable/** * Native code saves some indication of the stack backtrace in this slot. */private transient Object backtrace; Error 不需要捕获OutOfMemoryError chained exception facility wrapped exception让下层抛出的抛出物向外传播是不好的设计，因为它通常与上层提供的抽象无关。 反应式编程（Reactive Stream）因为其本身是异步、基于事件机制的，所以出现异常情况，决不能简单抛出去；另外，由于代码堆栈不再是同步调用那种垂直的结构，这里的异常处理和日志需要更加小心，我们看到的往往是特定 executor 的堆栈，而不是业务方法调用关系。 生成闭区间[0,1]浮点数?Maven 目录隔离Lombok：通过注解精简代码https://projectlombok.org/Lombok会把javac编译的AST放到Lombok Processor交给不同的Handler处理，输出修改AST，javac继续解析生成字节码文件。关键注解 of是白名单 exclude黑名单@Data(包括get/set/toString/EqualsAndHashCode) @Getter @Setter 1234567891011121314151617181920@Data@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode(of = "id")public class Category &#123; private Integer id; private Integer parentId; private String name; private Boolean status; private Integer sortOrder; private Date createTime; private Date updateTime;&#125; @NoArgsConstructor无参构造器@AllArgsConstructor无参构造器@ToString(exclude = &quot;column&quot;)@EqualsAndHashCode(exclude = &quot;column&quot;)@Sl4j @Log4j java 反编译http://jd.benow.ca/ RESTful API 设计参考文献列表https://github.com/aisuhua/restful-api-design-references ajax复杂对象传递给spring bootajax里必须要contentType:&quot;application/json;charset=utf-8&quot;因为默认是application/x-www-form-urlencoded Gson类中有泛型类的反射原理JavaEE规范设计模式里氏替换 长方形和正方形当把父类替换成子类，程序运行的和期望不一样。如果正方形继承长方形，当对长方形的resize方法里有一个判断长宽是否相等的条件，正方形会死循环。正确方法：长方形正方形都实现这个接口。注意没有set方法，所以长方形和正方形的resize是不通用的。写resize方法只能传入长方形类。防止继承泛滥。1234public interface Quadrangle&#123; long getWidth(); long getLength();&#125; 子类重载父类方法，入参要比父类的入参更宽松！123456789101112public class Child extends Base&#123; // 重写 @Override public void method(HashMap map)&#123; super.method(map); &#125; // 重载 比父类的入参更宽松 // 当使用Child.method(hashmap);的时候不会被调用 public void method(Map map)&#123; &#125;&#125; 后置条件：子类实现父类的抽象方法返回值要比父类更严格 组合/聚合复用原则 db的Connect类123public abstract class DBConnection&#123; public abstract String getConnection();&#125; 123456public class MysqlConnection extends DBConnection&#123; @Override public String getConnection()&#123; return "mysql数据库连接"; &#125;&#125; 1234567public class Dao&#123; // 可以通过set/构造方法注入 private DBConnection dbConnection; public void addProduct()&#123; String conn = dbConnection.getConnection(); &#125;&#125; 数据库设计原则1 实体聚合原则2 不用外键3 减少中间表设计 Objcet 的源码 Maven 报错No plugin found for prefix ‘tomcat7找到Maven的setting：123&lt;pluginGroups&gt; &lt;pluginGroup&gt;org.apache.tomcat.maven&lt;/pluginGroup&gt;&lt;/pluginGroups&gt; HTTP服务的性能测试图表snowflake获取当前目录 System.getProperty()参数大全System.out.println(System.getProperty(&quot;user.dir&quot;)); StringUtils源码学习forEach 反编译是迭代器modCount在线程不安全的迭代器里会抛异常UnsupportedOperationException 从Arrays.asList()转化过来的List的不支持add()和remove()方法，这是由于从Arrays.asList()返回的是返回java.util.Arrays$ArrayList，而不是ArrayList。Arrays$ArrayList和ArrayList都是继承AbstractList，add() 和remove()等方法在AbstractList中默认throw UnsupportedOperationException而不做任何操作。ArrayList重写这些方法对List进行操作，而Arrays$ArrayList却没有重写add()和 remove()等方法，所以对从Arrays.asList()转化过来的List进行add()和remove()会出现UnsupportedOperationException异常。 Arrays.asList返回的是Arrays的内部类java.util.Arrays.ArrayList 该类继承了AbstractList但是并没有实现所有的方法，和java.util.ArrayList还是有区别的。 AbstractList的add方法： res.add(new ArrayList&lt;&gt;(Arrays.asList(num[i],num[lo],num[hi]))); 求int[]最大值的正确写法int maxa = Arrays.stream(arr).max().getAsInt(); List remove的index不能是Integer12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; String的字典序比较展开代码 123456789101112131415161718192021222324252627/** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The result is * a negative integer if this &#123;@code String&#125; object * lexicographically precedes the argument string. */public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; replace和replaceAll都是全部替换1234567891011121314151617181920public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement);&#125;/** * Replaces each substring of this string that matches the literal target * sequence with the specified literal replacement sequence. The * replacement proceeds from the beginning of the string to the end, for * example, replacing "aa" with "b" in the string "aaa" will result in * "ba" rather than "ab". * * @param target The sequence of char values to be replaced * @param replacement The replacement sequence of char values * @return The resulting string * @since 1.5 */public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString()));&#125; hashset的实现static final 静态类对象 所有实例共享 12345678910111213private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; 二进制System.out.println(0b101);//二进制:5 （0b开头的）System.out.println(011); //八进制9 List&lt;String&gt; 2 String[] [Ljava.lang.Object; cannot be cast to [Ljava.lang.String; rst.toArray(new String[rst.size()]); http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html 二维数组clone1234this.mat = new int[matrix.length][]; for (int i = 0; i &lt; matrix.length; i++) &#123; this.mat[i] = matrix[i].clone(); &#125; ThreadLocalTimer打印整数的二进制表示0x8000000 表示100000…0 123456int a = -6;for(int i =0;i&lt;32;i++)&#123; //取第一位，右移 int t = (a&amp;0x8000000&gt;&gt;&gt;i)&gt;&gt;&gt;(31-i); out(t);&#125; System.exit结束一个jvm。 状态0是正常退出123//非零是异常by convention, a nonzero status code indicates abnormal termination.public static void exit(int status) forEach： ConcurrentModificationException报错代码：123456for(List&lt;Integer&gt; list :subsets) &#123; List&lt;Integer&gt; before = new ArrayList&lt;&gt;(list); before.add(i); //subsets的大小在不断增加！终止不了 subsets.add(before);&#125; at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator 被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。 在使用迭代器遍历的时候，如果使用ArrayList中的remove(int index) remove(Object o) remove(int fromIndex ,int toIndex) add等方法的时候都会修改modCount，在迭代的时候需要保持单线程的唯一操作，如果期间进行了插入或者删除，就会被迭代器检查获知，从而出现运行时异常 被动加载和主动加载final static List menu = Arrays.asList{}import static A.menu;A类不会被初始化 不会占用任何内存去掉final变成主动加载 位运算取模只要5个CPU周期 %至少26个CPU周期Character 内部静态类做cache 1234567891011121314private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125;public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125; 2.123int digit(char ch, int radix) &#123; return digit((int)ch, radix);&#125; 当radix基数大于传入的数字，返回-1，只能传入小于radix的数字 @FunctionalInterface适合用lambda表达式 JIN123456System.loadLibrary("NativeMath");//中的sqrt c++实现#include&lt;math.h&gt;JNIEXPORT jdouble JNICALL Java_包名_sqrt(JNIEnv *env,jobject obj,jdouble value)&#123; return sqrt(value);&#125; 回调(控制反转)与代理回调:展开代码 123456789101112131415161718192021222324interface ICallBack&#123; public void callBack();&#125;class Caller&#123; public void call(ICallBack callBack)&#123; System.out.println("start"); callBack.callBack(); System.out.println("end"); &#125;&#125;public class callbackk &#123; public static void main(String[] args) &#123; Caller call = new Caller(); call.call(new ICallBack() &#123; @Override public void callBack() &#123; System.out.println("这个叫回调"); &#125; &#125;); &#125; &#125; 线程Thread是回调者，Runnable回调接口12345new Thread(new Runnable()&#123; @Override public void run()&#123; &#125;&#125;).start(); 观察者模式/回调函数 事件处理机制RPC基于TCP/IP的会话层协议set的contain时间复杂度是O(1),list的contain时间复杂度是O(n)chrome的source根据域名不同存放资源 可以打断点调试 丢失精度一定要用BigDecimal的string构造器devide(b,2,BigDecimal.Round_HALF_UP)保留两位小数四舍五入guaga:String-&gt;listSplitter.on(&quot;,&quot;).splitToList(&quot;a,b,c&quot;); simditor1.8中文API 全文搜索引擎Lucene Charactor.isLetterOrDigit()MD5增加复杂度saltUUID重置密码之前：验证完密码问题则写入token123String Token = UUID.randomUUID().toString();//放入本地缓存 防止空，放个前缀`token_`TokenCache.setKey("token_"+username,forgetToken); 生成的是一个永远不会重复的字符串把token放到本地cache中设置有效期 Guava中的本地缓存LoadingCache调用链模式没有顺序1234567891011121314151617181920212223242526//TokenCache::private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder() .initialCapacity(1000)//缓存的初始化容量1000 .maximumSize(10000)//缓存的最大容量，超过则会使用LRU（最少使用）算法移除 .expireAfterAccess(12,TimeUnit.HOURS)//有效期12个小时 .build(new CacheLoader&lt;String,String&gt;()&#123; //默认数据加载，调用get时，key没有命中，则调用这个 @Override public String load(String s) throws Exception&#123; //防空指针 return "null"; &#125; &#125;);public static void setKey(String key,String value)&#123; localCache.put(key,value);&#125;public static String getKey(String key)&#123; String value = null; try&#123; value = localCache.get(key); if("null".equals(value))return null; return value; &#125;catch (...)&#123;&#125; return null;&#125; joda.time字符串-&gt;Date()123DateTimeFormatter df = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");DateTime dt = df.parseDateTime("2015-04-20 2:2:2");return dt.toDate(); CollectionUtils.isEmpty(List)枚举：限制取值 封装响应编码ResponseCode扩展的时候加枚举对象123456789101112131415161718public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 用法 在response对象里：12345@JsonIgnorepublic boolean isSuccess()&#123; //0 return this.status== ResponseCode.SUCCESS.getCode();&#125; 1234567enum color&#123; //枚举的3个实例化对象 外部不允许定义新的color对象 green,red,yellow&#125;color coenum;coenum = color.red;color[] values = color.values(); EnumSet1EnumSet&lt;color&gt; set = EnumSet.allOf(color.class); EnumMap&lt;color,String&gt;12EnumMap&lt;color,String&gt; map = new EnumMap&lt;color, String&gt;(color.class);map.put(color.red,"red"); 构造方法（私有）1234567891011enum Color&#123; red(10),green(20),yellow; private int color; private Color()&#123; System.out.println("无参构造器"); &#125; private Color(int color)&#123; this.color = color; System.out.println("有参构造器"+color); &#125;&#125; 当用Color.red时，会调用3次构造器创建red,green,yellow三个对象 实现接口添加方法12345public int getColor()&#123; return color;&#125;//输出0 Color.red.getColor输出10Color.yellow.getColor(); 也可以单独定义方法 添加抽象方法，每个对象要都实现.getBytes(&#39;iso8859-1&#39;)以iso编码读new String(,&quot;gb2312&quot;)静态代码块：用staitc声明，jvm加载类时执行，仅执行一次 printf(&quot;%n&quot;)总是输出正确的平台特定行分隔符，所以它是跨平台的 内部类 方法内部类只能在方法内实例化，并且不能使用方法内的非final变量方法结束局部变量弹栈，但内部类对象可能需要对象回收 比方法生命周期长。用final在类加载会放入常量池，jdk1.8开始不需要final 编译器自动final，所以不能改变 静态内部类 能使用外部类的静态成员和方法 不用new外部类也能访问 使用内部类可以使用多继承 优先选择静态内部类(防止内存泄漏) 原因：因为java里传参是传值在里面引用外面的参数，外面的参数不应该被修改。不然里面变量和外面变量就会有二义性。如果是传引用两个会同时修改不会有二义性 适配器安卓开发中常用，用A接口的子类转换B接口的子类 代理模式与AOP与模板方法不同：代理是控制对象 模板是延迟到子类定义操作，定义骨架 工厂方法模式：定义一个 创建对象的接口让类的实例化推迟到实现这个接口的子类中进行。依赖注入 策略模式和依赖倒置原则（面向接口编程）模板方法（设计模式） 权限管理 算法骨架不改变算法的结构，重新定义算法的特定步骤展开代码 1234567891011121314151617181920212223242526package javacoretest;abstract class BaseManager&#123; public void action(String username,String method)&#123; if("admin".equals(username))&#123; execute(method); &#125; else&#123; System.out.println("没有权限"); &#125; &#125; public abstract void execute(String Method);&#125;//延迟到子类实现ClassManager...子类有不同的实现class UserManager extends BaseManager&#123; @Override public void execute(String method)&#123; if("add".equals(method)) System.out.println("添加"); else if("del".equals(method)) System.out.println("删除"); &#125;&#125;public class Templete &#123; public static void main(String[] args) &#123; UserManager um = new UserManager(); um.action("admin","add"); &#125;&#125; MD5密码处理展开代码 1234567891011121314151617181920212223242526272829303132import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class MD5demo &#123; //数据库 所以密码只能重置不能查看 private static String savePassWord ="pmq7VoTEWWLYh1ZPCDRujQ=="; public static void main(String[] args) &#123; System.out.println(login("admin123456")); &#125; private static boolean login(String password)&#123; if(savePassWord.equals(md5(password)))&#123; return true; &#125;else &#123; return false; &#125; &#125; private static String md5(String password)&#123; try &#123; MessageDigest md = MessageDigest.getInstance("md5"); byte[] bytes = md.digest(password.getBytes("UTF-8")); String str = Base64.getEncoder().encodeToString(bytes); return str; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 位运算应用 判断奇偶：a&amp;1 = 0 偶数 a&amp;1 = 1 奇数 取模a &amp; (2^n - 1) 12System.out.println(999999&amp;7);System.out.println(999999%8);//相等 &amp;00001111是取get后4位 |00001111是set后4位为1 ^00001111是翻转后4位 java8时间LocalDate LocalTime LocalDateTime 国际化ResourceBundle simpledateformat??? 抗锯齿 异常e.getMassage()printStackTrace();调用堆栈 char 和 byte c++的char 8位，1字节。无byte。typedef unsigned char byte; java byte 静态方法没有this引用 包：保证类名的唯一性 工厂方法：返回一个类的新实例的静态方法 数组用Arraylist 因为内部管理数组，自动创建内部数组转移元素 扩容。 泛型类，自动装箱、自动拆箱 new ArrayList&lt;&gt;(Arrays.asList()) //[]-&gt;ArrayList asList固定长度 不支持add 输入输出 int.next() 读取空格分割的单词 ？？？？？读取密码用Console javaw runs Java code without association with current terminal/console (which is useful for GUI applications),there is no associated console window System.console() returns null.空指针异常 格式化字符串 System.out.printf(“%8.2f”,1000.0/3.0); (Integer).intValue() Object.clone()protected native Object clone() throws CloneNotSupportedException;浅拷贝，子类只能调用被保护的clone自己 Cloneable接口是空的。 实现了Cloneable只是标识 惯例重写Object.clone() 定义成public 1public A clone() throws CloneNotSupportedException 在没有实现Cloneable接口的实例上调用Object的clone方法会导致引发异常CloneNotSupportedException。 标记接口（tagging interface): 空的。使用目的：可以用instanceof Cloneable检查 ??enum toString的逆方法是valueOf super不是对象的引用。不能赋值给对象变量，是只是编译器调用超类方法的关键字 sout(char[]) √ char数组的打印有点特殊，int数组打印是打印出来一个地址，而char数组是打印数组里的内容。 如果重写了equals方法，请一并重写hashCode方法 重写类的equals方法-&gt;支持List 重写+hashCode方法-&gt;支持Set(HashMap,HashSet,LinkedHashMap,ConcurrentHashMap) (obj instanceof Person) 8种基本类型，其它都是对象（引用类型）-&gt; 包装类型 整型 byte short int long 浮点 float double 字符型 char 逻辑型 boolean 方法体里声明的基本数据类型在栈内存里 基本数据类型来说，赋值（=号）就相当于拷贝了一份值 当执行到new这个关键字，会在堆内存分配内存空间，并把该内存空间的地址赋值给arr1 注解 @interface元注解 注解只有一个成员，成员必须取名value（） 没有成员 标识注解 @Target（{}）作用域 @Retention（）生命周期 @Inherited 允许继承 Thread线程共享 *代码和数据空间线程由独立的运行栈和*程序计数器 线程的概念模型 虚拟cpu，在THREAD类中 将代码和数据传给thread类 线程体方法run()中的代码 构造线程的方法 定义线程类，重写run方法，通过start启动 12345678publc class FactorialThreadTester&#123; public static void main(String[] args)&#123; System.out.println("main thread starts"); FactorialThread thread = new FactorialThread(10); thread.start(); System.out.println("main thread ends"); &#125; &#125; runable 主方法main中创建一个新线程会等main执行完后再new 互斥锁 保证同一时刻有且只有一个线程在操作共享数据 解决端口占用123netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80 tasklist | findstr 2000 //端口号taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程 HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。 忽略序列化private transient String passwd;生命周期仅存于调用者的内存中而不会写到磁盘里持久化 final变量经常和static关键字一起使用，作为常量 final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写，只能被继承 final的类无法被继承 public void setLength(final int size)表示不能修改size的值 。对象则不能改变引用 类不能多继承，抽象类的方法可以不实现接口可以多继承 InterruptedException: 如何使HashMap线程安全的123Map&lt;,&gt; ht = new Hashtable&lt;&gt;();Map&lt;,&gt; sy = new Collections.synchronizedMap(new HashMap&lt;,&gt;())Map&lt;,&gt; concurr = new ConcurrentHashMap&lt;&gt;(); CHM（ConcurrentHashMap)性能最佳* Hashtable使用public synchronized阻塞，保证线程安全 .mf 是bean的JAR清单 迭代文件1234try(DirectoryStream&lt;Path&gt; entries = files.newDirectoryStream(dir))&#123; for(Path entry : entries)&#123; &#125;&#125; Map的方法put putAll 1@Native public static final int MAX_VALUE = 0x7fffffff; 0x7fffffff是补码表示的Integer的最小值(-2^31)和最大值(2^31-1),int是4字节。 String内部是通过char数组表示，数组的长度在Java中限制为一个int型所能表示的最大值 最小值 Math.min(,) substring(,)前闭后开 in-place 原地算法 删除重复元素 用!=略过并用unique的覆盖]]></content>
      <categories>
        <category>java源码8+netMVCspring+ioNetty+数据库+并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Thread</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
