<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="date" content="2018-12-25 15:34:13">
<meta name="tags" content="[面试卡片]"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.codehilite {background-color:#fff;color:#333333;}
.codehilite .hll {background-color:#ffffcc;}
.codehilite .c{color:#999988;font-style:italic}
.codehilite .err{color:#a61717;background-color:#e3d2d2}
.codehilite .k{font-weight:bold}
.codehilite .o{font-weight:bold}
.codehilite .cm{color:#999988;font-style:italic}
.codehilite .cp{color:#999999;font-weight:bold}
.codehilite .c1{color:#999988;font-style:italic}
.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}
.codehilite .gd{color:#000000;background-color:#ffdddd}
.codehilite .ge{font-style:italic}
.codehilite .gr{color:#aa0000}
.codehilite .gh{color:#999999}
.codehilite .gi{color:#000000;background-color:#ddffdd}
.codehilite .go{color:#888888}
.codehilite .gp{color:#555555}
.codehilite .gs{font-weight:bold}
.codehilite .gu{color:#800080;font-weight:bold}
.codehilite .gt{color:#aa0000}
.codehilite .kc{font-weight:bold}
.codehilite .kd{font-weight:bold}
.codehilite .kn{font-weight:bold}
.codehilite .kp{font-weight:bold}
.codehilite .kr{font-weight:bold}
.codehilite .kt{color:#445588;font-weight:bold}
.codehilite .m{color:#009999}
.codehilite .s{color:#dd1144}
.codehilite .n{color:#333333}
.codehilite .na{color:teal}
.codehilite .nb{color:#0086b3}
.codehilite .nc{color:#445588;font-weight:bold}
.codehilite .no{color:teal}
.codehilite .ni{color:purple}
.codehilite .ne{color:#990000;font-weight:bold}
.codehilite .nf{color:#990000;font-weight:bold}
.codehilite .nn{color:#555555}
.codehilite .nt{color:navy}
.codehilite .nv{color:teal}
.codehilite .ow{font-weight:bold}
.codehilite .w{color:#bbbbbb}
.codehilite .mf{color:#009999}
.codehilite .mh{color:#009999}
.codehilite .mi{color:#009999}
.codehilite .mo{color:#009999}
.codehilite .sb{color:#dd1144}
.codehilite .sc{color:#dd1144}
.codehilite .sd{color:#dd1144}
.codehilite .s2{color:#dd1144}
.codehilite .se{color:#dd1144}
.codehilite .sh{color:#dd1144}
.codehilite .si{color:#dd1144}
.codehilite .sx{color:#dd1144}
.codehilite .sr{color:#009926}
.codehilite .s1{color:#dd1144}
.codehilite .ss{color:#990073}
.codehilite .bp{color:#999999}
.codehilite .vc{color:teal}
.codehilite .vg{color:teal}
.codehilite .vi{color:teal}
.codehilite .il{color:#009999}
.codehilite .gc{color:#999;background-color:#EAF2F5}
</style><title>面试卡片</title></head><body><article class="markdown-body"><p><a href="https://blog.csdn.net/jackfrued/article/details/44921941">https://blog.csdn.net/jackfrued/article/details/44921941</a>
<a href="https://github.com/randian666/algorithm-study">https://github.com/randian666/algorithm-study</a>
<a href="https://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2">https://www.nowcoder.com/discuss/50571?type=2&amp;order=0&amp;pos=21&amp;page=2</a>
<a href="https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md">https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md</a>
<a href="http://www.linya.pub/">http://www.linya.pub/</a></p>
<p><a href="https://www.nowcoder.com/discuss/111311">https://www.nowcoder.com/discuss/111311</a></p>
<h3 id="_1">反爬虫<a class="headerlink" href="#_1" title="Permanent link"></a></h3>
<h3 id="_2">一个端口的连接数太多<a class="headerlink" href="#_2" title="Permanent link"></a></h3>
<h3 id="jvm">JVM分哪几个区<a class="headerlink" href="#jvm" title="Permanent link"></a></h3>
<h3 id="zookeeper">zookeeper的应用场景<a class="headerlink" href="#zookeeper" title="Permanent link"></a></h3>
<p>分布式锁</p>
<h3 id="_3">索引什么时候会失效<a class="headerlink" href="#_3" title="Permanent link"></a></h3>
<h3 id="_4">红黑树原理<a class="headerlink" href="#_4" title="Permanent link"></a></h3>
<h3 id="spring">Spring容器初始化过程<a class="headerlink" href="#spring" title="Permanent link"></a></h3>
<p>ioc aop原理</p>
<h3 id="_5">协程<a class="headerlink" href="#_5" title="Permanent link"></a></h3>
<h3 id="java">Java内存分配策略<a class="headerlink" href="#java" title="Permanent link"></a></h3>
<p>Java对象的内存分配主要是指在堆上分配（也有经过JIT编译后被拆散为标量类型并间接地在栈上分配的情况），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，则将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。</p>
<p>怎么把对象分配到老年代上</p>
<h3 id="redis">redis持久化<a class="headerlink" href="#redis" title="Permanent link"></a></h3>
<p>持久化方式：
1）快照 Mysql Dump和Redis RDB 2）写日志 Mysql Binlog Hbase Hlog Redis AOF</p>
<p>RDB是保存数据库中的键值对，AOF保存redis执行的命令。</p>
<h4 id="rdb">RDB<a class="headerlink" href="#rdb" title="Permanent link"></a></h4>
<p>RDB是压缩过的二进制文件,会生成临时文件，把老的RDB文件替换掉。
BGSAVE不会阻塞服务器进程，会创建子进程创建RBD文件。copy-on-write策略，但是父进程写入还会做副本 内存开销大。
触发机制：从节点全量复制主节点会生成RDB文件。 debug reload 、 shutdown。
缺点磁盘性能，宕机没快照的丢了。但是恢复速度快。</p>
<h4 id="aof">AOF<a class="headerlink" href="#aof" title="Permanent link"></a></h4>
<p>AOF更新频率通常比RDB高。
写【命令】先从redis 写到硬盘缓冲区 再根据3种策略（everysec每秒，always，no（操作系统自己刷)）fsync到硬盘AOF文件。
AOF会开子进程重写。</p>
<h4 id="_6">主从复制<a class="headerlink" href="#_6" title="Permanent link"></a></h4>
<p>主从复制（副本）集群是为了解决多请求，读写分离，高可用，
分布式是为了解决一个请求的多个步骤。
数据是单向的。可以通过<code>slaceof</code> 或者配置方式<code>slave-read-only yes</code>实现。
进入redis用<code>info replication</code>可以查看主从状态</p>
<h5 id="_7">全量复制<a class="headerlink" href="#_7" title="Permanent link"></a></h5>
<p>1）第一次是全量复制<code>full resync</code> master会<code>BGSAVE</code>。
2）从节点的数据全部清除<code>Flushing old data</code>，通过网络接受RDB文件，加载RDB文件到内存。
<code>info server |grep run</code> 
3）在同步期间master的写命令会单独记录，rdb同步完后通过偏移同步给slave。
可以看到redis实例的run_id。如果从复制的主节点的id发生变化，则需要全量复制。</p>
<p><img alt="fullsync.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/fullsync.jpg" /></p>
<h5 id="_8">部分复制<a class="headerlink" href="#_8" title="Permanent link"></a></h5>
<p><code>info replication</code> 可以看到master的偏移量<code>master_repl_offset</code>和slave的偏移量<code>slave_repl_offset</code>，主节点可以看到各个从节点的偏移量。
偏移量主比从大表示主写入了数据还没同步到从。
如果主从连接断了，先重连，从服务器发送runid和offset，主服务器发送buffer中的部分数据。</p>
<h4 id="redis-sentinel">redis 高可用 sentinel<a class="headerlink" href="#redis-sentinel" title="Permanent link"></a></h4>
<p>currentHashMap
mysql 的其他引擎
设计数据库表</p>
<h3 id="_9">数据库里的乐观锁和悲观锁<a class="headerlink" href="#_9" title="Permanent link"></a></h3>
<p>悲观锁：<code>select ... for update;</code> 
   主键明确&amp;有结果行锁，无结果集（查空）无锁。 
   查询无主键或者不走索引<code>where id&lt;&gt;'66'</code> <code>like</code>，表索 。
乐观锁：数据库<code>version</code>字段</p>
<h3 id="hash">Hash碰撞的方法<a class="headerlink" href="#hash" title="Permanent link"></a></h3>
<p>1）开放地址法 开放地址法分： 线性探测法（会聚集）、平方探测、双散列
2）链地址法</p>
<p>不成功平均查找长度，要按照冲突解决方法查找到当前位置为空位置。最后/散列函数的mod（hash函数的分类个数）</p>
<h3 id="1">1.泛型的好处<a class="headerlink" href="#1" title="Permanent link"></a></h3>
<p>泛型：向不同对象发送同一个消息，不同的对象在接收到时会产生不同的行为（即方法）；也就是说，每个对象可以用自己的方式去响应共同的消息。消息就是调用函数，不同的行为是指不同的实现（执行不同的函数）。
用同一个调用形式，既能调用派生类又能调用基类的同名函数。</p>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ul>
<li>为什么不能根据返回类型来区分重载?
因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。</li>
</ul>
<p>虚函数是实现多态 &ldquo;动态编联”的基础，C++中如果用基类的指针来析构子类对象，基类的析构要加<code>virtual</code>，不然不会调用子类的析构，会内存泄漏。</p>
<h3 id="2inndb">2.数据库索引INNDB的好处<a class="headerlink" href="#2inndb" title="Permanent link"></a></h3>
<p>事务，主键索引，外键
自增长列必须是主键，索引的第一个列，而且因为不是表锁要考虑并发增长。
innodb其实不是根据每个记录产生行锁的，根据页加锁，而且用位图。</p>
<p>意向锁。锁定对象分为几个层次，支持行锁、表锁同时存在。</p>
<p>一致性非锁定读：读快照 多版本并发控制：read committed是最新快照，重复读是事务开始时的快照。通过undo完成的。</p>
<p>redo 保证事务的一致性、持久性。undo 保证事务的一致性（回滚）和MVCC多版本并发控制。</p>
<p>行锁会用gap锁锁住一个区间，阻止多个事务插入到同一范围内。是为了解决幻读问题。
一个事务select * from t where a&gt;2 for update;对[2+)加锁，另一个事务插入5失败。</p>
<p>不走索引表锁。</p>
<p>myisam 缓冲池之缓存索引文件，不缓存数据。 索引和数据分文件。</p>
<h3 id="_10">脏读<a class="headerlink" href="#_10" title="Permanent link"></a></h3>
<p>脏页是最终一致性的，数据库实例内存和磁盘异步造成的。脏（数据）读违反了隔离性。</p>
<h3 id="xa">XA事务 分布式事务<a class="headerlink" href="#xa" title="Permanent link"></a></h3>
<p>事务管理器（Mysql客户端）和资源管理器（Mysql数据库）之间用两阶段提交，等所有参与全局事务的都能提交再提交
用JAVA JTA API</p>
<h3 id="2mysql">2.mysql日志文件（不是引擎）<a class="headerlink" href="#2mysql" title="Permanent link"></a></h3>
<p>binlog(逻辑日志，是sql）用于主从复制、慢查询、查询、错误
重做日志缓存，按一定频率写到重做日志文件 是innodb的。</p>
<p>因为只有一个主键并且建了B+树，所以其他辅助索引的插入是离散的，所以，有insert buffer</p>
<h4 id="_11">主从复制<a class="headerlink" href="#_11" title="Permanent link"></a></h4>
<p>主节点创建线程发送binlog，读取binlog时会加锁。
从节点I/O线程接受binlog，保存在relaylog。
从节点SQL线程读取relaylog，并执行sql。完成数据一致性。</p>
<p>主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。</p>
<h3 id="3cas">3.CAS算法原理？优缺点？<a class="headerlink" href="#3cas" title="Permanent link"></a></h3>
<p>非阻塞算法：一个线程的失败或者挂起不会导致其他线程也失败或者挂起。
无锁算法：算法的每个步骤，都存在某个线程能执行下去。多个线程竞争CAS总有一个线程胜出并继续执行。</p>
<p>CAS 是实现非阻塞同步的计算机指令，它有三个操作数，内存位置，旧的预期值，新值，
对于多个状态变量的场景，通过<code>AtomicReference</code>包装这个对象，每次更新先获取旧值，再创建新值，用这两个值进行CAS原子更新。</p>
<p>AQS利用CAS原子操作维护自身的状态，结合LockSupport对线程进行阻塞和唤醒从而实现更为灵活的同步操作。</p>
<h4 id="aqs">AQS<a class="headerlink" href="#aqs" title="Permanent link"></a></h4>
<p><code>private volatile int state;</code>
<code>ReentrantLock</code>用来表示所有者重复获取该锁的次数
<code>Semaphore</code>表示剩余许可数量
<code>FutureTask</code>用于表示任务状态(现在FutureTask不用AQS了)但也是state</p>
<p>当线程尝试更改AQS状态操作获得失败时，会将Thread对象抽象成Node对象 形成CLH队列，LIFO规则。</p>
<h3 id="4">4.为什么是三次握手<a class="headerlink" href="#4" title="Permanent link"></a></h3>
<p>三次握手的过程：
<a href="https://juejin.im/post/5a0444d45188255ea95b66bc">https://juejin.im/post/5a0444d45188255ea95b66bc</a>
客户端 SYN=1+序号a ， 
服务端 SYN=1，ACK=1,序号b，ack=序号a+1, 
客户端 ACK = 1，序号=a+1,ack=b+1</p>
<p>信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 三次通信是理论上的最小值。</p>
<p>1）初始化序号 （来解决网络包乱序（reordering）问题），互相通知自己的序号。</p>
<p>2）为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
如果A发送2个建立链接给B，第一个没丢只是滞留了，如果不第三次握手只要B同意连接就建立了。
如果B以为连接已经建立了，就一直等A。所以需要A再确认。</p>
<p>首次握手隐患：服务器收到ACK 发送SYN-ACK之后没有回执，会重发SYN-ACK。产生SYN flood。
用<code>tcp_syncookies</code> 参数</p>
<h3 id="41">4.1 快重传<a class="headerlink" href="#41" title="Permanent link"></a></h3>
<h3 id="tcpwindow-size-16bit">TCP滑动窗口window size 16bit位 可靠性+流量控制+拥塞控制<a class="headerlink" href="#tcpwindow-size-16bit" title="Permanent link"></a></h3>
<p>window 接收端告诉发送端自己还有多少缓冲区可以接收数据rwnd
option中还有一个窗口扩大因子</p>
<h3 id="5">5.为什么四次分手<a class="headerlink" href="#5" title="Permanent link"></a></h3>
<p>1)由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。
    当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。
    收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h4 id="time_wait2msl">为什么要TIME_WAIT等2MSL  最长报文段寿命<a class="headerlink" href="#time_wait2msl" title="Permanent link"></a></h4>
<p>1）可靠地实现TCP全双工连接终止。等最后一个ACK到达。
MSL是任何IP数据报的最长存活时间。
如果没收到ACK，则被动方重发FIN，再ACK正好是两个MSL。
主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。
【rst】是一种关闭连接的方式。
2)让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。
为什么是2MSL是让某个方向上最多存活MSL被丢弃，另一个方向上的应答最多存活MSL被丢弃。</p>
<h4 id="time_wait-close_wait">TIME_WAIT 和 CLOSE_WAIT<a class="headerlink" href="#time_wait-close_wait" title="Permanent link"></a></h4>
<p>1）发送FIN变成FIN_WAIT1，然后收到对方ACK+FIN，发完ACK
2）FIN_WAIT1 收到ACK之后到FIN_WAIT2，然后收到FIN，发送ACK
这个状态等2MSL后就CLOSED
作用：让本连接持续时间内所有的报文都从网络中消失，下个连接中不会出现旧的请求报文。</p>
<p>HTTP长连接主动关闭的是server，TIME_WAIT可以修改参数解决。
<code>net.ipv4.tcp_tw_recycle = 1</code>可以快速回收TIME-WAIT</p>
<p>CLOSE_WAIT 被动关闭后没有释放连接，一般是代码写的有问题。</p>
<p>TCP连接状态书上一共11种</p>
<h4 id="udp">和UDP区别<a class="headerlink" href="#udp" title="Permanent link"></a></h4>
<p>1）无连接 不可靠 无序
2）广播
3）速度快 报头只有8字节 TCP是字节流，数据分段TCP是无边界的，UDP面向报文，保留了边界。</p>
<h3 id="6">6.数据库最左匹配原理<a class="headerlink" href="#6" title="Permanent link"></a></h3>
<h3 id="7http-https">7.http https<a class="headerlink" href="#7http-https" title="Permanent link"></a></h3>
<p>https的过程：</p>
<p><img alt="httphttps.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/httphttps.jpg" />
http 有9种方法
<img alt="https2.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/https2.jpg" /></p>
<p>RSA:
两种方式：
1）全密文：用对方公钥加密，对方用私钥解密 
2）明文+印章（防抵赖）：用自己私钥签名，对方用公钥验签
使用AOP实现</p>
<h3 id="8">8.进程间通信<a class="headerlink" href="#8" title="Permanent link"></a></h3>
<p>套接字，管道，命名管道、邮件槽、远程过程调用、消息队列，共享内存，信号量,信号。</p>
<p>信号：异步的通知机制，用来提醒进程一个事件已经发生</p>
<p>信号是在软件层次上对中断机制的一种模拟。    </p>
<p><code>trap -l</code>
<code>trap "" INT</code> 表明忽略SIGINT信号，按Ctrl+C也不能使脚本退出</p>
<p><a href="https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/IPC.md">https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/IPC.md</a></p>
<p>管道只能两个进程
消息队列能多个进程</p>
<h4 id="_12">管道 【随进程持续】：<a class="headerlink" href="#_12" title="Permanent link"></a></h4>
<p>1）单向 半双工：把一个程序的输出直接连接到另一个程序的输入
2）除非读端已经存在，否则写端的打开管道操作会一直阻塞
3）只能父子进程、兄弟进程
4）无格式字节流，需要事先约定数据格式。</p>
<h6 id="_13">匿名管道：内存文件描述符（内核）。<a class="headerlink" href="#_13" title="Permanent link"></a></h6>
<p>1）<code>pipe(2)</code>系统调用时，这个函数会让系统构建一个匿名管道
2）这样在进程中就打开了两个新的，打开的文件描述符：父进程关闭管道读端，子进程关闭管道写端。
3）一般再fork一个子进程，然后通过管道实现父子进程间的通信。
4）通过只在【内存】（内核）中的文件描述符fd<a href="///D://iotacecil.github.io/source/_posts/l%3D0%2Cr%3D1%2Cl%2B%2B%2Cwhile%28l%3D%3Dr%29%E7%9A%84%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E7%BB%93%E6%9D%9F">0</a>表示读 fd[1]表示写。（父子进程分别关闭一端组合成父进程-&gt;子进程/子进程-&gt;父进程的管道）</p>
<h5 id="fifofifo">命名管道FIFO文件：提供一个路径名与之关联，以FIFO文件形式存在于【文件系统】<a class="headerlink" href="#fifofifo" title="Permanent link"></a></h5>
<p><code>mkfifo()</code>
可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接。
1)读管道程序 mkfifo创建管道文件，死循环read
2)写程序 打开管道文件写。</p>
<p>借助了文件系统的file结构和VFS的索引节点inode。过将两个file 结构指向同一个临时的VFS 索引节点，而这个VFS引节点又指向一个物理页面</p>
<p>管道和命名管道都是随进程持续的，而消息队列还有后面的信号量、共享内存都是随内核持续的</p>
<h4 id="msgget">消息队列（链表） msgget（同一台机器） 系统内核： （一种逐渐被淘汰的方式）<a class="headerlink" href="#msgget" title="Permanent link"></a></h4>
<p><code>msgid = msgget((key_t)1234, 0666 | IPC_CREAT);</code>msgget()msgrcv()
1）异步：消息队列本身是【异步】的，消息队列独立于进程存在。它允许接收者在消息发送很长时间后再取回消息
2）消息必须以<code>long int</code> 开头 , 接收程序可以通过消息类型有选择地接收数据。
3）可以同时通过发送消息，避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。</p>
<p>4）轮询：收者必须轮询消息队列，才能收到最近的消息。
5）优先级
6）与管道相比，消息队列提供了有格式的数据 【读写双方都需要<code>msgget</code>建立消息队列】
7）和信号相比，消息队列能够传递更多的信息</p>
<h4 id="shmget">共享内存<code>shmget</code> 最快但是无法解决同步<a class="headerlink" href="#shmget" title="Permanent link"></a></h4>
<p>1）<code>shmget</code>创建一个 结构体大小的共享内存，有权限
2）<code>shmat</code> 映射到进程的地址空间。
3）读写的时候要用written标志防止两个进程同时读写 而且要把written变成原子操作
4）<code>shmdt</code>可以分离共享内存
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">shared_use_st</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">written</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">text</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
<span class="p">};</span>
</pre></div></p>
<p>同一个Linux机器的两个进程访问同一块共享内存，他们访问共享内存中的同一个对象的时候，指针相同吗？
可能相同也可能不同</p>
<h4 id="semget">信号量<code>semget</code> 有权限<a class="headerlink" href="#semget" title="Permanent link"></a></h4>
<p>不是线程同步的posix信号量，是<code>SYSTEM V</code>信号量
信号量能解决 共享内存同步问题</p>
<h3 id="9">9.线程池的运行流程，使用参数以及方法策略<a class="headerlink" href="#9" title="Permanent link"></a></h3>
<p>运行流程：
1）如果运行的线程小于<code>corePollsize</code>，则创建新线程，即使其他事空闲的。
2）当线程池中线程数量&gt;<code>corePollsize</code> 则只有当<code>workQueue</code>满才去创建新线程处理任务
3）如果没有空闲，任务封装成Work对象放到等待队列
4) 如果队列满了，用<code>handler</code>指定的策略 （5种）
<code>ctl</code> 状态值（高3位）和有效线程数（29位）</p>
<p><img alt="threadpoll.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/threadpoll.jpg" /></p>
<p>线程池的状态：
RUNNING： 能接受提交
SHUTDOWN: 不能提交，但是能处理。
STOP： 不接受提交也不处理 
TIDYING： 所有任务都已经终止 有效线程数为0
TERMINATED： 标识</p>
<p>一共有5种线程池：
1）fixed
2）cached 处理大量短时间工作任务 长期闲置的时候不会消耗资源
3）sigle 保证顺序执行多个任务
4）scheduled 定时、周期工作调度
5）<code>newWrokStealingPoll</code> 工作窃取</p>
<h4 id="_14">如何优化线程池<a class="headerlink" href="#_14" title="Permanent link"></a></h4>
<h3 id="10">10.线程同步的方法<a class="headerlink" href="#10" title="Permanent link"></a></h3>
<p>互斥量(mutex) </p>
<p>读写锁 
 降级：获得写入锁能不能不释放获得读取锁。
 升级：一般不支持，因为两个读线程同时升级为写入锁，会死锁。</p>
<p>synchronized<br />
volatile
ThreadLocal
LinkedBlockingQueue</p>
<p>直接交接队列<code>SynchronousQueue</code>不使用缓存，没有空闲线程就开线程，需要限定好线程池最大数量。
atomic</p>
<h3 id="101-semaphore">10.1信号量 Semaphore ： 管理多线程竞争<a class="headerlink" href="#101-semaphore" title="Permanent link"></a></h3>
<p>例子：100个线程抢10个数据库连接。</p>
<h3 id="102-condition">10.2 Condition ： 线程通信 多个阻塞队列线程间通信<a class="headerlink" href="#102-condition" title="Permanent link"></a></h3>
<p>目的：Condition 可以在多线程中创建多个阻塞队列。
例子1：实现 【仓库数量&gt;1】 的生产者消费者：
将生产者和消费者放入不同的阻塞队列，精准控制。
生产者判断full满就阻塞，加入商品后唤醒所有阻塞empty的消费者线程。</p>
<p>Condition
1）由Lock对象生成
2）<code>await</code> 会释放锁，阻塞。 <code>signal</code>能唤醒。 wait和notify只能建立一个阻塞队列。 </p>
<h3 id="103">10.3锁<a class="headerlink" href="#103" title="Permanent link"></a></h3>
<h4 id="lock-reenreantlock">Lock ReenreantLock<a class="headerlink" href="#lock-reenreantlock" title="Permanent link"></a></h4>
<p>1）可中断 2）可定时轮询 3）锁分段，每个链表节点用一个独立的锁，多线程能对链表的不同部分操作。
4）公平性
同一个账户的存钱、取钱业务应该先完整完成一次后才释放锁。
Lock可以跨方法锁对象：登录加锁，登出释放。
<code>tryLock</code>如果获取锁失败会立刻返回 false，不会阻塞。</p>
<h4 id="syncronize">syncronize 可重入<a class="headerlink" href="#syncronize" title="Permanent link"></a></h4>
<p>对象头 Monitor(管程) entry set，wait set
<a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a>
正确说法：给调用该方法的【对象】加锁。在一个方法调用结束之前，其他线程无法得到这个对象的控制权。</p>
<p>缺点：只能实现方法级别的排他性，不能保证业务层面（多个方法）。</p>
<h5 id="synchronized">Synchronized的锁优化机制<a class="headerlink" href="#synchronized" title="Permanent link"></a></h5>
<h4 id="notifywait"><code>notify</code>和<code>wait</code><a class="headerlink" href="#notifywait" title="Permanent link"></a></h4>
<p>放置在sychronized作用域中，wait会释放synchronized关联的锁阻塞，
实现存库为1的生产者消费者。</p>
<p>线程池 参数，常用的
callable</p>
<h3 id="11c">11.C++虚函数作用及底层实现<a class="headerlink" href="#11c" title="Permanent link"></a></h3>
<p>虚函数是使用虚函数表和虚函数表指针实现的。
虚函数表：一个类 的 虚函数 的 地址表：用于索引类本身及其父类的虚函数地址，如果子类重写，则会替换成子类虚函数地址。
虚函数表指针： 存在于每个对象中，指向对象所在类的虚函数表的地址。
多继承：存在多个虚函数表指针。</p>
<h3 id="12">12.<a class="headerlink" href="#12" title="Permanent link"></a></h3>
<h3 id="13">13.<a class="headerlink" href="#13" title="Permanent link"></a></h3>
<h3 id="15onlogn">15.基于比较的算法的最优时间复杂度是O(nlog(n))<a class="headerlink" href="#15onlogn" title="Permanent link"></a></h3>
<p>因为n个数字全排列是n! 一次比较之后，两个元素顺序确定，排列数为 n!/2!
总的复杂度是O(log(n!)) 根据斯特林公式就等于O(nlog(n))</p>
<h3 id="16">16 快速排序<a class="headerlink" href="#16" title="Permanent link"></a></h3>
<p>基本：
最普通的，每次取<a href="///D://iotacecil.github.io/source/_posts/l%3D0%2Cr%3D1%2Cl%2B%2B%2Cwhile%28l%3D%3Dr%29%E7%9A%84%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E7%BB%93%E6%9D%9F">0</a>作子集划分s1+<a href="///D://iotacecil.github.io/source/_posts/l%3D0%2Cr%3D1%2Cl%2B%2B%2Cwhile%28l%3D%3Dr%29%E7%9A%84%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E7%BB%93%E6%9D%9F">0</a>+s2,再递归两个子集。
最坏情况123456 O(n^2)
<div class="codehilite"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">qS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span><span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&gt;=</span><span class="n">right</span><span class="o">)</span><span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
        <span class="c1">// 因为保证i最后在左集合右边 用++i </span>
        <span class="c1">// 所以初始化的时候边界都向外扩一格</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(++</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(--</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">);</span>
            <span class="c1">// 关键</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">){</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span><span class="n">i</span> <span class="o">,</span> <span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 把主元放到左集合右边</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="n">qS</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">qS</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div></p>
<p>注意1：
主元：1取头、中、尾的中位数比随机函数便宜。
用ifelse判断这三个数，1)把最小的放到左边2)把最大的放到右边3)把中间的数替换到最后位置上
<code>pivot = nums[n-1]</code></p>
<p>然后用pivot划分子集，i从左开始，j从右开始,i最后停在j右边，交换<code>[i],[n-1]</code>，pivot放了正确的位置。</p>
<p>注意2：
如果有重复元素 如果11111，
1）重复元素也交换，最后pivot也会被换到中间，很等分nlogn。
2）不交换，i直接比较到最后，pivot还是在最后，变成n^2</p>
<p>注意3：
小规模数据集（N不到100可能还不如插入排序）
当递归的长度够小直接插入排序。</p>
<p _="%" endfold="endfold">JDK <code>Arrays.sort()</code>中的根据阈值从merge，quick，insert，count sort中选一个
{% fold %}
<div class="codehilite"><pre><span class="cm">/**如果数组长度小于 this, Quicksort 优先于 merge sort.*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">QUICKSORT_THRESHOLD</span> <span class="o">=</span> <span class="mi">286</span><span class="o">;</span>

<span class="cm">/**如果数组长度小于 this , insertion sort 优先于 Quicksort.*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INSERTION_SORT_THRESHOLD</span> <span class="o">=</span> <span class="mi">47</span><span class="o">;</span>

<span class="cm">/**如果Byte数组长度大于this, counting sort 优先于 insertion sort. */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNTING_SORT_THRESHOLD_FOR_BYTE</span> <span class="o">=</span> <span class="mi">29</span><span class="o">;</span>

<span class="cm">/** 如果short or char 数组长度大于 this, counting sort 优先于 Quicksort.*/</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR</span> <span class="o">=</span> <span class="mi">3200</span><span class="o">;</span>
</pre></div></p>
<h3 id="17">17 堆排序 不需要额外空间<a class="headerlink" href="#17" title="Permanent link"></a></h3>
<p>堆（数组实现的完全二叉树）
左孩子是<code>(1+i&lt;&lt;1)</code> // 1+i&lt;&lt;2 奇数
右孩子是<code>(i+1)&lt;&lt;1</code> //偶数
父节点是<code>(i-1)&gt;&gt;1</code></p>
<p>堆排序：
线性复杂度将数组调成最大堆O(n)，将堆顶和数组最后交换，堆规模-1，再调成最大堆。</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">heapSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">s</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">--;</span>
        <span class="c1">//swap(0,n-1)</span>
        <span class="kt">int</span> <span class="n">rst</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">s</span><span class="o">];</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">shifDown</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>建堆方法1：
从上到下，每个新加的结点放在最右下，然后shiftUp每个 复杂度O(nlogn) (都可以做全排序了)
正确方法：
思路：
每个叶节点都成一个子堆，下滤操作能完成两个子堆的合并。</p>
<div class="codehilite"><pre><span class="kd">private</span> <span class="kt">int</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">rst</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">s</span><span class="o">];</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">rst</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">shifDown</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span><span class="n">last</span><span class="o">,</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">rst</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//down不会超过树的高度 所以O(logn)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">shifDown</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&gt;&gt;&gt;</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">half</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">child</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">child</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">rc</span><span class="o">]){</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">rc</span><span class="o">];</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">rc</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 大顶堆，如果比叶子都大，下面已经是有序堆了，就完成了</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">el</span><span class="o">){</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">el</span><span class="o">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">child</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// log(n)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">shifUp</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)&gt;&gt;&gt;</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">parent</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">)</span><span class="k">break</span><span class="o">;</span>
        <span class="c1">// 下移父节点</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">heapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
        <span class="n">shifDown</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span><span class="n">i</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>

<p>复杂度：
复杂度每个节点只需要比较的长度最多是这个节点到叶子的高度（而不是在树中的深度）。O(N)的
因为二叉树越底层节点越多。深度越高节点越多，所以上滤复杂度高。</p>
<p>从右下开始依次下滤，所有叶子节点都不用下滤。
如果全堆大小为n，内部节点最后一个的idx是<code>(n/2)-1</code>
例子：一共9个节点 各层1，2，4，2个。最后一个内部节点是3，它的右边和下面都是叶子。</p>
<h3 id="18">18 没有中序没办法确定二叉树<a class="headerlink" href="#18" title="Permanent link"></a></h3>
<p>前序 根左右
后序 左右根
找不到左右的边界</p>
<h3 id="19-redissds">19 redis动态字符串sds的优缺点<a class="headerlink" href="#19-redissds" title="Permanent link"></a></h3>
<p>结构：1）len 2）free 3）buf数组
优点
1）以\0结尾，可以复用c string的库函数。
2）O(1)复杂度获取长度
3) <strong>杜绝缓冲区溢出</strong> （c如果没分配够空间就直接覆盖了)
4) 减少内存重分配（空间预分配和惰性空间释放）
5）二进制安全（可以存图片等特殊格式），c字符串中不能包含空字符。</p>
<h3 id="20">20 数据库三范式<a class="headerlink" href="#20" title="Permanent link"></a></h3>
<p>第一范式：列不可拆分 目的：列原子性
第二范式：每个属性要完全依赖于主键
第三范式：非主键关键字段之间不能存在依赖关系，避免更新、插入、删除异常。每一列都要与主键直接相关。【消除传递依赖】。各种信息只在一个地方存储，不出现在多张表中
BCNF：表的部分主键依赖于非主键部分 应该拆分。
第四范式：两个均是1：N的关系，当出现在一张表的时候，会出现大量的冗余。所以就我们需要分解它，减少冗余。</p>
<h3 id="20-5">20 数据库 5约束<a class="headerlink" href="#20-5" title="Permanent link"></a></h3>
<p>主键约束PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。
唯一约束UNIQUE  默认值约束DEFAULT  非空约束NOT NULL 外键约束FOREIGN KEY CHECK （CHECK (P_Id&gt;0)）</p>
<h3 id="20-natural-join">20 自然连接 NATURAL JOIN<a class="headerlink" href="#20-natural-join" title="Permanent link"></a></h3>
<p>columns with the same name of associate tables will appear once only.
自然连接是指关系R和S在所有公共属性(common attribute)上的等接(Equijoin). 但在得到的结果中公共属性只保留一次, 其余删除.</p>
<p>控制文件：Oracle服务器在启动期间用来标识物理文件和数据库结构的二进制文件</p>
<h3 id="21-oommemory-leak">21 内存溢出OOM和内存泄漏memory leak<a class="headerlink" href="#21-oommemory-leak" title="Permanent link"></a></h3>
<p><code>jstat</code></p>
<h3 id="22">22 四种引用类型<a class="headerlink" href="#22" title="Permanent link"></a></h3>
<p>强引用，软引用，弱引用，虚引用
软引用：内存不够二次回收
弱引用：回收</p>
<h3 id="23-java">23 Java线程状态<a class="headerlink" href="#23-java" title="Permanent link"></a></h3>
<p>New， Runnable， Timed Waiting， Waiting，Blocked，Terminated</p>
<h3 id="24-12">24 生产者消费者问题（消费的是同一个东西） 1个互斥2个同步<a class="headerlink" href="#24-12" title="Permanent link"></a></h3>
<p>P表示-1，V表示+1
事件关系：
1）互斥：缓冲区是临界资源，需要<strong>互斥</strong>访问
2）同步：缓冲区满，生产者等待消费者取 （先后顺序）
3）同步：缓冲区空，消费者等生产者生产 （先后）</p>
<p>信号量机制：一个关系一个信号量
1）互斥信号量初始化为1
2）缓冲区同步的信号量根据系统资源初始值设定
    1）生产者：空闲缓冲区数量 信号量初始值<code>empty = n</code>
    2）消费者：缓冲区产品数量 初始值<code>full = 0</code>
互斥信号量是在同一个进程之间操作的。
一前一后同步关系 ，两个信号量的PV操作在不同的进程</p>
<p>生产者：
<div class="codehilite"><pre><span class="n">product</span><span class="o">(){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">1</span><span class="o">){</span>
        <span class="n">P</span><span class="o">(</span><span class="n">empty</span><span class="o">)</span>
        <span class="n">P</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="c1">//放入缓冲区</span>
        <span class="n">V</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="n">V</span><span class="o">(</span><span class="n">full</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">custom</span><span class="o">(){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">1</span><span class="o">){</span>
        <span class="n">P</span><span class="o">(</span><span class="n">full</span><span class="o">)</span>
        <span class="n">P</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="c1">// 取出</span>
        <span class="n">V</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="n">V</span><span class="o">(</span><span class="n">empty</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<img alt="cuspro.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/cuspro.jpg" /></p>
<p>注意点：
1）对于P操作 一定要先操作同步信号量再操作互斥信号量，不然互斥加锁然后同步阻塞 循环等待 就死锁了。 V操作顺序无所谓
2）生产和使用操作不要放到PV操作（临界区）里面，时间太多</p>
<h3 id="25">25 多生产者 多消费者 （一个临界区，但是生产者和消费者有特定类型）<a class="headerlink" href="#25" title="Permanent link"></a></h3>
<p>例子：只有一个盘子，父亲-儿子之间生产-消费 苹果，母亲-女儿之间生产-消费 橘子</p>
<p>关系：
1）互斥：盘子
2）同步：父亲儿子 消费-生产
3）同步：母亲女儿 消费-生产
4）同步：盘子空（事件） 之后 放入水果</p>
<p>事件信号量：
1）互斥1
2）盘子中的苹果 0
3) 盘子中的橘子 0
4）盘子中的剩余空间 1
<img alt="cuspromulti.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/cuspromulti.jpg" /></p>
<p>注意：
1）如果盘子资源为1，不用加互斥，剩余空间就可以用来互斥了
2）如果盘子资源为2以上，不加互斥会数据覆盖</p>
<h3 id="26-count">26 读者-写者问题 count计数器<a class="headerlink" href="#26-count" title="Permanent link"></a></h3>
<p>1）允许多个读
2）只许一个写
3）完成写之前不允许读/写
4）写之前要没有读/写操作</p>
<p>关系：
1）互斥：写-写
2）互斥：写-读（第一个读进程要对文件加锁）(最后一个进程解锁)</p>
<p>信号量：
1）互斥 是否有进程在访问文件 <code>semaphore rw = 1</code>
2) 当前有几个读进程在访问 <code>int count = 0</code>
3）互斥count：隐藏3 <code>mutex = 1</code> 因为判断是不是第一个和计数不原子，所以判断+增加要加锁
<img alt="read-write.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/read-write.jpg" /></p>
<p>问题：实际上是读优先。读进程太多会导致写进程饿死
改进：用信号量<code>semaphore w = 1;</code>
<div class="codehilite"><pre><span class="n">semaphore</span> <span class="n">rw</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// 文件互斥</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// 读进程计数</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// count计数互斥</span>
<span class="n">semaphore</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// 写进程优先</span>
<span class="n">writer</span><span class="o">(){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">1</span><span class="o">){</span>
        <span class="n">P</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
        <span class="n">P</span><span class="o">(</span><span class="n">rw</span><span class="o">)</span>
        <span class="c1">// 写文件</span>
        <span class="n">V</span><span class="o">(</span><span class="n">rw</span><span class="o">)</span>
        <span class="n">V</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">reader</span><span class="o">(){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">1</span><span class="o">){</span>
        <span class="c1">// 如果前一个读执行到释放w后，</span>
        <span class="c1">// w会被写抢走，下一个读会等待写完成</span>
        <span class="n">P</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
        <span class="c1">// 用于count互斥访问</span>
        <span class="n">P</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">P</span><span class="o">(</span><span class="n">rw</span><span class="o">)</span>
        <span class="n">count</span><span class="o">++</span>
        <span class="n">V</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="c1">// 写会抢走</span>
        <span class="n">V</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
        <span class="n">P</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
        <span class="n">count</span><span class="o">--</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">V</span><span class="o">(</span><span class="n">rw</span><span class="o">)</span>
        <span class="n">V</span><span class="o">(</span><span class="n">mutex</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
不是疯狂写优先。是读写公平的。先来先服务的。</p>
<h3 id="27">27 哲学家问题 两个临界资源 防止死锁<a class="headerlink" href="#27" title="Permanent link"></a></h3>
<p>5个哲学家 5个筷子 拿起左然后右吃饭
方法1：只允许4个人吃饭(初始值为4的信号量)
方法2：奇数号的先拿左边，偶数号的先拿右边
方法3：用一个信号量同时对拿左边拿右边加锁
<img alt="zexuemutex.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/zexuemutex.jpg" /></p>
<h3 id="28">28 银行家算法（避免死锁） 安全序列 不会死锁<a class="headerlink" href="#28" title="Permanent link"></a></h3>
<p>手里有100亿钱，A要最多借70，B最多借40，C最多借50，借完了就会全部还回来。现在已经分别借了ABC一些，ABC其中一个再发起了一个请求，应不应该借？
银行家算法：每次分配资源之前，判断是否会进入不安全状态（可能会产生死锁（没钱借又拿不会钱）
<img alt="yinhang.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/yinhang.jpg" />
找安全序列：
用剩余资源 遍历所有进程 还需资源，如果可以分配，则分配+拿回全部资源+加入安全序列+从遍历中移除，再从头遍历所有进程。
<img alt="yinhang2.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/yinhang2.jpg" /></p>
<h3 id="29">29 死锁条件<a class="headerlink" href="#29" title="Permanent link"></a></h3>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
死锁的发生必须满足以下四个条件：
- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="30">30 死锁处理策略<a class="headerlink" href="#30" title="Permanent link"></a></h3>
<p>1）预防死锁 前面4个条件 2）避免死锁 银行家算法 3）死锁检测再解除
互斥条件：SPOOLing 技术，将打印机变成共享设备，加一个队列。
不剥夺条件：得不到就放弃自己的 或者直接抢
请求和保持条件：静态分配（进程运行前一次性分配全部资源）
循环等待条件：顺序资源分配法 对资源加编号 同类资源一次性分配完</p>
<h3 id="31">31 页面置换算法<a class="headerlink" href="#31" title="Permanent link"></a></h3>
<p>OPT：知道后面会访问什么。向之后看，之后最后出现/没出现的的先删除
缺页中断
页面置换（满了才换）
缺页率：缺页次数/请求次数
FIFO：Belady异常。
LRU：如果满了，将内存块中的数值向前找，最早出现的那个删除。
CLOCK：时钟置换算法，NRU最近未用算法。 循环队列。 访问位。</p>
<h3 id="32">32 递归冒泡排序<a class="headerlink" href="#32" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">bubblesort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">array</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">array</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">bubblesort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>

<h3 id="33-ajax">33 ajax的四个步骤<a class="headerlink" href="#33-ajax" title="Permanent link"></a></h3>
<p>1)创建xhr对象
2)open方法参数：method，url，同步或异步
3)send
4)注册一个监听器<code>onreadystatechange</code> readyState=4和status200 获得响应<code>.responseText</code></p>
<h3 id="34-xss">34 XSS攻击，跨站脚本攻击<a class="headerlink" href="#34-xss" title="Permanent link"></a></h3>
<p>网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些恶意的脚本代码（HTML、JavaScript）到Web页面中去，使别的用户访问都会执行相应的嵌入代码。
解决方法：
1）cookie设置成http Only 不让前端<code>document.cookie</code>拿到
2）对输入多做一些检查 对 html危险字符转义</p>
<p>CSRF 盗取用户cookie或者session伪造请求
1)每次提交加随机数token
2）检查referer</p>
<h3 id="35">35 防止表单重复提交<a class="headerlink" href="#35" title="Permanent link"></a></h3>
<p>1）submit方法最后把按钮disable掉
2）用token
3）重定向</p>
<h3 id="36-302location">36 重定向的响应头为302，并且必须要有Location响应头；<a class="headerlink" href="#36-302location" title="Permanent link"></a></h3>
<p>服务器通过response响应，重定向的url放在response的什么地方？
后端在header里的设置的Location url
重定向可以用于均衡负载</p>
<h3 id="37">37 二分<a class="headerlink" href="#37" title="Permanent link"></a></h3>
<p>2.[0,len) 保持len取不到 </p>
<p>好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的
<div class="codehilite"><pre><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
<span class="k">while</span><span class="o">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span><span class="o">+(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span><span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">){</span>
        <span class="c1">//在左边，边界为取不到的数</span>
        <span class="n">r</span><span class="o">=</span><span class="n">mid</span><span class="o">;</span><span class="c1">//[l,mid)</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="c1">//左闭又开</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="c1">//[mid+1,r)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//如果l==r [1,1)表示空的</span>
<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</pre></div></p>
<h3 id="38-io">38 IO模型<a class="headerlink" href="#38-io" title="Permanent link"></a></h3>
<h4 id="_15">阻塞和非阻塞：<a class="headerlink" href="#_15" title="Permanent link"></a></h4>
<p>阻塞IO：等待数据（收到一个完整的TCP包）和系统内核拷贝到用户内核都阻塞了。
非阻塞IO：内核数据没准备好直接返回错误，需要轮询。
非阻塞IO需要和IO通知机制一起使用。
I/O通知机制：1） I/O复用函数【向内核注册一组事件】，内核通过I/O复用函数把就绪事件通知给应用程序。 I/O复用函数本身是阻塞的，可以同时监听多个I/O事件。
2）SIGIO信号。</p>
<p>accept()为什么会阻塞？
即使用多线程，serverSocket.accept()询问操作系统的客户端连接accept()还是单线程的，系统级别的【同步】网络I/O模型。
阻塞，非阻塞是程序级别的，同步非同步时操作系统级别的。</p>
<p>多路复用IO模型：操作系统在一个端口上同时接受多个客户端I/O事件。
事件驱动IO。select阻塞轮询所有socket，可以同时处理多个连接，（连接数不高的话不一定比多线程阻塞IO好）优势不在于单个连接处理更快，在于能处理更多的连接。而且单线程执行，事件探测和事件响应在一起。
以上三个都属于同步IO，都会阻塞进程。
select/poll/epoll都需要等待读写时间就绪后读写，异步IO会把数据从内核拷贝到用户。
epoll是根据每个fd上面的callback函数实现的。而且有mmap内核空间和用户空间同处一块内存空间。</p>
<h3 id="_16">边缘触发和水平触发<a class="headerlink" href="#_16" title="Permanent link"></a></h3>
<p><a href="https://www.jianshu.com/p/7835726dc78b">https://www.jianshu.com/p/7835726dc78b</a>
边缘触发：即使有数据可读,但是没有新的IO活动到来,epoll也不会立即返回.
epoll默认是水平触发</p>
<p>Level信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发</p>
<p>Epoll事件分派接口可以表现为边沿前触发 (ET)和 水平触发(LT).这两个机制之间的区别可以描述如下。
ET模式只有在被监控文件描述符发生变化时才递交事件</p>
<h4 id="_17">同步和异步<a class="headerlink" href="#_17" title="Permanent link"></a></h4>
<p>事件处理模式
Reactor模式实现同步I/O，处理I/O操作的依旧是产生I/O的程序
异步I/O 订阅-通知：立即返回，内核完成数据准备+拷贝数据之后发送给用户进程一个信号。
Proactor实现异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。
异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。</p>
<h3 id="39-error-exception">39异常 Error 和 Exception的区别<a class="headerlink" href="#39-error-exception" title="Permanent link"></a></h3>
<p>1）Error是JVM负责的
2）RuntimeException 是程序负责的
3）checked Exception 是编译器负责的
<img alt="ErrirException.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/ErrirException.jpg" /></p>
<p>异常处理机制：
在堆上创建异常  try catch中有return之前都会先执行finally的return</p>
<h3 id="40">40 !!!线程安全的单例模式<a class="headerlink" href="#40" title="Permanent link"></a></h3>
<p>单元素枚举类是实现Singleton的最佳方法
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Singleton</span><span class="o">{</span>

    <span class="c1">//定义1个枚举的元素，即为单例类的1个实例</span>
    <span class="n">INSTANCE</span><span class="o">;</span>

    <span class="c1">// 隐藏了1个空的、私有的 构造方法</span>
    <span class="c1">// private Singleton () {}</span>

<span class="o">}</span>
<span class="c1">// 获取单例的方式：</span>
<span class="n">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
</pre></div></p>
<p>【初始化占位类模式】
如果是静态初始化对象不需要显示同步。
静态初始化：JVM在类初始化阶段执行，在类加载后并在线程执行前。JVM会获取锁确保这个类已经被加载。任何一个线程调用<code>getInstance</code>的时候会使静态内部类被加载和初始化。
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>  
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonHolder</span> <span class="o">{</span>  
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Singleton</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>  
    <span class="o">}</span>  
    <span class="kd">private</span> <span class="nf">Singleton</span> <span class="o">(){}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="n">SingletonHolder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span> 
    <span class="o">}</span>  
<span class="o">}</span>
</pre></div></p>
<p>用反射强行调用私有构造函数可以创建多个实例。防止序列化：重写私有的<code>readReslove()</code> 当反序列化readObject()的时候会直接调用readReslove替换原本的返回值。</p>
<p>双重检查锁已经被广泛地废弃了！</p>
<p>懒加载 推迟高开销的对象初始化操作。
同步 double checked locking 
只希望在第一次创建 实例的时候进行同步
创建对象分为3个步骤：
1）分配内存
2）初始化对象
3）obj指向内存地址
关键：（2）、（3）会被重排序（因为理论上单线程不会有错，而且能提高性能），导致obj不未空，但还没初始化，所以volatile禁止重排序。
如果两个操作之间没有happens-before则JVM可以重排序。
Volatile变量规则。对一个volatile修饰的变量，对他的写操作先行发生于读操作。</p>
<p>特别对于有final字段的对象，构造函数完成的时候才完成final的写入。
初始化安全：防止对对象的初始引用被重排序到构造过程之前。</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nf">LazySingle</span><span class="o">(){</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">LazySingle</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">LazySingle</span><span class="o">(){}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">// 1.只有一个线程能进来</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">LazySingle</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LazySingle</span><span class="o">();}}}</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
<span class="o">}}</span>
</pre></div>

<p>方法2：静态内部类</p>
<p>java进程间通信</p>
<p>java 线程通信
全局变量
2个线程之间的单向数据连接 NIO pipe 写sink 读source。
java线程同步的方法</p>
<h3 id="41_1">41 什么时候对象会被回收？如果互相引用<a class="headerlink" href="#41_1" title="Permanent link"></a></h3>
<p><a href="http://blog.jobbole.com/109170/">http://blog.jobbole.com/109170/</a>
强引用=null
引用计数算法 无法解决互相引用的情况。
所以用的是 <strong>可达性分析算法</strong>：判断对象的引用链是否可达。
如果循环引用，没有人指向这个环也会被回收。
从GC root（栈中的本地变量表中的对象、类（方法区）常量、静态属性保存的是对象……）</p>
<p>类回收：
ClassLoader已经被回收，Class对象没有引用，所有实例被回收。</p>
<p>资源管理，如果数据库连接对象被收回，但是没有调用close，数据库连接的资源不会释放，数据库连接就少一个了，要放在try()里。</p>
<h3 id="42-216">42  2进制字符串转16进制<a class="headerlink" href="#42-216" title="Permanent link"></a></h3>
<div class="codehilite"><pre> <span class="n">String</span> <span class="nf">b2h</span><span class="o">(</span><span class="n">String</span> <span class="n">bins</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">hexs</span> <span class="o">=</span> <span class="s">&quot;0123456789abcdf&quot;</span><span class="o">;</span>
    <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
    <span class="c1">//0101 n =4</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">&gt;=</span><span class="mi">4</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">(</span><span class="n">bins</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="o">+</span>
                <span class="o">((</span><span class="n">bins</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span>
                <span class="o">((</span><span class="n">bins</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="o">+</span>
                <span class="o">((</span><span class="n">bins</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">4</span><span class="o">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="o">*</span> <span class="mi">8</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hexs</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">));</span>
        <span class="n">n</span><span class="o">-=</span><span class="mi">4</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">last</span> <span class="o">+=</span> <span class="o">(</span><span class="n">bins</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span><span class="o">--</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">)*(</span><span class="mi">1</span><span class="o">&lt;&lt;(</span><span class="n">cnt</span><span class="o">++));</span>
    <span class="o">}</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hexs</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">last</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<h3 id="43-2">43 !十进制转2进制<a class="headerlink" href="#43-2" title="Permanent link"></a></h3>
<p>没有oj过
<div class="codehilite"><pre><span class="kd">public</span> <span class="n">String</span> <span class="nf">D2Bin</span><span class="o">(</span><span class="kt">int</span> <span class="n">de</span><span class="o">){</span>
    <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">de</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">de</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">de</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></div></p>
<h3 id="44">44 编辑距离<a class="headerlink" href="#44" title="Permanent link"></a></h3>
<p>1）定义<code>dp[n][m]</code>表示从s1的前n个字符-&gt;s2的前m个字符最少的编辑距离。
2）加一个：[n-1][m]+1
   减一个: [n][m-1]+1
   变一个:[n-1][m-1] +1 
   相等：[n-1][m-1]
<div class="codehilite"><pre><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="n">String</span> <span class="n">word1</span><span class="o">,</span> <span class="n">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">)){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>          
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="mi">1</span><span class="o">,</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">),</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>
<span class="o">}</span>
</pre></div></p>
<h3 id="45">45 布隆过滤器<a class="headerlink" href="#45" title="Permanent link"></a></h3>
<p>黑名单
如果数据量有8G，hash冗余要保证16G
构造：使用16/8 = 2G 可以表示16G个bit位。
set：用8个随机函数，得到0-16G中8个随机数，并将这8位设置为1。
get：同样用这8个随机函数，查看这8位是否都为1。</p>
<h3 id="46">46 精确的接口限流。<a class="headerlink" href="#46" title="Permanent link"></a></h3>
<p>/禁止重复提交：用户提交之后按钮置灰，禁止重复提交 
如果做到精确5秒里只能访问10次</p>
<p>漏桶法 流量整形
个固定容量的漏桶，按照常量固定速率流出水滴</p>
<p>令牌桶（对业务的峰值有一定容忍度）
固定容量令牌的桶，按照固定速率往桶里添加令牌</p>
<p>前端做还是后台做</p>
<p>大数据相关的</p>
<h3 id="47-linux">47 linux 怎么查询一个端口<a class="headerlink" href="#47-linux" title="Permanent link"></a></h3>
<h3 id="48">48 操作系统 进程通信<a class="headerlink" href="#48" title="Permanent link"></a></h3>
<p>进程和线程的区别
文件是进程创建的信息逻辑单元
每个进程有专用的线程表跟踪进程中的线程。和内核中的进程表类似。</p>
<h4 id="_18">进程结构：代码段、数据段、堆栈段<a class="headerlink" href="#_18" title="Permanent link"></a></h4>
<p>代码段：多个进程运行同一个程序，可以使用同一个代码段。
数据段：全局变量、常量、静态变量。
栈：用于存放 【函数调用】，存放函数的 【参数】，函数内部的【局部变量】
PCB位于核心堆栈的底部。
进程组ID是一个进程的必备属性。</p>
<p>子进程：
当调用<code>fork</code>时，子进程完全复制了父进程地址空间的内容，包括：堆、栈、数据段，并和父进程共享代码段，因为代码段是只读的，不会被修改。
在Linux上，对于多进程，子进程继承了父进程的下列哪些？
A 进程地址空间
B 共享内存
C 信号掩码
D 已打开的文件描述符
E 以上都不是</p>
<p>子进程对数据段和堆、栈段的修改不会影响父进程。
“写时复制”：现在fork不会立刻复制，当子进程要修改的时候才会分配进程空间 并复制。</p>
<h4 id="_19">创建一个守护进程<a class="headerlink" href="#_19" title="Permanent link"></a></h4>
<p>终端：系统与用户交互的界面，运行进程的终端被称为 【控制终端】。
控制终端关闭时，进程都会关闭，除了守护进程。
1）<code>fork()</code>一个子进程并退出父进程。
子进程拷贝了父进程的
【会话期、进程组、控制终端、工作目录、父进程的权限掩码、打开的文件描述符】。</p>
<p>2）在子进程中创建会话<code>setid()</code>让进程摆脱1）原会话2）进程组3）控制终端 的控制。</p>
<p>3）工作目录换成根目录<code>chdir("/")</code>
4）文件权限掩码设置成0 <code>umask(0)</code>
5）关闭所有打开的文件描述符</p>
<h4 id="_20">僵尸进程<a class="headerlink" href="#_20" title="Permanent link"></a></h4>
<p>子进程推出，父进程没有调用wait，子进程的进程描述符仍然在系统中。父进程应该调用wait取得子进程的终止状态。
如果父进程退出，僵尸进程变成孤儿进程给init（1）进程，init会周期性调用wait清除僵尸进程。</p>
<h3 id="49">49 线程之间什么是共享的<a class="headerlink" href="#49" title="Permanent link"></a></h3>
<p>1）地址空间2）全局变量3）打开文件4）子进程5）即将发生的定时器6）信号与信号处理程序6）账户信息
线程试图实现：共享同一组资源的多个线程的执行能力</p>
<h3 id="50">50 栈为什么要线程独立<a class="headerlink" href="#50" title="Permanent link"></a></h3>
<p>一个栈帧只有最下方的可以被读写，处于工作状态，为了实现多线程，必须绕开栈的限制。
每个线程创建一个新栈。多个栈用空白区域隔开，以备增长。
每个线程的栈有一帧，供各个被调用但是还没有从中返回的过程使用。
该栈帧存放了相应过程的局部变量、方法参数、过程调用完成后的返回地址，线程私有不共享。
例如X调用Y，Y调用Z， 执行Z时，X和Y和X使用的栈帧会全部保存在堆栈中。
<strong>每个线程有一个各自不同的执行历史。</strong></p>
<p>栈内存分配运算内置于处理器的指令集中，效率很高</p>
<p>运行时在模块入口时，数据区需求是确定的。
栈是编译器可以管理创建和释放的内容，堆需要GC
栈很少有碎片</p>
<h4 id="_21">静态全局变量、静态局部变量<a class="headerlink" href="#_21" title="Permanent link"></a></h4>
<p><a href="https://blog.csdn.net/hushpe/article/details/45396059">https://blog.csdn.net/hushpe/article/details/45396059</a>
<strong>static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</strong></p>
<p>1.全局变量：源程序作用域。
所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问<code>extern</code></p>
<p>2.静态全局变量：文件作用域。
如果加了static，就会对其它源文件隐藏。不能用extern导出。
例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心【命名冲突】。
全局变量、静态全局变量存储在静态数据区。只有程序刚开始运行时唯一一次初始化。</p>
<p>3.静态局部变量：static局部变量只被初始化一次，下一次依据上一次结果值。
！！！ 单例模式！！！</p>
<p>作用域：作用域（可见性）仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Singleton</span><span class="p">(){}</span>
    <span class="n">Singleton</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
    <span class="n">Singleton</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span> <span class="o">*</span> <span class="n">GetInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">Singleton</span> <span class="n">instance</span><span class="p">;</span>   <span class="c1">//局部静态变量</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></div>
  注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
局部变量改变为静态变量后是改变了它的存储方式即改变了它的【生存期】。
把全局变量改变为静态变量后是改变了它的【作用域】，限制了它的使用范围。  </p>
<p>4.static函数作用域只在本文件
从原来的栈中存放改为【静态存储区】。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p>
<p>可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.</p>
<p>静态存储区：内存在程序编译的时候就已经分配好
已经初始化过的全局变量在.data段，而未初始化的全局变量在.bss段。
.bss段不占用可执行文件的大小，而是在加载程序的时候由操作系统自动分配并初始化为0</p>
<h3 id="51threadpoolexecutor">51ThreadPoolExecutor 怎么实现的<a class="headerlink" href="#51threadpoolexecutor" title="Permanent link"></a></h3>
<p>1）线程池状态</p>
<h3 id="52-java">52 Java多继承<a class="headerlink" href="#52-java" title="Permanent link"></a></h3>
<p><a href="https://juejin.im/post/5a903ef96fb9a063435ef0c8#heading-1">https://juejin.im/post/5a903ef96fb9a063435ef0c8#heading-1</a>
内部类:每个内部类都能独立地继承自一个（接口的）实现，内部类允许继承多个非接口类型.</p>
<p>socket编程</p>
<p>mq有几种模式
Binding:Exchange和Queue的虚拟连接</p>
<h3 id="53-sb">53 sb依赖注入控制反转。<a class="headerlink" href="#53-sb" title="Permanent link"></a></h3>
<p>IOC:控制反转
控制：Java Bean的生命周期（创建、销毁）
反转：容器管理依赖关系。
IOC是一种设计模式。将对象-对象关系解耦和对象-IOC容器-对象关系。容器管理依赖关系。依赖对象的获得被反转了。</p>
<p>依赖注入DI方式:把底层类作为参数传递给上层类，实现上层对下层的“控制”。setter、接口、构造函数。组件之间依赖关系由容器在运行期决定。
SpringBoot Autowired是自动注入，自动从spring的上下文找到合适的bean来注入</p>
<p>IOC容器初始化
1）Resource定位
2）载入：把定义的Bean表示成IOC的数据结构（不包括Bean依赖注入）
3）注册到容器的HashMap中</p>
<p>IOC容器通过和注解配置(<code>Controller</code>)
1）IOC容器就是<code>ApplicationContext</code> 可以通过web.xml或者加载xml或者文件用<code>application-context.xml</code>初始化。
2）定义bean 然后<code>getBean()</code>就获取了对象可以调用方法了
bean的作用域6种 默认是单例，多次<code>getBean</code>是同一个。<code>prototype</code>每次都是新的。
bean有创建和销毁的回调函数。
3）如果要用两个类的组合，一个类里需要<code>new</code>另一个类，这样那个类的构造参数都需要在这个类里面改，这样强耦合。所以这个外部对象应该用构造函数（强依赖）/setter（可选依赖（可配置的（颜色）））等方法注入。
    通过配置文件的方法，注入依赖的参数。</p>
<h4 id="spring_1">Spring 怎么解决循环引用<a class="headerlink" href="#spring_1" title="Permanent link"></a></h4>
<p>Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。
<div class="codehilite"><pre><span class="cm">/** Cache of singleton objects: bean name --&gt; bean instance */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">singletonObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;(</span><span class="mi">256</span><span class="o">);</span>

<span class="cm">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ObjectFactory</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">singletonFactories</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ObjectFactory</span><span class="o">&lt;?&gt;&gt;(</span><span class="mi">16</span><span class="o">);</span>

<span class="cm">/** Cache of early singleton objects: bean name --&gt; bean instance */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">earlySingletonObjects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;(</span><span class="mi">16</span><span class="o">);</span>
</pre></div>
singletonFactories ： 单例对象工厂的cache 
earlySingletonObjects ：提前暴光的单例对象的Cache 
singletonObjects：单例对象的cache</p>
<h4 id="aop">AOP 面向切面编程 关注点分离，抽离业务逻辑<a class="headerlink" href="#aop" title="Permanent link"></a></h4>
<p>知识图谱 之间的关系 和结构存储neo4j
vue的特点
和react的比较</p>
<h3 id="54">54 前后端跨域怎么实现<a class="headerlink" href="#54" title="Permanent link"></a></h3>
<p>浏览器的同源策略导致了跨域。
1)JSONP 但是只能直接发get请求<code>&lt;script src="http://127.0.0.1:8897"&gt;&lt;script&gt;</code>
2)<code>Access-Control-Allow-Origin':'*'</code>
3)nginx反向代理</p>
<p>XSS 跨站脚本攻击：篡改网页，注入恶意html脚本。
CSRF 跨站请求伪造（利用用户登陆态）
Cookie的 <code>SameSite</code>属性strict</p>
<h3 id="55-cookies">55 cookies<a class="headerlink" href="#55-cookies" title="Permanent link"></a></h3>
<p>1) 存储在客户主机
2）服务器产生
3）会威胁客户隐私
4）用于跟踪用户访问和状态</p>
<p>cookie有两种
cookie的实现</p>
<p>redis string
redis</p>
<h3 id="56-redis">56 为什么要把页面放到redis中？<a class="headerlink" href="#56-redis" title="Permanent link"></a></h3>
<p>页面缓存，将整个页面手动渲染，加上所有vo，设定有效期1分钟，让用户1看到的是1分钟前的页面
详情页应该不能放（？）库存更新怎么办（？）
只是把页面商品信息放到了redis中</p>
<h3 id="redis_1">redis常用数据结构<a class="headerlink" href="#redis_1" title="Permanent link"></a></h3>
<p>string, hash,set,sorted set,list
<div class="codehilite"><pre>redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="s2">&quot;Palermo&quot;</span> 15.087269 37.502669 <span class="s2">&quot;Catania&quot;</span>
<span class="o">(</span>integer<span class="o">)</span> 2
redis&gt; GEODIST Sicily Palermo Catania
<span class="s2">&quot;166274.1516&quot;</span>
redis&gt; GEORADIUS Sicily <span class="m">15</span> <span class="m">37</span> <span class="m">100</span> km
1<span class="o">)</span> <span class="s2">&quot;Catania&quot;</span>
redis&gt; GEORADIUS Sicily <span class="m">15</span> <span class="m">37</span> <span class="m">200</span> km
1<span class="o">)</span> <span class="s2">&quot;Palermo&quot;</span>
2<span class="o">)</span> <span class="s2">&quot;Catania&quot;</span>
redis&gt; 
</pre></div></p>
<h4 id="redis_2">redis 有序集合<a class="headerlink" href="#redis_2" title="Permanent link"></a></h4>
<p>skiplist和dict会共享元素的成员和分值。
zset中的dict创建了一个从成员到分值的映射，程序可用O(1)的时间查找到【分值】(zscore)。
跳跃表实现zrank,zrange 还有查找全是logN</p>
<p>秒杀项目的请求流程
1）下订单和减库存如何保持一致？
ACID强一致性，利用关系型数据库的强一致性，【订单表和库存表】放在一个关系型数据库事务，实时一致性。
高并发场景提高关系型数据库吞吐量和存储，应该吧库存和订单放入同一个数据库分片。
主从复制只能提高数据库读。
BASE思想：分布式事务拆分，每个步骤都记录状态，使用【写前日志】或者数据库来记住任务的执行状态，一般通过行级锁实现比写前日志更快。</p>
<p>数据库分片：
1）分片ID
2）无需分片的表</p>
<h3 id="57">57 缓存与数据库一致性<a class="headerlink" href="#57" title="Permanent link"></a></h3>
<p>读请求和写请求串行化，串到一个内存队列里去。串行化就不会不一致。
先更新数据库再删除缓存。</p>
<p><img alt="cacheone.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/cacheone.jpg" /></p>
<p>缓存更新的时候加锁 防止大量请求直接访问数据库雪崩或者缓存不一致
<img alt="cacheupdate.jpg" src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/cacheupdate.jpg" /></p>
<p>缓存穿透：数据库中没这个数据，缓存中也没有，数据库被大量查询
方法 BloomFilter
1）查询结果为空的也缓存(命中不高 但是频繁更新的数据) 
2）对可能为空的key统一存放（命中不高 更新不频繁）</p>
<h3 id="58-mq">58 为什么秒杀系统需要mq 秒杀排队系统<a class="headerlink" href="#58-mq" title="Permanent link"></a></h3>
<p>多redis扣库存
一旦缓存丢失需要考虑恢复方案。比如抽奖系统扣奖品库存的时候，初始库存=总的库存数-已经发放的奖励数，但是如果是异步发奖，需要等到MQ消息消费完了才能重启redis初始化库存，否则也存在库存不一致的问题。
需要一个分布式锁来控制只能有一个服务去初始化库存</p>
<h3 id="mq">为什么秒杀系统需要mq 秒杀排队系统<a class="headerlink" href="#mq" title="Permanent link"></a></h3>
<p><a href="https://www.infoq.cn/article/yhd-11-11-queuing-system-design">https://www.infoq.cn/article/yhd-11-11-queuing-system-design</a>
1）削峰:减少瞬间流量。处理失败的消息退回队列，接收的下一条还是这个消息，这是因为消息传递不仅要保证一次且仅一次，还要保证顺序。
2）限流保证数据库不会挂掉，不然会影响其他服务。主要还是为了减少数据库访问 透这么多请求来数据库没有意义,会有大量锁冲突导致读请求会发生大量的超时。如果均成功再放下一批.
3）持久化:就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失。
4）订单和库存解耦. 
<div class="codehilite"><pre>#从队列里每次取几个
spring.rabbitmq.listener.simple.prefetch= 1
# 消费失败会重新压入队列
spring.rabbitmq.listener.simple.default-requeue-rejected= true
</pre></div></p>
<p>异步下单：
异步下单的前提是确保进入队列的购买请求一定能处理成功。Redis天然是单线程的，其INCR/DECR操作可以保证线程安全。而且入队之前要对用户user+goodsId判重。
假设处理一个秒杀订单需要1s，而将秒杀请求（或意向订单/预订单）加入队列（或消息系统等）可能只需要1ms。异步化将用户请求和业务处理解耦</p>
<p>其他消息中间件</p>
<p>如何用redis list实现mq</p>
<h3 id="59-mq">59 mq集群模式<a class="headerlink" href="#59-mq" title="Permanent link"></a></h3>
<p>Master-Slave模式
NetWork模式 两组Master-Slave模式</p>
<h3 id="60-mq">60 mq怎么实现的<a class="headerlink" href="#60-mq" title="Permanent link"></a></h3>
<p><a href="https://tech.meituan.com/2016/07/01/mq-design.html">https://tech.meituan.com/2016/07/01/mq-design.html</a>
AMQP协议: 虚拟主机（virtual host），交换机（exchange），队列（queue）和绑定（binding）。一个虚拟主机持有一组交换机、队列和绑定.
broker(消息队列服务端)
1）数据流：例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。 
2）RPC:两次RPC发送者把消息投递到服务端（broker），服务端再将消息转发一手到接收端，消费端最终做消费确认的情况是三次RPC。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。 
3）消息堆积:存储消息，在合适的时机投递消息。
4）广播：我维护消费关系，可以利用zk/config server等保存消费关系。</p>
<p>生产者和消费者是完全解耦.
？因为保证可靠消费？这样redis预减的库存就真的减少到mysql里了？不用再同步回来（？
持久化？
消息队列时需要考虑到的问题，如RPC、高可用、顺序和重复消息、可靠投递、消费关系解析等
直接模式</p>
<h3 id="61-linux">61 linux<a class="headerlink" href="#61-linux" title="Permanent link"></a></h3>
<ul>
<li>
<p>如何传文件 scp</p>
</li>
<li>
<p>如何查进程 
ps -ef |grep
如何在文件找查一个字符串
<code>grep 'abc' abc.txt</code>
<code>grep 'abc' abc*</code> 从abc开头的文件查找
参数<code>-o</code>只输出正则匹配的部分
参数<code>-v</code>输出不含正则的内容</p>
</li>
</ul>
<p>如果grep不带文件就等输入</p>
<p>echo不支持标准输入</p>
<ul>
<li>如何查找一个文件  find默认是递归查找的
<code>find ~ -name "abc.java</code></li>
</ul>
<p>sed 替换
awk 切片统计</p>
<p>终端 <code>/dev/tty</code>当前终端</p>
<p>vi： ZZ：命令模式下保存当前文件所做的修改后退出vi；</p>
<h3 id="netstat">netstat<a class="headerlink" href="#netstat" title="Permanent link"></a></h3>
<p>列出所有tcp端口 <code>netstat -at</code>
显示pid和进程名<code>netstat -p</code>
可以查看所有套接字的连接情况</p>
<h3 id="top">top 可以查看到哪些指标<a class="headerlink" href="#top" title="Permanent link"></a></h3>
<p>1： CPU 平均负载1min，5min,15min
在一段时间内CPU正在处理以及等待CPU处理的 【进程数】 之和。CPU使用队列的长度的统计信息。
2：进程、cpu状态、内存状态（系统内核控制的内存数）</p>
<p>打开的文件<code>lsof</code></p>
<p>String StringBuilder StringBuffer 
String 存在JVM哪里
1）一旦有一个用引号的字符串就会放到字符串常量池。
2）拼接创建的只在堆里。
3）堆里面创建新的字符串，用intern可以放【引用】到常量池（jdk1.7之前只只能放一个副本放到常量池）
方法区，方法区是JVM的一种规范。元空间MetaSpace和永久代PermGen都是方法区的实现。
原来在永久代里的字符串常量池移到了堆中。而且元空间替代了永久代。
本来永久代使用的是JVM内存，而元空间使用的是本地内存，字符串常量不会有性能问题（intern）和内存溢出。</p>
<p>two sum
如果数字在最后怎么优化
如果有序two sum怎么做
three sum</p>
<h3 id="_22">序列化的性能<a class="headerlink" href="#_22" title="Permanent link"></a></h3>
<h3 id="_23">二维数组搜索<a class="headerlink" href="#_23" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">searchMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">)</span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">)</span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span><span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span><span class="n">x</span><span class="o">++;</span>
        <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span><span class="n">y</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>

<h3 id="90-lc-48">矩阵旋转90度 lc 48<a class="headerlink" href="#90-lc-48" title="Permanent link"></a></h3>
<p>逆时针：第一步交换主对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。 如果是顺时针， 第一步交换对角线两侧的对称元素，第二步交换第i行和第n-1-i行，即得到结果。
<div class="codehilite"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>  
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>  
            <span class="o">}</span>            
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
           <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="o">];</span>
            <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></p>
<h3 id="_24">短链接<a class="headerlink" href="#_24" title="Permanent link"></a></h3>
<h3 id="_25">特征模型<a class="headerlink" href="#_25" title="Permanent link"></a></h3>
<h3 id="_26">归并排序<a class="headerlink" href="#_26" title="Permanent link"></a></h3>
<h3 id="_27">缓存穿透<a class="headerlink" href="#_27" title="Permanent link"></a></h3>
<p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。</p>
<h3 id="_28">多线程归并排序<a class="headerlink" href="#_28" title="Permanent link"></a></h3>
<h3 id="_29">线程上下文类加载器<a class="headerlink" href="#_29" title="Permanent link"></a></h3>
<p>JNDI服务，使用线程上下文加载器，父类加载器请求子类加载器完成类加载。</p>
<p>OSGi自定义加载器，程序模块和它的类加载器一起替换掉。</p>
<h3 id="_30">运行时字节码生成 动态代理<a class="headerlink" href="#_30" title="Permanent link"></a></h3>
<p>动态代理：原始类和接口还未知的时候就确定了代理类的代理行为。
代理类与原始类脱离直接联系后，可以用于不同的应用场景。</p>
<p>jvm以byte数组为单位拼接出 传入接口的每个方法的实现，并且调用外部传入this的invoke方法，的字节码文件。</p>
<h3 id="rcu">RCU机制<a class="headerlink" href="#rcu" title="Permanent link"></a></h3>
<p><a href="http://blog.jobbole.com/107958/">http://blog.jobbole.com/107958/</a></p>
<h3 id="_31">分布式锁<a class="headerlink" href="#_31" title="Permanent link"></a></h3>
<p>1）互斥性：保证不同节点的线程之间互斥2）同一个节点同一个线程可重入3）支持超时防死锁
<code>for update</code>悲观锁 大并发不建议
数据库是各个服务进程的临界资源。如果已经下订单了还没减库存，但是没加锁就会脏读。</p>
<p>乐观锁：因为查询加行锁开销比较大，用版本号，查询出版本号之后update或者delete的时候需要判断当前的版本号和刚才读的是否一致，这样就不用<code>for update</code></p>
<p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。
锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。</p>
<h4 id="redis_3">redis分布式锁<a class="headerlink" href="#redis_3" title="Permanent link"></a></h4>
<p>流程1）<code>setnx(key,currenttime+timeout)</code>2)<code>expire(key)</code>3)业务执行完后<code>del(key)</code>
其他tomcat获取不到锁返回0流程
1）<code>get(key)</code>判断当前时间和value的时间，
2)如果key超时了可以先get再set<code>getset(key,currenttime+timeout)</code> 如果get的值是null或者和之前的锁一样（？）继续<code>expire(key)</code>走加锁流程&hellip;</p>
<h3 id="_32">面向对象<a class="headerlink" href="#_32" title="Permanent link"></a></h3>
<p>对象的产生方式有
1）原型对象(prototype 原型链)为基础的 （所有对象都是实例）
2）基于类（Java)的对象模型。</p>
<h3 id="hdfs">分布式文件系统HDFS<a class="headerlink" href="#hdfs" title="Permanent link"></a></h3>
<p>1）每个文件拆分成很多小块128M（并行处理和负载均衡）.
2）文件以多副本存储（副本因子），高可用。
3）有一个节点存储着存储信息 1个Master，NameNode。N个Slave DataNode。</p>
<p>NameNode：1）处理客户端请求 文件系统的读写操作 2）元素据
DataNode：1）块的存储和操作 2）定期心跳</p>
<p>分布式文件系统一致性
HDFS 文件只能写1次 除了 append和truncate 而且不能多并发写。</p>
<p>节点失效
为什么本地文件系统不使用hash</p>
<h3 id="2255135">2.25匹马，5个跑道，每个跑道最多能有1匹马进行比赛，最少比多少次能比出前3名？前5名？<a class="headerlink" href="#2255135" title="Permanent link"></a></h3>
<p>5轮找出各组第一；5组第一跑一次，得出第一，只有前3的组可能是前3；最后一次A2, A3, B1, B2, C1参赛得出第二第三名。</p>
<h3 id="13100">13.100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？<a class="headerlink" href="#13100" title="Permanent link"></a></h3>
<h3 id="_33">分布式<a class="headerlink" href="#_33" title="Permanent link"></a></h3>
<p>1）均衡负载技术
均衡负载的算法有：随机 round roubin 一致性hash
2）容灾设计
3）高可用系统</p>
<p>Nginx是如何工作的？是如何配置的？</p>
<h3 id="jmm">JMM 内存模型<a class="headerlink" href="#jmm" title="Permanent link"></a></h3>
<p>线程工作内存，保存主内存副本拷贝。线程对变量的所有读取、赋值都必须在工作内存完成，不能直接读写主内存变量。
处理并发过程中的原子性、可见性、有序性。</p>
<p>volatile变量定义了8种操作顺序的规则，能保证代码执行的顺序与程序顺序相同。保证long和double不被拆分。
定义了8个happen before原则
1）单线程控制流程序次序 2）管程 3）volatile 4）线程启动、5终止、6中断 7）对象finalize 8）传递性</p>
<h4 id="8_1">8个原子操作<a class="headerlink" href="#8_1" title="Permanent link"></a></h4>
<p>主内存变量线程独占：
1）lock 线程独占，
同个线程可以lock多次，会清空工作内存中这个变量的值执行引擎use前要load assign
2）unlock 释放，之前会同步回主存</p>
<p>主内存-&gt;工作内存：
3）read 从主内存读入工作内存
4）load 将read的变量存入工作内存的变量副本</p>
<p>工作变量和执行引擎：
5）use 工作内存变量传递给执行引擎
6）assign 执行引擎赋值给工作变量</p>
<p>工作内存-&gt;主内存
7）store 工作内存传入主内存
8）write 将store的值放入主内存</p></article></body></html>