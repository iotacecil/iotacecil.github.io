<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
 
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="alg," />










<meta name="description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://blog.csdn.net/v_july_v/article/details/6803368https">
<meta name="keywords" content="alg">
<meta property="og:type" content="article">
<meta property="og:title" content="alg">
<meta property="og:url" content="http://iotaa.xyz/2018/03/24/alg/index.html">
<meta property="og:site_name" content="Learn &amp; practice">
<meta property="og:description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://blog.csdn.net/v_july_v/article/details/6803368https">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://iotaa.xyz/images/lc915.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/histo1.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lc790.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/kpath.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/ditui.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/fibo.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/quickmi.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lexpermu.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/fenpei.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/penneygame.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/abbinary.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/nbinary.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/nqueenbb.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/digits.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/minbracket.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/strstrbest.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/backup.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/substring.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/boyerright.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/boyerright2.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/boyer3.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/rabin-karp.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/ranbinmod.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/kbright.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/DFA.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/dfaconstruction.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/KMPDFA.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/knapsack.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/pointcover.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/vetexcover.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/MSTTSP.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/MMTSP.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/pagbb.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/bbtsp.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/optaplanner.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/tspdp.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/rotate2d.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/scalenetwork.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/shuku.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/stringsort.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/threepart.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/MSD.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/MSD2.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/LSD.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/indexsort.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lc611.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/mst.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/prim.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/singlelink.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/singleclu.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lc753.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lc7532.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/Hierholzer1.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/Hierholzer2.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/bipartite.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/matching.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/graphmostuse.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/graphtra.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/tuopu.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/graphcy.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/kolakoski.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/boggle.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/shijiebei.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/bus1.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/bus2.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/lc581.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/mounting.jpg">
<meta property="og:image" content="http://iotaa.xyz/images/fenzhi.jpg">
<meta property="og:updated_time" content="2018-10-17T10:57:36.675Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="alg">
<meta name="twitter:description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://blog.csdn.net/v_july_v/article/details/6803368https">
<meta name="twitter:image" content="http://iotaa.xyz/images/lc915.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://iotaa.xyz/2018/03/24/alg/"/>





  <title>alg | Learn & practice</title>
  








  <!--prettify代码高亮脚本引入-->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="top-scroll-bar"></div>
<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learn & practice</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://iotaa.xyz/2018/03/24/alg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learn & practice">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">alg</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T03:07:34+08:00">
                2018-03-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-10-17T18:57:36+08:00">
                2018-10-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法备忘/" itemprop="url" rel="index">
                    <span itemprop="name">算法备忘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>刷题顺序<br><a href="https://vjudge.net/article/6" target="_blank" rel="noopener">https://vjudge.net/article/6</a><br><a href="https://www.cnblogs.com/JuneWang/p/3773880.html" target="_blank" rel="noopener">https://www.cnblogs.com/JuneWang/p/3773880.html</a></p>
<p>微软187<br><a href="https://blog.csdn.net/v_july_v/article/details/6697883" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6697883</a><br>面试<br><a href="https://blog.csdn.net/v_july_v/article/details/6803368" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6803368</a><br><a href="https://www.cnblogs.com/JuneWang/p/3773880.html" target="_blank" rel="noopener">https://www.cnblogs.com/JuneWang/p/3773880.html</a></p>
<p><a href="https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001" target="_blank" rel="noopener">https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001</a></p>
<p><a href="https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html" target="_blank" rel="noopener">https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html</a></p>
<p>笔试题todo<br><a href="https://www.nowcoder.com/test/4575457/summary" target="_blank" rel="noopener">https://www.nowcoder.com/test/4575457/summary</a></p>
<h3 id="532-数组中有几个相差k的pair"><a href="#532-数组中有几个相差k的pair" class="headerlink" title="532 数组中有几个相差k的pair"></a>532 数组中有几个相差k的pair</h3><blockquote>
<p>输入: [3, 1, 4, 1, 5], k = 2<br>输出: 2<br>解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。<br>尽管数组中有两个1，但我们只应返回不同的数对的数量。</p>
</blockquote>
<p>set的解法33% //todo比双指针慢</p>
<h3 id="220-数组中是否有相差-lt-t-idx差-lt-k-的元素"><a href="#220-数组中是否有相差-lt-t-idx差-lt-k-的元素" class="headerlink" title="220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素"></a>220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素</h3><blockquote>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true</p>
</blockquote>
<p>2.桶</p>
<p>1.40% 用容量k的TreeSet,超过k删除最左<br>判断能否和ceiling合floor&lt;=t<br>如果不能 放入treeset等待</p>
<h3 id="219-是否有重复元素-下标相差-lt-k"><a href="#219-是否有重复元素-下标相差-lt-k" class="headerlink" title="219 是否有重复元素 下标相差&lt;=k"></a>219 是否有重复元素 下标相差&lt;=k</h3><blockquote>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true</p>
</blockquote>
<p>放进一个FIFO大小为(k+1) 相差k 的set，当有add失败的时候就true</p>
<h3 id="442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间"><a href="#442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间" class="headerlink" title="442  1 ≤ a[i] ≤ n 找到所有出现2次的元素 O(1) 空间"></a>442  <code>1 ≤ a[i] ≤ n</code> 找到所有出现2次的元素 O(1) 空间</h3><blockquote>
<p>some elements appear twice and others appear once.<br>Input:[4,3,2,7,8,2,3,1]<br>Output:[2,3]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4-&gt;[4,3,2,-7,8,2,3,1] </span><br><span class="line">3-&gt;[4,3,-2,-7,8,2,3,1]</span><br><span class="line">2-&gt;[4,-3,-2,-7,8,2,3,1]</span><br><span class="line">7-&gt;[4,-3,-2,-7,8,2,-3,1]</span><br><span class="line">8-&gt;[4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">2-&gt;[4,[3],-2,-7,8,2,-3,-1]</span><br><span class="line">3-&gt;[4,[3],[2],-7,8,2,-3,-1]</span><br><span class="line">1-&gt;[-4,[3],[2],-7,8,2,-3,-1]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Math.abs(idx) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[idx] = -nums[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="769-最多能排序的块-0-n的排列切割，块排序后连接是排序的原数组"><a href="#769-最多能排序的块-0-n的排列切割，块排序后连接是排序的原数组" class="headerlink" title="769 最多能排序的块 0-n的排列切割，块排序后连接是排序的原数组"></a>769 最多能排序的块 0-n的排列切割，块排序后连接是排序的原数组</h3><blockquote>
<p>输入: arr = [1,0,2,3,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。<br>然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx:0 1 2 3 4</span><br><span class="line">arr:1 0 2 3 4</span><br><span class="line">max:0 1 2 3 4</span><br><span class="line">当前index&lt;当前max 表示可以划分成一组，==max表示要换下一组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,max = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==(max=Math.max(max,arr[i])))</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="915-Max-left-lt-Min-right"><a href="#915-Max-left-lt-Min-right" class="headerlink" title="915 Max(left)&lt;=Min(right)"></a>915 Max(left)&lt;=Min(right)</h3><p>画折线图，当前<code>A[i]&lt;left</code> 则把切分线抬到<code>globalMax</code><br><img src="/images/lc915.jpg" alt="lc915"><br>7ms 60%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionDisjoint</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> leftMax = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> global = leftMax;</span><br><span class="line">    <span class="keyword">int</span> parti = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftMax&gt;A[i])&#123;</span><br><span class="line">            leftMax = global;</span><br><span class="line">            parti = i;</span><br><span class="line">        &#125;<span class="keyword">else</span> global = Math.max(global,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parti+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="768-最多能排序的块-重复元素"><a href="#768-最多能排序的块-重复元素" class="headerlink" title="768 最多能排序的块 重复元素"></a>768 最多能排序的块 重复元素</h3><blockquote>
<p>输入: arr = [2,1,3,4,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。<br>然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。<br>arr的长度在[1, 2000]之间。<br>arr[i]的大小在[0, 10**8]之间。</p>
</blockquote>
<p>最快的100%： 只构造后缀min数组,线性扫描更新max,保证<code>leftMax&lt;Rmin</code>的划分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted100</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] minOfRight = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    minOfRight[n - <span class="number">1</span>] = arr[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        minOfRight[i] = Math.min(minOfRight[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max = Math.max(max,arr[i]);</span><br><span class="line">        <span class="comment">// 等于 重复元素 去掉=就是第一题 68%</span></span><br><span class="line">        <span class="keyword">if</span> (max &lt;= minOfRight[i + <span class="number">1</span>]) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>56%：前缀max数组 后缀min数组<br>left<code>[2,1]</code> right<code>[3,4,4]</code><br><code>leftMax&lt;rightMin</code>的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr     [2, 1, 3, 4, 4]</span><br><span class="line"></span><br><span class="line">比较切分位置0~n-1：[0:i][i+1:n-1]</span><br><span class="line">leftMax    [2, !2, !3, !4, 4] </span><br><span class="line">rightMin[1, 1, !3, !4, !4]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] minRight = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    maxLeft[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxLeft[i] = Math.max(maxLeft[i-<span class="number">1</span>],arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    minRight[n-<span class="number">1</span>] = arr[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        minRight[i] = Math.min(minRight[i+<span class="number">1</span>],arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLeft[i] &lt;= minRight[i+<span class="number">1</span>])&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44%拷贝一个数组排序，做累加,相等则可以划分<br><code>[2,1 |,3 |,4 |,4]</code><br><code>[1,2 |,3 |,4 |,4]</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 =<span class="number">0</span>,sum2 =<span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] copy = arr.clone();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        sum1 += copy[i];</span><br><span class="line">        sum2 += arr[i];</span><br><span class="line">        <span class="keyword">if</span>(sum1 == sum2)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401 二进制手表"></a>401 二进制手表</h3><p>上排1,2,4,8表示小时 下排1,2,4,8,16,32表示分钟<br>上1,2 下 16，8，1 表示3:25</p>
<blockquote>
<p>Input: n = 1 两了几个led灯 所有可能的时间<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
</blockquote>
<p>计算小时和分钟里有多少个1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span> ; h++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span> ; m++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.bitCount((h&lt;&lt;<span class="number">6</span>) + m) == num)&#123;</span><br><span class="line">                times.add(String.format(<span class="string">"%d:%02d"</span>,h,m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="汉明重量-Hamming-weight-32位int有多少个1"><a href="#汉明重量-Hamming-weight-32位int有多少个1" class="headerlink" title="汉明重量 Hamming weight 32位int有多少个1"></a>汉明重量 Hamming weight 32位int有多少个1</h3><blockquote>
<p>Input: 11<br>Output: 3<br>Integer 11 has binary representation 00000000000000000000000000001011</p>
</blockquote>
<blockquote>
<p>X与X-1相与得到的最低位永远是0</p>
</blockquote>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>0 1 0 0 0 1 0 0 0 1 0 0 0 0</td>
</tr>
<tr>
<td>X-1</td>
<td>0 1 0 0 0 1 0 0 0 0 1 1 1 1</td>
</tr>
<tr>
<td>X &amp; (X-1)</td>
<td>0 1 0 0 0 1 0 0 0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<h3 id="477-全部汉明距离Integer-bitCount-x-y"><a href="#477-全部汉明距离Integer-bitCount-x-y" class="headerlink" title="477 全部汉明距离Integer.bitCount(x ^ y)"></a>477 全部汉明距离<code>Integer.bitCount(x ^ y)</code></h3><blockquote>
<p>Input: 4, 14, 2<br>Output: 6<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>
</blockquote>
<p>4  = 0100<br>14 = 1110<br>2  = 0010<br>0x3+2<em>1+2</em>1+1*2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>,n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//有几个num这个位是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">            bitCnt += (nums[j] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += bitCnt*(n-bitCnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="338-0-n每个数字有几个1位-O-n-复杂度"><a href="#338-0-n每个数字有几个1位-O-n-复杂度" class="headerlink" title="338 0~n每个数字有几个1位 O(n)复杂度"></a>338 0~n每个数字有几个1位 O(n)复杂度</h3><blockquote>
<p>Input: 5<br>Output: [0,1,1,2,1,2]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num ; i++) &#123;</span><br><span class="line">        f[i] = f[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lt-803-建筑物之间的最短距离"><a href="#lt-803-建筑物之间的最短距离" class="headerlink" title="lt 803 建筑物之间的最短距离"></a>lt 803 建筑物之间的最短距离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">盖房子，在最短的距离内到达所有的建筑物。</span><br><span class="line">给定三个建筑物(0,0),(0,4),(2,2)和障碍物(0,2):</span><br><span class="line"></span><br><span class="line">    1 - 0 - 2 - 0 - 1</span><br><span class="line">    |   |   |   |   |</span><br><span class="line">    0 - 0 - 0! - 0 - 0</span><br><span class="line">    |   |   |   |   |</span><br><span class="line">    0 - 0 - 1 - 0 - 0</span><br><span class="line">点(1,2)是建造房屋理想的空地，因为3+3+1=7的总行程距离最小。所以返回7。</span><br></pre></td></tr></table></figure>
<h3 id="lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161"><a href="#lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161" class="headerlink" title="lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161"></a>lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sl = s.length();</span><br><span class="line">    <span class="keyword">int</span> tl = t.length();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(t))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(sl-tl)&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(sl,tl);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        idx = i+<span class="number">1</span>;<span class="comment">// &gt;=1</span></span><br><span class="line">        <span class="comment">// 前面已经相等了</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != t.charAt(i))&#123;</span><br><span class="line">            <span class="comment">// 比较两个字符串的a, b的index+1, index+1 位以后是否相等</span></span><br><span class="line">            <span class="comment">// 或者 index+1, index 是否相等，</span></span><br><span class="line">            <span class="comment">// 或者index, index+1是否相等</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(idx).equals(t.substring(idx)) || </span><br><span class="line">            s.substring(idx).equals(t.substring(idx-<span class="number">1</span>)) || </span><br><span class="line">            s.substring(idx-<span class="number">1</span>).equals(t.substring(idx));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h3><h3 id="取模和取余rem"><a href="#取模和取余rem" class="headerlink" title="取模和取余rem"></a>取模和取余rem</h3><p>java的<code>%</code>取余 python 取模<br>求 整数商： c = a/b;</p>
<p>计算模或者余数： r = a - c*b.<br>例如：计算-7 Mod 4<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">-7</span>%<span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>那么：a = -7；b = 4；</p>
<p>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</p>
<p>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</p>
<h3 id="线段上格点的个数"><a href="#线段上格点的个数" class="headerlink" title="线段上格点的个数"></a>线段上格点的个数</h3><blockquote>
<p>P1=(1,11) P2=(5,3)<br>out: 3 (2,9) (3,7) (4,5)</p>
</blockquote>
<p>答案是gcd(|x1-x2|,|y1-y2|)-1<br>最大公约数：共有约数中最大的一个<br>x相差4，y相差8 求分成（/）最多多少份，x,y都是整数</p>
<h3 id="火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼"><a href="#火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼" class="headerlink" title="火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼"></a>火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼</h3><blockquote>
<p>3节车厢，按照1，2，3依次入轨编组，可以在左边形成1 2 3，1 3 2，2 1 3，2 3 1，321。<br>问1-2-3-4能否编程4，1，3，2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设序列是1,2,3,4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] train = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = train.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; m ; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(train[i]&gt;train[j]&amp;&amp;train[i]&gt;train[k]&amp;&amp;train[k]&gt;train[j])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><h3 id="lt476石子合并-区间dp"><a href="#lt476石子合并-区间dp" class="headerlink" title="lt476石子合并 区间dp"></a>lt476石子合并 区间dp</h3><blockquote>
<p>有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小<br>in : 4 1 1 4 out: 18</p>
</blockquote>
<h3 id="lc84直方图中的最大矩形poj2559"><a href="#lc84直方图中的最大矩形poj2559" class="headerlink" title="lc84直方图中的最大矩形poj2559"></a>lc84直方图中的最大矩形poj2559</h3><p><img src="/images/histo1.jpg" alt="histo1.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo next</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>矩阵乘法相关题目：<br><a href="http://www.matrix67.com/blog/archives/276" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/276</a></p>
<h3 id="poj3734"><a href="#poj3734" class="headerlink" title="poj3734"></a>poj3734</h3><h3 id="790-L型，XX型骨牌覆盖2xN的board"><a href="#790-L型，XX型骨牌覆盖2xN的board" class="headerlink" title="790 L型，XX型骨牌覆盖2xN的board"></a>790 L型，XX型骨牌覆盖2xN的board</h3><blockquote>
<p>Input: 3<br>Output: 5<br>Explanation:<br>The five different ways are listed below, different letters indicates different tiles:<br>XYZ XXZ XYY XXY XYY<br>XYZ YYZ XZZ XYY XXY</p>
</blockquote>
<p><img src="/images/lc790.jpg" alt="lc790.jpg"><br>1.如果只XX骨牌<br>dp[i] 表示N = i的时候有多少种解<br>其实是费fib数列</p>
<h4 id="poj-2411"><a href="#poj-2411" class="headerlink" title="poj 2411"></a>poj 2411</h4><p><a href="http://poj.org/problem?id=2411" target="_blank" rel="noopener">http://poj.org/problem?id=2411</a><br>输入：大矩阵的h高，和w宽<br>输出:用宽2，高1的骨牌一共有多少种拼法</p>
<h3 id="图中长度为k的路径计数"><a href="#图中长度为k的路径计数" class="headerlink" title="图中长度为k的路径计数"></a>图中长度为k的路径计数</h3><p><a href="https://www.nowcoder.com/acm/contest/185/B" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/185/B</a></p>
<blockquote>
<p>求出从 1 号点 到 n 号点长度为k的路径的数目.</p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AC</span></span><br><span class="line"><span class="comment">//    final static int M = 10000;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] mul(<span class="keyword">long</span>[][] A,<span class="keyword">long</span>[][] B)&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] rst = <span class="keyword">new</span> <span class="keyword">long</span>[A.length][B[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;B.length ; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;B[<span class="number">0</span>].length ; j++) &#123;</span><br><span class="line">                    rst[i][j] = (rst[i][j]+A[i][k]*B[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] pow(<span class="keyword">long</span>[][] A,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">long</span>[][] rst =<span class="keyword">new</span> <span class="keyword">long</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">            rst[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                rst = mul(rst,A );</span><br><span class="line">            &#125;</span><br><span class="line">            A = mul(A, A);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        <span class="keyword">long</span>[][] graph = <span class="keyword">new</span> <span class="keyword">long</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;n ; j++) &#123;</span><br><span class="line">                graph[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span>[][] Gn = pow(graph, k);</span><br><span class="line">        System.out.println(Gn[<span class="number">0</span>][n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>有向图 从A点走K步到达B(边可重复)的方案数<br><code>G[u][v]</code>表示u到v 长度为k的路径数量<br>k=1 1条边可达的点 G1是图的邻接矩阵<br><img src="/images/kpath.jpg" alt="kpath.jpg"></p>
<h3 id="快速幂logN完成幂运算"><a href="#快速幂logN完成幂运算" class="headerlink" title="快速幂logN完成幂运算"></a>快速幂logN完成幂运算</h3><p>carmichael number<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this^exponent mod m</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">modPow</span><span class="params">(BigInteger exponent, BigInteger m)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><p><img src="/images/ditui.jpg" alt="ditui.jpg"><br>实际上求m项地推公式的第n项 可以用初项线性表示，通过快速幂O(m^2logn)</p>
<h3 id="fibo递推公式"><a href="#fibo递推公式" class="headerlink" title="fibo递推公式"></a>fibo递推公式</h3><p><a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B" target="_blank" rel="noopener">特征方程</a><br>1.二阶递推公式的特征方程<br>递推公式Xn = aXn-1 - bXn-2<br>特征方程x^2-ax+b =0<br>解得x1,x2则存在F(n) = Ax1+Bx2<br>带入F(0),F(1) 可得通项</p>
<p>2.矩阵解法<br>二阶递推式存在2x2矩阵A<br><img src="/images/fibo.jpg" alt="fibo.jpg"></p>
<p>矩阵乘法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] mul(<span class="keyword">int</span>[][] A,<span class="keyword">int</span>[][] B)&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] rst = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;B.length ; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;B[<span class="number">0</span>].length ; j++) &#123;</span><br><span class="line">                rst[i][j] = (rst[i][j]+A[i][k]*B[k][j])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/quickmi.jpg" alt="quickmi"><br>快速幂，将n用二进制表示，5-&gt;101表示A^5 = A^4+A^1,<br>A每次翻倍，n一直右移，n最右为1的时候加上当前A翻倍的结果。<br>矩阵的幂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] A,<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] rst =<span class="keyword">new</span> <span class="keyword">int</span>[A.length][A.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">        rst[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(;n&gt;0;n&gt;&gt;=1)</span></span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)!=<span class="number">0</span>)rst = mul(rst,A );</span><br><span class="line">        A = mul(A, A);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解fibo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] A = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] rst = sl.pow(A, n);</span><br><span class="line">System.out.println(rst[<span class="number">1</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<h3 id="763-划分尽可能多字母区间"><a href="#763-划分尽可能多字母区间" class="headerlink" title="763 划分尽可能多字母区间"></a>763 划分尽可能多字母区间</h3><blockquote>
<p>输入: S = “ababcbacadefegdehijhklij”<br>输出: [9,7,8]<br>解释:<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。<br>ababcba 从第一个a到最后一个a是必须包含的长度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//45%</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个字母最后出现的index</span></span><br><span class="line">    <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">      last[S.charAt(i)-<span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">        <span class="comment">//更新当前字母的区间</span></span><br><span class="line">        end = Math.max(end,last[S.charAt(i)-<span class="string">'a'</span>]);</span><br><span class="line">        <span class="comment">//关键</span></span><br><span class="line">        <span class="keyword">if</span>(i==end)&#123;</span><br><span class="line">            rst.add(end-start+<span class="number">1</span>);</span><br><span class="line">            start = end+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-3sum-a-b-c-0"><a href="#15-3sum-a-b-c-0" class="headerlink" title="15 3sum a + b + c = 0"></a>15 3sum a + b + c = 0</h3><blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<p>关键：去重技巧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//75%</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;num.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//关键去重</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||(i&gt;<span class="number">0</span>&amp;&amp;num[i]!=num[i-<span class="number">1</span>]))&#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i+<span class="number">1</span>,hi=num.length-<span class="number">1</span>,sum = <span class="number">0</span>-num[i];</span><br><span class="line">            <span class="comment">//关键</span></span><br><span class="line">            <span class="keyword">while</span> (lo&lt;hi)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[lo]+num[hi] == sum)&#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i],num[lo],num[hi]));</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (lo&lt;hi&amp;&amp;num[lo]==num[lo+<span class="number">1</span>])lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo&lt;hi&amp;&amp;num[hi]==num[hi-<span class="number">1</span>])hi--;</span><br><span class="line">                    lo++;hi--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num[lo]+num[hi]&lt;sum)lo++;</span><br><span class="line">                <span class="keyword">else</span> hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="16-3sum-最接近target的值"><a href="#16-3sum-最接近target的值" class="headerlink" title="16 3sum 最接近target的值"></a>16 3sum 最接近target的值</h3><p>//todo nexttime</p>
<h3 id="18-4sum-外层for-用3sum找target-nums-i"><a href="#18-4sum-外层for-用3sum找target-nums-i" class="headerlink" title="18 4sum 外层for 用3sum找target-nums[i]"></a>18 4sum 外层for 用3sum找<code>target-nums[i]</code></h3><h3 id="454-4-sum-2-poj2785-4-Values-whose-Sum-is-0"><a href="#454-4-sum-2-poj2785-4-Values-whose-Sum-is-0" class="headerlink" title="454 4 sum 2 poj2785 4 Values whose Sum is 0"></a>454 4 sum 2 poj2785 4 Values whose Sum is 0</h3><p>用poj的方法11%<br>4个分别有n个数字的数组ABCD，每个数组中取一个，合为0的组合数。<br>c+d = -a-b<br>从A,B中找出n^2种组合，从C,D中找出n^2种组合，排序二分找到lowerbound和upbound。</p>
<p>正确方法：计算c+d的时候放入hashmap计数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;C.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;D.length ; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = C[i] + D[j];</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span> )+<span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;B.length ; j++) &#123;</span><br><span class="line">            res += map.getOrDefault(-(A[i]+B[j]),<span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="914-相同数字的牌划分成一组，每组数量相同-能否划分"><a href="#914-相同数字的牌划分成一组，每组数量相同-能否划分" class="headerlink" title="914 相同数字的牌划分成一组，每组数量相同 能否划分"></a>914 相同数字的牌划分成一组，每组数量相同 能否划分</h3><blockquote>
<p>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p>
</blockquote>
<p>计数，求最大公约数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span>||deck.length&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count.put(i, count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : count.values()) res = gcd(i, res);</span><br><span class="line">    <span class="keyword">return</span> res &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; <span class="number">0</span> ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="916"><a href="#916" class="headerlink" title="916"></a>916</h3><blockquote>
<p>b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称单词 b 是单词 a 的子集。 例如，“wrr” 是 “warrior” 的子集，但不是 “world” </p>
</blockquote>
<h3 id="7-整数反转-integer越界"><a href="#7-整数反转-integer越界" class="headerlink" title="7 整数反转 integer越界"></a>7 整数反转 integer越界</h3><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = x&lt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rst&gt;Integer.MAX_VALUE/<span class="number">10</span>||(rst==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;add&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rst&lt;Integer.MIN_VALUE/<span class="number">10</span>||(rst==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;add&lt;-<span class="number">8</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rst = rst*<span class="number">10</span>+add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="319-n个灯泡-n轮开关"><a href="#319-n个灯泡-n轮开关" class="headerlink" title="319 n个灯泡 n轮开关"></a>319 n个灯泡 n轮开关</h3><p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</p>
<blockquote>
<p>输入: 3<br>输出: 1<br>解释:<br>初始时, 灯泡状态 [关闭, 关闭, 关闭].<br>第一轮后, 灯泡状态 [开启, 开启, 开启].<br>第二轮后, 灯泡状态 [开启, 关闭, 开启].<br>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </p>
</blockquote>
<p>你应该返回 1，因为只有一个灯泡还亮着。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被按奇数下的灯泡还亮着。<br>当第d轮可以整除i灯泡i被按下。所以如果i有奇个除数，则最后是开的。<br>例如12，</p>
<h3 id="451-字符串按频率排序-桶排序"><a href="#451-字符串按频率排序-桶排序" class="headerlink" title="451 字符串按频率排序 桶排序"></a>451 字符串按频率排序 桶排序</h3><h3 id="lt168-吹气球"><a href="#lt168-吹气球" class="headerlink" title="lt168 吹气球"></a>lt168 吹气球</h3><p>每次吹气球i可以得到的分数为 <code>nums[left] * nums[i] * nums[right]</code>，</p>
<blockquote>
<p>in [4, 1, 5, 10]<br>out 返回 270<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [4, 1, 5, 10] burst 1, 得分 4 * 1 * 5 = 20</span><br><span class="line">nums = [4, 5, 10]    burst 5, 得分 4 * 5 * 10 = 200 </span><br><span class="line">nums = [4, 10]       burst 4, 得分 1 * 4 * 10 = 40</span><br><span class="line">nums = [10]          burst 10, 得分 1 * 10 * 1 = 10</span><br><span class="line">总共的分数为 20 + 200 + 40 + 10 = 270</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="矩阵链乘法O-n-3-的dp"><a href="#矩阵链乘法O-n-3-的dp" class="headerlink" title="矩阵链乘法O(n^3)的dp"></a>矩阵链乘法O(n^3)的dp</h3><h3 id="最大值为k的不重叠子数组的长度和？"><a href="#最大值为k的不重叠子数组的长度和？" class="headerlink" title="最大值为k的不重叠子数组的长度和？??"></a>最大值为k的不重叠子数组的长度和？??</h3><p><a href="https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/</a></p>
<blockquote>
<p>Input : arr[] = {2, 1, 4,   9,   2, 3,   8,   3, 4}  k = 4<br>Output : 5<br>{2, 1, 4} =&gt; Length = 3<br>{3, 4} =&gt; Length = 2<br>So, 3 + 2 = 5 is the answer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lensum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n&amp;&amp;arr[i]&lt;=k)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == k)flag = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//？？？</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) ans+=cnt;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n&amp;&amp;arr[i]&gt;k)i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="689-高频题-找到三个长度为k互不重叠的子数组的最大和"><a href="#689-高频题-找到三个长度为k互不重叠的子数组的最大和" class="headerlink" title="689!!!高频题 找到三个长度为k互不重叠的子数组的最大和"></a>689!!!高频题 找到三个长度为k互不重叠的子数组的最大和</h3><blockquote>
<p>Input: [1,2,1,2,6,7,5,1], 2<br>不重叠窗口为2的数组的和  <code>[1, 2], [2, 6], [7, 5]</code><br>返回 起始索引为 [0, 3, 5]。<br>也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。</p>
</blockquote>
<p><a href="https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/</a><br><a href="https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/</a></p>
<h3 id="121-只能买卖一次-买卖股票的利润"><a href="#121-只能买卖一次-买卖股票的利润" class="headerlink" title="121 只能买卖一次 买卖股票的利润"></a>121 只能买卖一次 买卖股票的利润</h3><blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>
</blockquote>
<p>方法1：两次for，找最大差值 10% 262ms<br>方法2：Kadane算法(maximum subarray)先找到最低值，保留并更新最低值，并更新最大差值 2ms 36%</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minP = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;minP)minP = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-minP&gt;maxP)maxP = prices[i]-minP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp 保留前i天的最低值 更新第i天的最大差值 3ms 19%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] mindp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] maxdp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    mindp[<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">    maxdp[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        mindp[i] = Math.min(mindp[i-<span class="number">1</span>],prices[i]);</span><br><span class="line">       <span class="comment">//当天的股价-前i-1天的min价格</span></span><br><span class="line">        maxdp[i] = Math.max(maxdp[i-<span class="number">1</span>],prices[i]-mindp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxdp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dp2: 4 ms 15%<br>转换成53 将price reduce成每天的收益<br><code>[7,1,5,3,6,4]-&gt;[ ,-6,4,-2,3,-2]</code><br>在[4,-2,3]持有股票，从day2 [1]买进后的累积和最大<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 53!!!最大subarray sum</span><br><span class="line">Kadane <span class="number">14</span>ms <span class="number">19</span>%</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>],rst = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        rst = Math.max(rst,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>greedy:</p>
<h3 id="122-可以买卖多次-买股票的利润"><a href="#122-可以买卖多次-买股票的利润" class="headerlink" title="122 可以买卖多次 买股票的利润"></a>122 可以买卖多次 买股票的利润</h3><blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<h3 id="123-最多买卖2次的-买股票利润-考到"><a href="#123-最多买卖2次的-买股票利润-考到" class="headerlink" title="123 最多买卖2次的 买股票利润 考到"></a>123 最多买卖2次的 买股票利润 考到</h3><blockquote>
<p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<h3 id="188-最多k次买卖的-买卖股票利润"><a href="#188-最多k次买卖的-买卖股票利润" class="headerlink" title="188 最多k次买卖的 买卖股票利润"></a>188 最多k次买卖的 买卖股票利润</h3><blockquote>
<p>输入: [3,2,6,5,0,3], k = 2<br>输出: 7<br>解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<h3 id="重复元素很多的数组排序"><a href="#重复元素很多的数组排序" class="headerlink" title="重复元素很多的数组排序"></a>重复元素很多的数组排序</h3><p><a href="https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/</a></p>
<blockquote>
<p>AVL or Red-Black to sort in O(n Log m) time where m is number of distinct elements.<br>//todo</p>
</blockquote>
<h3 id="621-todo"><a href="#621-todo" class="headerlink" title="621 todo"></a>621 todo</h3><p>26 种不同种类的任务  每个任务都可以在 1 个单位时间内执行完<br>两个相同种类的任务之间必须有长度为 n 的冷却时间</p>
<blockquote>
<p>输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>输出: 8</p>
</blockquote>
<p>执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</p>
<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516 最长回文子序列"></a>516 最长回文子序列</h3><h3 id="Rearrange-a-string"><a href="#Rearrange-a-string" class="headerlink" title="Rearrange a string"></a>Rearrange a string</h3><p><a href="https://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/</a></p>
<h3 id="386-字典序数字-todo"><a href="#386-字典序数字-todo" class="headerlink" title="!!386 字典序数字 todo"></a>!!386 字典序数字 todo</h3><p>dfs 112ms 71%<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   1        2        3    ...</span><br><span class="line">  /\        /\       /\</span><br><span class="line">10 ...19  20...29  30...39   ....</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        dfs(rst,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; rst,<span class="keyword">int</span> n,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        rst.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur*<span class="number">10</span>+i&gt;n)<span class="keyword">return</span>;</span><br><span class="line">            dfs(rst,n,<span class="number">10</span>*cur+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关：<br>permutation的字典序<br>思想：字典序全排列算法：保证尽可能长的前缀不变，后缀慢慢增加<br> abc 保证前面不变，后面增加一点点 -&gt; acb ，cb不能增大了，-&gt;bac<br> 从右向左扫描 例如 321 是递增的 表示不能再增加<br> 从右向左扫描到第一次增大的位置，和右边比较大的数交换。1 2 3 扫描到2，和3交换。<br> 1 3 2 扫描到1降了，1和2交换 2 3 1  31不是最小后缀 变成2 1 3 </p>
<p>算法：<br><img src="/images/lexpermu.jpg" alt="lexpermu.jpg"><br> 1.从右想左 找到第一次下降位置<br> 2.用后缀中比当前位置大的最小数字交换<br> 3.保证后缀最小（翻转？）</p>
<h3 id="636-单核cpu函数调用栈"><a href="#636-单核cpu函数调用栈" class="headerlink" title="636 单核cpu函数调用栈"></a>636 单核cpu函数调用栈</h3><p>日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：”0:start:0” 表示函数 0 从 0 时刻开始运行。”0:end:0” 表示函数 0 在 0 时刻结束。</p>
<p>函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。</p>
<blockquote>
<p>输入 n = 2<br>logs =<br>[“0:start:0”,<br> “1:start:2”,<br> “1:end:5”,<br> “0:end:6”]<br>输出：[3, 4]</p>
</blockquote>
<p>函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。<br>现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。<br>函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。<br>所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。</p>
<p>stack + start[] ac 15%</p>
<h3 id="378-矩阵从左到右从上到下有序，找第k小的元素"><a href="#378-矩阵从左到右从上到下有序，找第k小的元素" class="headerlink" title="378 矩阵从左到右从上到下有序，找第k小的元素"></a>378 矩阵从左到右从上到下有序，找第k小的元素</h3><p>1.全部放进k大的PriorityQueue,最后poll掉k-1个，return peek 28%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  PriorityQueue&lt;Integer&gt; que = <span class="keyword">new</span> PriorityQueue(k);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span>[] row:matrix)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> x :row)&#123;</span><br><span class="line">             que.add(x);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">         que.poll();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> que.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.</p>
<h3 id="373"><a href="#373" class="headerlink" title="373"></a>373</h3><h3 id="概率生成函数-概率母函数"><a href="#概率生成函数-概率母函数" class="headerlink" title="概率生成函数 概率母函数"></a>概率生成函数 概率母函数</h3><p>1.x的系数是a1,a2,…an 的单个组合的全体。</p>
<ol start="2">
<li>x^2的系数是a1,a2,…a2的两个组合的全体。<br>………<br>n. x^n的系数是a1,a2,….an的n个组合的全体（只有1个）。</li>
</ol>
<blockquote>
<p>有1克、2克、3克、4克的砝码各一枚，能称出哪几种重量？每种重量各有几种可能方案？</p>
</blockquote>
<p>设x表示砝码，x的指数表示砝码的重量<br>1个1克的砝码可以用函数1+1<em>x^1表示，<br>1个2克的砝码可以用函数1+1</em>x^2表示，<br>1个3克的砝码可以用函数1+1<em>x^3表示，<br>1个4克的砝码可以用函数1+1</em>x^4表示，</p>
<ul>
<li><p>1表示数量0个<br>例如1个2克的砝码：1+x^2<br>1其实应该写为：1*x^0,即1代表重量为2的砝码数量为0个。</p>
</li>
<li><p>系数表示状态数（方案数）<br>1+x^2，也就是1<em>x^0 + 1</em>x^2，不取2克砝码，有1种状态；或者取2克砝码，也有1种<br>状态。</p>
</li>
</ul>
<p>(1+x)(1+x^2)(1+x^3)(1+x^4)<br>=(1+x+x^2+x^4)(1+x^3+^4+x^7)<br>=1 + x + x^2 + 2<em>x^3 + 2</em>x^4 + 2<em>x^5 + 2</em>x^6 + 2<em>x^7 + x^8 + x^9 + x^10<br>从上面的函数知道：可称出从1克到10克，系数便是方案数。<br>有2</em>x^5 项，即称出5克的方案有2种：5=3+2=4+1；</p>
<blockquote>
<p>求用1分、2分、3分的邮票贴出不同数值的方案数：每种是无限的。</p>
</blockquote>
<h3 id="分配问题及应用"><a href="#分配问题及应用" class="headerlink" title="分配问题及应用"></a>分配问题及应用</h3><p><img src="/images/fenpei.jpg" alt="fenpei.jpg"></p>
<h3 id="硬币相关问题"><a href="#硬币相关问题" class="headerlink" title="硬币相关问题"></a>硬币相关问题</h3><p><a href="http://www.raychase.net/3144" target="_blank" rel="noopener">http://www.raychase.net/3144</a><br>正正反 甲赢 正反反 乙赢 Penney’s game</p>
<p><img src="/images/penneygame.jpg" alt="penneygame.jpg"></p>
<blockquote>
<p>使用长度为3字节的序列，玩家B相对玩家A有优势。这是因为这个游戏是一个非传递博弈，所以无论如何选定第一个序列，总会有一个序列有更大的获胜概率。</p>
</blockquote>
<p>反反正:正反反 = 1：3<br>因为只要出现一次正，想得到反反正的人就必输了，他肯定得先看到两次反，我就得到正反反了。<br>两个硬币4种情况有3种有正</p>
<p>正正反：反正正 = 1：3<br>只要出现一次反，反正正就赢了。</p>
<p>正反反HTT：正正反HHT = 1:2<br>反正正thh:反反正tth = 1：2</p>
<p><a href="https://en.wikipedia.org/wiki/Penney%27s_game" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Penney%27s_game</a><br>对于二号玩家：1-2-3 -&gt;  (not-2)-1-2<br>第一个字节与1号玩家的第二个字节相反，<br>第二个字节与1号玩家的第一个字节相同，<br>第三个字节与1号玩家的第二个字节相同。</p>
<p><a href="http://www.matrix67.com/blog/archives/3638" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/3638</a></p>
<blockquote>
<p>所有 1 都不相邻的 k 位 01 串有 Fk+2 个 Fi 表示 Fibonacci 数列中的第 i 项</p>
</blockquote>
<p>抛掷第 k 次才出现连续两个正面”的意思就是， k 位 01 串的末三位是 011，并且前面 k – 3 位中的数字 1 都不相邻。 k-3位的01不相邻的串有F(k-1)个</p>
<blockquote>
<p>平均需要抛掷多少次硬币，才会首次出现连续的 n 个正面？</p>
</blockquote>
<p>答案是 2^(n+1) – 2<br>神奇的模式概率与“鞅”//todo<br><a href="http://www.math-engineering.uestc.edu.cn/" target="_blank" rel="noopener">http://www.math-engineering.uestc.edu.cn/</a><br>模式的平均等待时间：<br>模式 HHHHHH 的平均等待时间 126</p>
<blockquote>
<p>扔硬币直到连续两次出现正面，求扔的期望次数</p>
</blockquote>
<p>• 扔到的是反面，那么还期望抛 E 次，因为抛到反面完全没用，总数就期望抛 E+1，所以是0.5<em>(1 + E)<br>• 扔到的是正面，如果下一次是反面，那么相当于重头来过，总数就期望抛，则是0.25</em>(2 + E)<br>• 扔到两次，都是正面，总数是 2，则是0.25<em>2<br>所以递归来看E = 0.5</em>(1 + E) + 0.25<em>(2 + E) + 0.25</em>2，解得E = 6</p>
<blockquote>
<p>A赢： 先正后反， B赢 连续两次反面：A胜的概率 3/4</p>
</blockquote>
<p>B 赢概率是1/2*1/2 = 1/4</p>
<p>多重排列：pingpang中有重复2个p 2个n 2个g</p>
<ol>
<li>标记为p1p2n1n2g1g2ia 全排列个数是8!</li>
<li>p的重复度 为p1p2的全排列 2!</li>
<li>P(N,r1,r2…rt)  标记为P(8;2,2,2,1,1)</li>
<li>P(8;2,2,2,1,1)*2!*2!*2! = 8!</li>
</ol>
<p>理解二项式定理(a+b)^n<br><img src="/images/abbinary.jpg" alt="abbinary.jpg"><br>通项是a^k b^(n-k) 前面的系数表示 n个数的可重排列，a有k个，b有n-k个</p>
<p>不仅是二项式<br>通项是a1^(r1) a2^(r2) at^(rt)<br><img src="/images/nbinary.jpg" alt="nbinary.jpg"><br>(x1+x2+…+xm)^n 展开式的项数等于C(n+m-1,n).</p>
<blockquote>
<p>有6个洞 编号1-9个球，求球入洞的方案数</p>
</blockquote>
<p>隔板法：</p>
<ol>
<li>划分6个洞需要5个隔板，用1~9填充隔板的空间。变成5个隔板和9个球的全排列。</li>
<li>5个隔板是相同的，P（14,5,1,1,1,1,1,1,1,1,1,1) = 14!/5!</li>
</ol>
<p>另一种方法：</p>
<ol>
<li>1号球可以放6个位置</li>
<li>1号球等于把空间又划分成了1前和1后，2球有5+2种可能</li>
<li>同理 3号球有7-1+2 =8个可能…</li>
<li>6乘到14 = 14!/5!</li>
</ol>
<blockquote>
<p>52张牌分发给4个人，每人13张，问每人有一张A的概率有多少？<br>10.55%</p>
</blockquote>
<p>52张牌分发给4个人，每人13张的方法数为52！/(13!)^4 。<br>每人发一张A的方法数为4！* 48！/(12!)^4 .</p>
<blockquote>
<p>4个相同的桔子和6个不同的苹果放到5个不同的盒子中，问每个盒子里有2个水果的概率有多大？<br>7.4%</p>
</blockquote>
<p>把4个相同桔子放入5个不同盒子的放法数为C(5,4),<br>把6个不同苹果放入5个不同盒子的放法数为5^6 .因此总的分配方法数为C(5,4)*5^6 .</p>
<p>每个盒子有2个水果，有如下三种情况：<br>1、（AA)(AA)(AA)(OO)(OO)<br>C(5,2)<em>6!/2!/2!/2!<br>2、AA)(AA)(OA)(OA)(OO)<br>C(5,1)\</em>C(4,2)*6!/2!/2!<br>3.（AA)(OA)(OA)(OA)(OA)<br>C(5,4)*6!/2!</p>
<blockquote>
<p>将n个不同的球放入编号为1,2,…,k的k个盒子中，试求：</p>
</blockquote>
<ol>
<li>第一个盒子是空盒的概率: 第一个盒子是空盒的方案数为(k－1) n 。</li>
<li>设k≥n,求n个球落入n个不同盒子的概率:  n个球落入n个不同盒子的方案数为C(k,n)n!。</li>
<li>第一盒或第二盒两盒中至少一个是空盒的概率。该方案数为第一个盒子是空盒的方案数加上第二个<br>盒子是空盒的方案数，再减去两个盒子都是空盒的方案<br>数。</li>
</ol>
<blockquote>
<p>随机地将15名插班生分配到三个班级，每班各5名。设15名插班生中有3为女生。试求：<br>将15名插班生分配到三个班级，每班各5名的方案数为C(15,5)C(10,5)C(5,5)=15!/(5!5!5!)。</p>
</blockquote>
<ol>
<li>每一个班级分到一名女生的概率:3!*12!/(4!4!4!)</li>
<li>三名女生分到同一班的概率: 3*12!/(5!5!2!)</li>
</ol>
<h3 id="649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营"><a href="#649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营" class="headerlink" title="649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营"></a>649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营</h3><p>禁止一名参议员的权利：<br>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p>
<p>宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p>
<blockquote>
<p>输入: “RD”<br>输出: “Radiant”<br>解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</p>
</blockquote>
<blockquote>
<p>输入: “RDD”<br>输出: “Dire”<br>解释:<br>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利<br>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止<br>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利<br>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</p>
</blockquote>
<h3 id="495-给定攻击时间和中毒状态持续时间，问中毒状态总时长"><a href="#495-给定攻击时间和中毒状态持续时间，问中毒状态总时长" class="headerlink" title="495 给定攻击时间和中毒状态持续时间，问中毒状态总时长"></a>495 给定攻击时间和中毒状态持续时间，问中毒状态总时长</h3><blockquote>
<p>Input: [1,2], 2<br>Output: 3 (1-2-4)</p>
</blockquote>
<p>8ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeSeries==<span class="keyword">null</span>||timeSeries.length&lt;<span class="number">1</span>||duration==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;timeSeries.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//每次取间隔或者duration</span></span><br><span class="line">      rst += Math.min(duration,timeSeries[i+<span class="number">1</span>]-timeSeries[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rst += duration;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//todo again<br>按 区间的做法：100% 4ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeSeries==<span class="keyword">null</span>||timeSeries.length&lt;<span class="number">1</span>||duration==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = timeSeries[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end = timeSeries[<span class="number">0</span>]+duration;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;timeSeries.length;i++)&#123;</span><br><span class="line">        <span class="comment">//Input: [1,4], 2 </span></span><br><span class="line">        <span class="keyword">if</span>(timeSeries[i]&gt;end)&#123;</span><br><span class="line">            result += (end-start);</span><br><span class="line">            start = timeSeries[i];</span><br><span class="line">        &#125;</span><br><span class="line">        end = timeSeries[i]+duration;</span><br><span class="line">    &#125;</span><br><span class="line">        result+=(end-start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="899-操作字符串前k个字符放到最后-输出字典序最小的"><a href="#899-操作字符串前k个字符放到最后-输出字典序最小的" class="headerlink" title="899 操作字符串前k个字符放到最后 输出字典序最小的"></a>899 操作字符串前k个字符放到最后 输出字典序最小的</h3><blockquote>
<p>Input: S = “cba”, K = 1<br>Output: “acb”</p>
<p>Input: S = “baaca”, K = 3<br>Output: “aaabc”<br>Explanation:<br>In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.<br>In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.</p>
</blockquote>
<p>当k=1 字符串只能旋转<br>当k&gt;1的时候，固定第一位，可以把后面任意一位转到第二位，即确定第一位，可以和后面所有数字比较，然后放到最后，冒泡排序。</p>
<h3 id="77combinations-C-n-k-C-n-1-k-1-C-n-1-k"><a href="#77combinations-C-n-k-C-n-1-k-1-C-n-1-k" class="headerlink" title="77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)"></a>77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)</h3><p><code>C(n-1,k-1)</code>表示选这个数，<code>C(n-1,k)</code>表示不选这个数<br>88%的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combineFast(<span class="keyword">int</span> n,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n||k&lt;<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = combine(n-<span class="number">1</span>,k-<span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; list:result)&#123;</span><br><span class="line">        list.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    result.addAll(combine(n-<span class="number">1</span>,k ));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    math 8% C(n,k)=C(n-1,k-1)+C(n-1,k)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combineMath(<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==n||k==<span class="number">0</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=k ; i++) &#123;</span><br><span class="line">            row.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(row));</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">this</span>.combineMath(n-<span class="number">1</span>,k-<span class="number">1</span> );</span><br><span class="line">    result.forEach(e-&gt;e.add(n));</span><br><span class="line">    result.addAll(<span class="keyword">this</span>.combineMath(n-<span class="number">1</span>,k ));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24两个一组交换链表"><a href="#24两个一组交换链表" class="headerlink" title="24两个一组交换链表"></a>24两个一组交换链表</h3><h3 id="NqueenBB"><a href="#NqueenBB" class="headerlink" title="NqueenBB"></a>NqueenBB</h3><p><img src="/images/nqueenbb.jpg" alt="nqueenbb.jpg"><br>N – 1’ in the backslash code is there to ensure that the codes are never negative because we will be using the codes as indices in an array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slash /</span><br><span class="line"> 0  1  2  3  4  5  6  7 </span><br><span class="line"> 1  2  3  4  5  6  7  8 </span><br><span class="line"> 2  3  4  5  6  7  8  9 </span><br><span class="line"> 3  4  5  6  7  8  9 10 </span><br><span class="line"> 4  5  6  7  8  9 10 11 </span><br><span class="line"> 5  6  7  8  9 10 11 12 </span><br><span class="line"> 6  7  8  9 10 11 12 13 </span><br><span class="line"> 7  8  9 10 11 12 13 14</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">backslash \</span><br><span class="line"> 7  6  5  4  3  2  1  0 </span><br><span class="line"> 8  7  6  5  4  3  2  1 </span><br><span class="line"> 9  8  7  6  5  4  3  2 </span><br><span class="line">10  9  8  7  6  5  4  3 </span><br><span class="line">11 10  9  8  7  6  5  4 </span><br><span class="line">12 11 10  9  8  7  6  5 </span><br><span class="line">13 12 11 10  9  8  7  6 </span><br><span class="line">14 13 12 11 10  9  8  7</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;N ; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;N ; c++) &#123;</span><br><span class="line">       slashCode[r][c]=r+c;</span><br><span class="line">       backslashCode[r][c]=r-c+(N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bb 5ms 78%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] slashCode, backslashCode;</span><br><span class="line"><span class="comment">//记录这个code是不是已经占用了</span></span><br><span class="line"><span class="keyword">boolean</span>[] rowocc;</span><br><span class="line"><span class="keyword">boolean</span>[] slashocc,backslashocc;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">     slashCode = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    backslashCode = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    rowocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">     slashocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    backslashocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;n ; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;n ; c++) &#123;</span><br><span class="line">           slashCode[r][c]=r+c;</span><br><span class="line">           backslashCode[r][c]=r-c+(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nqueen(rst,<span class="number">0</span>,n,board);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">addBoard</span><span class="params">(<span class="keyword">int</span>[][] board)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; rst  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] row:board)&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:row)&#123;</span><br><span class="line">            sb.append((i==<span class="number">0</span>?<span class="string">"."</span>:<span class="string">"Q"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        rst.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (slashocc[slashCode[row][col]] ||</span><br><span class="line">            backslashocc[backslashCode[row][col]] ||</span><br><span class="line">            rowocc[row])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nqueen</span><span class="params">(List&lt;List&lt;String&gt;&gt; rst,<span class="keyword">int</span> col,<span class="keyword">int</span> n,<span class="keyword">int</span>[][] board)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col&gt;=n)&#123;</span><br><span class="line">        rst.add(addBoard(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSafe(board,i,col))&#123;</span><br><span class="line">             board[i][col] = <span class="number">1</span>;</span><br><span class="line">             rowocc[i] = <span class="keyword">true</span>;</span><br><span class="line">            slashocc[slashCode[i][col]] = <span class="keyword">true</span>;</span><br><span class="line">            backslashocc[backslashCode[i][col]] = <span class="keyword">true</span>;</span><br><span class="line">            nqueen(rst,col+<span class="number">1</span>,n,board);</span><br><span class="line">            rowocc[i] = <span class="keyword">false</span>;</span><br><span class="line">            slashocc[slashCode[i][col]] = <span class="keyword">false</span>;</span><br><span class="line">            backslashocc[backslashCode[i][col]] = <span class="keyword">false</span>;</span><br><span class="line">            board[i][col] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>check whether slash code ( j + i ) or backslash code ( j – i + 7 ) are used (keep two arrays that will tell us which diagonals are occupied). </p>
<h3 id="179-一组非负数，拼接成最大的正整数"><a href="#179-一组非负数，拼接成最大的正整数" class="headerlink" title="179 一组非负数，拼接成最大的正整数"></a>179 一组非负数，拼接成最大的正整数</h3><blockquote>
<p>Input: [10,2]<br>Output: “210”</p>
</blockquote>
<p>String s1 = “9”;<br>String s2 = “31”;</p>
<p>String case1 =  s1 + s2; // 931<br>String case2 = s2 + s1; // 319</p>
<blockquote>
<p>String concatenation may be O(n^2) in Java (depends on if the compiler optimizes). Using StringBuilder is O(n).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="comment">//变成String数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">        strs[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    Arrays.sort(strs,(a,b)-&gt;(b+a).compareTo(a+b));</span><br><span class="line">    <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="500-判断字符串是不是在键盘的同一行"><a href="#500-判断字符串是不是在键盘的同一行" class="headerlink" title="500 判断字符串是不是在键盘的同一行"></a>500 判断字符串是不是在键盘的同一行</h3><p>流： 正则很慢 流也很慢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findWords(String[] words)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(words).parallel().filter(s-&gt;s.toLowerCase().matches(<span class="string">"[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*"</span>)).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="42"><a href="#42" class="headerlink" title="42"></a>42</h3><h3 id="683-K-Empty-Slots"><a href="#683-K-Empty-Slots" class="headerlink" title="683 - K Empty Slots"></a>683 - K Empty Slots</h3><h3 id="最长01串"><a href="#最长01串" class="headerlink" title="最长01串"></a>最长01串</h3><h3 id="倒水问题-BFS"><a href="#倒水问题-BFS" class="headerlink" title="倒水问题 BFS"></a>倒水问题 BFS</h3><h4 id="poj-3414-Pots"><a href="#poj-3414-Pots" class="headerlink" title="poj 3414 Pots"></a>poj 3414 Pots</h4><p><a href="http://poj.org/problem?id=3414" target="_blank" rel="noopener">http://poj.org/problem?id=3414</a></p>
<blockquote>
<p>输入：3 5 4<br>输出<br>容量A3 B5 获得4升水的最短序列<br>6<br>FILL(2)<br>POUR(2,1)<br>DROP(1)<br>POUR(2,1)<br>FILL(2)<br>POUR(2,1)</p>
</blockquote>
<p>Accepted    3128K   1125MS  Java    3840B</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pathNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">pathNode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cell</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cell</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bfs</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] marked = <span class="keyword">new</span> <span class="keyword">int</span>[A+<span class="number">1</span>][B+<span class="number">1</span>];</span><br><span class="line">    pathNode[] pathNodes = <span class="keyword">new</span> pathNode[A+B+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] pre =  <span class="keyword">new</span> <span class="keyword">int</span>[A+<span class="number">1</span>][B+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Deque&lt;Cell&gt; que = <span class="keyword">new</span> ArrayDeque&lt;Cell&gt;();</span><br><span class="line">    <span class="comment">//初始状态 2个空桶</span></span><br><span class="line">    que.add(<span class="keyword">new</span> Cell(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    marked[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty())&#123;</span><br><span class="line">        Cell cell = que.poll();</span><br><span class="line">        <span class="keyword">int</span> a = cell.a,b = cell.b;</span><br><span class="line">        <span class="comment">//6种操作 满，空，互相倒 x2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;<span class="number">6</span> ; d++) &#123;</span><br><span class="line">            <span class="keyword">int</span> na=<span class="number">0</span>,nb=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//装满A</span></span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>)&#123;na=A;nb=b;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;na= a;nb=B;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">2</span>)&#123;na=<span class="number">0</span>;nb=b;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">3</span>)&#123;na=a; nb=<span class="number">0</span>;&#125;</span><br><span class="line">            <span class="comment">//A-&gt;B</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> all = a+b;</span><br><span class="line">                na = all&gt;=B?all-B:<span class="number">0</span>;</span><br><span class="line">                nb = all&gt;=B?B:all;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//B-&gt;A</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> all = a+b;</span><br><span class="line">                na = all&gt;=A?A:all;</span><br><span class="line">                nb = all&gt;=A?all-A:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个桶状态没试过</span></span><br><span class="line">            <span class="keyword">if</span>(marked[na][nb]==<span class="number">0</span>)&#123;</span><br><span class="line">                marked[na][nb] =<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//关键：记录当前操作序号cnt是在node(a,b)是做d操作得来的</span></span><br><span class="line">                pathNodes[cnt] = <span class="keyword">new</span> pathNode(a,b,d);</span><br><span class="line">                <span class="comment">//可以查到对上一个的操作</span></span><br><span class="line">                pre[na][nb] = cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(na == C||nb==C)&#123;</span><br><span class="line">                    Deque&lt;Integer&gt; op = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">                    <span class="keyword">int</span> enda = na,endb = nb;</span><br><span class="line">                    <span class="keyword">while</span> (enda!=<span class="number">0</span>||endb!=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> p = pre[enda][endb];</span><br><span class="line">                        op.push(pathNodes[p].t);</span><br><span class="line">                        enda = pathNodes[p].a;</span><br><span class="line">                        endb = pathNodes[p].b;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(op.size());</span><br><span class="line">                    <span class="keyword">while</span> (!op.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = op.poll();</span><br><span class="line">                        <span class="keyword">if</span>(x==<span class="number">0</span>||x==<span class="number">1</span>) System.out.printf(<span class="string">"FILL(%d)\n"</span>,x+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>||x==<span class="number">3</span>)System.out.printf(<span class="string">"DROP(%d)\n"</span>,x-<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>) System.out.printf(<span class="string">"POUR(1,2)\n"</span>);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">5</span>)System.out.printf(<span class="string">"POUR(2,1)\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                que.add(<span class="keyword">new</span> Cell(na,nb));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//            System.out.println("下一层");</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"impossible"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="poj-1606"><a href="#poj-1606" class="headerlink" title="poj 1606"></a>poj 1606</h4><h3 id="2-N-大整数"><a href="#2-N-大整数" class="headerlink" title="2^N 大整数"></a>2^N 大整数</h3><h3 id="287-O-1-空间，找到数组中重复的数字"><a href="#287-O-1-空间，找到数组中重复的数字" class="headerlink" title="287 O(1)空间，找到数组中重复的数字"></a>287 O(1)空间，找到数组中重复的数字</h3><h3 id="查找第二小-大的元素"><a href="#查找第二小-大的元素" class="headerlink" title="查找第二小/大的元素"></a>查找第二小/大的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secondMin2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = Integer.MAX_VALUE,second = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;=first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = arr[j];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[j]&lt;=second&amp;&amp;arr[j]!=first)</span><br><span class="line">            second = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secondMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = Integer.MIN_VALUE,second = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;=first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = arr[j];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[j]&gt;=second&amp;&amp;arr[j]!=first)</span><br><span class="line">            second = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序数组中小于target的"><a href="#排序数组中小于target的" class="headerlink" title="排序数组中小于target的"></a>排序数组中小于target的</h3><p>2 4 6 8 9 target=14</p>
<ol>
<li>2+9&lt;14 cnt+=4</li>
<li>4+9&lt;14 cnt+=3</li>
<li>6+9&gt;14,6+8==14,start==end 结束</li>
</ol>
<h3 id="给定一个数字范围，找到其中有几个首尾相同的数字"><a href="#给定一个数字范围，找到其中有几个首尾相同的数字" class="headerlink" title="给定一个数字范围，找到其中有几个首尾相同的数字"></a>给定一个数字范围，找到其中有几个首尾相同的数字</h3><p><img src="/images/digits.jpg" alt="digits.jpg"></p>
<h3 id="百万数字中找最大20个"><a href="#百万数字中找最大20个" class="headerlink" title="百万数字中找最大20个"></a>百万数字中找最大20个</h3><p>用开始20个数字构造20个node的最小堆，接下来的数字比root大则replace，insert</p>
<h3 id="每秒最大桶数量减半，求t时刻一共消耗了多少"><a href="#每秒最大桶数量减半，求t时刻一共消耗了多少" class="headerlink" title="每秒最大桶数量减半，求t时刻一共消耗了多少"></a>每秒最大桶数量减半，求t时刻一共消耗了多少</h3><p>方法1：按递减排序，减半，再排序，一共排序t次<br>方法2：维持最大堆，每次取root减半再插入</p>
<h3 id="？445-链表数字相加"><a href="#？445-链表数字相加" class="headerlink" title="？445 链表数字相加"></a>？445 链表数字相加</h3><blockquote>
<p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>
<p>？递归写法</p>
<h3 id="896有正负的数列判断单调"><a href="#896有正负的数列判断单调" class="headerlink" title="896有正负的数列判断单调"></a>896有正负的数列判断单调</h3><p>用首尾判断up/down，中间相邻遍历判断up/down和之前不符return false<br>20ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n=A.length;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">boolean</span> up= (A[n-<span class="number">1</span>]-A[<span class="number">0</span>])&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (A[i+<span class="number">1</span>]!=A[i] &amp;&amp; (A[i+<span class="number">1</span>]-A[i]&gt;<span class="number">0</span>)!=up) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(strs==<span class="keyword">null</span>||strs.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   String rst = strs[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">    <span class="comment">//削减rst以匹配每个后面的单词</span></span><br><span class="line">       <span class="keyword">while</span>(strs[i].indexOf(rst)!=<span class="number">0</span>)&#123;</span><br><span class="line">           rst =rst.substring(<span class="number">0</span>,Math.min(rst.length()-<span class="number">1</span>,strs[i].length()));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="718-最长公共子串40ms-90"><a href="#718-最长公共子串40ms-90" class="headerlink" title="718 最长公共子串40ms 90%"></a>718 最长公共子串40ms 90%</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.length,n = b.length;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            max = Math.max(max,dp[i][j]=a[i]==b[j]?<span class="number">1</span>+dp[i+<span class="number">1</span>][j+<span class="number">1</span>]:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rolling hash<br><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution/</a></p>
<h3 id="括号串达到匹配需要最小的逆转次数"><a href="#括号串达到匹配需要最小的逆转次数" class="headerlink" title="括号串达到匹配需要最小的逆转次数"></a>括号串达到匹配需要最小的逆转次数</h3><blockquote>
<p>Input:  exp = “}}}{“<br>Output: 2 </p>
</blockquote>
<p>将匹配的括号都去掉，<code>{</code>的个数是m=3，<code>}</code>的个数是n=3<br>m/3+n/2 = 2+1=3<br><img src="/images/minbracket.jpg" alt="minbracket.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minReversal</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span>((len&amp;<span class="number">1</span>)!=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    Deque&lt;Character&gt; que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'&#125;'</span>&amp;&amp;!s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.peek()==<span class="string">'&#123;'</span>)que.pop();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                que.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mn = que.size();</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()&amp;&amp;que.peek()==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">        que.pop();</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当m+n是偶数的时候ceil(n/2)+ceil(m/2)=</span></span><br><span class="line">    <span class="keyword">return</span> (mn/<span class="number">2</span>+n%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="28字符串indexOf匹配暴力-Substring-Search"><a href="#28字符串indexOf匹配暴力-Substring-Search" class="headerlink" title="28字符串indexOf匹配暴力 Substring Search"></a>28字符串indexOf匹配暴力 Substring Search</h3><p>各种字符串匹配算法<br><a href="http://www-igm.univ-mlv.fr/~lecroq/string/" target="_blank" rel="noopener">http://www-igm.univ-mlv.fr/~lecroq/string/</a><br><img src="/images/strstrbest.jpg" alt="strstrbest.jpg"><br><a href="https://algs4.cs.princeton.edu/53substring/" target="_blank" rel="noopener">https://algs4.cs.princeton.edu/53substring/</a><br><img src="/images/backup.jpg" alt="backup"><br>方法1是维持一个pattern长度的buffer<br><img src="/images/substring.jpg" alt="substring.jpg"><br>流的情况下 没有backup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADA B RAC</span><br><span class="line">ADA[C]R i-=j</span><br><span class="line"> ADACR</span><br></pre></td></tr></table></figure></p>
<h4 id="Boyer-Moore-74-5ms-亚线性"><a href="#Boyer-Moore-74-5ms-亚线性" class="headerlink" title="!!!Boyer-Moore 74% 5ms 亚线性"></a>!!!Boyer-Moore 74% 5ms 亚线性</h4><p>alg4<br>1.构建right表示target中字符的最右位置是NEEDLE<br><img src="/images/boyerright.jpg" alt="boyerright.jpg"><br>2.source从左到右扫描，target从右向左<br>如果出现不匹配T是target里没有的，i到j+1<br>如果出现不匹配N是target里的，则用right，将target里N的位置和它对齐<br><img src="/images/boyerright2.jpg" alt="boyerright2.jpg"><br>当前j=3,right[‘N’] = 0,skip=3<br>第三种情况，至少保证i不能回退<br><img src="/images/boyer3.jpg" alt="boyer3.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        right[c] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target.length(); j++)</span><br><span class="line">            right[target.charAt(j)] = j;</span><br><span class="line">        <span class="keyword">int</span> m = target.length();</span><br><span class="line">        <span class="keyword">int</span> n = source.length();</span><br><span class="line">        <span class="keyword">int</span> skip;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i += skip) &#123;</span><br><span class="line">            skip = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target.charAt(j) != source.charAt(i+j)) &#123;</span><br><span class="line">                    skip = Math.max(<span class="number">1</span>, j - right[source.charAt(i+j)]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RabinKarp-31-8ms-线性"><a href="#RabinKarp-31-8ms-线性" class="headerlink" title="RabinKarp 31% 8ms 线性"></a>RabinKarp 31% 8ms 线性</h4><p><img src="/images/rabin-karp.jpg" alt="rabin-karp"><br><img src="/images/ranbinmod.jpg" alt="ranbinmod.jpg"></p>
<p>正确性：<br><img src="/images/kbright.jpg" alt="kbright.jpg"><br>线性求mod<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    private long longRandomPrime()&#123;</span></span><br><span class="line"><span class="comment">//        BigInteger prime = BigInteger.probablePrime(31,new Random());</span></span><br><span class="line"><span class="comment">//        return prime.longValue();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">long</span> q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        h = (R * h + key.charAt(j)) % q;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//变成拉斯维加斯算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String source,String target, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;target.length() ; j++)</span><br><span class="line">        <span class="keyword">if</span> (target.charAt(j) != source.charAt(i + j))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">searchRabinKarp</span><span class="params">(String source,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> m = target.length();</span><br><span class="line">    <span class="keyword">int</span> n = source.length();</span><br><span class="line">    <span class="keyword">long</span> RM = <span class="number">1</span>;</span><br><span class="line">    q = <span class="number">1877124611</span>;<span class="comment">//保证不冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=m-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        RM = (R * RM) % q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> patHash = hash(target,m);</span><br><span class="line">    <span class="keyword">long</span> txtHash = hash(source, m);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//一开始就匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(source,target, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for hash match; if hash match, check for exact match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// Remove leading digit, add trailing digit, check for match.</span></span><br><span class="line">        txtHash = (txtHash + q - RM*source.charAt(i-m) % q) % q;</span><br><span class="line">        txtHash = (txtHash*R + source.charAt(i)) % q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match</span></span><br><span class="line">        <span class="keyword">int</span> offset = i - m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(source, target,offset))</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no match</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="187-rolling-hash-DNA序列中出现2次以上长为10的子串"><a href="#187-rolling-hash-DNA序列中出现2次以上长为10的子串" class="headerlink" title="187 rolling-hash DNA序列中出现2次以上长为10的子串"></a>187 rolling-hash DNA序列中出现2次以上长为10的子串</h4><p>//todo</p>
<h4 id="暴力-O（MN）"><a href="#暴力-O（MN）" class="headerlink" title="暴力 O（MN）"></a>暴力 O（MN）</h4><p>双指针<br>i的位置是txt已匹配过的最后位置<br>15% 13ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(source==<span class="keyword">null</span>||source.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,N = source.length();</span><br><span class="line">    <span class="keyword">int</span> j,M = target.length();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,j=<span class="number">0</span>; i &lt;N&amp;&amp;j&lt;M ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(source.charAt(i)==target.charAt(j))j++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i-=j;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M)<span class="keyword">return</span> i-M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按indexOf简化 43% 7ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lens = source.length();</span><br><span class="line">    <span class="keyword">int</span> tar = target.length();</span><br><span class="line">    <span class="keyword">char</span>[] targetArr = target.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] sourceArr = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> first = targetArr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = lens-tar;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i]!=first)&#123;</span><br><span class="line">            <span class="keyword">while</span> (++i&lt;=max&amp;&amp;sourceArr[i]!=first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=max)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j+tar-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt;end&amp;&amp;sourceArr[j]==targetArr[k] ; k++,j++) ;</span><br><span class="line">            <span class="keyword">if</span>(j == end)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>java <code>indexOf</code>实现</p>
<ul>
<li>最长公共前缀：indexOf<br>73% 5ms<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> indexOf( source.toCharArray(),<span class="number">0</span>,source.length(),target.toCharArray(),<span class="number">0</span>,target.length(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param source:左值（被查找）</span></span><br><span class="line"><span class="comment">@param count长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找位置&gt;=左值长度</span></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">            <span class="comment">//traget空？返回左值长度</span></span><br><span class="line">            <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fromIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右值为0，返回查找位置</span></span><br><span class="line">        <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">        <span class="comment">//最后一个匹配的下标，至少减去右值的长度</span></span><br><span class="line">        <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="comment">/* Look for first character. */</span></span><br><span class="line">            <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">                <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                        == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                    <span class="comment">/* Found whole string. */</span></span><br><span class="line">                    <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍"><a href="#KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍" class="headerlink" title="KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍"></a>KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍</h3><p>基于DFA<br><img src="/images/DFA.jpg" alt="DFA.jpg"><br>用一个dfa[][]记录j回退多远<br>1对target构建dfa<br>构造DFA的时间是O（MR）的，可以对每个状态设置一个匹配/非匹配去掉R<br>9ms 24%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serachByKMP</span><span class="params">(String source,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> M = target.length();</span><br><span class="line">    <span class="keyword">int</span> N = source.length();</span><br><span class="line">    <span class="keyword">int</span>[] dfa = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    dfa[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//For the pattern “AAACAAAAAC”,</span></span><br><span class="line">    <span class="comment">//lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span>&amp;&amp;target.charAt(k)!=target.charAt(i))</span><br><span class="line">            k = dfa[k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target.charAt(k)==target.charAt(i))&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfa[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//[0, 0, 0, 1, 0]</span></span><br><span class="line">    <span class="comment">//"mississippi", </span></span><br><span class="line">    <span class="comment">// "issip"     q=4 i=5 dfa[3]=1</span></span><br><span class="line">    <span class="comment">// "issip"     q=1 i=5</span></span><br><span class="line">    <span class="comment">//    "issip" </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">0</span>&amp;&amp;target.charAt(q)!=source.charAt(i))</span><br><span class="line">            q = dfa[q-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target.charAt(q)==source.charAt(i))</span><br><span class="line">            q++;</span><br><span class="line">        <span class="keyword">if</span>(q==M)</span><br><span class="line">            <span class="keyword">return</span> i-M+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/dfaconstruction.jpg" alt="dfaconstruction.jpg"><br><img src="/images/KMPDFA.jpg" alt="KMPDFA.jpg"><br>2.对source遍历一遍dfa<br>12.44% 39ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> M = target.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">    <span class="comment">//构建DFA</span></span><br><span class="line">    dfa[target.charAt(<span class="number">0</span>)][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> X = <span class="number">0</span>,j=<span class="number">1</span>;j&lt;M;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">            dfa[c][j] = dfa[c][X];<span class="comment">//复制上一列匹配失败</span></span><br><span class="line">        dfa[target.charAt(j)][j] = j+<span class="number">1</span>;<span class="comment">//更新匹配成功</span></span><br><span class="line">        X = dfa[target.charAt(j)][X];<span class="comment">//重启状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟一遍DFA</span></span><br><span class="line">    <span class="keyword">int</span> i,j,N = source.length();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,j=<span class="number">0</span>; i  &lt; N&amp;&amp;j&lt; M; i++) &#123;</span><br><span class="line">        j = dfa[source.charAt(i)][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M) <span class="keyword">return</span> i-M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。<br>1 子序列 不连续 2 字串 连续<br>KMP:getIndexOf<br>d之前【最长前缀】和【最长后缀】的匹配长度<br>(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)<br>所以最长匹配是3：abc,记录在d位置上<br>int[]next =  f(“abcabcd”)={-1,0,0,1，2，3}<br>关键加速求解匹配</p>
<h3 id="3-最长不重复字串"><a href="#3-最长不重复字串" class="headerlink" title="3 最长不重复字串"></a>3 最长不重复字串</h3><p>18%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LS</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">            start = Math.max(start,map.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max,i-start+<span class="number">1</span>);</span><br><span class="line">        map.put(c,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="879"><a href="#879" class="headerlink" title="879"></a>879</h3><p>G 名成员 第i种犯罪会产生<code>profit[i]</code> 利润，需要<code>group[i]</code>名成员参与。计划产生P利润有多少种方案。</p>
<blockquote>
<p>Input: G = 5, P = 3, group = [2,2], profit = [2,3]<br>output: 2</p>
</blockquote>
<p><code>dp[k][i][j]</code> 产生i利润 用j个人 完成前k个任务 的方案数</p>
<h3 id="576-无向图访问所有点的最短边数"><a href="#576-无向图访问所有点的最短边数" class="headerlink" title="576 无向图访问所有点的最短边数"></a>576 无向图访问所有点的最短边数</h3><h3 id="fraction-背包问题"><a href="#fraction-背包问题" class="headerlink" title="fraction 背包问题"></a>fraction 背包问题</h3><p>Items can be broen down 贪心按value/weight排序<br><img src="/images/knapsack.jpg" alt="knapsack.jpg"></p>
<h3 id="顶点覆盖"><a href="#顶点覆盖" class="headerlink" title="顶点覆盖"></a>顶点覆盖</h3><p><img src="/images/pointcover.jpg" alt="pointcover.jpg"><br><img src="/images/vetexcover.jpg" alt="vetexcover.jpg"></p>
<h3 id="最大团：在一个无向图中找出一个点数最多的完全图"><a href="#最大团：在一个无向图中找出一个点数最多的完全图" class="headerlink" title="最大团：在一个无向图中找出一个点数最多的完全图"></a>最大团：在一个无向图中找出一个点数最多的完全图</h3><h3 id="任务分配问题一般可以在多项式时间内转化成最大流量问题"><a href="#任务分配问题一般可以在多项式时间内转化成最大流量问题" class="headerlink" title="任务分配问题一般可以在多项式时间内转化成最大流量问题"></a>任务分配问题一般可以在多项式时间内转化成最大流量问题</h3><h3 id="hdu-1813-IDA搜索Iterative-Deepening-A"><a href="#hdu-1813-IDA搜索Iterative-Deepening-A" class="headerlink" title="hdu 1813 IDA搜索Iterative Deepening A,"></a>hdu 1813 IDA<em>搜索Iterative Deepening A</em>,</h3><h3 id="tsp"><a href="#tsp" class="headerlink" title="tsp"></a>tsp</h3><p>最小生成树解TSP<br><img src="/images/MSTTSP.jpg" alt="MSTTSP.jpg"><br>这样求得的最优解不超过真正最优解的2倍<br>证明：2-近似算法<br>任何一个哈密顿回路OPT删去一条边就是一个生成树。<br>我们找的是最小生成树T肯定小于哈密顿回路减1条边的生成树长度<br>所以T&lt;OPT<br>所以欧拉回路&lt;2OPT<br>因为抄近路不会增加长度所以MST生成的结果不会超过2OPT</p>
<p>最小权匹配算法MM<br><img src="/images/MMTSP.jpg" alt="MMTSP.jpg"><br>1.奇数度的顶点一定是偶数个，将偶数个奇数度定点两两配对<br>2.将每个匹配加入最小生成树，每个顶点都变成偶数度，得到欧拉图<br>3.沿着欧拉回路跳过走过的点抄近路 得到哈密顿回路<br>证明：不超过最优解的1.5倍</p>
<p>代价函数：<br>在搜索树结点计算的最大化问题以该节点为根的值（可行解/目标函数）的上界。<br>父节点不小于子节点（最大化问题）</p>
<p>界：到达叶节点得到的最优值<br><img src="/images/pagbb.jpg" alt="pagbb.jpg"><br><img src="/images/bbtsp.jpg" alt="bbtsp.jpg"></p>
<p>optaPlanner<br><img src="/images/optaplanner.jpg" alt="optaplanner.jpg"></p>
<ol>
<li>数学公式定义</li>
<li>随机算法模板<br>2.1 迭代局部搜索</li>
</ol>
<p>tsp数据集<br><a href="https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/" target="_blank" rel="noopener">https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/</a></p>
<p><a href="https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournament" target="_blank" rel="noopener">https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournament</a><br>TSPP:tsp with profit（在顶点上）分3种</p>
<ol>
<li>PTP(profitable tour problem)找到最小 cost-profit 的circuit</li>
<li>OP(orienteering problem),也叫selective TSP(STSP)。cost是约束，求不超过cost的最大profit</li>
<li>PCTSP（prize-collecting)profit是约束，目的是找到不低于profit的最小cost。</li>
</ol>
<p>数据：<br>遗传算法：<br>最大效益中國郵差問題</p>
<p>time window on vertex OP </p>
<p> VRP</p>
<p>0~3的tspdp解法<br><img src="/images/tspdp.jpg" alt="tspdp.jpg"></p>
<h3 id="17-九宫格输入法数字对应的字符串"><a href="#17-九宫格输入法数字对应的字符串" class="headerlink" title="17 九宫格输入法数字对应的字符串"></a>17 九宫格输入法数字对应的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] letters = &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;String&gt; rst,<span class="keyword">int</span> idx,String digits,String cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.length()==digits.length())&#123;</span><br><span class="line">        rst.add(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(digits.charAt(idx)&gt;=<span class="string">'2'</span>&amp;&amp;digits.charAt(idx)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        String num2letter = letters[digits.charAt(idx)-<span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;num2letter.length();i++)&#123;</span><br><span class="line">            help(rst,idx+<span class="number">1</span>,digits,cur+num2letter.charAt(i));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="93-分解Ip地址"><a href="#93-分解Ip地址" class="headerlink" title="93 分解Ip地址"></a>93 分解Ip地址</h3><p>dfs<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; rst,String s,<span class="keyword">int</span> idx,String cur,<span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">4</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">4</span>&amp;&amp;idx==s.length())&#123;</span><br><span class="line">        rst.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx+i&gt;s.length())<span class="keyword">break</span>;</span><br><span class="line">        String tmp = s.substring(idx,idx+i);</span><br><span class="line">        <span class="keyword">if</span>((tmp.startsWith(<span class="string">"0"</span>)&amp;&amp;tmp.length()&gt;<span class="number">1</span>)||(i==<span class="number">3</span>&amp;&amp;Integer.parseInt(tmp)&gt;=<span class="number">256</span>))<span class="keyword">continue</span>;</span><br><span class="line">        dfs(rst,s,idx+i,cur+tmp+(cnt==<span class="number">3</span>?<span class="string">""</span>:<span class="string">"."</span>),cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ip2cidr"><a href="#ip2cidr" class="headerlink" title="ip2cidr"></a>ip2cidr</h3><p>找末尾1的位置<code>x &amp; -x</code></p>
<h3 id="131"><a href="#131" class="headerlink" title="131"></a>131</h3><h3 id="54旋转矩阵"><a href="#54旋转矩阵" class="headerlink" title="54旋转矩阵"></a>54旋转矩阵</h3><p><img src="/images/rotate2d.jpg" alt="rotate2d.jpg"><br>top=0,bot=3,left=0,right = 3<br>n是矩阵大小n&gt;1的时候继续，每一圈，矩阵大小-=2<br>将2赋值给8：<br>[top+i][right]=[top][left+i]<br>i=3:3赋值给12<br>每个i要赋值4遍，上下左右<br>外层完了之后子问题是top++,left++,right–,bot–,n-=2</p>
<p>方法2：翻转？</p>
<h3 id="59-生成nxn的旋转矩阵"><a href="#59-生成nxn的旋转矩阵" class="headerlink" title="59 生成nxn的旋转矩阵"></a>59 生成nxn的旋转矩阵</h3><h3 id="49"><a href="#49" class="headerlink" title="49"></a>49</h3><p>直接拿CharArray的sort重建String当key 49%</p>
<h3 id="435-去掉最少区间使区间不重叠"><a href="#435-去掉最少区间使区间不重叠" class="headerlink" title="435 去掉最少区间使区间不重叠"></a>435 去掉最少区间使区间不重叠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals,(a,b)-&gt;&#123;a.end!=b.end?(a.end-b.end):(a.start-b.start)&#125;);</span><br></pre></td></tr></table></figure>
<p>性能很慢44ms<br>换 提升到2ms 打败了100%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;Inteval&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval a,Interval b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.start==b.start)<span class="keyword">return</span> a.end-b.end;</span><br><span class="line">        <span class="keyword">return</span> a.start-b.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>算法：按start排序，如果重叠了，end更新成min(end1,end2)</code></p>
<h3 id="697-保留数组中最高频出现数字频数的最短数组长度"><a href="#697-保留数组中最高频出现数字频数的最短数组长度" class="headerlink" title="697 保留数组中最高频出现数字频数的最短数组长度"></a>697 保留数组中最高频出现数字频数的最短数组长度</h3><blockquote>
<p>Input: [1,2,2,3,1,4,2]<br>最小连续子数组，使得子数组的度与原数组的度相同。返回子数组的长度<br>Output: 6 最高频是2-&gt;【2,2,3,1,4,2】<br>用3个hashmap扫一遍记录每个数字出现的cnt,left,right<br>最后cnt最大的right-left+1<br>合并成一个hashmap&lt;Integer,int[3]&gt;</p>
</blockquote>
<h3 id="819-找出句子中出现频率最高没被ban掉的词"><a href="#819-找出句子中出现频率最高没被ban掉的词" class="headerlink" title="819 找出句子中出现频率最高没被ban掉的词"></a>819 找出句子中出现频率最高没被ban掉的词</h3><p>正则去掉所有标点</p>
<blockquote>
<p>“Bob hit a ball, the hit BALL flew far after it was hit.”</p>
</blockquote>
<p>pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。<br>其他六个是<br>L：字母；<br>M：标记符号（一般不会单独出现）；<br>Z：分隔符（比如空格、换行等）；<br>S：符号（比如数学符号、货币符号等）；<br>N：数字（比如阿拉伯数字、罗马数字等）；<br>C：其他字符<br>P：各种标点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//busymannote</span></span><br><span class="line"><span class="comment">// [Bob, hit, a, ball, the, hit, BALL, flew, far, after, it, was, hit]</span></span><br><span class="line">paragraph.split(<span class="string">"\\PL+"</span>);</span><br><span class="line"><span class="comment">// Bob hit a ball the hit BALL flew far after it was hit</span></span><br><span class="line">paragraph.replaceAll(<span class="string">"\\pP"</span>,<span class="string">""</span>);</span><br><span class="line">paragraph.replaceAll(<span class="string">"[^a-zA-Z ]"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> </span>&#123;</span><br><span class="line"> Set&lt;String&gt; ban = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(banned));</span><br><span class="line">    Map&lt;String,Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    String[] split = paragraph.toLowerCase().split(<span class="string">"\\PL+"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s:split)<span class="keyword">if</span>(!ban.contains(s))cnt.put(s,cnt.getOrDefault(s,<span class="number">0</span> )+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.max(cnt.entrySet(),Map.Entry.comparingByValue()).getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="亚线性算法o-n-小于输入规模"><a href="#亚线性算法o-n-小于输入规模" class="headerlink" title="亚线性算法o(n)小于输入规模"></a>亚线性算法o(n)小于输入规模</h3><p>亚线性时间：<br><a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E5%B0%BA%E5%BA%A6%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">scale-free network</a>S：<br>大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接。<br>网络中随机抽取一个节点，它的度是多少呢？这个概率分布就称为节点的度分布<br><img src="/images/scalenetwork.jpg" alt="scalenetwork.jpg"><br>顶点的度满足幂律分布（也称为帕累托分布）,所以不能均匀采样计算每个人的平均度数。</p>
<p>亚线性空间<br>中位数问题，知道所有的输入，有O(n)的分治算法</p>
<h3 id="水库抽样Reservpor-Sampling-亚线性空间"><a href="#水库抽样Reservpor-Sampling-亚线性空间" class="headerlink" title="水库抽样Reservpor Sampling 亚线性空间"></a>水库抽样Reservpor Sampling 亚线性空间</h3><blockquote>
<p>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</p>
</blockquote>
<p>当扫描到前n个数字时，保留数组中k个均匀的抽样<br>1.k大小的数组<br>2.填充k个元素<br>3.收到第i个元素t。以k/i的概率替换A中的元素。这样保证收到第i个数字的时候，i在k中的概率是k/i。<br>实现：生成<code>[1..k..i]</code>中随机数j，如果j&lt;=k（k/i的概率),A[j]=t<br>证明：第i个数接收时有k/i的概率在k数组中，当第i+1个数接收时,i+1有k/(i+1)概率在数组k中，并且刚好替换掉的是第i个数的概率是k中选i：1/k，所以第i+1个数来之后i还在k中的概率是（1-k/(i+1)*1/k)=（1-1/(1+i)）<br><img src="/images/shuku.jpg" alt="shuku.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] stream,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] reserve = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        reserve[i]=stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;k)reserve[j]=stream[i];</span><br><span class="line">    &#125;<span class="comment">//sout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="398-数组中重复元素随机返回index"><a href="#398-数组中重复元素随机返回index" class="headerlink" title="398 数组中重复元素随机返回index"></a>398 数组中重复元素随机返回index</h3><blockquote>
<p>int[] nums = new int[] {1,2,3,3,3};<br>Solution solution = new Solution(nums);</p>
</blockquote>
<blockquote>
<p>// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.<br>solution.pick(3);</p>
</blockquote>
<blockquote>
<p>// pick(1) should return 0. Since in the array only nums[0] is equal to 1.<br>solution.pick(1);</p>
</blockquote>
<p>水库抽样：流式处理，空间复杂度O(1),pick O(N)<br>如果用hashmap，初始化O(N)时间，O（N）空间，数组太大就不行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">this</span>.r = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rst =-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=target)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//以1/++cnt的概率抽这个数</span></span><br><span class="line">            <span class="comment">// int j = r.nextInt(++cnt);</span></span><br><span class="line">            <span class="comment">// if(j==0)rst=i;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//不赋值变量从180ms-&gt;127ms</span></span><br><span class="line">            <span class="keyword">if</span>(r.nextInt(++cnt)==<span class="number">0</span>)rst=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="？？382-随机链表-extremely-large-and-its-length-is-unknown"><a href="#？？382-随机链表-extremely-large-and-its-length-is-unknown" class="headerlink" title="？？382 随机链表 extremely large and its length is unknown"></a>？？382 随机链表 extremely large and its length is unknown</h3><p>长度不知，读到第三个node，让它的概率变成1/3，用1/3的概率替换掉之前选择的item</p>
<blockquote>
<p>由于计算机产生的随机数都是伪随机数，对于相同的随机数引擎会产生一个相同的随机数序列，因此，如果不使用静态变量（static），会出现每次调用包含随机数引擎的函数时，随机数会重新开始产生随机数，因此会产生相同的一串随机数。比如你第一次调用产生100个随机数，第二次调用仍然会产生这一百个随机数。如果将随机数引擎设置为静态变量，那么第一次调用会产生随机数序列中的前100个随机数，第二次调用则会产生第100到200的随机数。</p>
</blockquote>
<h3 id="频繁元素计算-Misra-Gries-MG-算法"><a href="#频繁元素计算-Misra-Gries-MG-算法" class="headerlink" title="频繁元素计算 Misra Gries(MG)算法"></a>频繁元素计算 Misra Gries(MG)算法</h3><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h3 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h3><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><h3 id="堆排序不稳定"><a href="#堆排序不稳定" class="headerlink" title="堆排序不稳定"></a>堆排序不稳定</h3><p><img src="/images/stringsort.jpg" alt="stringsort.jpg"><br>测试：6 5 12 至少都比内置的快<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String str=<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line">       String[] words2 = <span class="keyword">new</span> String[<span class="number">10000</span>];</span><br><span class="line">       Random random=<span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span>  j= <span class="number">0</span>; j &lt;words2.length ; j++) &#123;</span><br><span class="line">           StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">           <span class="keyword">int</span> length = random.nextInt(<span class="number">30</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">               <span class="keyword">int</span> number=random.nextInt(<span class="number">62</span>);</span><br><span class="line">               sb.append(str.charAt(number));</span><br><span class="line">           &#125;</span><br><span class="line">           words2[j] = sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">       String[] word3 = words2.clone();</span><br><span class="line">       String[] word4 = words2.clone();</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">       sort(words2, <span class="number">0</span>,words2.length-<span class="number">1</span> ,<span class="number">0</span> );</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end-start);</span><br><span class="line">       <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">       MSD.sort(word3);</span><br><span class="line">       <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end2-start2);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">       Arrays.sort(word4);</span><br><span class="line">       <span class="keyword">long</span> end3 = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end3-start3);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="三向快速排序-不稳定"><a href="#三向快速排序-不稳定" class="headerlink" title="三向快速排序 不稳定"></a>三向快速排序 不稳定</h3><p><img src="/images/threepart.jpg" alt="threepart.jpg"><br>取第一位，将所有字符串分成3份<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threewaypart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&gt;d)<span class="keyword">return</span> s.charAt(d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] a ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        String tmp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo,gt = hi;</span><br><span class="line">        <span class="keyword">int</span> v = charAt(a[lo],d);</span><br><span class="line">        <span class="keyword">int</span> i = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = charAt(a[i],d);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;v)swap(a,lt++,i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t&gt;v)swap(a,i,gt--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,lo,lt-<span class="number">1</span>,d);</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=<span class="number">0</span>)sort(a, lt, gt, d+<span class="number">1</span>);</span><br><span class="line">        sort(a,gt+<span class="number">1</span>,hi , d );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">"4PGC938"</span>,<span class="string">"2iye230"</span>,<span class="string">"2iye231"</span>,<span class="string">"3cio720"</span>,<span class="string">"fds"</span>,<span class="string">"1"</span>,<span class="string">"4PGC933"</span>,<span class="string">"4PGC9382"</span>,<span class="string">"4PGC9384"</span>,<span class="string">"4PGC9385"</span>,<span class="string">"4PGC9387"</span>,<span class="string">"4PGC9388"</span>,<span class="string">"4PGC9389"</span>&#125;;</span><br><span class="line">       sort(words,<span class="number">0</span> , words.length-<span class="number">1</span>,<span class="number">0</span> );</span><br><span class="line">        System.out.println(Arrays.toString(words));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="MSD-most-significant-digit-first-不用长度相同从左开始"><a href="#MSD-most-significant-digit-first-不用长度相同从左开始" class="headerlink" title="MSD most-significant-digit-first 不用长度相同从左开始"></a>MSD most-significant-digit-first 不用长度相同从左开始</h3><p>一般也是NW复杂度，对于N很大的情况可以达到$Nlog_RN$<br><img src="/images/MSD.jpg" alt="MSD"><br>ASCII的R是256，需要count[258]<br>Unicode需要65536，可能要几小时<br>按第0位分组，对每组递归按第1位分组…n<br><img src="/images/MSD2.jpg" alt="MSD2"><br>当前前d位都相同的组，组内字符串个数小于15，用插入排序<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] aux;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&gt;d)<span class="keyword">return</span> s.charAt(d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> String[a.length];</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(String v,String w,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt;Math.min(v.length(),w.length()) ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.charAt(i)&lt;w.charAt(i))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(v.charAt(i)&gt;w.charAt(i))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  v.length()&lt;w.length();</span><br><span class="line"><span class="comment">//        return v.substring(d).compareTo(w.substring(d))&lt;0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//添加一步阈值，如果a长度太小，直接用插入排序</span></span><br><span class="line">    <span class="keyword">if</span>(hi&lt;=lo+M)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;lo&amp;&amp;less(a[j],a[j-<span class="number">1</span>],d);j--) &#123;</span><br><span class="line">                String tmp = a[j];</span><br><span class="line">                a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0位留作字符串结尾？</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">2</span> ];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        count[charAt(a[i],d)+<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        aux[count[charAt(a[i],d)+<span class="number">1</span>]++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        a[i] =aux[i-lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R ; i++) &#123;</span><br><span class="line">        sort(a,lo+count[i],lo+count[i+<span class="number">1</span>]-<span class="number">1</span>,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] words = &#123;<span class="string">"4PGC938"</span>,<span class="string">"2iye230"</span>,<span class="string">"2iye231"</span>,<span class="string">"3cio720"</span>,<span class="string">"fds"</span>,<span class="string">"1"</span>,<span class="string">"4PGC933"</span>,<span class="string">"4PGC9382"</span>,<span class="string">"4PGC9384"</span>,<span class="string">"4PGC9385"</span>,<span class="string">"4PGC9387"</span>,<span class="string">"4PGC9388"</span>,<span class="string">"4PGC9389"</span>&#125;;</span><br><span class="line">    sort(words);</span><br><span class="line">    System.out.println(Arrays.toString(words));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先"><a href="#LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先" class="headerlink" title="LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先"></a>LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先</h3><p><img src="/images/LSD.jpg" alt="LSD"><br>长度相同的字符串，从最后一位开始排序<br>（如何应用到变长字符串？）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="comment">//只初始化一次</span></span><br><span class="line">    String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = w-<span class="number">1</span>; d &gt;=<span class="number">0</span> ; d--) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">            count[a[i].charAt(d)+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R ; i++) &#123;</span><br><span class="line">            count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">            aux[count[a[i].charAt(d)]++]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a[i]=aux[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="key-index-count-sort键索引计数法-稳定的"><a href="#key-index-count-sort键索引计数法-稳定的" class="headerlink" title="key-index count sort键索引计数法 稳定的"></a>key-index count sort键索引计数法 稳定的</h3><p><img src="/images/indexsort.jpg" alt="indexsort"><br>count:[0, 2, 3, 1, 2, 1, 3]<br>累加cnt[0, 2, 5, 6, 8, 9, 12] 起始索引<br>结果[a, a, b, b, b, c, d, d, e, f, f, f]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span>[] countt(String s)&#123;</span><br><span class="line">    <span class="keyword">int</span> N = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">        <span class="comment">//关键 +1</span></span><br><span class="line">        count[s.charAt(i)-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span>[] acu()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">char</span>[] axuu(String s)&#123;</span><br><span class="line">  <span class="keyword">char</span>[] axu = <span class="keyword">new</span>  <span class="keyword">char</span>[s.length()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//关键 ++</span></span><br><span class="line">        axu[count[s.charAt(i)-<span class="string">'a'</span>]++] = s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> axu;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(countt(<span class="string">"dacffbdbfbea"</span>)));</span><br><span class="line">System.out.println(Arrays.toString(acu()));</span><br><span class="line">String dacffbdbfbea = Arrays.toString(axuu(<span class="string">"dacffbdbfbea"</span>));</span><br></pre></td></tr></table></figure></p>
<h3 id="611数组中符合三角形边长的对数"><a href="#611数组中符合三角形边长的对数" class="headerlink" title="611数组中符合三角形边长的对数"></a>611数组中符合三角形边长的对数</h3><p>线性扫描 复杂度n^2<br><img src="/images/lc611.jpg" alt="lc611.jpg"></p>
<h3 id="数组组成三角形的最大周长nlogn"><a href="#数组组成三角形的最大周长nlogn" class="headerlink" title="数组组成三角形的最大周长nlogn"></a>数组组成三角形的最大周长nlogn</h3><p>贪心，排序，如果 $a[i]&lt;a[i-1]+a[i-2]$ 则没有其他两条边可以两边之和<code>&gt;</code>第三边了，换下一条当最长边。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxC</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">2</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i-<span class="number">1</span>]+A[i-<span class="number">2</span>])<span class="keyword">return</span> A[i]+A[i-<span class="number">1</span>]+A[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MST："><a href="#MST：" class="headerlink" title="MST："></a>MST：</h3><p>将图的点分成2个集合，用边连接两个集合中的点，最小的边集是MST</p>
<h3 id="MST和聚类："><a href="#MST和聚类：" class="headerlink" title="MST和聚类："></a>MST和聚类：</h3><p>连通图<br>将图的点分成2个集合，边两端连的是不同集合，最小的边集是MST<br><img src="/images/mst.jpg" alt="mst"><br>假设分为6和其它点2个集合，在6-2 3-6 6-0 6-4四条连接两个集合的边中取最小边，标记成黑色。<br>再随机分两个集合，不要让黑色边跨集合</p>
<h4 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h4><p>kruskal遍历所有边(优先队列)，判断边的两点是否在一个集合里(find)，如果在则说明这条边加上会有环，如果不在，则union(v,w)并且将这条边加入mst。直到找到n-1条边。<br>复杂度$ElogE$ 空间E</p>
<ul>
<li>因为不仅维护优先队列还要union-find所以效率一般比prim慢</li>
</ul>
<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><p>prim复杂度$ElogV$ 空间V<br>prim优化：将marked[]和emst[] 替换为两个顶点索引数组edgeTo[] 和distTo[]<br><img src="/images/prim.jpg" alt="prim.jpg"><br>每个没在MST中的顶点只保留(更新)离mst中点最短的边。</p>
<h3 id="聚类：single-link"><a href="#聚类：single-link" class="headerlink" title="聚类：single link"></a>聚类：single link</h3><p><img src="/images/singlelink.jpg" alt="singlelink.jpg"><br><img src="/images/singleclu.jpg" alt="singleclu.jpg"></p>
<h4 id="前序ABCDEFGH-gt-中序不可能是"><a href="#前序ABCDEFGH-gt-中序不可能是" class="headerlink" title="前序ABCDEFGH-&gt;中序不可能是"></a>前序ABCDEFGH-&gt;中序不可能是</h4><h3 id="145-后序遍历二叉树"><a href="#145-后序遍历二叉树" class="headerlink" title="145 后序遍历二叉树"></a>145 后序遍历二叉树</h3><p>1.函数式编程 不用help函数（可变数组），复制数组</p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">post</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> list;</span><br><span class="line">    List&lt;Integer&gt; left = post(root.left);</span><br><span class="line">    List&lt;Integer&gt; right = post(root.right);</span><br><span class="line">    list.addAll(left);</span><br><span class="line">    list.addAll(right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<p>原理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rev_post(root):</span><br><span class="line">    <span class="comment"># 全部反过来刚好是后序遍历</span></span><br><span class="line">    print(root-&gt;val);</span><br><span class="line">    rev_post(root-&gt;right)</span><br><span class="line">    rev_post(root-&gt;left)</span><br><span class="line">reverse(rev_post(root));</span><br></pre></td></tr></table></figure></p>
<p>方法1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> list;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        list.addFirst(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)stack.push(root.left);</span><br><span class="line">        <span class="comment">//下一次poll出的是右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)stack.push(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果使用ArrayList 1%</span></span><br><span class="line">    <span class="comment">//Collections.reverse(list);</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="753-输出能包含所有密码可能性的最短串"><a href="#753-输出能包含所有密码可能性的最短串" class="headerlink" title="753 输出能包含所有密码可能性的最短串"></a>753 输出能包含所有密码可能性的最短串</h3><blockquote>
<p>Input: n = 2, k = 2<br>Output: “00110” 包含了00,01,10,11</p>
</blockquote>
<p><a href="https://leetcode.com/problems/cracking-the-safe/solution/" target="_blank" rel="noopener">官方解</a><br><a href="https://www.youtube.com/watch?v=EWG6e-yBL94" target="_blank" rel="noopener">de Bruijn Card Trick</a></p>
<ol>
<li>方法1<br><img src="/images/lc753.jpg" alt="hamilton"><br>每个点1次<br>写出n个数的组合(11,12,22,21) 并找出哈密尔顿路径</li>
<li>方法2<br><img src="/images/lc7532.jpg" alt="euler"><br>每条边1次<br>写出(n-1)个数的组合(1,2) 的完全图，找出欧拉环路(circuit)。de Bruijn 序列的数量为欧拉环的数量。<br>用k个数字，长度有n的组合有$k^n$种，但是因为可以首尾相连，总共de Bruijn的数量是<br>$\frac{k! k^{n-1}}{k^n}$</li>
<li>方法3 用不重复的最小字典序Lyndon Word<br>例子：<br>1.列出所有长度为4的组合1111,1112…以及能被4整除的长度(1,2)的组合1,2,11,22.<br>2.所有按字典序排序<br>3.去除所有旋转之后相同的组合，只保留字典序最小的：01和10只保留01<blockquote>
<p>n = 6, k = 2<br>0 000001 000011 000101 000111 001 001011 001101 001111 01 010111 011 011111 1</p>
</blockquote>
</li>
<li>连起来就是最小的de Bruijin sequence</li>
</ol>
<h4 id="Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words"><a href="#Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words" class="headerlink" title="Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words."></a>Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.</h4><h3 id="332-欧拉路径-每条边一次"><a href="#332-欧拉路径-每条边一次" class="headerlink" title="332 欧拉路径 每条边一次"></a>332 欧拉路径 每条边一次</h3><p>(这道题不用判断)<br>只有1个点入度比出度少1（起点）&amp;&amp; 只有一个点入度比出度多1（终点）其余点入度==出度</p>
<h4 id="Hierholzer：O-e"><a href="#Hierholzer：O-e" class="headerlink" title="Hierholzer：O(e)"></a>Hierholzer：O(e)</h4><p>删除边<code>e(u,v)</code>，并<code>dfs(v)</code>，不断寻找封闭回路，</p>
<blockquote>
<p>从v点出发一定会回到v。因为入度出度相等。虽然可能不包含所有点和边。<br>总是可以回到以前的点，从另一条路走，把其它所有的边全部遍历掉。</p>
</blockquote>
<p><strong>不是拓扑排序，拓扑排序每个点仅1次</strong><br><img src="/images/Hierholzer1.jpg" alt="Hierholzer"><br>path里加入{0},{2}头插法{2,0}//保证远的在后面<br>dfs回到1，继续找封闭回路<br><img src="/images/Hierholzer2.jpg" alt="Hierholzer"></p>
<blockquote>
<p>Input: tickets = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code></p>
</blockquote>
<ol>
<li>用hashmap记录每个点的出度的点，建图</li>
<li>输出字典序靠前的序列，用优先队列，先访问的会后回溯到dfs插到链表头。（后序遍历：全部遍历完了再加入（退栈)）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; rst = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Map&lt;String,PriorityQueue&lt;String&gt; &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String[] edge:tickets)&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; nei = map.getOrDefault(edge[<span class="number">0</span>],<span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">        nei.add(edge[<span class="number">1</span>]);</span><br><span class="line">        map.put(edge[<span class="number">0</span>],nei);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rst,map,<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedList&lt;String&gt; rst,Map&lt;String,PriorityQueue&lt;String&gt; &gt; map,String start)</span></span>&#123;</span><br><span class="line">  PriorityQueue&lt;String&gt; pri = map.get(start);</span><br><span class="line">    <span class="keyword">while</span>(pri!=<span class="keyword">null</span>&amp;&amp;!pri.isEmpty())</span><br><span class="line">        dfs(rst,map,pri.poll());</span><br><span class="line">    rst.addFirst(start);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历stack：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="两个帅不能处在同一条直线上的所有可行位置"><a href="#两个帅不能处在同一条直线上的所有可行位置" class="headerlink" title="两个帅不能处在同一条直线上的所有可行位置"></a>两个帅不能处在同一条直线上的所有可行位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">81</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i/<span class="number">9</span>%<span class="number">3</span>==i%<span class="number">9</span>%<span class="number">3</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i/<span class="number">9</span>+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;i%<span class="number">9</span>+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻煎饼排序的最少次数"><a href="#翻煎饼排序的最少次数" class="headerlink" title="翻煎饼排序的最少次数"></a>翻煎饼排序的最少次数</h3><h3 id="279完美平方数？？？"><a href="#279完美平方数？？？" class="headerlink" title="279完美平方数？？？"></a>279完美平方数？？？</h3><h3 id="198"><a href="#198" class="headerlink" title="198"></a>198</h3><h3 id="164-桶排序找区间最大值"><a href="#164-桶排序找区间最大值" class="headerlink" title="164 桶排序找区间最大值"></a>164 桶排序找区间最大值</h3><h3 id="求数组的最大gap"><a href="#求数组的最大gap" class="headerlink" title="求数组的最大gap"></a>求数组的最大gap</h3><h3 id="二分图-让每条边的两个顶点属于不同的集合"><a href="#二分图-让每条边的两个顶点属于不同的集合" class="headerlink" title="二分图 让每条边的两个顶点属于不同的集合"></a>二分图 让每条边的两个顶点属于不同的集合</h3><p><img src="/images/bipartite.jpg" alt="bipartite.jpg"><br>max match：没有两点共享1点，最多的边数<br><img src="/images/matching.jpg" alt="matching"><br>maximal:再加一条边就有两条边有共同顶点了<br>maximum：有两种matching的画法，3条边的为max</p>
<ol>
<li>室友分配问题不是二分图，因为有3人团，是最大团问题</li>
<li>出租车和乘客匹配问题 问题是求最小边和</li>
<li>分配老师给班级是二分图max match问题</li>
</ol>
<h4 id="785-是否是二分图"><a href="#785-是否是二分图" class="headerlink" title="785 是否是二分图"></a>785 是否是二分图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入[0]=&#123;1,3&#125;0的邻点是1,3</span><br><span class="line">[[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br></pre></td></tr></table></figure>
<p>不用建图，已经是邻接表了。<br>按算法4上75%<br>还可以优化mark和color为一个数组，用位运算变更状态，变成boolean的dfs<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">boolean</span>[] color;</span><br><span class="line"><span class="keyword">boolean</span> isTwo = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBiartie</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    color = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s =<span class="number">0</span>;s&lt;graph.length;s++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[s])dfs(graph,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isTwo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :G[v])&#123;</span><br><span class="line">        color[w]=!color[v];</span><br><span class="line">        dfs(G,w);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])isTwo=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成boolean的dfs-&gt;100%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">boolean</span>[] color;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    color = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;graph.length ; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[s]&amp;&amp;!dfs(graph,s))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w:graph[v])&#123;</span><br><span class="line">        <span class="comment">//*关键</span></span><br><span class="line">        <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">        color[w]=!color[v];</span><br><span class="line">        <span class="keyword">if</span>(!dfs(graph,w))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人"><a href="#886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人" class="headerlink" title="886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人"></a>886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人</h4><p>边集-&gt;邻接表-&gt;二分图</p>
<p>边集-&gt;邻接矩阵-&gt;二分图dfs染色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBiparitition</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span>[][] dislikes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="comment">//边集-&gt;无向图 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dislikes)&#123;</span><br><span class="line">        graph[d[<span class="number">0</span>]-<span class="number">1</span>][d[<span class="number">1</span>]-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        graph[d[<span class="number">1</span>]-<span class="number">1</span>][d[<span class="number">0</span>]-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(group[i] == <span class="number">0</span>&amp;&amp; !dfs2d(graph,group,i,<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可不可以分到g组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs2d</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span>[] group,<span class="keyword">int</span> idx,<span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    group[idx] = g;</span><br><span class="line">    <span class="comment">//行是邻边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[idx][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == g)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">0</span>&amp;&amp;!dfs2d(graph,group,i,-g))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="494-在数字中间放正负号使之-target"><a href="#494-在数字中间放正负号使之-target" class="headerlink" title="494 在数字中间放正负号使之==target"></a>494 在数字中间放正负号使之==target</h3><p>递归的2种写法另一种void用全局变量累加<br>？？为什么递归中不能写<code>dfs(idx++)</code><br>O(2^n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> S,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt =dfs(nums, S+nums[pos], pos+<span class="number">1</span>)+dfs(nums, S-nums[pos], pos+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>53%<br>优化记忆化：用当前的idx和当前的S当key 注意如果用<code>String key=idx+&quot;&quot;+S</code>有一个case会报错，应该是数字大的时候混淆了。<br>sum不会超过1000所以<code>Integer key = idx*10000+S</code>就可以通过。</p>
<p>dp??：<br>所有可能的target最大值是全部正号sum(a),或者全部负号）dp[2*sum(a)+1]<br>题目sum最大2k，则dp[4001]</p>
<h3 id="图的度"><a href="#图的度" class="headerlink" title="图的度"></a>图的度</h3><p><img src="/images/graphmostuse.jpg" alt="graphmostuse"><br>1.顶点v的度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(Map&lt;Integer,List&lt;Integer&gt;&gt; graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :graph.get(v))&#123;</span><br><span class="line">        degree++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> degree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.所有顶点的最大度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDegree</span><span class="params">(Map&lt;Integer,List&lt;Integer&gt;&gt; graph)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:graph.keySet())&#123;</span><br><span class="line">        max = Math.max(degree(graph,v ),max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.</p>
<h3 id="图的遍历顺序"><a href="#图的遍历顺序" class="headerlink" title="图的遍历顺序"></a>图的遍历顺序</h3><p><img src="/images/graphtra.jpg" alt="graphtra"><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pre;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; post;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge:edges)&#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        post = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        reversePost = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">( List&lt;Integer&gt;[] graph ,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        pre.add(v);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w :graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])</span><br><span class="line">                dfs(graph,w);</span><br><span class="line">        &#125;</span><br><span class="line">        post.add(v);</span><br><span class="line">        reversePost.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 5, 4, 6, 9, 10, 11, 12, 2, 3, 7, 8]</span></span><br><span class="line"><span class="comment">[1, 4, 5, 10, 12, 11, 9, 6, 0, 3, 2, 7, 8]</span></span><br><span class="line"><span class="comment">[8, 7, 2, 3, 0, 6, 9, 11, 12, 10, 5, 4, 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DepthFirstOrder sl = <span class="keyword">new</span> DepthFirstOrder(<span class="number">13</span>,<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">5</span>&#125;,&#123;<span class="number">0</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,<span class="number">6</span>&#125;,&#123;<span class="number">8</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">9</span>,<span class="number">12</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>&#125;&#125;);</span><br><span class="line">        System.out.println(sl.pre);</span><br><span class="line">        System.out.println(sl.post);</span><br><span class="line">        System.out.println(sl.reversePost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="调度问题：给定一组任务，安排执行时间-gt-拓扑排序"><a href="#调度问题：给定一组任务，安排执行时间-gt-拓扑排序" class="headerlink" title="调度问题：给定一组任务，安排执行时间-&gt;拓扑排序"></a>调度问题：给定一组任务，安排执行时间-&gt;拓扑排序</h3><p><strong>DAG的拓扑排序是dfs逆后排序</strong><br>将一张图拉成边全部向下的图<br><img src="/images/tuopu.jpg" alt="tuopu"></p>
<h4 id="拓扑排序：有向环"><a href="#拓扑排序：有向环" class="headerlink" title="拓扑排序：有向环"></a>拓扑排序：有向环</h4><blockquote>
<p>{0, 3}, {1, 3}, {3, 2}, {2, 1} 0-&gt; 3-&gt;2-&gt;1-&gt;3<br><img src="/images/graphcy.jpg" alt="graphcy"></p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法4 p386</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"><span class="keyword">private</span> Deque&lt;Integer&gt; cycle;<span class="comment">//环</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Deque <span class="title">cycle</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    marked =<span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    List&lt;Integer&gt;[] graph=<span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;numCourses ; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge :prerequisites) &#123;</span><br><span class="line">        graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(graph));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    onStack[v] =<span class="keyword">true</span>;</span><br><span class="line">    marked[v] =<span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span>(graph[v].size()&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w:graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(cycle!=<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">            edgeTo[w] = v;</span><br><span class="line">            dfs(graph,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">            cycle = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x !=w ; x=edgeTo[x]) &#123;</span><br><span class="line">                cycle.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            cycle.push(w);</span><br><span class="line">            cycle.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[v] =<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="207-先修课程有环则返回false-拓扑排序"><a href="#207-先修课程有环则返回false-拓扑排序" class="headerlink" title="?207 先修课程有环则返回false 拓扑排序"></a>?207 先修课程有环则返回false 拓扑排序</h4><p>??和并查集的区别（？<br>按算法4上88.45%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cycle = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    marked =<span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    List&lt;Integer&gt;[] graph=<span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;numCourses ; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;2,0&#125;,&#123;1,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;,&#123;1,3&#125;&#125;-&gt;[[], [0, 3], [0], [1, 2]]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge :prerequisites) &#123;</span><br><span class="line">        graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(graph[v].size()&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//dfs是从起点到v的有向路径，onstack保存了递归中经历的点</span></span><br><span class="line">    onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[w])</span><br><span class="line">        dfs(graph,w);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">            cycle = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个点出发没有环</span></span><br><span class="line">    onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>56% 有可以优化到100%4ms的方法<br>1.邻接表存储课程依赖图L<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List[] graph_;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span></span><br><span class="line"><span class="function">    graph_ </span>= <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">    &#123;graph_[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] back:prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = back[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lesson = back[<span class="number">1</span>];</span><br><span class="line">        graph_[lesson].add(pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.定义状态<code>int[] visit = new int[numCourses];</code><br>3.dfs每个顶点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hasCircle(i,visit))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>4.dfs 检查有没有环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[idx]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(visited[idx]==<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    List&lt;Integer&gt; neib = graph_[idx];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:neib)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCircle(i,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[idx]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="210-输出修课顺序"><a href="#210-输出修课顺序" class="headerlink" title="210 输出修课顺序"></a>210 输出修课顺序</h4><blockquote>
<p>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>  Output: [0,1,2,3] or [0,2,1,3]</p>
</blockquote>
<p>用onStack和post 11%</p>
<h3 id="kolakoski序列找规律"><a href="#kolakoski序列找规律" class="headerlink" title="kolakoski序列找规律"></a>kolakoski序列找规律</h3><p><img src="/images/kolakoski.jpg" alt="kolakoski"></p>
<h4 id="lc481-返回kolakoski前N中有几个1"><a href="#lc481-返回kolakoski前N中有几个1" class="headerlink" title="lc481 返回kolakoski前N中有几个1"></a>lc481 返回kolakoski前N中有几个1</h4><h3 id="174-骑士从左上到右下找公主，求初始血量"><a href="#174-骑士从左上到右下找公主，求初始血量" class="headerlink" title="174 骑士从左上到右下找公主，求初始血量"></a>174 骑士从左上到右下找公主，求初始血量</h3><p>dp[i][j]表示到i,j的最少血量，因为右下角一格也要减<br>dp[n-1][m],dp[n][m-1]=1表示走完了右下角还剩下1点血<br>dp[0~n-2][m]和dp[n][0~m-2]都是非法值，为了取min设置MAX_VALUE<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])-dungeon[i][j]);</span><br></pre></td></tr></table></figure></p>
<h3 id="671-根的值-lt-子树的值的二叉树中的第二小元素"><a href="#671-根的值-lt-子树的值的二叉树中的第二小元素" class="headerlink" title="671 根的值&lt;=子树的值的二叉树中的第二小元素"></a>671 根的值&lt;=子树的值的二叉树中的第二小元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      2</span><br><span class="line">  2       5</span><br><span class="line">4   3(out)</span><br></pre></td></tr></table></figure>
<p>1.dfs在set中加入所有节点，遍历set<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = root.val;</span><br><span class="line"><span class="keyword">int</span> ans = Long.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:set)&#123;</span><br><span class="line">    <span class="keyword">if</span>(min&lt;v&amp;&amp;v&lt;ans)ans = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans&lt;Long.MAX_VALUE?(<span class="keyword">int</span>) ans:-<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>2.在dfs的时候只有node.val == root.val的时候表示这个分支需要继续遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">min = root.val;</span><br><span class="line"><span class="keyword">int</span> ans = Long.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">dfs</span><span class="params">(TreeNode rote)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min&lt;root.val&amp;&amp;root.val&lt;ans)</span><br><span class="line">            ans = root.val;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(min == root.val)&#123;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="伪多项式时间"><a href="#伪多项式时间" class="headerlink" title="伪多项式时间"></a>伪多项式时间</h3><p>一个整数是否是素数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n mod i</span><br></pre></td></tr></table></figure></p>
<p>运行时间与数值n的二进制位数呈指数增长<br>整数需要的bit位数x=logn 复杂度$O(2^{x})$<br>每加1位，时间翻倍<br>857 ：‭‭001101011001‬<br>421 ：‭‭000110100101‬</p>
<hr>
<h3 id="97-s1和s2是否交错组成s3"><a href="#97-s1和s2是否交错组成s3" class="headerlink" title="!!97 s1和s2是否交错组成s3"></a>!!97 s1和s2是否交错组成s3</h3><p><a href="https://leetcode.com/problems/interleaving-string/solution/" target="_blank" rel="noopener">Solution</a><br>状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中<br>任意位置s3[i]一定是由s1[m],s2[n]组成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1=&quot;aa  bc   c&quot;</span><br><span class="line">s2=&quot;  db  bca&quot;</span><br><span class="line">s3=&quot;aadbbcbcac&quot;</span><br></pre></td></tr></table></figure></p>
<p>dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况<br>dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遍历s3的位置：</span><br><span class="line">  遍历s1的长度，s3+1-s1为s2的长度</span><br><span class="line">    如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了</span><br><span class="line">       ||s3当前与s1当前匹配并且dp[s1-1][s2]:</span><br><span class="line">         dp[s1][s2] = true</span><br></pre></td></tr></table></figure></p>
<p>可以用滚动数组降成1维</p>
<p>？？？按背包问题递减更新 99%<br>ct的意义<br>动态规划中的ct<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ct = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(s1.length(), i + <span class="number">1</span>); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[j - <span class="number">1</span>] &amp;&amp; s1.charAt(j- <span class="number">1</span>) == s3.charAt(i))&#123;</span><br><span class="line">                dp[j] = <span class="keyword">true</span>;</span><br><span class="line">                ct = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> dp[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ct)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="62-从左上角走到右下角总共有多少种不同方式"><a href="#62-从左上角走到右下角总共有多少种不同方式" class="headerlink" title="62 从左上角走到右下角总共有多少种不同方式"></a>62 从左上角走到右下角总共有多少种不同方式</h3><p>f[m][n] = f[m-1][n]+f[m][n-1]<br>简化成一维dp<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniPath</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="comment">//一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//加上左边走过来的走法</span></span><br><span class="line">            res[j]+=res[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="!数学公式"></a>!数学公式</h4><p>m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。<br>问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。<br>$C_{m+n-2}^{m-1}$<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rst=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;Math.min(m-<span class="number">1</span>,n-<span class="number">1</span>);i++)&#123;</span><br><span class="line">    rst=rst*(m+n-<span class="number">2</span>-i)/(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)rst;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="63-有障碍物的左上到右下"><a href="#63-有障碍物的左上到右下" class="headerlink" title="63 有障碍物的左上到右下"></a>63 有障碍物的左上到右下</h3><p>dp[i][j]定义为走到i,j的方法数，障碍物则为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obs[i][j]==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//dp[i][j]=0//res[j]=0;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="64-从左上角走到右下角的最少sum"><a href="#64-从左上角走到右下角的最少sum" class="headerlink" title="64 从左上角走到右下角的最少sum"></a>64 从左上角走到右下角的最少sum</h3><p>grid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]);</p>
<hr>
<h3 id="32-括号字符串中合法的括号对"><a href="#32-括号字符串中合法的括号对" class="headerlink" title="32 ?括号字符串中合法的括号对"></a>32 ?括号字符串中合法的括号对</h3><p>方法1. stack:栈底放-1，当栈空&amp;&amp;读到是<code>)</code>将<code>)</code>的index当栈底。每次读到<code>)</code>弹栈，并更新<code>i-peek()</code>，因为peek为没消掉的<code>(</code>的前一个位置<br>方法22. 从左向右扫描，当左括号数==右括号数更新max，当右括号&gt;左括号置0.<br>  从右向左扫描，同理更新max，当左括号&gt;右括号重置0.</p>
<hr>
<h3 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h3><p>以1为首位的数字的概率为30%</p>
<h3 id="719"><a href="#719" class="headerlink" title="719"></a>719</h3><h3 id="169-众数-Boyer-Moore-Voting-Algorithm"><a href="#169-众数-Boyer-Moore-Voting-Algorithm" class="headerlink" title="!!!169 众数 Boyer-Moore Voting Algorithm"></a>!!!169 众数 Boyer-Moore Voting Algorithm</h3><p>1.hashmap,直到有计数&gt;n/2 break-&gt;return 11%<br>2.随机数44% 因为一半以上都是这个数，可能只要循环两边就找到了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = random.nextInt(nums.length);</span><br><span class="line">        <span class="keyword">int</span> choose = nums[idx];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==cur&amp;&amp;++cnt&gt;nums.length/<span class="number">2</span>)<span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.39% 计算用每个数字的每一位投票，1的个数&gt;n/2则为1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> rst =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        mask = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num&amp;mask)!=<span class="number">0</span>)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;n/<span class="number">2</span>)rst|=mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-moore-voting-在线算法92"><a href="#4-moore-voting-在线算法92" class="headerlink" title="4.moore voting 在线算法92%"></a>4.moore voting 在线算法92%</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设就是第一个数</span></span><br><span class="line">    <span class="keyword">int</span> maj = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="comment">//第一个数就cnt=1</span></span><br><span class="line">        <span class="keyword">if</span>(num==maj)cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(--cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等于0 从头开始做</span></span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">            maj = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化100%</strong><br>每次取两个不同的数删除，最后剩下的返回<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                res=e;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(res!=e)&#123;</span><br><span class="line">                    count--;<span class="comment">//删除这个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>5.排序取中间的数<br>6.C++专有 部分排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">    nth_element(nums.begin(),nums.begin()+nums.size()/<span class="number">2</span>,nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.分治???</p>
<hr>
<h3 id="节点是随机变量的有向无环图-贝叶斯网络BN"><a href="#节点是随机变量的有向无环图-贝叶斯网络BN" class="headerlink" title="节点是随机变量的有向无环图=贝叶斯网络BN"></a>节点是随机变量的有向无环图=贝叶斯网络BN</h3><p>求联合概率会用到最小生成树</p>
<ol>
<li>如果$84*148=B6A8$成立，则公式采用的是__进制表示的<br>$(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8$<br>$=&gt;(3x^2+6x+2)(x-12)=0$<br>$=&gt;x=12$</li>
</ol>
<ul>
<li>快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数<br>24表示在这种进制下个位应该为0</li>
</ul>
<p>逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A</p>
<p>树的前/中/后序遍历本质都是DFS</p>
<hr>
<h3 id="402-去掉数字串中k个数字留下最小的数字"><a href="#402-去掉数字串中k个数字留下最小的数字" class="headerlink" title="402 去掉数字串中k个数字留下最小的数字"></a>402 去掉数字串中k个数字留下最小的数字</h3><p>Input: num = “1432219”, k = 3<br>Output: “1219”<br>找最小数字：从高位，越高位越小的数。<br>算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉<br>用栈，下一个位置比栈顶小，则把栈顶换掉。<br>注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="string">"1234567890"</span>;</span><br><span class="line">k=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="comment">// len=10,k=9  但是0比所有前9个都小，则</span></span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">0</span>&amp;&amp;num.charAt(i)&lt;stack[top-<span class="number">1</span>]&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    top--;</span><br><span class="line">    k--;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0覆盖掉1 之后截取stack中len-k=1长度并且去掉0</span></span><br><span class="line">    stack[top++]=num.charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="236-最低的二叉树公共祖先LCA"><a href="#236-最低的二叉树公共祖先LCA" class="headerlink" title="236 最低的二叉树公共祖先LCA"></a>236 最低的二叉树公共祖先LCA</h3><p>方法1：找出两条从root开始的路径，返回路径不开始不相同的前一个点<br>27%空间两个array<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; pathp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; pathq = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// if(!findPath(root,p,pathp)||!findPath(root,p,pathp))return </span></span><br><span class="line">    findPath(root,p,pathp);</span><br><span class="line">    findPath(root,q,pathq);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;Math.min(pathp.size(),pathq.size());i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathp.get(i).val!=pathq.get(i).val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathp.get(i-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findPath</span><span class="params">(TreeNode root,TreeNode node,List&lt;TreeNode&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    path.add(root);</span><br><span class="line">    <span class="keyword">if</span>(root.val == node.val)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;findPath(root.left,node,path))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp;findPath(root.right,node,path))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><br>方法二：只遍历一次树，这种方法如果其中一个q不在树中，会返会p,应该返回null<br>13%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val==p.val||root.val==q.val)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这道题两个点都保证存在，可以absent的</p>
<p>终止条件<code>root==null|root==q||root=p</code></p>
<ol>
<li>在左/右子树找p|q，两边都能找到一个值（因为值不重复） 则返回当前root</li>
<li>如果左边没找到p|q，右边找到了p|q，最低的祖先就是找到的p|q，(因为保证p|q一定在树中)</li>
</ol>
<h3 id="235-BST的LCA"><a href="#235-BST的LCA" class="headerlink" title="235 BST的LCA"></a>235 BST的LCA</h3><p>8.9%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">lcaBST</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root== <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)<span class="keyword">return</span> lcaBST(root.left,p ,q );</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)<span class="keyword">return</span> lcaBST(root.right,p ,q );</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化1： 13% 9ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="222-完全二叉树的节点数"><a href="#222-完全二叉树的节点数" class="headerlink" title="222 完全二叉树的节点数"></a>222 完全二叉树的节点数</h3><p><a href="https://blog.csdn.net/jmspan/article/details/51056085" target="_blank" rel="noopener">83%</a></p>
<h3 id="DLS可以达到BFS一样空间的DFS"><a href="#DLS可以达到BFS一样空间的DFS" class="headerlink" title="DLS可以达到BFS一样空间的DFS"></a>DLS可以达到BFS一样空间的DFS</h3><h3 id="word-search"><a href="#word-search" class="headerlink" title="word search"></a>word search</h3><p>用全局mark数组58%，改用char修改board98%<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    boolean[][] marked;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n  = board.length;</span><br><span class="line">    <span class="keyword">int</span> m = board[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//        marked = new boolean[n][m];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;m ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word.charAt(<span class="number">0</span>)!=board[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,<span class="number">0</span>,i,j,word))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> idx,<span class="keyword">int</span> i,<span class="keyword">int</span> j,String word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;board.length-<span class="number">1</span>||i&lt;<span class="number">0</span>||j&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||j&lt;<span class="number">0</span>||word.charAt(idx)!=board[i][j])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(idx==word.length()-<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line"><span class="comment">//        marked[i][j] = true;</span></span><br><span class="line">board[i][j]=<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> ans = dfs(board,idx+<span class="number">1</span>,i+<span class="number">1</span>,j,word)||</span><br><span class="line">            dfs(board,idx+<span class="number">1</span>,i,j+<span class="number">1</span>,word)||dfs(board,idx+<span class="number">1</span>,i-<span class="number">1</span>,j,word)</span><br><span class="line">            ||dfs(board,idx+<span class="number">1</span>,i,j-<span class="number">1</span>,word);</span><br><span class="line"><span class="comment">//        marked[i][j]=false;</span></span><br><span class="line">    board[i][j]=tmp;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h4 id="Boggle"><a href="#Boggle" class="headerlink" title="Boggle"></a>Boggle</h4><p><img src="/images/boggle.jpg" alt="boggle.jpg"></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; board =</span><br><span class="line">&gt; [</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line">&gt; Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">&gt; Given word = &quot;SEE&quot;, return true.</span><br><span class="line">&gt; Given word = &quot;ABCB&quot;, return false.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="后缀树字典树-每层多一个字符的字典树"><a href="#后缀树字典树-每层多一个字符的字典树" class="headerlink" title="后缀树字典树 每层多一个字符的字典树"></a>后缀树字典树 每层多一个字符的字典树</h3><h3 id="后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><a href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2" class="headerlink" title="后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)"></a>后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</h3><h3 id="后缀数组-A-后缀的起始位置"><a href="#后缀数组-A-后缀的起始位置" class="headerlink" title="后缀数组 A[]后缀的起始位置"></a>后缀数组 A[]后缀的起始位置</h3><p>//Memory Limit Exceeded<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] suffixes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    N = s.length();</span><br><span class="line">    suffixes = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        suffixes[i] = s.substring(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(suffixes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“alohomora”<br>1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”<br>2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀<br>  [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra<br>  A[i]的i是字典序的i，值是真实位置<br>  例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8);</p>
<h4 id="生成后缀数组"><a href="#生成后缀数组" class="headerlink" title="生成后缀数组"></a>生成后缀数组</h4><p>Manber-Myers O(n)但是太复杂</p>
<p>排序后缀目录：桶排序</p>
<h3 id="Aho-Corasick"><a href="#Aho-Corasick" class="headerlink" title="Aho-Corasick"></a>Aho-Corasick</h3><p>1添加失败链接<br>2缝衣针字符串序号数组</p>
<hr>
<h3 id="A-B两人选k种可乐达到期望最大"><a href="#A-B两人选k种可乐达到期望最大" class="headerlink" title="A,B两人选k种可乐达到期望最大"></a>A,B两人选k种可乐达到期望最大</h3><p>A选m个，B选(n-m)个<br>每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大<br>输出 买k种可乐的数量<br>期望和：$m/n*a+(m-n)/n*b$的最大值 全部买期望最大那种<br>输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1<br>m/n=.5<br>0.5x1+0.5x2=0.5+1=1.5<br>0.5x3+0.5x1 = 2  全部买第二种可乐<br>输出:0 2</p>
<hr>
<h3 id="火车换乘"><a href="#火车换乘" class="headerlink" title="??火车换乘"></a>??火车换乘</h3><p>保证每个车错过能在30分钟以后换车<br>输入：城市n 火车数m<br>from1 to3 cost800 18:00 21:00<br>…<br>输出从1到n的最小花费</p>
<hr>
<h3 id="16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><a href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16" class="headerlink" title="16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16"></a>16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</h3><p>A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)*(P(C进入1/8)*P(A赢了C)+P(D进入1/8)*P(A赢了D))<br>A进入1/2需要赢没比过的另外4个队<br>A变成冠军需要赢没比过的另外8个队<br>分组问题：如果1/4赛 1234 5678是一组4个是一组<br>如果1/2赛  8个是一组<br><img src="/images/shijiebei.jpg" alt="shijiebei"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span> inergroup = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"> <span class="keyword">int</span> group= <span class="number">1</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">16</span> ; j++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">16</span>;k++) &#123;</span><br><span class="line">    <span class="comment">//在同一个大组</span></span><br><span class="line">    <span class="keyword">if</span>(j/group==k/group) &#123;</span><br><span class="line">    <span class="comment">//不在同一个小组</span></span><br><span class="line">    <span class="keyword">if</span> (j / inergroup != k / inergroup) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] * dp[i - <span class="number">1</span>][k] * p[j][k];</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<p>第一轮：1进入1/8赢的概率是[1][2] 1打败2的概率=0.133<br>第二轮：1赢了1/8进入1/4赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1在第2轮的获胜概率是0加上1在上一轮胜利的概率0.133 ×3在上一轮获胜的概率0.335×1赢3的概率0.21</span><br><span class="line">1 2 0.00935655</span><br><span class="line">1在第2轮的获胜概率是0.00935655加上1在上一轮胜利的概率0.133 ×4在上一轮获胜的概率0.665×1赢4的概率0.292</span><br><span class="line">1 2 0.0351825</span><br></pre></td></tr></table></figure></p>
<p>第三轮：1赢了1/4在1/2半决赛赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1在第3轮的获胜概率是0加上1在上一轮胜利的概率0.0351825 ×5在上一轮获胜的概率0.336947×1赢5的概率0.67</span><br><span class="line">1 3 0.00794261</span><br><span class="line">1在第3轮的获胜概率是0.00794261加上1在上一轮胜利的概率0.0351825 ×6在上一轮获胜的概率0.198831×1赢6的概率0.27</span><br><span class="line">1 3 0.00983136</span><br><span class="line">1在第3轮的获胜概率是0.00983136加上1在上一轮胜利的概率0.0351825 ×7在上一轮获胜的概率0.0229419×1赢7的概率0.953</span><br><span class="line">1 3 0.0106006</span><br><span class="line">1在第3轮的获胜概率是0.0106006加上1在上一轮胜利的概率0.0351825 ×8在上一轮获胜的概率0.44128×1赢8的概率0.353</span><br><span class="line">1 3 0.016081</span><br></pre></td></tr></table></figure></p>
<p>第四轮：1赢了1/2变成冠军的概率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1在第4轮的获胜概率是0加上1在上一轮胜利的概率0.016081 ×9在上一轮获胜的概率0.0606261×1赢9的概率0.328</span><br><span class="line">1 4 0.000319777</span><br><span class="line">1在第4轮的获胜概率是0.000319777加上1在上一轮胜利的概率0.016081 ×10在上一轮获胜的概率0.0113548×1赢10的概率0.128</span><br><span class="line">1 4 0.000343149</span><br><span class="line">1在第4轮的获胜概率是0.000343149加上1在上一轮胜利的概率0.016081 ×11在上一轮获胜的概率0.203126×1赢11的概率0.873</span><br><span class="line">1 4 0.00319478</span><br><span class="line">1在第4轮的获胜概率是0.00319478加上1在上一轮胜利的概率0.016081 ×12在上一轮获胜的概率0.147508×1赢12的概率0.082</span><br><span class="line">1 4 0.00338929</span><br><span class="line">1在第4轮的获胜概率是0.00338929加上1在上一轮胜利的概率0.016081 ×13在上一轮获胜的概率0.160952×1赢13的概率0.771</span><br><span class="line">1 4 0.00538485</span><br><span class="line">1在第4轮的获胜概率是0.00538485加上1在上一轮胜利的概率0.016081 ×14在上一轮获胜的概率0.0877648×1赢14的概率0.3</span><br><span class="line">1 4 0.00580826</span><br><span class="line">1在第4轮的获胜概率是0.00580826加上1在上一轮胜利的概率0.016081 ×15在上一轮获胜的概率0.240971×1赢15的概率0.405</span><br><span class="line">1 4 0.00737766</span><br><span class="line">1在第4轮的获胜概率是0.00737766加上1在上一轮胜利的概率0.016081 ×16在上一轮获胜的概率0.0876971×1赢16的概率0.455</span><br><span class="line">1 4 0.00801932</span><br></pre></td></tr></table></figure></p>

</div></div>
<hr>
<hr>
<hr>
<h3 id="815-换公交-BFS"><a href="#815-换公交-BFS" class="headerlink" title="!815 换公交 BFS"></a>!815 换公交 BFS</h3><p><code>routes = [[1, 2, 7], [3, 6, 7]]</code><br>表示环线<code>1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;</code><br>求从S-&gt;T的最少公交车数量（不是少的站点）</p>
<blockquote>
<p>Input: routes = [[1, 2, 7], [3, 6, 7]]<br>S = 1<br>T = 6<br>Output: 2乘坐 routes[0]到7，换routes[1]到6</p>
</blockquote>
<p>易错点1： bfs的size保留当前层的定点数<br>易错点2： deque的add和poll</p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;0,1,6,16,22,23&#125;,</span><br><span class="line"> &#123;14,15,24,32&#125;,</span><br><span class="line"> &#123;4,10,12,20,24,28,33&#125;,</span><br><span class="line"> &#123;1,10,11,19,27,33&#125;,</span><br><span class="line"> &#123;11,23,25,28&#125;,</span><br><span class="line"> &#123;15,20,21,23,29&#125;,</span><br><span class="line"> &#123;29&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p> S=4 T=21<br>bfs，起点入队，遍历起点可以到达的所有公交(4可以达公交2)，遍历所有公交2上的可达<code>stop{4,10,12,20,24,28,33},</code><br>如果没到T，则4乘的公交换一辆，再遍历有4公交上的其他可达stop。<br><strong>用size保留当前层的定点数</strong> 4的bus全部遍历完后size==0。下一轮重新获取<code>que.size()</code><br>如果4的所有公交都不能达到T，则必须换乘cnt+1。当前起点变成<code>stop{10}</code>，遍历它的公交和stop，不行就{12}这些都是cnt+1可达的。直到<code>stop{20}-&gt;bus{2,5}</code>遍历公交5的stop找到T，bfs换乘1层找到的。</p>
<p>注意deque的add是addLast，push是addFirst,poll是pollFirst，pop是poolFirst 队列应该是add+poll,<br>bfs如果用栈，则会在这一层还没找完先找下一层cnt=1{4}-&gt;<br><img src="/images/bus1.jpg" alt="bus1.jpg"><br><code>cnt=2{33:[2, 3]}-&gt;</code><br>将{1,10,11,19,27,33}入队<br><img src="/images/bus2.jpg" alt="bus2.jpg"><br>所以回到下一次size–的时候取到了下一层的点33,两个bus都标记过了<br>然后就全乱了<br><code>{27:[3]}-&gt;{19:[3]}-&gt;{11:[3,4]}-&gt;bus4</code>的最后<code>{28:[2,4]}-&gt;25:[4]-&gt;cnt=3{23:[0,4,5]}-&gt;bus5</code>找到21<br>本来应该<code>bus[2]-&gt;20-&gt;bus[5]</code>结果<code>bus[2]-&gt;bus[4]-&gt;bus[5]</code></p>

</div></div>
<p>数据结构：</p>
<ol>
<li>{站点：list&lt;经过的公交车id&gt;}</li>
<li>list&lt;公交车id&gt; 标记已经乘过的公交</li>
<li>BFS连通分量<code>while(!que.empty)</code>，<br> 遍历一辆车的连通分量<code>while(que.size()&gt;0)</code><br> 遍历当前节点相邻的busid是否乘过<code>for(int car:list)，</code><br> 并标记这个车的连通分量已乘过，遍历这个连通分量<code>for(int t:routes[car])</code>中有没有T，有则结束，没有则将整个连通分量入队。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todonexttime</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="fib"><a href="#fib" class="headerlink" title="fib"></a>fib</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    num++;<span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == -<span class="number">1</span>)memo[n] = fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="11-数组index当底边，值当杯子两侧，最大面积"><a href="#11-数组index当底边，值当杯子两侧，最大面积" class="headerlink" title="11 数组index当底边，值当杯子两侧，最大面积"></a>11 数组index当底边，值当杯子两侧，最大面积</h3><hr>
<hr>
<h3 id="347桶排序-int数组中最常出现的n个"><a href="#347桶排序-int数组中最常出现的n个" class="headerlink" title="?347桶排序 int数组中最常出现的n个"></a>?347桶排序 int数组中最常出现的n个</h3><p>桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。<br>99%<br>不用map，遍历一次找到max和min 建len = max-min+1的数组计数<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> rst;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE,max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; min)min = nums[i];</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;max) max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[max-min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">        data[nums[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> ArrayList[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[data[i]]== <span class="keyword">null</span>)&#123;</span><br><span class="line">                bucket[data[i]] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                bucket[data[i]].add(i+min);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bucket[data[i]].add(i+min);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =nums.length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)<span class="keyword">return</span> rst;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            rst.addAll(bucket[i]);</span><br><span class="line">            k-=bucket[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><br>用map AC34%</p>
<h3 id="242-Anagram-相同字母的单词"><a href="#242-Anagram-相同字母的单词" class="headerlink" title="242 Anagram 相同字母的单词"></a>242 Anagram 相同字母的单词</h3><h3 id="22-卡特兰数括号"><a href="#22-卡特兰数括号" class="headerlink" title="22 卡特兰数括号"></a>22 卡特兰数括号</h3><p>left括号数量小于n，right括号数量必须小于left不然(()))肯定不合理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;rst.add(s);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(left&gt;<span class="number">0</span>)help(rst,s+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line"><span class="keyword">if</span>(right&lt;<span class="number">0</span>)help(rst,s+<span class="string">")"</span>,left,right+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="344-reverse-String"><a href="#344-reverse-String" class="headerlink" title="344 reverse String"></a>344 reverse String</h3><p>转成char数组/位运算做法77%比stringbuilder好</p>
<h3 id="238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><a href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法" class="headerlink" title="238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法"></a>238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</h3><p>left数组：自己左边数的乘积[1,1,2,6]<br>right数组:自己右边的乘积（包括自己）[24,12,4,1]<br>left和right对应位置相乘<br>不用extra space<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span> to n-<span class="number">1</span>)&#123;</span><br><span class="line">    res[i]=res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(n-<span class="number">1</span> to <span class="number">0</span>)&#123;</span><br><span class="line">    res[i]*right;</span><br><span class="line">    right*=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<h3 id="371-不用’-’用位运算完成求和"><a href="#371-不用’-’用位运算完成求和" class="headerlink" title="371 不用’+’用位运算完成求和"></a>371 不用’+’用位运算完成求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = a^b;<span class="comment">//0^0=0,0^1=1,1^1=0 </span></span><br><span class="line">    <span class="keyword">int</span> carry = (a&amp;b)&lt;&lt;<span class="number">1</span>;<span class="comment">//当ab相等的时候需要进位</span></span><br><span class="line">    <span class="comment">//a+b=（a xor b）+ （(a and b) &lt;&lt; 1）</span></span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)<span class="keyword">return</span> getSum(rst,carry);</span><br><span class="line">    <span class="keyword">return</span> rst;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="412-遇到3-5和3-amp-5的倍数变成特定字符"><a href="#412-遇到3-5和3-amp-5的倍数变成特定字符" class="headerlink" title="412 遇到3||5和3&amp;5的倍数变成特定字符"></a>412 遇到3||5和3&amp;5的倍数变成特定字符</h3><p>不用%最快方法!<br>对于CPU取余数的运算相对来说效率很低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,fizz=<span class="number">0</span>,buzz=<span class="number">0</span>;i&lt;=n ;i++)&#123;</span><br><span class="line">          fizz++;</span><br><span class="line">          buzz++;</span><br><span class="line">          <span class="keyword">if</span>(fizz==<span class="number">3</span> &amp;&amp; buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fizz==<span class="number">3</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Fizz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Buzz"</span>);</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ret.add(String.valueOf(i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="551-出现两个以上A或者3个以上L为false"><a href="#551-出现两个以上A或者3个以上L为false" class="headerlink" title="551 出现两个以上A或者3个以上L为false"></a>551 出现两个以上A或者3个以上L为false</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> s.indexOf(<span class="string">"A"</span>)==s.lastIndexOf(<span class="string">"A"</span>) &amp;&amp; s.indexOf(<span class="string">"LLL"</span>) == -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="476"><a href="#476" class="headerlink" title="476"></a>476</h3><p>前导0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到左边第一个1，然后后面全置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);<span class="comment">//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);<span class="comment">//连续4个1 但是如果位数不够就只有3个1或者更少</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//让全1的无符号右移1格1111-0111得到1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"><a href="#292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢" class="headerlink" title="292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"></a>292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢</h3><h3 id="lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal"><a href="#lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal" class="headerlink" title="lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal"></a>lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal</h3><h4 id="Morris-Inorder-中序-Tree-Traversal"><a href="#Morris-Inorder-中序-Tree-Traversal" class="headerlink" title="Morris Inorder(中序) Tree Traversal"></a>Morris Inorder(中序) Tree Traversal</h4><p><strong>先把每个中缀的前缀（左子树最右）指向中缀，遍历完后把这些链接都删除还原为 null</strong></p>
<ol>
<li>找root的前趋：root 的中序前趋是左子树(第一个左结点)cur的最右标记为pre， pre.right = root<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找前趋</span></span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node pre = current.left;</span><br><span class="line">    <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span>&amp;&amp;pre.right!=cur)&#123;</span><br><span class="line">        pre=pre.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建链接：第一次到达这个最右的结点，cur的左边其实还有结点</span></span><br><span class="line"><span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">  pre.right = cur;</span><br><span class="line">  cur=cur.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>找root.left的前趋：cur向左（相当于新的root（1）的状态），找到cur的最右，标识成pre.right = cur</li>
<li><p>当cur向左是null则找到中序遍历的第一个输出，cur向右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    sout(current.val);</span><br><span class="line">    current=current.right;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当cur的left==null并且右链接已经建立到上一层。cur移动到上一层，找到前趋pre就是右链接的cur.left。 把这个右链接(pre.right)删除，输出（中），然后继续向右（上）并删除这种从前趋right过来的线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre.right=cur</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">  pre.right = <span class="keyword">null</span>;</span><br><span class="line">  sout(cur.val);</span><br><span class="line">  cur=cur.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="110-判断树平衡-在计算高度时同时判断平衡只需要O-n"><a href="#110-判断树平衡-在计算高度时同时判断平衡只需要O-n" class="headerlink" title="110 判断树平衡 在计算高度时同时判断平衡只需要O(n)"></a>110 判断树平衡 在计算高度时同时判断平衡只需要O(n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> balance =<span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isbalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    height(root);</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)balance = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)<br>与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况<br>2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间</p>
<h3 id="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><a href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树" class="headerlink" title="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"></a>红黑树：将3-结点变成左二叉树，将2-3变成二叉树</h3><p>有二叉树高效查找和2-3树高效平衡插入<br>红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$</p>
<p>插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转）</p>
<h3 id="581-需要排序的最小子串，整个串都被排序了-递增"><a href="#581-需要排序的最小子串，整个串都被排序了-递增" class="headerlink" title="581 需要排序的最小子串，整个串都被排序了 递增"></a>581 需要排序的最小子串，整个串都被排序了 递增</h3><p><img src="/images/lc581.jpg" alt="lc581"><br>40大于35，只排序到右边遍历过来第一个<code>n&lt;n-1</code>是不够的<br>要找到[30~31]中的min和max<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fid</span><span class="params">(<span class="keyword">int</span>[]A)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,3,2,2,2</span></span><br><span class="line">    <span class="keyword">int</span> n = A.length, beg = -<span class="number">1</span>, end = -<span class="number">2</span>, min = A[n-<span class="number">1</span>], max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        max = Math.max(max, A[i]);<span class="comment">//从前往后，找到最大值max=3</span></span><br><span class="line">        min = Math.min(min, A[n-<span class="number">1</span>-i]);<span class="comment">//从后往前找到最小值min=2</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; max) end = i; <span class="comment">//a=2&lt;3 end = 2-&gt;3-&gt;4 直到找到a[i]&gt;max</span></span><br><span class="line">        <span class="keyword">if</span> (A[n-<span class="number">1</span>-i] &gt; min) beg = n-<span class="number">1</span>-i;<span class="comment">//begin =1 直到找到a[i]&lt;min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end - beg + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136 Single Number"></a>136 Single Number</h3><p>异或 0^12=12,12^12=0<br><a href="https://leetcode.com/articles/single-number/" target="_blank" rel="noopener">single number</a><br>$$2(a+b+c)-(a+a+b+b+c)$$ <code>2*sum(set(list))-sum(list)</code></p>
<h3 id="141链表环检测"><a href="#141链表环检测" class="headerlink" title="141链表环检测"></a>141链表环检测</h3><p>空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针<br>最坏情况，快指针和慢指针相差环长q -1步<br><div><div class="fold_hider"><div class="close hider_title">cpp练习</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        auto slow = head;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h2 id="160-链表相交于哪一点"><a href="#160-链表相交于哪一点" class="headerlink" title="160 链表相交于哪一点"></a>160 链表相交于哪一点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val<br>思路2：将a,b连成m+n长的链表遍历两遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1 → a2  c1 → c2 → c3 -null- b1 → b2 → b3  c1 → c2 → c3</span><br><span class="line">       // ↘</span><br><span class="line">       //   c1 → c2 → c3</span><br><span class="line">        // ↗            </span><br><span class="line">b1 → b2 → b3  c1 → c2 → c3 -null- a1 → a2  c1 → c2 → c3</span><br></pre></td></tr></table></figure></p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            ListNode a = headA;</span><br><span class="line">            ListNode b = headB;</span><br><span class="line">            <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="keyword">null</span>)&#123;a=headB;&#125;<span class="keyword">else</span>&#123;a=a.next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="keyword">null</span>)&#123;b=headA;&#125;<span class="keyword">else</span>&#123;b=b.next;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="168-lt1350"><a href="#168-lt1350" class="headerlink" title="168 lt1350"></a>168 lt1350</h3><p>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>…<br>26 -&gt; Z<br>27 -&gt; AA<br>28 -&gt; AB<br>递归26进制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="string">""</span> : convertToTitle(--n / <span class="number">26</span>) + (<span class="keyword">char</span>)(<span class="string">'A'</span> + (n % <span class="number">26</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>88%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">   --n;</span><br><span class="line">   sb.insert(<span class="number">0</span>,(<span class="keyword">char</span>)(n%<span class="number">26</span>+<span class="string">'A'</span> ));</span><br><span class="line">   n/=<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure></p>
<h3 id="1-爬山：局部贪心，快速找到可行解，局部最优"><a href="#1-爬山：局部贪心，快速找到可行解，局部最优" class="headerlink" title="1. 爬山：局部贪心，快速找到可行解，局部最优"></a>1. 爬山：局部贪心，快速找到可行解，局部最优</h3><ul>
<li>8数码:启发函数：当前状态和目标状态的距离：错位方块个数。<ol>
<li>深度优先<br><img src="/images/mounting.jpg" alt="mounting"></li>
<li>每次将当前节点S的子节点按启发式函数由大到小压入栈</li>
</ol>
</li>
</ul>
<p>8数码BFS优先队列<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> newX,<span class="keyword">int</span> newY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = matrix[x][y];</span><br><span class="line">    matrix[x][y] = matrix[newX][newY];</span><br><span class="line">    matrix[newX][newY] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    printPath(root.parent);</span><br><span class="line">    print2D(root.mat);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">createNode</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> newX,<span class="keyword">int</span> newY,<span class="keyword">int</span> level,Node parent)</span></span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node();</span><br><span class="line">    node.parent = parent;</span><br><span class="line"></span><br><span class="line">    node.mat = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        node.mat[i] = matrix[i].clone();</span><br><span class="line">    &#125;</span><br><span class="line">    swap(node.mat,x ,y , newX,newY);</span><br><span class="line">    node.cost = Integer.MAX_VALUE;</span><br><span class="line">    node.x = newX;</span><br><span class="line">    node.y = newY;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span>[][] from,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span>[][] end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//扩展距离小的</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(node -&gt; (node.cost + node.level))</span><br><span class="line">    );</span><br><span class="line">    Node root = createNode(from,x ,y ,x ,y ,<span class="number">0</span> , <span class="keyword">null</span>);</span><br><span class="line">    root.cost = calCost(from,end );</span><br><span class="line">    que.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        Node min = que.poll();</span><br><span class="line">        <span class="comment">//结果，从子节点向上递归打印</span></span><br><span class="line">        <span class="keyword">if</span>(min.cost==<span class="number">0</span>) &#123;</span><br><span class="line">            printPath(min);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4个方向挪动白块四个方向为什么不会重复状态死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isInBoard(min.x+row[i],min.y+col[i]))&#123;</span><br><span class="line">                Node child = createNode(min.mat,min.x ,min.y , min.x+row[i], min.y+col[i], min.level+<span class="number">1</span>, min);</span><br><span class="line">                child.cost = calCost(child.mat,end );</span><br><span class="line">                que.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="Best-First搜索：全局最优贪心"><a href="#Best-First搜索：全局最优贪心" class="headerlink" title="Best-First搜索：全局最优贪心"></a>Best-First搜索：全局最优贪心</h3><ul>
<li>当前所有可扩展节点中启发函数最优点</li>
<li>用堆</li>
</ul>
<h3 id="分支界限：组合优化"><a href="#分支界限：组合优化" class="headerlink" title="分支界限：组合优化"></a>分支界限：组合优化</h3><ul>
<li>多阶段图搜索：最短路径<ul>
<li>爬山与BF算法得到最优解都需要遍历整个空间</li>
</ul>
<ol>
<li>用爬山生成界限(可行解or最优解的上限)<br><img src="/images/fenzhi.jpg" alt="fenzhi"></li>
</ol>
</li>
</ul>
<h3 id="Rabin-Karp"><a href="#Rabin-Karp" class="headerlink" title="Rabin-Karp"></a>Rabin-Karp</h3><p>O(MN)</p>
<h3 id="1-枚举："><a href="#1-枚举：" class="headerlink" title="1. 枚举："></a>1. 枚举：</h3><ol>
<li><p>小于N的完美立方 $a^3=b^3+c^3+d^3$</p>
<blockquote>
<p>按a的值从小到大输出a&gt;b&gt;c&gt;d</p>
</blockquote>
<ul>
<li>a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1]</li>
</ul>
</li>
<li><p>称硬币:已经分组称了3次12枚硬币，找出假币</p>
<blockquote>
<p>ABCD EFGH even<br>ABI EFJK up<br>ABIJ EFGH even<br>输出假的硬币</p>
</blockquote>
<ul>
<li>数据结构 <code>char Left[3][7]`</code>char Right[3][7]<code></code>char result[3][7]` 一共称3次，每边最多放6个硬币，result（天平右边的情况）</li>
<li><code>isFake(char c,bool light )</code>假设函数：c是轻的</li>
<li><code>for(char c= &#39;A&#39; to &#39;L&#39;)</code>枚举假硬币</li>
<li><code>for(3)</code>三次称重情况都匹配<ul>
<li>如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换</li>
<li><code>switch result[i][0]</code> 选择三种u,e,d的情况<ul>
<li>如果 第一次实验为up,右边高，则c应该出现在right,当<code>right.indexOf(c)==null</code>//没出现 return false</li>
<li>如果even 判断出现在left||right</li>
<li>d 判断出现在left</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><p>熄灯问题(deng.java)</p>
<blockquote>
<p>按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4<br>给定每盏灯的初始状态，求按钮方案，使灯全熄灭<br>输入 01矩阵 输出 01矩阵<br>一个按钮按两次及以上是无意义的，按钮次序无关<br>{0,1,1,0,1,0},<br>{1,0,0,1,1,1},<br>{0,0,1,0,0,1},<br>{1,0,0,1,0,1},<br>{0,1,1,1,0,0}</p>
</blockquote>
<ul>
<li>枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数）</li>
<li>只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按</li>
<li>一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1]</li>
<li>一个bit异或1 反转<code>1^1-&gt;0反转0^1-&gt;1反转；</code></li>
<li>j位 置1 <code>|=(1&lt;&lt;j)</code></li>
<li>j位 置0 <code>&amp;=~(1&lt;&lt;j)</code></li>
<li>取第j 位的值 <code>&gt;&gt;j&amp;1</code><blockquote>
<p> 主循环：1.遍历第一行开关状态<br> 2.每次换第一行重置原来灯状态lighting[]=输入<br> 3.对每一行，每一个灯，按switch更新lighting</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(getBit(result,i,j)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">0</span>)FlipBit(lights,i,j-<span class="number">1</span>);</span><br><span class="line">FlipBit(lights,i,j);</span><br><span class="line"><span class="keyword">if</span>(j&lt;<span class="number">5</span>)FlipBit(lights,i,j+<span class="number">1</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">4</span>)&#123;lights[i+<span class="number">1</span>]^= switchs;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>&gt;  4.更新开关，下一行开关为上一行还亮着灯的位置回3
&gt;  5.当lighting最后一行为0，结束
</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol>
<li>汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2)<ol>
<li>A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c)</li>
<li>再将B上n-1个移动到C，用A中转</li>
<li>回到0 A上n-2个移动到C，用B中转</li>
</ol>
</li>
<li>n皇后 递归代替多重循环</li>
</ol>
<h4 id="链表DELETE-IF"><a href="#链表DELETE-IF" class="headerlink" title="链表DELETE_IF"></a>链表DELETE_IF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>list-&gt;nodelist 会stackOverflow<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">create</span><span class="params">(List&lt;Integer&gt; data)</span></span>&#123;</span><br><span class="line">    Node first = <span class="keyword">new</span> Node(data.get(<span class="number">0</span>));</span><br><span class="line">    Node sub = create(data.subList(<span class="number">1</span>,data.size()));</span><br><span class="line">    first.next=sub;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>迭代：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node head =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span> to size)&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(i);</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.next =node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">reverse</span><span class="params">(Nodde head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    Node second = reverse(head.next);</span><br><span class="line">    second.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>迭代：<br>中间状态null&lt;-1&lt;-2<3 |="" 4-="">5-&gt;null<br>3是newhead 反转成功的链表 | 4curhead是还没反转的链表<br>newhead=null开始，curhead从第一个node开始，两个同时向右每次移一格，直到curhead=null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node newhead = <span class="keyword">null</span>;</span><br><span class="line">Node curhead = head;</span><br><span class="line"><span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node tmp = curhead.next;</span><br><span class="line">    curhead.next = newhead;</span><br><span class="line">    curhead=tmp;</span><br><span class="line">    newhead = curhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newhead;</span><br></pre></td></tr></table></figure></3></p>
<p>转成栈浪费空间并且代码复杂</p>
<h3 id="654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"><a href="#654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树" class="headerlink" title="654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"></a>654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树</h3><p>stack：<br>[3,2,1,6,0,5]<br>1.栈底是数组最大值，即树根<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3left-&gt;</span><br><span class="line"> right-&gt;2-&gt;1 stack:3,2,1</span><br><span class="line">将栈里比cur小的右链变成当前最大值的左链，pop所有比6小的元素</span><br><span class="line">6left-&gt;3</span><br><span class="line">        -&gt;right-&gt;2-&gt;1 stack：6</span><br><span class="line">6left-&gt;3</span><br><span class="line"> right-&gt;0 stack:6,0</span><br><span class="line">5left-&gt;0,6right-&gt;5</span><br><span class="line">6-&gt;left-&gt;3</span><br><span class="line">         -&gt;right-&gt;2-&gt;1</span><br><span class="line"> -&gt;right-&gt;5</span><br><span class="line">          -&gt;left-&gt;0</span><br></pre></td></tr></table></figure></p>
<p>68%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    TreeNode cur = nums[i];</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek().val&lt;cur.val)&#123;</span><br><span class="line">        cur.left = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">        stack.peek().right=cur;</span><br><span class="line">    stack.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty()?<span class="keyword">null</span>:stack.removeLast();</span><br></pre></td></tr></table></figure></p>
<p>递归95% 递归熟练 11ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> max = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =start+<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">        max = nums[]</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[max]);</span><br><span class="line">    root.left = build(nums,start,max-<span class="number">1</span>);</span><br><span class="line">    root.right = build(nums,max+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/alg/" rel="tag"># alg</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/21/busyman/" rel="next" title="busyman Notes">
                <i class="fa fa-chevron-left"></i> busyman Notes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/24/Apriori-FP/" rel="prev" title="Apriori_FP">
                Apriori_FP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">学习一个技术不要轻易过去，要有技术深度做一个demo</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#532-数组中有几个相差k的pair"><span class="nav-number">1.</span> <span class="nav-text">532 数组中有几个相差k的pair</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#220-数组中是否有相差-lt-t-idx差-lt-k-的元素"><span class="nav-number">2.</span> <span class="nav-text">220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#219-是否有重复元素-下标相差-lt-k"><span class="nav-number">3.</span> <span class="nav-text">219 是否有重复元素 下标相差&lt;=k</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间"><span class="nav-number">4.</span> <span class="nav-text">442  1 ≤ a[i] ≤ n 找到所有出现2次的元素 O(1) 空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#769-最多能排序的块-0-n的排列切割，块排序后连接是排序的原数组"><span class="nav-number">5.</span> <span class="nav-text">769 最多能排序的块 0-n的排列切割，块排序后连接是排序的原数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#915-Max-left-lt-Min-right"><span class="nav-number">6.</span> <span class="nav-text">915 Max(left)&lt;=Min(right)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#768-最多能排序的块-重复元素"><span class="nav-number">7.</span> <span class="nav-text">768 最多能排序的块 重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#401-二进制手表"><span class="nav-number">8.</span> <span class="nav-text">401 二进制手表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉明重量-Hamming-weight-32位int有多少个1"><span class="nav-number">9.</span> <span class="nav-text">汉明重量 Hamming weight 32位int有多少个1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#477-全部汉明距离Integer-bitCount-x-y"><span class="nav-number">10.</span> <span class="nav-text">477 全部汉明距离Integer.bitCount(x ^ y)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#338-0-n每个数字有几个1位-O-n-复杂度"><span class="nav-number">11.</span> <span class="nav-text">338 0~n每个数字有几个1位 O(n)复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-803-建筑物之间的最短距离"><span class="nav-number">12.</span> <span class="nav-text">lt 803 建筑物之间的最短距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161"><span class="nav-number">13.</span> <span class="nav-text">lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">14.</span> <span class="nav-text">72 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取模和取余rem"><span class="nav-number">15.</span> <span class="nav-text">取模和取余rem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段上格点的个数"><span class="nav-number">16.</span> <span class="nav-text">线段上格点的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼"><span class="nav-number">17.</span> <span class="nav-text">火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间dp"><span class="nav-number">18.</span> <span class="nav-text">区间dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt476石子合并-区间dp"><span class="nav-number">19.</span> <span class="nav-text">lt476石子合并 区间dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc84直方图中的最大矩形poj2559"><span class="nav-number">20.</span> <span class="nav-text">lc84直方图中的最大矩形poj2559</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poj3734"><span class="nav-number">21.</span> <span class="nav-text">poj3734</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#790-L型，XX型骨牌覆盖2xN的board"><span class="nav-number">22.</span> <span class="nav-text">790 L型，XX型骨牌覆盖2xN的board</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#poj-2411"><span class="nav-number">22.1.</span> <span class="nav-text">poj 2411</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图中长度为k的路径计数"><span class="nav-number">23.</span> <span class="nav-text">图中长度为k的路径计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速幂logN完成幂运算"><span class="nav-number">24.</span> <span class="nav-text">快速幂logN完成幂运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递推公式"><span class="nav-number">25.</span> <span class="nav-text">递推公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fibo递推公式"><span class="nav-number">26.</span> <span class="nav-text">fibo递推公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#763-划分尽可能多字母区间"><span class="nav-number">27.</span> <span class="nav-text">763 划分尽可能多字母区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3sum-a-b-c-0"><span class="nav-number">28.</span> <span class="nav-text">15 3sum a + b + c = 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3sum-最接近target的值"><span class="nav-number">29.</span> <span class="nav-text">16 3sum 最接近target的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4sum-外层for-用3sum找target-nums-i"><span class="nav-number">30.</span> <span class="nav-text">18 4sum 外层for 用3sum找target-nums[i]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#454-4-sum-2-poj2785-4-Values-whose-Sum-is-0"><span class="nav-number">31.</span> <span class="nav-text">454 4 sum 2 poj2785 4 Values whose Sum is 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#914-相同数字的牌划分成一组，每组数量相同-能否划分"><span class="nav-number">32.</span> <span class="nav-text">914 相同数字的牌划分成一组，每组数量相同 能否划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#916"><span class="nav-number">33.</span> <span class="nav-text">916</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-整数反转-integer越界"><span class="nav-number">34.</span> <span class="nav-text">7 整数反转 integer越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#319-n个灯泡-n轮开关"><span class="nav-number">35.</span> <span class="nav-text">319 n个灯泡 n轮开关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#451-字符串按频率排序-桶排序"><span class="nav-number">36.</span> <span class="nav-text">451 字符串按频率排序 桶排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt168-吹气球"><span class="nav-number">37.</span> <span class="nav-text">lt168 吹气球</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵链乘法O-n-3-的dp"><span class="nav-number">38.</span> <span class="nav-text">矩阵链乘法O(n^3)的dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大值为k的不重叠子数组的长度和？"><span class="nav-number">39.</span> <span class="nav-text">最大值为k的不重叠子数组的长度和？??</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#689-高频题-找到三个长度为k互不重叠的子数组的最大和"><span class="nav-number">40.</span> <span class="nav-text">689!!!高频题 找到三个长度为k互不重叠的子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-只能买卖一次-买卖股票的利润"><span class="nav-number">41.</span> <span class="nav-text">121 只能买卖一次 买卖股票的利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-可以买卖多次-买股票的利润"><span class="nav-number">42.</span> <span class="nav-text">122 可以买卖多次 买股票的利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-最多买卖2次的-买股票利润-考到"><span class="nav-number">43.</span> <span class="nav-text">123 最多买卖2次的 买股票利润 考到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#188-最多k次买卖的-买卖股票利润"><span class="nav-number">44.</span> <span class="nav-text">188 最多k次买卖的 买卖股票利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复元素很多的数组排序"><span class="nav-number">45.</span> <span class="nav-text">重复元素很多的数组排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#621-todo"><span class="nav-number">46.</span> <span class="nav-text">621 todo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-最长回文子序列"><span class="nav-number">47.</span> <span class="nav-text">516 最长回文子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rearrange-a-string"><span class="nav-number">48.</span> <span class="nav-text">Rearrange a string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#386-字典序数字-todo"><span class="nav-number">49.</span> <span class="nav-text">!!386 字典序数字 todo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#636-单核cpu函数调用栈"><span class="nav-number">50.</span> <span class="nav-text">636 单核cpu函数调用栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#378-矩阵从左到右从上到下有序，找第k小的元素"><span class="nav-number">51.</span> <span class="nav-text">378 矩阵从左到右从上到下有序，找第k小的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#373"><span class="nav-number">52.</span> <span class="nav-text">373</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概率生成函数-概率母函数"><span class="nav-number">53.</span> <span class="nav-text">概率生成函数 概率母函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配问题及应用"><span class="nav-number">54.</span> <span class="nav-text">分配问题及应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬币相关问题"><span class="nav-number">55.</span> <span class="nav-text">硬币相关问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营"><span class="nav-number">56.</span> <span class="nav-text">649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#495-给定攻击时间和中毒状态持续时间，问中毒状态总时长"><span class="nav-number">57.</span> <span class="nav-text">495 给定攻击时间和中毒状态持续时间，问中毒状态总时长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#899-操作字符串前k个字符放到最后-输出字典序最小的"><span class="nav-number">58.</span> <span class="nav-text">899 操作字符串前k个字符放到最后 输出字典序最小的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77combinations-C-n-k-C-n-1-k-1-C-n-1-k"><span class="nav-number">59.</span> <span class="nav-text">77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24两个一组交换链表"><span class="nav-number">60.</span> <span class="nav-text">24两个一组交换链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NqueenBB"><span class="nav-number">61.</span> <span class="nav-text">NqueenBB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#179-一组非负数，拼接成最大的正整数"><span class="nav-number">62.</span> <span class="nav-text">179 一组非负数，拼接成最大的正整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#500-判断字符串是不是在键盘的同一行"><span class="nav-number">63.</span> <span class="nav-text">500 判断字符串是不是在键盘的同一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42"><span class="nav-number">64.</span> <span class="nav-text">42</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#683-K-Empty-Slots"><span class="nav-number">65.</span> <span class="nav-text">683 - K Empty Slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长01串"><span class="nav-number">66.</span> <span class="nav-text">最长01串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒水问题-BFS"><span class="nav-number">67.</span> <span class="nav-text">倒水问题 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#poj-3414-Pots"><span class="nav-number">67.1.</span> <span class="nav-text">poj 3414 Pots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poj-1606"><span class="nav-number">67.2.</span> <span class="nav-text">poj 1606</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-N-大整数"><span class="nav-number">68.</span> <span class="nav-text">2^N 大整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#287-O-1-空间，找到数组中重复的数字"><span class="nav-number">69.</span> <span class="nav-text">287 O(1)空间，找到数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找第二小-大的元素"><span class="nav-number">70.</span> <span class="nav-text">查找第二小/大的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序数组中小于target的"><span class="nav-number">71.</span> <span class="nav-text">排序数组中小于target的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定一个数字范围，找到其中有几个首尾相同的数字"><span class="nav-number">72.</span> <span class="nav-text">给定一个数字范围，找到其中有几个首尾相同的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百万数字中找最大20个"><span class="nav-number">73.</span> <span class="nav-text">百万数字中找最大20个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#每秒最大桶数量减半，求t时刻一共消耗了多少"><span class="nav-number">74.</span> <span class="nav-text">每秒最大桶数量减半，求t时刻一共消耗了多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？445-链表数字相加"><span class="nav-number">75.</span> <span class="nav-text">？445 链表数字相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#896有正负的数列判断单调"><span class="nav-number">76.</span> <span class="nav-text">896有正负的数列判断单调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">77.</span> <span class="nav-text">14 最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#718-最长公共子串40ms-90"><span class="nav-number">78.</span> <span class="nav-text">718 最长公共子串40ms 90%</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#括号串达到匹配需要最小的逆转次数"><span class="nav-number">79.</span> <span class="nav-text">括号串达到匹配需要最小的逆转次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28字符串indexOf匹配暴力-Substring-Search"><span class="nav-number">80.</span> <span class="nav-text">28字符串indexOf匹配暴力 Substring Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Boyer-Moore-74-5ms-亚线性"><span class="nav-number">80.1.</span> <span class="nav-text">!!!Boyer-Moore 74% 5ms 亚线性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RabinKarp-31-8ms-线性"><span class="nav-number">80.2.</span> <span class="nav-text">RabinKarp 31% 8ms 线性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#187-rolling-hash-DNA序列中出现2次以上长为10的子串"><span class="nav-number">80.3.</span> <span class="nav-text">187 rolling-hash DNA序列中出现2次以上长为10的子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暴力-O（MN）"><span class="nav-number">80.4.</span> <span class="nav-text">暴力 O（MN）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍"><span class="nav-number">81.</span> <span class="nav-text">KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-最长不重复字串"><span class="nav-number">82.</span> <span class="nav-text">3 最长不重复字串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#879"><span class="nav-number">83.</span> <span class="nav-text">879</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#576-无向图访问所有点的最短边数"><span class="nav-number">84.</span> <span class="nav-text">576 无向图访问所有点的最短边数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fraction-背包问题"><span class="nav-number">85.</span> <span class="nav-text">fraction 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顶点覆盖"><span class="nav-number">86.</span> <span class="nav-text">顶点覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大团：在一个无向图中找出一个点数最多的完全图"><span class="nav-number">87.</span> <span class="nav-text">最大团：在一个无向图中找出一个点数最多的完全图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务分配问题一般可以在多项式时间内转化成最大流量问题"><span class="nav-number">88.</span> <span class="nav-text">任务分配问题一般可以在多项式时间内转化成最大流量问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hdu-1813-IDA搜索Iterative-Deepening-A"><span class="nav-number">89.</span> <span class="nav-text">hdu 1813 IDA搜索Iterative Deepening A,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsp"><span class="nav-number">90.</span> <span class="nav-text">tsp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-九宫格输入法数字对应的字符串"><span class="nav-number">91.</span> <span class="nav-text">17 九宫格输入法数字对应的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-分解Ip地址"><span class="nav-number">92.</span> <span class="nav-text">93 分解Ip地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip2cidr"><span class="nav-number">93.</span> <span class="nav-text">ip2cidr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131"><span class="nav-number">94.</span> <span class="nav-text">131</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54旋转矩阵"><span class="nav-number">95.</span> <span class="nav-text">54旋转矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-生成nxn的旋转矩阵"><span class="nav-number">96.</span> <span class="nav-text">59 生成nxn的旋转矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49"><span class="nav-number">97.</span> <span class="nav-text">49</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435-去掉最少区间使区间不重叠"><span class="nav-number">98.</span> <span class="nav-text">435 去掉最少区间使区间不重叠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#697-保留数组中最高频出现数字频数的最短数组长度"><span class="nav-number">99.</span> <span class="nav-text">697 保留数组中最高频出现数字频数的最短数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#819-找出句子中出现频率最高没被ban掉的词"><span class="nav-number">100.</span> <span class="nav-text">819 找出句子中出现频率最高没被ban掉的词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#亚线性算法o-n-小于输入规模"><span class="nav-number">101.</span> <span class="nav-text">亚线性算法o(n)小于输入规模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水库抽样Reservpor-Sampling-亚线性空间"><span class="nav-number">102.</span> <span class="nav-text">水库抽样Reservpor Sampling 亚线性空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#398-数组中重复元素随机返回index"><span class="nav-number">103.</span> <span class="nav-text">398 数组中重复元素随机返回index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？？382-随机链表-extremely-large-and-its-length-is-unknown"><span class="nav-number">104.</span> <span class="nav-text">？？382 随机链表 extremely large and its length is unknown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#频繁元素计算-Misra-Gries-MG-算法"><span class="nav-number">105.</span> <span class="nav-text">频繁元素计算 Misra Gries(MG)算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树"><span class="nav-number">106.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#笛卡尔树"><span class="nav-number">107.</span> <span class="nav-text">笛卡尔树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式前向星"><span class="nav-number">108.</span> <span class="nav-text">链式前向星</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序不稳定"><span class="nav-number">109.</span> <span class="nav-text">堆排序不稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三向快速排序-不稳定"><span class="nav-number">110.</span> <span class="nav-text">三向快速排序 不稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSD-most-significant-digit-first-不用长度相同从左开始"><span class="nav-number">111.</span> <span class="nav-text">MSD most-significant-digit-first 不用长度相同从左开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先"><span class="nav-number">112.</span> <span class="nav-text">LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-index-count-sort键索引计数法-稳定的"><span class="nav-number">113.</span> <span class="nav-text">key-index count sort键索引计数法 稳定的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#611数组中符合三角形边长的对数"><span class="nav-number">114.</span> <span class="nav-text">611数组中符合三角形边长的对数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组组成三角形的最大周长nlogn"><span class="nav-number">115.</span> <span class="nav-text">数组组成三角形的最大周长nlogn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MST："><span class="nav-number">116.</span> <span class="nav-text">MST：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MST和聚类："><span class="nav-number">117.</span> <span class="nav-text">MST和聚类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kruskal"><span class="nav-number">117.1.</span> <span class="nav-text">kruskal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim"><span class="nav-number">117.2.</span> <span class="nav-text">prim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类：single-link"><span class="nav-number">118.</span> <span class="nav-text">聚类：single link</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前序ABCDEFGH-gt-中序不可能是"><span class="nav-number">118.1.</span> <span class="nav-text">前序ABCDEFGH-&gt;中序不可能是</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-后序遍历二叉树"><span class="nav-number">119.</span> <span class="nav-text">145 后序遍历二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#753-输出能包含所有密码可能性的最短串"><span class="nav-number">120.</span> <span class="nav-text">753 输出能包含所有密码可能性的最短串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words"><span class="nav-number">120.1.</span> <span class="nav-text">Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-欧拉路径-每条边一次"><span class="nav-number">121.</span> <span class="nav-text">332 欧拉路径 每条边一次</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hierholzer：O-e"><span class="nav-number">121.1.</span> <span class="nav-text">Hierholzer：O(e)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个帅不能处在同一条直线上的所有可行位置"><span class="nav-number">122.</span> <span class="nav-text">两个帅不能处在同一条直线上的所有可行位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#翻煎饼排序的最少次数"><span class="nav-number">123.</span> <span class="nav-text">翻煎饼排序的最少次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279完美平方数？？？"><span class="nav-number">124.</span> <span class="nav-text">279完美平方数？？？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198"><span class="nav-number">125.</span> <span class="nav-text">198</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#164-桶排序找区间最大值"><span class="nav-number">126.</span> <span class="nav-text">164 桶排序找区间最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求数组的最大gap"><span class="nav-number">127.</span> <span class="nav-text">求数组的最大gap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分图-让每条边的两个顶点属于不同的集合"><span class="nav-number">128.</span> <span class="nav-text">二分图 让每条边的两个顶点属于不同的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#785-是否是二分图"><span class="nav-number">128.1.</span> <span class="nav-text">785 是否是二分图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人"><span class="nav-number">128.2.</span> <span class="nav-text">886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#494-在数字中间放正负号使之-target"><span class="nav-number">129.</span> <span class="nav-text">494 在数字中间放正负号使之==target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的度"><span class="nav-number">130.</span> <span class="nav-text">图的度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历顺序"><span class="nav-number">131.</span> <span class="nav-text">图的遍历顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度问题：给定一组任务，安排执行时间-gt-拓扑排序"><span class="nav-number">132.</span> <span class="nav-text">调度问题：给定一组任务，安排执行时间-&gt;拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拓扑排序：有向环"><span class="nav-number">132.1.</span> <span class="nav-text">拓扑排序：有向环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#207-先修课程有环则返回false-拓扑排序"><span class="nav-number">132.2.</span> <span class="nav-text">?207 先修课程有环则返回false 拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#210-输出修课顺序"><span class="nav-number">132.3.</span> <span class="nav-text">210 输出修课顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kolakoski序列找规律"><span class="nav-number">133.</span> <span class="nav-text">kolakoski序列找规律</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lc481-返回kolakoski前N中有几个1"><span class="nav-number">133.1.</span> <span class="nav-text">lc481 返回kolakoski前N中有几个1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-骑士从左上到右下找公主，求初始血量"><span class="nav-number">134.</span> <span class="nav-text">174 骑士从左上到右下找公主，求初始血量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#671-根的值-lt-子树的值的二叉树中的第二小元素"><span class="nav-number">135.</span> <span class="nav-text">671 根的值&lt;=子树的值的二叉树中的第二小元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪多项式时间"><span class="nav-number">136.</span> <span class="nav-text">伪多项式时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-s1和s2是否交错组成s3"><span class="nav-number">137.</span> <span class="nav-text">!!97 s1和s2是否交错组成s3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-从左上角走到右下角总共有多少种不同方式"><span class="nav-number">138.</span> <span class="nav-text">62 从左上角走到右下角总共有多少种不同方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数学公式"><span class="nav-number">138.1.</span> <span class="nav-text">!数学公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-有障碍物的左上到右下"><span class="nav-number">139.</span> <span class="nav-text">63 有障碍物的左上到右下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-从左上角走到右下角的最少sum"><span class="nav-number">140.</span> <span class="nav-text">64 从左上角走到右下角的最少sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-括号字符串中合法的括号对"><span class="nav-number">141.</span> <span class="nav-text">32 ?括号字符串中合法的括号对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本福特定律"><span class="nav-number">142.</span> <span class="nav-text">本福特定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#719"><span class="nav-number">143.</span> <span class="nav-text">719</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-众数-Boyer-Moore-Voting-Algorithm"><span class="nav-number">144.</span> <span class="nav-text">!!!169 众数 Boyer-Moore Voting Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-moore-voting-在线算法92"><span class="nav-number">144.1.</span> <span class="nav-text">4.moore voting 在线算法92%</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点是随机变量的有向无环图-贝叶斯网络BN"><span class="nav-number">145.</span> <span class="nav-text">节点是随机变量的有向无环图=贝叶斯网络BN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#402-去掉数字串中k个数字留下最小的数字"><span class="nav-number">146.</span> <span class="nav-text">402 去掉数字串中k个数字留下最小的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-最低的二叉树公共祖先LCA"><span class="nav-number">147.</span> <span class="nav-text">236 最低的二叉树公共祖先LCA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-BST的LCA"><span class="nav-number">148.</span> <span class="nav-text">235 BST的LCA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-完全二叉树的节点数"><span class="nav-number">149.</span> <span class="nav-text">222 完全二叉树的节点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLS可以达到BFS一样空间的DFS"><span class="nav-number">150.</span> <span class="nav-text">DLS可以达到BFS一样空间的DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-search"><span class="nav-number">151.</span> <span class="nav-text">word search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Boggle"><span class="nav-number">151.1.</span> <span class="nav-text">Boggle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树字典树-每层多一个字符的字典树"><span class="nav-number">152.</span> <span class="nav-text">后缀树字典树 每层多一个字符的字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><span class="nav-number">153.</span> <span class="nav-text">后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀数组-A-后缀的起始位置"><span class="nav-number">154.</span> <span class="nav-text">后缀数组 A[]后缀的起始位置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成后缀数组"><span class="nav-number">154.1.</span> <span class="nav-text">生成后缀数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aho-Corasick"><span class="nav-number">155.</span> <span class="nav-text">Aho-Corasick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-B两人选k种可乐达到期望最大"><span class="nav-number">156.</span> <span class="nav-text">A,B两人选k种可乐达到期望最大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火车换乘"><span class="nav-number">157.</span> <span class="nav-text">??火车换乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><span class="nav-number">158.</span> <span class="nav-text">16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#815-换公交-BFS"><span class="nav-number">159.</span> <span class="nav-text">!815 换公交 BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fib"><span class="nav-number">160.</span> <span class="nav-text">fib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-数组index当底边，值当杯子两侧，最大面积"><span class="nav-number">161.</span> <span class="nav-text">11 数组index当底边，值当杯子两侧，最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347桶排序-int数组中最常出现的n个"><span class="nav-number">162.</span> <span class="nav-text">?347桶排序 int数组中最常出现的n个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#242-Anagram-相同字母的单词"><span class="nav-number">163.</span> <span class="nav-text">242 Anagram 相同字母的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-卡特兰数括号"><span class="nav-number">164.</span> <span class="nav-text">22 卡特兰数括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-reverse-String"><span class="nav-number">165.</span> <span class="nav-text">344 reverse String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><span class="nav-number">166.</span> <span class="nav-text">238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#371-不用’-’用位运算完成求和"><span class="nav-number">167.</span> <span class="nav-text">371 不用’+’用位运算完成求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#412-遇到3-5和3-amp-5的倍数变成特定字符"><span class="nav-number">168.</span> <span class="nav-text">412 遇到3||5和3&amp;5的倍数变成特定字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#551-出现两个以上A或者3个以上L为false"><span class="nav-number">169.</span> <span class="nav-text">551 出现两个以上A或者3个以上L为false</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#476"><span class="nav-number">170.</span> <span class="nav-text">476</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"><span class="nav-number">171.</span> <span class="nav-text">292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal"><span class="nav-number">172.</span> <span class="nav-text">lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Morris-Inorder-中序-Tree-Traversal"><span class="nav-number">172.1.</span> <span class="nav-text">Morris Inorder(中序) Tree Traversal</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-判断树平衡-在计算高度时同时判断平衡只需要O-n"><span class="nav-number">173.</span> <span class="nav-text">110 判断树平衡 在计算高度时同时判断平衡只需要O(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">174.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><span class="nav-number">175.</span> <span class="nav-text">红黑树：将3-结点变成左二叉树，将2-3变成二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#581-需要排序的最小子串，整个串都被排序了-递增"><span class="nav-number">176.</span> <span class="nav-text">581 需要排序的最小子串，整个串都被排序了 递增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">177.</span> <span class="nav-text">136 Single Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141链表环检测"><span class="nav-number">178.</span> <span class="nav-text">141链表环检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-链表相交于哪一点"><span class="nav-number"></span> <span class="nav-text">160 链表相交于哪一点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#168-lt1350"><span class="nav-number">1.</span> <span class="nav-text">168 lt1350</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-爬山：局部贪心，快速找到可行解，局部最优"><span class="nav-number">2.</span> <span class="nav-text">1. 爬山：局部贪心，快速找到可行解，局部最优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-First搜索：全局最优贪心"><span class="nav-number">3.</span> <span class="nav-text">Best-First搜索：全局最优贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支界限：组合优化"><span class="nav-number">4.</span> <span class="nav-text">分支界限：组合优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rabin-Karp"><span class="nav-number">5.</span> <span class="nav-text">Rabin-Karp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-枚举："><span class="nav-number">6.</span> <span class="nav-text">1. 枚举：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">7.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链表DELETE-IF"><span class="nav-number">7.1.</span> <span class="nav-text">链表DELETE_IF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建链表"><span class="nav-number">7.2.</span> <span class="nav-text">创建链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转链表"><span class="nav-number">7.3.</span> <span class="nav-text">反转链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"><span class="nav-number">8.</span> <span class="nav-text">654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/custom/custom.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
