<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
 
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="alg," />










<meta name="description" content="伪多项式时间一个整数是否是素数123def isPrime(n):    for i in range(2,n):        if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ 97 s1和s2是否交错组成s3Solution状">
<meta name="keywords" content="alg">
<meta property="og:type" content="article">
<meta property="og:title" content="alg">
<meta property="og:url" content="https://iotaa.xyz/2018/03/24/alg/index.html">
<meta property="og:site_name" content="vue&amp;java Mark">
<meta property="og:description" content="伪多项式时间一个整数是否是素数123def isPrime(n):    for i in range(2,n):        if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ 97 s1和s2是否交错组成s3Solution状">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://iotaa.xyz/images/BIT.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/coin.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/shijiebei.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/lc581.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/anagram.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/anagram2.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/loops.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/mounting.jpg">
<meta property="og:image" content="https://iotaa.xyz/images/fenzhi.jpg">
<meta property="og:updated_time" content="2018-07-12T07:58:00.312Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="alg">
<meta name="twitter:description" content="伪多项式时间一个整数是否是素数123def isPrime(n):    for i in range(2,n):        if n mod i 运行时间与数值n的二进制位数呈指数增长整数需要的bit位数x=logn 复杂度$O(2^{x})$每加1位，时间翻倍857 ：‭‭001101011001‬421 ：‭‭000110100101‬ 97 s1和s2是否交错组成s3Solution状">
<meta name="twitter:image" content="https://iotaa.xyz/images/BIT.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://iotaa.xyz/2018/03/24/alg/"/>





  <title>alg | vue&java Mark</title>
  








  <!--prettify代码高亮脚本引入-->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="top-scroll-bar"></div>
<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">vue&java Mark</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iotaa.xyz/2018/03/24/alg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vue&java Mark">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">alg</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T03:07:34+08:00">
                2018-03-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-12T15:58:00+08:00">
                2018-07-12
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="伪多项式时间"><a href="#伪多项式时间" class="headerlink" title="伪多项式时间"></a>伪多项式时间</h3><p>一个整数是否是素数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n mod i</span><br></pre></td></tr></table></figure></p>
<p>运行时间与数值n的二进制位数呈指数增长<br>整数需要的bit位数x=logn 复杂度$O(2^{x})$<br>每加1位，时间翻倍<br>857 ：‭‭001101011001‬<br>421 ：‭‭000110100101‬</p>
<h3 id="97-s1和s2是否交错组成s3"><a href="#97-s1和s2是否交错组成s3" class="headerlink" title="97 s1和s2是否交错组成s3"></a>97 s1和s2是否交错组成s3</h3><p><a href="https://leetcode.com/problems/interleaving-string/solution/" target="_blank" rel="noopener">Solution</a><br>状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中<br>任意位置s3[i]一定是由s1[m],s2[n]组成的<br>s1=”aa  bc   c”<br>s2=”  db  bca”<br>s3=”aadbbcbcac”<br>dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况<br>dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况<br>遍历s3的位置：<br>  遍历s1的长度，s3+1-s1为s2的长度<br>    如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了<br>       ||s3当前与s1当前匹配并且dp[s1-1][s2]:<br>         dp[s1][s2] = true<br>可以用滚动数组降成1维</p>
<p>？？？按背包问题递减更新 99%<br>ct的意义<br>动态规划中的ct<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ct = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(s1.length(), i + <span class="number">1</span>); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[j - <span class="number">1</span>] &amp;&amp; s1.charAt(j- <span class="number">1</span>) == s3.charAt(i))&#123;</span><br><span class="line">                dp[j] = <span class="keyword">true</span>;</span><br><span class="line">                ct = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> dp[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ct)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="62-从左上角走到右下角总共有多少种不同方式"><a href="#62-从左上角走到右下角总共有多少种不同方式" class="headerlink" title="62 从左上角走到右下角总共有多少种不同方式"></a>62 从左上角走到右下角总共有多少种不同方式</h3><p>f[m][n] = f[m-1][n]+f[m][n-1]<br>简化成一维dp<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniPath</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="comment">//一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//加上左边走过来的走法</span></span><br><span class="line">            res[j]+=res[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="!数学公式"></a>!数学公式</h4><p>m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。<br>问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。<br>$C_{m+n-2}^{m-1}$<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rst=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;Math.min(m-<span class="number">1</span>,n-<span class="number">1</span>);i++)&#123;</span><br><span class="line">    rst=rst*(m+n-<span class="number">2</span>-i)/(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)rst;</span><br></pre></td></tr></table></figure></p>
<h3 id="63-有障碍物的左上到右下"><a href="#63-有障碍物的左上到右下" class="headerlink" title="63 有障碍物的左上到右下"></a>63 有障碍物的左上到右下</h3><p>dp[i][j]定义为走到i,j的方法数，障碍物则为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obs[i][j]==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//dp[i][j]=0//res[j]=0;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="64-从左上角走到右下角的最少sum"><a href="#64-从左上角走到右下角的最少sum" class="headerlink" title="64 从左上角走到右下角的最少sum"></a>64 从左上角走到右下角的最少sum</h3><p>grid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]);</p>
<h3 id="32-括号字符串中合法的括号对"><a href="#32-括号字符串中合法的括号对" class="headerlink" title="32 括号字符串中合法的括号对"></a>32 括号字符串中合法的括号对</h3><p>1.stack:栈底放-1，当栈空&amp;&amp;读到是’)’将’)’的index当栈底。每次读到’)’弹栈，并更新i-peek()，因为peek为没消掉的’(‘的前一个位置<br>2.从左向右扫描，当左括号数==右括号数更新max，当右括号&gt;左括号置0.<br>  从右向左扫描，同理更新max，当左括号&gt;右括号重置0.</p>
<h3 id="？96-不同的BST数量"><a href="#？96-不同的BST数量" class="headerlink" title="？96 不同的BST数量"></a>？96 不同的BST数量</h3><p>(为什么是乘)<br>1个节点只有1种，2个节点1    2 一共两种<br>                      \  /<br>                      2  1<br>3个节点1      2      3<br>      / \    / \    / \<br>   （0）(2) (1)(1) (2)(0)<br>      1x2  + 1x1  + 2x1<br>左子树有j个节点，右子树有n-j-1个节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//节点个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="comment">//左边j个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        dp[i]+=dp[j]*dp[i-j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure></p>
<h3 id="！95-输出全部不同的BST"><a href="#！95-输出全部不同的BST" class="headerlink" title="！95 输出全部不同的BST"></a>！95 输出全部不同的BST</h3><p>[1~n]组成的BST<br>1…….k…n<br>       / \<br>[1~k-1]  [k+1,n] 与上一层的构建过程是一样的</p>
<h3 id="背包9讲"><a href="#背包9讲" class="headerlink" title="背包9讲:"></a>背包9讲:</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>N个物品，背包容量V<br>F[i,v]前i件物品放入容量v的背包可获得的最大价值。<br>如果放第i件，转化为前i-i件放入容量为v-Ci的背包中，最大价值是F[i-1,v-Ci]+Wi<br>$F[i,v]=max{F[i-1,v],F[i-1,v-C_i]+W_i}$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i&lt;- <span class="number">1</span> to N</span><br><span class="line">  <span class="keyword">for</span> v&lt;- Ci to V</span><br><span class="line">    F[i,v]&lt;-max&#123;F[i<span class="number">-1</span>,v],F[i<span class="number">-1</span>,v-Ci]+Wi&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间/空间复杂度O（VN)<br>1.简化空间-&gt;O(V) 递减顺序计算F[v]，保证计算F[v]时F[v-Ci] 保存的是F[i-1,v-Ci]<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i&lt;- <span class="number">1</span> to N</span><br><span class="line">  <span class="keyword">for</span> v &lt;- V to Ci</span><br><span class="line">    F[v] &lt;- max(F[v],F[v-Ci]+Wi)</span><br></pre></td></tr></table></figure></p>
<p>第二个for可以优化<br>for v&lt;- V to max(V-$\sum_{i}^{N}W_i$,Ci)</p>
<h4 id="taotao要吃鸡"><a href="#taotao要吃鸡" class="headerlink" title="taotao要吃鸡"></a>taotao要吃鸡</h4><p>1.<br>m+h容量背包，在m+h没装满时可以任意取一个超过重量的<br>最外层遍历：最后一个超额的物品i.<br>  计算m+h-1背包容量的最大val<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    ans = max(ans,v[i]+slove(m+h<span class="number">-1</span>),i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> W,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==index)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = W;j&gt;=w[i];j--)&#123;</span><br><span class="line">            dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<br>1.按重量排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m+h;j&gt;=goods[i].w;j--)&#123;</span><br><span class="line">        dp[j] = Math.max(dp[j],dp[j-goods[i].w]+goods[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//强行装的位置,不能填dp[0]，0表示装满了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = Math.min(m+h,goods[i].w-<span class="number">1</span>)j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j],goods[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(dp[m+h]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.初始化F</p>
<ul>
<li><p>恰好装满背包，F[0]=0 其余-∞<br>没有装任务物品时，只有容量为0的背包表示装满，其它容量为非法解。</p>
</li>
<li><p>不用装满，F全部为0<br>任何容量的背包，什么都不装，价值F都为0也是合法解。</p>
</li>
</ul>
<hr>
<h4 id="完全背包-每个物品可用无限次"><a href="#完全背包-每个物品可用无限次" class="headerlink" title="完全背包 每个物品可用无限次"></a>完全背包 每个物品可用无限次</h4><p>简化1.如果Ci&lt;=Cj,Wi&gt;=Wj 则j可以不考虑。<br>简化2.重量大于V的去掉。用计数排序算出v相同的物品中价值最高的那个O(V+N)<br>转化成01背包：将第i种物品拆成重量$C_i2^k$价值为$W_i2^k$ 件数可写成若干个$2^k$件的组合<br>用递增的循环O(VN)：<br> 01背包V&lt;-V to Ci 因为保证选i件物品时F[i-1,v-Ci]是绝对没有选第i件物品的情况<br> 而完全背包的子结果F[i,v-Ci]是<strong>加选一件第i种物品</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i&lt;- <span class="number">1</span> to N</span><br><span class="line">  <span class="keyword">for</span> v&lt;- Ci to V</span><br><span class="line">    F[v]&lt;- max(F[v],F[v-Ci]+Wi)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>两个状态转移方程<br>$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=kC_i&lt;=v}$<br>$F[i,v] = max(F[i-1,v],F[i,v-C_i]+W_i)</li>
</ul>
<h4 id="！416-数组分成两部分（不连续-sum相等。list的总sum为奇数则不可能。"><a href="#！416-数组分成两部分（不连续-sum相等。list的总sum为奇数则不可能。" class="headerlink" title="！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。"></a>！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">        sum+=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = sum;v&gt;=<span class="number">0</span>;v--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[v]==<span class="number">1</span>)dp[v+n]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[sum/<span class="number">2</span>]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="多重背包-第i种物品最多Mi件可用"><a href="#多重背包-第i种物品最多Mi件可用" class="headerlink" title="多重背包 第i种物品最多Mi件可用"></a>多重背包 第i种物品最多Mi件可用</h4><p>$F[i,v] = max{F[i-1,v-kC_i]+kW_i|0&lt;=k&lt;=Mi}</p>
<h3 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h3><p>以1为首位的数组数显的概率为30%</p>
<h3 id="正确二分查找的写法"><a href="#正确二分查找的写法" class="headerlink" title="正确二分查找的写法"></a>正确二分查找的写法</h3><p>1.查找范围是 [0,len-1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r=n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;target)&#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        r=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果l&gt;r</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>2.[0,len) 保持len取不到<br>好处：len就是长度[a,a+len)，[a,b)+[b,c)=[a,c),[a,a)是空的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]==target)<span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid]&gt;target)&#123;</span><br><span class="line">        <span class="comment">//在左边，边界为取不到的数</span></span><br><span class="line">        r=mid;<span class="comment">//[l,mid)</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//左闭又开</span></span><br><span class="line">        l = mid+<span class="number">1</span>;<span class="comment">//[mid+1,r)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果l==r [1,1)表示空的</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="307"><a href="#307" class="headerlink" title="307"></a>307</h3><h4 id="Binary-Index-Tree"><a href="#Binary-Index-Tree" class="headerlink" title="Binary Index Tree"></a>Binary Index Tree</h4><p>与dp不同，dp[i]存储了前i个的总和 e只存部分<br><a href="https://visualgo.net/bn/fenwicktree" target="_blank" rel="noopener">visualgo可视化</a><br>1.update树<br>每个叶子节点的父节点的计算方法i+lowbit(i)<br>1的父节点=001+001=010<br>2的父节点=010+010=100==4<br>4的父节点=100+100 = 1000==8</p>
<hr>
<p>最低位：lowbit(5) = 101&amp;((010+1)==011)=001<br>5的父节点=101+001=110==6<br>沿着path向上更新，最多只会更新logn(树高个节点)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dif = val-nums[i];</span><br><span class="line">    nums[i++]=val;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;e.length)&#123;</span><br><span class="line">        e[i]+=dif;</span><br><span class="line">        i+=(i&amp;-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/BIT.jpg" alt="BIT"><br>2.sum树 前7个元素的和=7+11+10<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=e[i];</span><br><span class="line">        i-=(i&amp;-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(j+<span class="number">1</span>)-query(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>k=末尾零个数</th>
<th>二进制末尾有k个0则e[i] 是2^k个元素的和</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 -&gt; 1</td>
<td>e[1]=a[1]</td>
</tr>
<tr>
<td>2 -&gt; 10</td>
<td>e[2]=a[1]+a[2]</td>
</tr>
<tr>
<td>3 -&gt; 11</td>
<td>e[3]=a[3]</td>
</tr>
<tr>
<td>4 -&gt; 100</td>
<td>e[4]=a[1]+a[2]+a[3]+a[4] = e[2]+e[3]+a[4]</td>
</tr>
<tr>
<td>5 -&gt; 101</td>
<td>e[5]=a[5]</td>
</tr>
<tr>
<td>6 -&gt; 110</td>
<td>e[6] = e[5]+e[6]</td>
</tr>
<tr>
<td>7 -&gt; 111</td>
<td>e[7] = a[7]</td>
</tr>
<tr>
<td>8 -&gt; 1000</td>
<td>e[8] = e[4]+e[6]+e[7]+a[8]</td>
</tr>
</tbody>
</table>
<h4 id="315-输出数组每个位置后有多少个数字比它小"><a href="#315-输出数组每个位置后有多少个数字比它小" class="headerlink" title="315 输出数组每个位置后有多少个数字比它小"></a>315 输出数组每个位置后有多少个数字比它小</h4><h3 id="80-数组每个元素只保留-lt-2次"><a href="#80-数组每个元素只保留-lt-2次" class="headerlink" title="80 数组每个元素只保留&lt;=2次"></a>80 数组每个元素只保留&lt;=2次</h3><p>cnt表示插入位置，i用于遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]!=nums[cnt-<span class="number">2</span>])&#123;</span><br><span class="line">        nums[cnt++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="节点是随机变量的有向无环图-贝叶斯网络BN"><a href="#节点是随机变量的有向无环图-贝叶斯网络BN" class="headerlink" title="节点是随机变量的有向无环图=贝叶斯网络BN"></a>节点是随机变量的有向无环图=贝叶斯网络BN</h3><p>求联合概率会用到最小生成树</p>
<ol>
<li>如果84*148=B6A8成立，则公式采用的是__进制表示的<br>(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8<br>=&gt;(3x^2+6x+2)(x-12)=0<br>=&gt;x=12</li>
</ol>
<ul>
<li>快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数<br>24表示在这种进制下个位应该为0</li>
</ul>
<p>逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A</p>
<p>树的前/中/后序遍历本质都是DFS</p>
<p>无向图的连通分量可以用并查集（集合）来做<br>并查集：[12,3,4,5]-&gt;[6,2,3,4,5]位置存放的是根节点</p>
<h3 id="452-重叠线段"><a href="#452-重叠线段" class="headerlink" title="452 重叠线段"></a>452 重叠线段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//按结束顺序排序不会出现</span></span><br><span class="line"><span class="comment">//  |__|     只有：  |___| 和 |____|</span></span><br><span class="line"><span class="comment">//|______|的情况  |____|       |_|</span></span><br><span class="line">Arrays.sort(points,(a,b)-&gt;a[<span class="number">1</span>]&gt;b[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = points[i][<span class="number">1</span>];</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">while</span>(i+<span class="number">1</span>&lt;points.length&amp;&amp;points[i+<span class="number">1</span>][<span class="number">0</span>]&lt;=cur&amp;&amp;cur&lt;=points[i+<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br></pre></td></tr></table></figure>
<p>前一个的end在i+1的线段中，则跳过。<br>问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 402 去掉数字串中k个数字留下最小的数字</span><br><span class="line">Input: num = &quot;1432219&quot;, k = 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">找最小数字：从高位，越高位越小的数。</span><br><span class="line">算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉</span><br><span class="line">用栈，下一个位置比栈顶小，则把栈顶换掉。</span><br><span class="line">注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。</span><br><span class="line">```java</span><br><span class="line">num=&quot;1234567890&quot;;</span><br><span class="line">k=9;</span><br><span class="line">for(int i =0;i&lt;len;i++)&#123;</span><br><span class="line">    // len=10,k=9  但是0比所有前9个都小，则</span><br><span class="line">while(top!=0&amp;&amp;num.charAt(i)&lt;stack[top-1]&amp;&amp;k&gt;0)&#123;</span><br><span class="line">    top--;</span><br><span class="line">    k--;   </span><br><span class="line">    &#125;</span><br><span class="line">    //0覆盖掉1 之后截取stack中len-k=1长度并且去掉0</span><br><span class="line">    stack[top++]=num.charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="欧拉图：一笔画"><a href="#欧拉图：一笔画" class="headerlink" title="欧拉图：一笔画"></a>欧拉图：一笔画</h3><p>经过所有顶点、所有边的<strong>闭路径</strong>（边不重复，允许顶点重复）</p>
<p>欧拉路径：<br>经过所有顶点，所有边的路径（边不重复，顶点重复） 不是闭路径（不需要回到原地）。</p>
<p>欧拉图判定条件：<br>无向图：G是连通的，所有顶点的度都是偶数。<br>有向图：G弱连通，每个顶点的出度和入度相等</p>
<p>欧拉路径判定条件：<br>无向图：G连通，恰有两个顶点的度是奇数。从一个奇数顶点出发，到另一个奇数度顶点结束。<br>有向图：G连通，恰两个顶点出度入度不相等，其实于出度多1的终结与入度多1的。</p>
<h3 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h3><p>一条经过所有顶点的回路（不要求经过所有边）</p>
<p>哈密顿通路：经过所有顶点的通路，不要求回路</p>
<p>充分条件：<br>满足： 是哈密顿图</p>
<h3 id="236-最低的二叉树公共祖先"><a href="#236-最低的二叉树公共祖先" class="headerlink" title="236 最低的二叉树公共祖先"></a>236 最低的二叉树公共祖先</h3><p>终止条件<code>root==null|root==q||root=p</code></p>
<ol>
<li>在左/右子树找p|q，两边都能找到一个值（因为值不重复） 则返回当前root</li>
<li>如果左边没找到p|q，右边找到了p|q，最低的祖先就是找到的p|q，(因为保证p|q一定在树中)</li>
</ol>
<h3 id="222-完全二叉树的节点数"><a href="#222-完全二叉树的节点数" class="headerlink" title="222 完全二叉树的节点数"></a>222 完全二叉树的节点数</h3><p><a href="https://blog.csdn.net/jmspan/article/details/51056085" target="_blank" rel="noopener">83%</a></p>
<h3 id="DLS可以达到BFS一样空间的DFS"><a href="#DLS可以达到BFS一样空间的DFS" class="headerlink" title="DLS可以达到BFS一样空间的DFS"></a>DLS可以达到BFS一样空间的DFS</h3><h3 id="139-word-break"><a href="#139-word-break" class="headerlink" title="139 word break"></a>139 word break</h3><p>1.状态：boolean[n+1]长度为i的前缀能否由字典组成<br>2.初始值：[0]=true 空字符串<br>3.转移方程if(dp[i]==true&amp;&amp;dic.contains(sub(i,i+j)))dp[i+j]=true<br>4.结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[j]&amp;&amp;dic.contains(s.substring(j,i)))&#123;</span><br><span class="line">            f[i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[s.length()];</span><br></pre></td></tr></table></figure>
<h3 id="55jump-game"><a href="#55jump-game" class="headerlink" title="55jump game"></a>55jump game</h3><p><a href="https://leetcode.com/problems/jump-game/solution/" target="_blank" rel="noopener">jump game</a><br>i+nums[i]大于lastp表示i位置可以跳到lastp位置。<br>将lastp更新成现在的i。再向前直到lastp变成0，表示0位置可以到下一个lastp一直到len-1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lastp = len-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">if</span>(i+nums[i]&gt;=lastp)lastp==i;</span><br><span class="line"><span class="keyword">return</span> lastp==<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="45-jump-game最少跳跃次数"><a href="#45-jump-game最少跳跃次数" class="headerlink" title="45 jump game最少跳跃次数"></a>45 jump game最少跳跃次数</h3><p>1.在本次可跳跃的长度范围内如果不能达到len-1则表示一定要跳跃<br>2.BFS</p>
<h3 id="322找钱最少硬币数"><a href="#322找钱最少硬币数" class="headerlink" title="322找钱最少硬币数"></a>322找钱最少硬币数</h3><p>贪心算法一般考举反例。<br>不能用贪心的原因：如果coin={1,2,5,7,10}则使用2个7组成14是最少的，贪心不成立。<br>满足贪心则需要coin满足倍数关系{1,5,10,20,100,200}</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3 (11 = 5 + 5 + 1)<br>1.递归mincoins(coins,11)=mincoins(coins,11-1)+1=(mincoins,10-1)+1+1..=(mincoins,0)+n<br><img src="/images/coin.jpg" alt="coin"></p>
<p>2.dp:<br>    1初始化table[amount+1]={0,max,max…}<br>    2table[5]=table[0]对每个coin重填整行表格<br>    3if(amount&gt;=coin)dp[amoun]+=dp[amount-coin]<br>3.dfs分支限界<br>    1.逆序coins数组 贪心从大硬币开始试</p>
<p>定义dp[i][j]用前i种硬币达到amount[j]最少的硬币数量<br>用1，2，5组成11的数量=只用1,2组成11的数量+1，2，5组成[11-5]<br>1.dp[i][j]=min(dp[i][j],dp[i-1][j-k<em>coin[i]]+k)：[i-1]不用这枚硬币之前能够到加上k枚i硬币达到amount[J]。需要遍历n.复杂度n\</em>amount^2<br>2.不需要遍历几枚硬币dp[i][j]=min(dp[i][j],dp[i][j-coin[i]]+1).复杂度n*amount 降成了一维。dp[i]=dp[i-coin[i]]+1<br>基础：dp[amount] 当amount=0时，dp=0;当coin有1时dp[i]=i</p>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ol>
<li>最小割 st-cut 去掉这几条边，源点S和终点T就会被分为两个不相交的set，S到不了T。这种边集的最小值<br>断掉两点间的通信的最小代价。</li>
<li>最大流max-flow 边的流量小于capacity。每个点的入流和出流相等。除了源点S和终点T。求源点/终点能发出/接收的最大值。</li>
</ol>
<p>其实可以是一个问题。</p>
<h4 id="Ford-fulkerson算法"><a href="#Ford-fulkerson算法" class="headerlink" title="Ford-fulkerson算法"></a>Ford-fulkerson算法</h4><p>1 先假设每条边的当前流量是0/capacity<br>2 找到S到T的路径，并最大化这条路径上的空的边的当前流量<br>3 继续找路径，如果可以通过一条边的反向到达T，经过的是一条边的反向流，则减少这条边逆向流过去。<br>4 每条边到达正向包和或者负向为0 不能remove from backward edge</p>
<h4 id="flow-value-lemma-最小cut上的流量-最大网络流"><a href="#flow-value-lemma-最小cut上的流量-最大网络流" class="headerlink" title="flow value lemma :最小cut上的流量 == 最大网络流"></a>flow value lemma :最小cut上的流量 == 最大网络流</h4><p>flow &lt;= capacity of cut<br>max flw == min cut</p>
<h4 id="已知最大流-cur-capacity-求cut"><a href="#已知最大流-cur-capacity-求cut" class="headerlink" title="已知最大流(cur/capacity) 求cut"></a>已知最大流(cur/capacity) 求cut</h4><p>从S点 正向走最不满的正向流。走最满的逆向流，满正向流和空逆向流当作不存在。</p>
<h4 id="如何找augmenting-path-BFS"><a href="#如何找augmenting-path-BFS" class="headerlink" title="如何找augmenting path BFS"></a>如何找augmenting path BFS</h4><p>如果容量都是integer<br>number of augemntation &lt;= maxflow value 每次增加至少1</p>
<h3 id="TrieNode字典树-find-insert复杂度为字符串商都"><a href="#TrieNode字典树-find-insert复杂度为字符串商都" class="headerlink" title="TrieNode字典树 find/insert复杂度为字符串商都"></a>TrieNode字典树 find/insert复杂度为字符串商都</h3><p>结点保存子节点（指针）的目录[26]下一个字符<br>和结点是否终止boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct TrieNode&#123;</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">boolean</span> terminal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以把terminal变成int用<code>map&lt;String,int&gt;</code>表示字典树</p>
<h3 id="后缀树字典树-每层多一个字符的字典树"><a href="#后缀树字典树-每层多一个字符的字典树" class="headerlink" title="后缀树字典树 每层多一个字符的字典树"></a>后缀树字典树 每层多一个字符的字典树</h3><h3 id="后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><a href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2" class="headerlink" title="后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)"></a>后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</h3><h3 id="后缀数组-A-后缀的起始位置"><a href="#后缀数组-A-后缀的起始位置" class="headerlink" title="后缀数组 A[]后缀的起始位置"></a>后缀数组 A[]后缀的起始位置</h3><p>“alohomora”<br>1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”<br>2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀<br>  [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra<br>  A[i]的i是字典序的i，值是真实位置<br>  例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8);</p>
<h4 id="生成后缀数组"><a href="#生成后缀数组" class="headerlink" title="生成后缀数组"></a>生成后缀数组</h4><p>Manber-Myers O(n)但是太复杂</p>
<p>排序后缀目录：桶排序</p>
<h3 id="Aho-Corasick"><a href="#Aho-Corasick" class="headerlink" title="Aho-Corasick"></a>Aho-Corasick</h3><p>1添加失败链接<br>2缝衣针字符串序号数组</p>
<h3 id="A-B两人选k种可乐达到期望最大"><a href="#A-B两人选k种可乐达到期望最大" class="headerlink" title="A,B两人选k种可乐达到期望最大"></a>A,B两人选k种可乐达到期望最大</h3><p>A选m个，B选(n-m)个<br>每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大<br>输出 买k种可乐的数量<br>期望和：$m/n<em>a+(m-n)/n</em>b$的最大值 全部买期望最大那种<br>输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1<br>m/n=.5<br>0.5x1+0.5x2=0.5+1=1.5<br>0.5x3+0.5x1 = 2  全部买第二种可乐<br>输出:0 2</p>
<h3 id="火车换乘"><a href="#火车换乘" class="headerlink" title="火车换乘"></a>火车换乘</h3><p>保证每个车错过能在30分钟以后换车<br>输入：城市n 火车数m<br>from1 to3 cost800 18:00 21:00<br>…<br>输出从1到n的最小花费</p>
<h3 id="16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><a href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16" class="headerlink" title="16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16"></a>16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</h3><p>A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)<em>(P(C进入1/8)</em>P(A赢了C)+P(D进入1/8)*P(A赢了D))<br>A进入1/2需要赢没比过的另外4个队<br>A变成冠军需要赢没比过的另外8个队<br>分组问题：如果1/4赛 1234 5678是一组4个是一组<br>如果1/2赛  8个是一组<br><img src="/images/shijiebei.jpg" alt="shijiebei"><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span> inergroup = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"> <span class="keyword">int</span> group= <span class="number">1</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">16</span> ; j++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">16</span>;k++) &#123;</span><br><span class="line">    <span class="comment">//在同一个大组</span></span><br><span class="line">    <span class="keyword">if</span>(j/group==k/group) &#123;</span><br><span class="line">    <span class="comment">//不在同一个小组</span></span><br><span class="line">    <span class="keyword">if</span> (j / inergroup != k / inergroup) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] * dp[i - <span class="number">1</span>][k] * p[j][k];</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>第一轮：1进入1/8赢的概率是[1][2] 1打败2的概率=0.133<br>第二轮：1赢了1/8进入1/4赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1在第2轮的获胜概率是0加上1在上一轮胜利的概率0.133 ×3在上一轮获胜的概率0.335×1赢3的概率0.21</span><br><span class="line">1 2 0.00935655</span><br><span class="line">1在第2轮的获胜概率是0.00935655加上1在上一轮胜利的概率0.133 ×4在上一轮获胜的概率0.665×1赢4的概率0.292</span><br><span class="line">1 2 0.0351825</span><br></pre></td></tr></table></figure></p>
<p>第三轮：1赢了1/4在1/2半决赛赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1在第3轮的获胜概率是0加上1在上一轮胜利的概率0.0351825 ×5在上一轮获胜的概率0.336947×1赢5的概率0.67</span><br><span class="line">1 3 0.00794261</span><br><span class="line">1在第3轮的获胜概率是0.00794261加上1在上一轮胜利的概率0.0351825 ×6在上一轮获胜的概率0.198831×1赢6的概率0.27</span><br><span class="line">1 3 0.00983136</span><br><span class="line">1在第3轮的获胜概率是0.00983136加上1在上一轮胜利的概率0.0351825 ×7在上一轮获胜的概率0.0229419×1赢7的概率0.953</span><br><span class="line">1 3 0.0106006</span><br><span class="line">1在第3轮的获胜概率是0.0106006加上1在上一轮胜利的概率0.0351825 ×8在上一轮获胜的概率0.44128×1赢8的概率0.353</span><br><span class="line">1 3 0.016081</span><br></pre></td></tr></table></figure></p>
<p>第四轮：1赢了1/2变成冠军的概率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1在第4轮的获胜概率是0加上1在上一轮胜利的概率0.016081 ×9在上一轮获胜的概率0.0606261×1赢9的概率0.328</span><br><span class="line">1 4 0.000319777</span><br><span class="line">1在第4轮的获胜概率是0.000319777加上1在上一轮胜利的概率0.016081 ×10在上一轮获胜的概率0.0113548×1赢10的概率0.128</span><br><span class="line">1 4 0.000343149</span><br><span class="line">1在第4轮的获胜概率是0.000343149加上1在上一轮胜利的概率0.016081 ×11在上一轮获胜的概率0.203126×1赢11的概率0.873</span><br><span class="line">1 4 0.00319478</span><br><span class="line">1在第4轮的获胜概率是0.00319478加上1在上一轮胜利的概率0.016081 ×12在上一轮获胜的概率0.147508×1赢12的概率0.082</span><br><span class="line">1 4 0.00338929</span><br><span class="line">1在第4轮的获胜概率是0.00338929加上1在上一轮胜利的概率0.016081 ×13在上一轮获胜的概率0.160952×1赢13的概率0.771</span><br><span class="line">1 4 0.00538485</span><br><span class="line">1在第4轮的获胜概率是0.00538485加上1在上一轮胜利的概率0.016081 ×14在上一轮获胜的概率0.0877648×1赢14的概率0.3</span><br><span class="line">1 4 0.00580826</span><br><span class="line">1在第4轮的获胜概率是0.00580826加上1在上一轮胜利的概率0.016081 ×15在上一轮获胜的概率0.240971×1赢15的概率0.405</span><br><span class="line">1 4 0.00737766</span><br><span class="line">1在第4轮的获胜概率是0.00737766加上1在上一轮胜利的概率0.016081 ×16在上一轮获胜的概率0.0876971×1赢16的概率0.455</span><br><span class="line">1 4 0.00801932</span><br></pre></td></tr></table></figure></p>

</div></div></p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。<br>1 子序列 不连续 2 字串 连续<br>KMP:getIndexOf<br>d之前【最长前缀】和【最长后缀】的匹配长度<br>(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)<br>所以最长匹配是3：abc,记录在d位置上<br>int[]next =  f(“abcabcd”)={-1,0,0,1，2，3}<br>关键加速求解匹配</p>
<h3 id="90-有重复的subset-1-2-2-2"><a href="#90-有重复的subset-1-2-2-2" class="headerlink" title="90 有重复的subset[1,2,2,2]"></a>90 有重复的subset[1,2,2,2]</h3><ol>
<li>选不同的2得到{1,2}是重复的</li>
<li>次序不同得到{1,2},{2,1}是重复的<br>先排序，再去重。</li>
</ol>
<h3 id="78-subset-1-2-3-gt-1-1-2-1-2-3-2-3-2-3"><a href="#78-subset-1-2-3-gt-1-1-2-1-2-3-2-3-2-3" class="headerlink" title="78 subset[1,2,3]-&gt;[1][1,2][1,2,3][2,3][2][3]"></a>78 subset[1,2,3]-&gt;[1][1,2][1,2,3][2,3][2][3]</h3><p>回溯法：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    back(rst,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rst,List&lt;Integer&gt; item,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rst.add(<span class="keyword">new</span> ArrayList&lt;&gt;(item));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =index;i&lt;nums.length;i++)&#123;</span><br><span class="line">        item.add(nums[i]);</span><br><span class="line">        <span class="comment">//1.当i=2+1==nums.length 则回到上一层i=2,remove</span></span><br><span class="line">        back(rst,item,nums,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2.结束了back(,,2)并去掉了&#123;3&#125; </span></span><br><span class="line">        <span class="comment">//3回到back(,,index=1)并去掉了[2] item里只有1，</span></span><br><span class="line">        <span class="comment">//  i++ 添加[3]-&gt;rst.add(&#123;1,3&#125;)</span></span><br><span class="line">        <span class="comment">//4.结束back(,,index=1)回到index=0 remove 0 index=1 add&#123;2&#125; back</span></span><br><span class="line">        item.remove(item.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>位运算法 集合每一项可以用0，1表示取不取<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 从000到111的过程<br>{A,B,C}=111=7<br>{A,B}=110=6<br>{A}=100=5…<br>一共有2^3种<br>A用100表示<br>B用010表示<br>C用001表示<br>如果i=011=3,添加j=0,001,j=1,010到item；i=100=4,添加j==2,1&lt;&lt;2=4<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  <span class="keyword">int</span> setnum = <span class="number">1</span>&lt;&lt;nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;setnum;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;j))!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                item.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rst.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="815-换公交"><a href="#815-换公交" class="headerlink" title="815 换公交"></a>815 换公交</h3><p>routes = [[1, 2, 7], [3, 6, 7]]<br>把车routes[0]的路线当成一个连通分量，并分配一个颜色标记<br>BFS相同连通分量标记的点跳过。</p>
<p>数据结构：</p>
<ol>
<li>{站点：list&lt;经过的公交车id&gt;}</li>
<li>list&lt;公交车id&gt; 标记已经乘过的公交</li>
<li>BFS连通分量<code>while(!que.empty)</code>，<br> 遍历一辆车的连通分量<code>while(que.size()&gt;0)</code><br> 遍历当前节点相邻的busid是否乘过<code>for(int car:list)，</code><br> 并标记这个车的连通分量已乘过，遍历这个连通分量<code>for(int t:routes[car])</code>中有没有T，有则结束，没有则将整个连通分量入队。</li>
</ol>
<h3 id="fib"><a href="#fib" class="headerlink" title="fib"></a>fib</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    num++;<span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == -<span class="number">1</span>)memo[n] = fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-数组index当底边，值当杯子两侧，最大面积"><a href="#11-数组index当底边，值当杯子两侧，最大面积" class="headerlink" title="11 数组index当底边，值当杯子两侧，最大面积"></a>11 数组index当底边，值当杯子两侧，最大面积</h3><h3 id="！30-字典中单词连续出现在字符串中的位置-AC自动机（？"><a href="#！30-字典中单词连续出现在字符串中的位置-AC自动机（？" class="headerlink" title="！30 字典中单词连续出现在字符串中的位置 AC自动机（？"></a>！30 字典中单词连续出现在字符串中的位置 AC自动机（？</h3><p>加入字典的常用写法<code>dict.put(word,dict.getOrDefault(word,0)+1)</code><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), m = words.length, k;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span> || (k = words[<span class="number">0</span>].length()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Integer&gt; wDict = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wDict.containsKey(word))</span><br><span class="line">            wDict.put(word, wDict.get(word) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wDict.put(word, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, start, x, wordsLen = m * k;</span><br><span class="line">    HashMap&lt;String, Integer&gt; curDict = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    String test, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        curDict.clear();</span><br><span class="line">        start = i;</span><br><span class="line">        <span class="keyword">if</span> (start + wordsLen &gt; n)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j + k &lt;= n; j += k) &#123;</span><br><span class="line">            test = s.substring(j, j + k);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (wDict.containsKey(test)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!curDict.containsKey(test)) &#123;</span><br><span class="line">                    curDict.put(test, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    start = checkFound(res, start, wordsLen, j, k, curDict, s);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// curDict.containsKey(test)</span></span><br><span class="line">                x = curDict.get(test);</span><br><span class="line">                <span class="keyword">if</span> (x &lt; wDict.get(test)) &#123;</span><br><span class="line">                    curDict.put(test, x + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    start = checkFound(res, start, wordsLen, j, k, curDict, s);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// curDict.get(test)==wDict.get(test), slide start to</span></span><br><span class="line">                <span class="comment">// the next word of the first same word as test</span></span><br><span class="line">                <span class="keyword">while</span> (!(temp = s.substring(start, start + k)).equals(test)) &#123;</span><br><span class="line">                    decreaseCount(curDict, temp);</span><br><span class="line">                    start += k;</span><br><span class="line">                &#125;</span><br><span class="line">                start += k;</span><br><span class="line">                <span class="keyword">if</span> (start + wordsLen &gt; n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// totally failed up to index j+k, slide start and reset all</span></span><br><span class="line">            start = j + k;</span><br><span class="line">            <span class="keyword">if</span> (start + wordsLen &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            curDict.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkFound</span><span class="params">(List&lt;Integer&gt; res, <span class="keyword">int</span> start, <span class="keyword">int</span> wordsLen, <span class="keyword">int</span> j, <span class="keyword">int</span> k,</span></span></span><br><span class="line"><span class="function"><span class="params">        HashMap&lt;String, Integer&gt; curDict, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start + wordsLen == j + k) &#123;</span><br><span class="line">        res.add(start);</span><br><span class="line">        <span class="comment">// slide start to the next word</span></span><br><span class="line">        decreaseCount(curDict, s.substring(start, start + k));</span><br><span class="line">        <span class="keyword">return</span> start + k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseCount</span><span class="params">(HashMap&lt;String, Integer&gt; curDict, String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// remove key if curDict.get(key)==1, otherwise decrease it by 1</span></span><br><span class="line">    <span class="keyword">int</span> x = curDict.get(key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">        curDict.remove(key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curDict.put(key, x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="3-连续最长不重复子序列"><a href="#3-连续最长不重复子序列" class="headerlink" title="3 连续最长不重复子序列"></a>3 连续最长不重复子序列</h3><p>两指针i从左向右遍历到最后<br>j指示i之前不重复的最高位置。<br>i-j+1为当前最长结果</p>
<h3 id="409-string中字符组成回文串的最大长度"><a href="#409-string中字符组成回文串的最大长度" class="headerlink" title="409 string中字符组成回文串的最大长度"></a>409 string中字符组成回文串的最大长度</h3><p>1.开int[128]，直接用int[char]++计数<br>2.奇数-1变偶数&amp;(~1)<br>3.判断奇数(&amp;1)&gt;0</p>
<h3 id="！5-最长回文串"><a href="#！5-最长回文串" class="headerlink" title="！5 最长回文串"></a>！5 最长回文串</h3><p>bealen[i][j]表示[i]-[j]是回文串<br>反转做法不行:abcxyzcba -&gt; abczyxcba -&gt;相同的abc并不是回文<br>“cba”是“abc”的 reversed copy<br>中心扩展法：回文的中心有奇数：n个，偶数：n-1个位置<br>会输出靠后的abab-&gt;输出bab<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">    len = s.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;<span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// int max = 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//"babad" -&gt;"bab" -&gt;i =1 len = 3   </span></span><br><span class="line">        <span class="comment">//"cbbd" -&gt; "bb" -&gt;i=1 len = 2</span></span><br><span class="line">        <span class="keyword">int</span> len1 = help(s,i,i);<span class="comment">//奇数扩展</span></span><br><span class="line">        <span class="keyword">int</span> len2 = help(s,i,i+<span class="number">1</span>);<span class="comment">//偶数扩展</span></span><br><span class="line">        <span class="keyword">int</span> max = Math.max(len1,len2);</span><br><span class="line">        <span class="keyword">if</span>(max&gt;end-start)&#123;</span><br><span class="line">            start = i - (max-<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//去掉中间那个左边长度的一半</span></span><br><span class="line">            end = i+max/<span class="number">2</span>;<span class="comment">//右边长度的一半</span></span><br><span class="line">        &#125;<span class="comment">//end-start= i+max/2-i+(max-1)/2 = max-1/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);     </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;len&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Manacher’s-算法-O-n"><a href="#Manacher’s-算法-O-n" class="headerlink" title="Manacher’s 算法 O(n)"></a>Manacher’s 算法 O(n)</h4><p>前缀/</p>
<h4 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h4><p><code>next[i][c]</code> 编号为i的节点表示的回文串两边添加c后变成的回文串编号。<br><code>fail[i]</code>节点i失配后<br><code>cnt[i]</code></p>
<h3 id="347桶排序-int数组中最常出现的n个"><a href="#347桶排序-int数组中最常出现的n个" class="headerlink" title="347桶排序 int数组中最常出现的n个"></a>347桶排序 int数组中最常出现的n个</h3><p>桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。</p>
<h3 id="242-Anagram-相同字母的单词"><a href="#242-Anagram-相同字母的单词" class="headerlink" title="242 Anagram 相同字母的单词"></a>242 Anagram 相同字母的单词</h3><h3 id="22-卡特兰数括号"><a href="#22-卡特兰数括号" class="headerlink" title="22 卡特兰数括号"></a>22 卡特兰数括号</h3><p>left括号数量小于n，right括号数量必须小于left不然(()))肯定不合理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;rst.add(s);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(left&gt;<span class="number">0</span>)help(rst,s+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line"><span class="keyword">if</span>(right&lt;<span class="number">0</span>)help(rst,s+<span class="string">")"</span>,left,right+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><ol>
<li>递归的每一帧不够小，尾递归-&gt;栈</li>
<li>先序迭代1：先放入栈右子树再入栈左子树。不能推广到中序、后序遍历qia<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">    x=s.pop();visit(x);</span><br><span class="line">   <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)stack.push(root.right);</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="344-reverse-String"><a href="#344-reverse-String" class="headerlink" title="344 reverse String"></a>344 reverse String</h3><p>转成char数组/位运算做法77%比stringbuilder好</p>
<h3 id="238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><a href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法" class="headerlink" title="238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法"></a>238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</h3><p>left数组：自己左边数的乘积[1,1,2,6]<br>right数组:自己右边的乘积（包括自己）[24,12,4,1]<br>left和right对应位置相乘<br>不用extra space<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span> to n-<span class="number">1</span>)&#123;</span><br><span class="line">    res[i]=res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(n-<span class="number">1</span> to <span class="number">0</span>)&#123;</span><br><span class="line">    res[i]*right;</span><br><span class="line">    right*=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<h3 id="371-不用’-’用位运算完成求和"><a href="#371-不用’-’用位运算完成求和" class="headerlink" title="371 不用’+’用位运算完成求和"></a>371 不用’+’用位运算完成求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = a^b;<span class="comment">//0^0=0,0^1=1,1^1=0 </span></span><br><span class="line">    <span class="keyword">int</span> carry = (a&amp;b)&lt;&lt;<span class="number">1</span>;<span class="comment">//当ab相等的时候需要进位</span></span><br><span class="line">    <span class="comment">//a+b=（a xor b）+ （(a and b) &lt;&lt; 1）</span></span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)<span class="keyword">return</span> getSum(rst,carry);</span><br><span class="line">    <span class="keyword">return</span> rst;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="412-遇到3-5和3-amp-5的倍数变成特定字符"><a href="#412-遇到3-5和3-amp-5的倍数变成特定字符" class="headerlink" title="412 遇到3||5和3&amp;5的倍数变成特定字符"></a>412 遇到3||5和3&amp;5的倍数变成特定字符</h3><p>不用%最快方法!<br>对于CPU取余数的运算相对来说效率很低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,fizz=<span class="number">0</span>,buzz=<span class="number">0</span>;i&lt;=n ;i++)&#123;</span><br><span class="line">          fizz++;</span><br><span class="line">          buzz++;</span><br><span class="line">          <span class="keyword">if</span>(fizz==<span class="number">3</span> &amp;&amp; buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fizz==<span class="number">3</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Fizz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Buzz"</span>);</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ret.add(String.valueOf(i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-3sum-0-荷兰国旗写法3指针"><a href="#15-3sum-0-荷兰国旗写法3指针" class="headerlink" title="15 3sum=0 荷兰国旗写法3指针"></a>15 3sum=0 荷兰国旗写法3指针</h3><p>1p：从0~len-2，3个数的和 右边至少留两个数 sum=0-nums[i]转化成2sum问题<br>去重：当num[i]=num[i-1]:continue<br>另外两个指针从1p往后从len-1往前。<br>去重：预判：nums[low]=nums[low+1]:low++;nums[high]=nums[high-1]:high–;</p>
<h3 id="152-最大子列乘积-保留当前值之前的最大积和最小积"><a href="#152-最大子列乘积-保留当前值之前的最大积和最小积" class="headerlink" title="152 最大子列乘积 保留当前值之前的最大积和最小积"></a>152 最大子列乘积 保留当前值之前的最大积和最小积</h3><p>负数的最小积有潜力变成最大积<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> nextmax = nums[i]*curmax;</span><br><span class="line">    <span class="keyword">int</span> nextmin = nums[i]*curmin;</span><br><span class="line">    curmax=Math.max(Math.max(nextmax,nextmin),nums[i]);</span><br><span class="line">    curmin=Math.min(Math.min(nextmax,nextmin),nums[i]);</span><br><span class="line">    sum = Math.max(curmax,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="818-A加速，R掉头并减速，到指定位置最少需要多少条指令"><a href="#818-A加速，R掉头并减速，到指定位置最少需要多少条指令" class="headerlink" title="818 A加速，R掉头并减速，到指定位置最少需要多少条指令"></a>818 A加速，R掉头并减速，到指定位置最少需要多少条指令</h3><h3 id="551-出现两个以上A或者3个以上L为false"><a href="#551-出现两个以上A或者3个以上L为false" class="headerlink" title="551 出现两个以上A或者3个以上L为false"></a>551 出现两个以上A或者3个以上L为false</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> s.indexOf(<span class="string">"A"</span>)==s.lastIndexOf(<span class="string">"A"</span>) &amp;&amp; s.indexOf(<span class="string">"LLL"</span>) == -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="34"><a href="#34" class="headerlink" title="34"></a>34</h3><p>二分查找获取最左/右边相等的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取最右</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"> <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(nums[mid]&gt;target)j = mid-<span class="number">1</span>;</span><br><span class="line"> <span class="comment">//找到了继续向右找</span></span><br><span class="line"> <span class="keyword">else</span> i =mid;&#125;</span><br><span class="line">rst[<span class="number">1</span>]=j;</span><br></pre></td></tr></table></figure></p>
<h3 id="？698-减枝？DP方法"><a href="#？698-减枝？DP方法" class="headerlink" title="？698 减枝？DP方法"></a>？698 减枝？DP方法</h3><h3 id="239"><a href="#239" class="headerlink" title="239"></a>239</h3><p>Monotonic queue 前后可以修改o(1)，并且可以随机访问<br>维护一个单调递减的序列，读一个窗口输出单调队列的first</p>
<h3 id="476"><a href="#476" class="headerlink" title="476"></a>476</h3><p>前导0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到左边第一个1，然后后面全置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);<span class="comment">//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);<span class="comment">//连续4个1 但是如果位数不够就只有3个1或者更少</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//让全1的无符号右移1格1111-0111得到1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="464-博弈"><a href="#464-博弈" class="headerlink" title="464 博弈"></a>464 博弈</h2><p>A,B玩家轮流从1-10中选数组加到同一个total，让total先大于11的赢.B肯定赢。<br>1.计算1-n个数的permutation，并判断每个赢的可能性复杂度(n!)<br>2.因为1,2…和2,1…是一样的，所以可以降为$2^n$</p>
<h3 id="486-两个人只能从list的两端取数，预测最后谁摸到的点数sum高"><a href="#486-两个人只能从list的两端取数，预测最后谁摸到的点数sum高" class="headerlink" title="486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高"></a>486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高</h3><p>{3，9，1，2}</p>
<ol>
<li>二维数组dp：<code>[i][j]</code>只用右上三角表示两个人都从list取1个数，2个数，3个数到list长能获得的最大差值</li>
<li>填对角线，如果两个人只身下一个数为3：{A取3，B取0}，剩下9：{A取9，B取0}…</li>
<li>如果剩下2个数，剩下{3,9}<code>[1][2]</code>：{A取9，B剩下{3}回到1的情况}…</li>
<li>如果剩下3个数，剩下{3,9,1}<code>[1][3]</code>:{A取3,B剩下{9,1}即表格<code>[2][3]</code>的情况}</li>
<li>剩下4个数，填<code>[1][4]</code>即为答案</li>
</ol>
<p>递归：但是会有很多重复计算复杂度$2^n$<br>比如让对手选[3,9,1]后，自己选[9,1]和[3,9]/让对手选[9,1,2]后，自己选[9,1]和[1,2]<br>[9,1]被计算了两次。可以进行存储<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大的分数差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dif</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果长度为1，获得的差值就是这个数</span></span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="comment">//选一个数之后 交给对手用相同策略选</span></span><br><span class="line">    <span class="keyword">return</span> max(nums[left]-dif(nums,left+<span class="number">1</span>,right),nums[right]-dif(nums,left,right+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用一个数组存储key是<code>left*len+right</code><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m;</span><br><span class="line"><span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.m= <span class="keyword">new</span> <span class="keyword">int</span>[len*len];</span><br><span class="line">  <span class="keyword">return</span> help(nums,<span class="number">0</span>,len-<span class="number">1</span>)&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> nums[l];</span><br><span class="line">    <span class="keyword">int</span> index = l*len+r;</span><br><span class="line">    <span class="keyword">if</span>(m[index]&gt;<span class="number">0</span>)<span class="keyword">return</span> m[index];</span><br><span class="line">    m[index]=Math.max(nums[l]-help(nums,l+<span class="number">1</span>,r),nums[r]-help(nums,l,r-<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> m[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="292"><a href="#292" class="headerlink" title="292"></a>292</h3><h2 id="lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal"><a href="#lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal" class="headerlink" title="lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal"></a>lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal</h2><h3 id="Morris-Inorder-中序-Tree-Traversal"><a href="#Morris-Inorder-中序-Tree-Traversal" class="headerlink" title="Morris Inorder(中序) Tree Traversal"></a>Morris Inorder(中序) Tree Traversal</h3><p><strong>先把每个中缀的前缀（左子树最右）指向中缀，遍历完后把这些链接都删除还原为 null</strong></p>
<ol>
<li>找root的前趋：root 的中序前趋是左子树(第一个左结点)cur的最右标记为pre， pre.right = root<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找前趋</span></span><br><span class="line">Node cur = root;</span><br><span class="line"><span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node pre = current.left;</span><br><span class="line">    <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span>&amp;&amp;pre.right!=cur)&#123;</span><br><span class="line">        pre=pre.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建链接：第一次到达这个最右的结点，cur的左边其实还有结点</span></span><br><span class="line"><span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">  pre.right = cur;</span><br><span class="line">  cur=cur.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>找root.left的前趋：cur向左（相当于新的root（1）的状态），找到cur的最右，标识成pre.right = cur</li>
<li><p>当cur向左是null则找到中序遍历的第一个输出，cur向右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">    sout(current.val);</span><br><span class="line">    current=current.right;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当cur的left==null并且右链接已经建立到上一层。cur移动到上一层，找到前趋pre就是右链接的cur.left。 把这个右链接(pre.right)删除，输出（中），然后继续向右（上）并删除这种从前趋right过来的线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pre.right=cur</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pre.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">  pre.right = <span class="keyword">null</span>;</span><br><span class="line">  sout(cur.val);</span><br><span class="line">  cur=cur.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a>Convert BST to Greater Tree</h3><p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/solution/" target="_blank" rel="noopener">17ms 66% Reverse Morris In-order Traversal</a><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//最右 </span></span><br><span class="line">        <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sum+=cur.val;</span><br><span class="line">            cur.val=sum;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//找前继，键link</span></span><br><span class="line">            TreeNode pre = cur.right;</span><br><span class="line">            <span class="comment">//一直向左</span></span><br><span class="line">            <span class="keyword">while</span>(pre.left!=<span class="keyword">null</span>&amp;&amp;pre.left!=cur)&#123;</span><br><span class="line">                pre=pre.left;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//找到了pre 联立链接</span></span><br><span class="line">            <span class="keyword">if</span>(pre.left== <span class="keyword">null</span>)&#123;</span><br><span class="line">               pre.left = cur;</span><br><span class="line">               cur=cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右边没了，并且左连接向上</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre.left=<span class="keyword">null</span>;</span><br><span class="line">                sum+=cur.val;</span><br><span class="line">                cur.val= sum;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div></div><br>正常做法递归中序 15ms 99%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">convertBST(root.right);</span><br><span class="line">sum+=root.val;</span><br><span class="line">root.val=sum;</span><br><span class="line">convertBST(root.left);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="110-判断树平衡-在计算高度时同时判断平衡只需要O-n"><a href="#110-判断树平衡-在计算高度时同时判断平衡只需要O-n" class="headerlink" title="110 判断树平衡 在计算高度时同时判断平衡只需要O(n)"></a>110 判断树平衡 在计算高度时同时判断平衡只需要O(n)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> balance =<span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isbalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    height(root);</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)balance = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)<br>与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况<br>2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间</p>
<h2 id="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><a href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树" class="headerlink" title="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"></a>红黑树：将3-结点变成左二叉树，将2-3变成二叉树</h2><p>有二叉树高效查找和2-3树高效平衡插入<br>红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$</p>
<p>插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转）</p>
<h2 id="581-需要排序的最小子串，整个串都被排序了-递增"><a href="#581-需要排序的最小子串，整个串都被排序了-递增" class="headerlink" title="581 需要排序的最小子串，整个串都被排序了 递增"></a>581 需要排序的最小子串，整个串都被排序了 递增</h2><p><img src="/images/lc581.jpg" alt="lc581"><br>40大于35，只排序到右边遍历过来第一个<code>n&lt;n-1</code>是不够的<br>要找到[30~31]中的min和max<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fid</span><span class="params">(<span class="keyword">int</span>[]A)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,3,2,2,2</span></span><br><span class="line">    <span class="keyword">int</span> n = A.length, beg = -<span class="number">1</span>, end = -<span class="number">2</span>, min = A[n-<span class="number">1</span>], max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        max = Math.max(max, A[i]);<span class="comment">//从前往后，找到最大值max=3</span></span><br><span class="line">        min = Math.min(min, A[n-<span class="number">1</span>-i]);<span class="comment">//从后往前找到最小值min=2</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; max) end = i; <span class="comment">//a=2&lt;3 end = 2-&gt;3-&gt;4 直到找到a[i]&gt;max</span></span><br><span class="line">        <span class="keyword">if</span> (A[n-<span class="number">1</span>-i] &gt; min) beg = n-<span class="number">1</span>-i;<span class="comment">//begin =1 直到找到a[i]&lt;min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end - beg + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136 Single Number"></a>136 Single Number</h2><p>异或 0^12=12,12^12=0<br><a href="https://leetcode.com/articles/single-number/" target="_blank" rel="noopener">single number</a><br>$$2(a+b+c)-(a+a+b+b+c)$$ <code>2*sum(set(list))-sum(list)</code></p>
<h2 id="438-Anagrams-in-a-String-滑动窗口"><a href="#438-Anagrams-in-a-String-滑动窗口" class="headerlink" title="438 Anagrams in a String 滑动窗口"></a>438 Anagrams in a String 滑动窗口</h2><p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem." target="_blank" rel="noopener">Sliding Window algorithm</a><br><img src="/images/anagram.jpg" alt="anagram"><br><img src="/images/anagram2.jpg" alt="anagram2"><br>两个数组一样，则找到index，不一样，则窗口向前滑动一哥<br>输出0，1，4<br>s: “cbaebabacd” p: “abc” 顺序无关，连续出现在s中<br>Output:<br>[0, 6]</p>
<blockquote>
<p><strong>Anagram</strong> result of [rearranging the letter of a word to produce a new word using all the orginal letters exactly once]<br>1) The first count array store frequencies of characters in pattern.<br>2) The second count array stores frequencies of characters in current window of text.</p>
</blockquote>
<h2 id="141链表环检测"><a href="#141链表环检测" class="headerlink" title="141链表环检测"></a>141链表环检测</h2><p>空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针<br>最坏情况，快指针和慢指针相差环长q -1步<br><div><div class="fold_hider"><div class="close hider_title">cpp练习</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        auto slow = head;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="142-环起始于哪个node"><a href="#142-环起始于哪个node" class="headerlink" title="142 环起始于哪个node"></a>142 环起始于哪个node</h3><p><img src="/images/loops.jpg" alt="loops"><br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;3 meet:6<br>a: 从head到环<br>b：快指针走了两次的环内距离(慢指针到环起点的距离)<br>c: 慢指针没走完的环内距离<br>已知快指针走的距离是slow的两倍<br>慢=a+b  快=a+2b+c<br>则a=c<br>从len(head - 环起点) == 慢指针没走完的环距离<br>head与慢指针能在环起点相遇。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=slow)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="160-链表相交于哪一点"><a href="#160-链表相交于哪一点" class="headerlink" title="160 链表相交于哪一点"></a>160 链表相交于哪一点</h2><p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val<br>思路2：将a,b连成m+n长的链表遍历两遍<br>      a1 → a2  c1 → c2 → c3 -null- b1 → b2 → b3  c1 → c2 → c3<br>             // ↘<br>             //   c1 → c2 → c3<br>              // ↗<br>      b1 → b2 → b3  c1 → c2 → c3 -null- a1 → a2  c1 → c2 → c3<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            ListNode a = headA;</span><br><span class="line">            ListNode b = headB;</span><br><span class="line">            <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="keyword">null</span>)&#123;a=headB;&#125;<span class="keyword">else</span>&#123;a=a.next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="keyword">null</span>)&#123;b=headA;&#125;<span class="keyword">else</span>&#123;b=b.next;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h2 id="168"><a href="#168" class="headerlink" title="168"></a>168</h2><p>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>…<br>26 -&gt; Z<br>27 -&gt; AA<br>28 -&gt; AB<br>递归26进制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="string">""</span> : convertToTitle(--n / <span class="number">26</span>) + (<span class="keyword">char</span>)(<span class="string">'A'</span> + (n % <span class="number">26</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="169-众数-Boyer-Moore-Voting-Algorithm"><a href="#169-众数-Boyer-Moore-Voting-Algorithm" class="headerlink" title="169 众数 Boyer-Moore Voting Algorithm"></a>169 众数 Boyer-Moore Voting Algorithm</h2><p>每次取两个不同的数删除，最后剩下的返回<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                res=e;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(res!=e)&#123;</span><br><span class="line">                    count--;<span class="comment">//删除这个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h1 id="搜索算法的优化"><a href="#搜索算法的优化" class="headerlink" title="搜索算法的优化"></a>搜索算法的优化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>8数码（9宫格拼图) 移动序列，树搜索：每个移动状态为节点，边为状态转移。</li>
<li>哈密顿环：从一个点出发经过所有的点1次回到原点。</li>
<li>子集的合 S={} 求sum(S’)=num ：树搜索，栈，深度优先<blockquote>
<p>搜索速度：广度优先 最优解 ；深度优先:存在问题，可行解。（得遍历完整个空间得到最优）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>？？？空间：深度栈：多项式； 广度优先队列：最坏指数</p>
</blockquote>
<h2 id="1-爬山：局部贪心，快速找到可行解，局部最优"><a href="#1-爬山：局部贪心，快速找到可行解，局部最优" class="headerlink" title="1. 爬山：局部贪心，快速找到可行解，局部最优"></a>1. 爬山：局部贪心，快速找到可行解，局部最优</h2><ul>
<li>8数码:启发函数：当前状态和目标状态的距离：错位方块个数。<ol>
<li>深度优先<br><img src="\images\mounting.jpg" alt="mounting"></li>
<li>每次将当前节点S的子节点按启发式函数由大到小压入栈</li>
</ol>
</li>
</ul>
<h3 id="Best-First搜索：全局最优贪心"><a href="#Best-First搜索：全局最优贪心" class="headerlink" title="Best-First搜索：全局最优贪心"></a>Best-First搜索：全局最优贪心</h3><ul>
<li>当前所有可扩展节点中启发函数最优点</li>
<li>用堆</li>
</ul>
<h3 id="分支界限：组合优化"><a href="#分支界限：组合优化" class="headerlink" title="分支界限：组合优化"></a>分支界限：组合优化</h3><ul>
<li>多阶段图搜索：最短路径<ul>
<li>爬山与BF算法得到最优解都需要遍历整个空间</li>
</ul>
<ol>
<li>用爬山生成界限(可行解or最优解的上限)<br><img src="\images\fenzhi.jpg" alt="fenzhi"></li>
</ol>
</li>
</ul>
<h1 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h1><h2 id="Rabin-Karp"><a href="#Rabin-Karp" class="headerlink" title="Rabin-Karp"></a>Rabin-Karp</h2><p>O(MN)</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h3 id="1-枚举："><a href="#1-枚举：" class="headerlink" title="1. 枚举："></a>1. 枚举：</h3><ol>
<li><p>小于N的完美立方 $a^3=b^3+c^3+d^3$</p>
<blockquote>
<p>按a的值从小到大输出a&gt;b&gt;c&gt;d</p>
</blockquote>
<ul>
<li>a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1]</li>
</ul>
</li>
<li><p>生理周期</p>
<blockquote>
<p>A周期23天，B周期28天，C周期31天<br>给定三个高峰p,e,i;求给定日子d后下一次三次高峰同一天还有多少天。 输出天数小于21252.<br>输入：0 0 0 0</p>
</blockquote>
<ul>
<li>k=[d+1,21252] ;(k-p)%23,(k-e)%28,(k-i)%31==0<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=d+<span class="number">1</span>;(k-p)%<span class="number">23</span>;++k); <span class="comment">//找到第一个高峰</span></span><br><span class="line"><span class="keyword">for</span>(;(k-e)%<span class="number">28</span>;k+=<span class="number">23</span>); <span class="comment">//找双高峰</span></span><br><span class="line"><span class="keyword">for</span>(;(k-i)%<span class="number">33</span>;k+=<span class="number">23</span>*<span class="number">28</span>); <span class="comment">//找三高峰</span></span><br><span class="line"><span class="comment">//输出k-d</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>称硬币:已经分组称了3次12枚硬币，找出假币</p>
<blockquote>
<p>ABCD EFGH even<br>ABI EFJK up<br>ABIJ EFGH even<br>输出假的硬币</p>
</blockquote>
<ul>
<li>数据结构 <code>char Left[3][7]`</code>char Right[3][7]<code></code>char result[3][7]` 一共称3次，每边最多放6个硬币，result（天平右边的情况）</li>
<li><code>isFake(char c,bool light )</code>假设函数：c是轻的</li>
<li><code>for(char c= &#39;A&#39; to &#39;L&#39;)</code>枚举假硬币</li>
<li><code>for(3)</code>三次称重情况都匹配<ul>
<li>如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换</li>
<li><code>switch result[i][0]</code> 选择三种u,e,d的情况<ul>
<li>如果 第一次实验为up,右边高，则c应该出现在right,当<code>right.indexOf(c)==null</code>//没出现 return false</li>
<li>如果even 判断出现在left||right</li>
<li>d 判断出现在left</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p>熄灯问题(deng.java)</p>
<blockquote>
<p>按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4<br>给定每盏灯的初始状态，求按钮方案，使灯全熄灭<br>输入 01矩阵 输出 01矩阵<br>一个按钮按两次及以上是无意义的，按钮次序无关<br>{0,1,1,0,1,0},<br>{1,0,0,1,1,1},<br>{0,0,1,0,0,1},<br>{1,0,0,1,0,1},<br>{0,1,1,1,0,0}</p>
</blockquote>
<ul>
<li>枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数）</li>
<li>只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按</li>
<li>一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1]</li>
<li>一个bit异或1 反转<code>1^1-&gt;0反转0^1-&gt;1反转；</code></li>
<li>j位 置1 <code>|=(1&lt;&lt;j)</code></li>
<li>j位 置0 <code>&amp;=~(1&lt;&lt;j)</code></li>
<li>取第j 位的值 <code>&gt;&gt;j&amp;1</code><blockquote>
<p> 主循环：1.遍历第一行开关状态<br> 2.每次换第一行重置原来灯状态lighting[]=输入<br> 3.对每一行，每一个灯，按switch更新lighting</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(getBit(result,i,j)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">0</span>)FlipBit(lights,i,j-<span class="number">1</span>);</span><br><span class="line">FlipBit(lights,i,j);</span><br><span class="line"><span class="keyword">if</span>(j&lt;<span class="number">5</span>)FlipBit(lights,i,j+<span class="number">1</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">4</span>)&#123;lights[i+<span class="number">1</span>]^= switchs;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>&gt;  4.更新开关，下一行开关为上一行还亮着灯的位置回3
&gt;  5.当lighting最后一行为0，结束
</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol>
<li>汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2)<ol>
<li>A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c)</li>
<li>再将B上n-1个移动到C，用A中转</li>
<li>回到0 A上n-2个移动到C，用B中转</li>
</ol>
</li>
<li>n皇后 递归代替多重循环</li>
</ol>
<h4 id="链表DELETE-IF"><a href="#链表DELETE-IF" class="headerlink" title="链表DELETE_IF"></a>链表DELETE_IF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>list-&gt;nodelist 会stackOverflow<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">create</span><span class="params">(List&lt;Integer&gt; data)</span></span>&#123;</span><br><span class="line">    Node first = <span class="keyword">new</span> Node(data.get(<span class="number">0</span>));</span><br><span class="line">    Node sub = create(data.subList(<span class="number">1</span>,data.size()));</span><br><span class="line">    first.next=sub;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>迭代：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node head =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span> to size)&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(i);</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.next =node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">reverse</span><span class="params">(Nodde head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    Node second = reverse(head.next);</span><br><span class="line">    second.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>迭代：<br>中间状态null&lt;-1&lt;-2<3 |="" 4-="">5-&gt;null<br>3是newhead 反转成功的链表 | 4curhead是还没反转的链表<br>newhead=null开始，curhead从第一个node开始，两个同时向右每次移一格，直到curhead=null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node newhead = <span class="keyword">null</span>;</span><br><span class="line">Node curhead = head;</span><br><span class="line"><span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    Node tmp = curhead.next;</span><br><span class="line">    curhead.next = newhead;</span><br><span class="line">    curhead=tmp;</span><br><span class="line">    newhead = curhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newhead;</span><br></pre></td></tr></table></figure></3></p>
<p>转成栈浪费空间并且代码复杂</p>
<h4 id="combinations-从list中选n个的组合"><a href="#combinations-从list中选n个的组合" class="headerlink" title="combinations 从list中选n个的组合"></a>combinations 从list中选n个的组合</h4><p>递归框架：<br>1选择第0号元素，递归去除第一个元素中选n-1个<code>com(data.subList(1,data.size()),n-1)</code><br>2不选，去除第一个元素后选n个元素</p>
<p>递归基准：<br>1.当data为空，并且选择0个则合理<br>2.当n=0 选完了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com</span><span class="params">(List&lt;Integer&gt; selected,List&lt;Integer&gt; data,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)printList(selected);</span><br><span class="line">    <span class="keyword">if</span>(data.isEmpty())<span class="keyword">return</span>;</span><br><span class="line">    selected.add(data.get(<span class="number">0</span>));</span><br><span class="line">    com(selected,data.subList(<span class="number">1</span>,data.size()),n-<span class="number">1</span>);</span><br><span class="line">    selected.remove(selected.size()-<span class="number">1</span>,n);</span><br><span class="line">    com(selected,data.subList(<span class="number">1</span>,data.size()),n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最长上升子序列<br>无后效性：可写出递推式。之与子问题函数的状态函数值有关，与到达值的路径无关<br>子问题：求以$a_k(k=1,2,3…N)$为终点的最长上升子序列长度<br>max(n个子问题)</p>
<ul>
<li>如果ak比已得最长子序列的最后ai大，则长度+1<br><code>maxLen(k)=max(maxLen(i):i in range(1,k)且ai&lt;ak且k!=1)+1</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n)</span><br><span class="line">	maxlen[i]=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n)</span><br><span class="line">	<span class="comment">##求以ai 为终点的最长</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,i)<span class="comment"># ai左边所有的数</span></span><br><span class="line">		<span class="keyword">if</span> a[i]&gt;a[j]: <span class="comment"># ai为终点的更长</span></span><br><span class="line">		<span class="comment">#？？ maxlen[i]也更新了，可能比manlen[j]+1大</span></span><br><span class="line">			maxlen[i]=max(maxlen[j]+<span class="number">1</span>,maxlen[i])</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/alg/" rel="tag"># alg</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/21/busyman/" rel="next" title="busyman Notes">
                <i class="fa fa-chevron-left"></i> busyman Notes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/24/Apriori-FP/" rel="prev" title="Apriori_FP">
                Apriori_FP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#伪多项式时间"><span class="nav-number">1.</span> <span class="nav-text">伪多项式时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-s1和s2是否交错组成s3"><span class="nav-number">2.</span> <span class="nav-text">97 s1和s2是否交错组成s3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-从左上角走到右下角总共有多少种不同方式"><span class="nav-number">3.</span> <span class="nav-text">62 从左上角走到右下角总共有多少种不同方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数学公式"><span class="nav-number">3.1.</span> <span class="nav-text">!数学公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-有障碍物的左上到右下"><span class="nav-number">4.</span> <span class="nav-text">63 有障碍物的左上到右下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-从左上角走到右下角的最少sum"><span class="nav-number">5.</span> <span class="nav-text">64 从左上角走到右下角的最少sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-括号字符串中合法的括号对"><span class="nav-number">6.</span> <span class="nav-text">32 括号字符串中合法的括号对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？96-不同的BST数量"><span class="nav-number">7.</span> <span class="nav-text">？96 不同的BST数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#！95-输出全部不同的BST"><span class="nav-number">8.</span> <span class="nav-text">！95 输出全部不同的BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包9讲"><span class="nav-number">9.</span> <span class="nav-text">背包9讲:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包"><span class="nav-number">9.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#taotao要吃鸡"><span class="nav-number">9.2.</span> <span class="nav-text">taotao要吃鸡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包-每个物品可用无限次"><span class="nav-number">9.3.</span> <span class="nav-text">完全背包 每个物品可用无限次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#！416-数组分成两部分（不连续-sum相等。list的总sum为奇数则不可能。"><span class="nav-number">9.4.</span> <span class="nav-text">！416 数组分成两部分（不连续) sum相等。list的总sum为奇数则不可能。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多重背包-第i种物品最多Mi件可用"><span class="nav-number">9.5.</span> <span class="nav-text">多重背包 第i种物品最多Mi件可用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本福特定律"><span class="nav-number">10.</span> <span class="nav-text">本福特定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确二分查找的写法"><span class="nav-number">11.</span> <span class="nav-text">正确二分查找的写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#307"><span class="nav-number">12.</span> <span class="nav-text">307</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Index-Tree"><span class="nav-number">12.1.</span> <span class="nav-text">Binary Index Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#315-输出数组每个位置后有多少个数字比它小"><span class="nav-number">12.2.</span> <span class="nav-text">315 输出数组每个位置后有多少个数字比它小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-数组每个元素只保留-lt-2次"><span class="nav-number">13.</span> <span class="nav-text">80 数组每个元素只保留&lt;=2次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点是随机变量的有向无环图-贝叶斯网络BN"><span class="nav-number">14.</span> <span class="nav-text">节点是随机变量的有向无环图=贝叶斯网络BN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#452-重叠线段"><span class="nav-number">15.</span> <span class="nav-text">452 重叠线段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#欧拉图：一笔画"><span class="nav-number">16.</span> <span class="nav-text">欧拉图：一笔画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈密顿图"><span class="nav-number">17.</span> <span class="nav-text">哈密顿图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-最低的二叉树公共祖先"><span class="nav-number">18.</span> <span class="nav-text">236 最低的二叉树公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-完全二叉树的节点数"><span class="nav-number">19.</span> <span class="nav-text">222 完全二叉树的节点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLS可以达到BFS一样空间的DFS"><span class="nav-number">20.</span> <span class="nav-text">DLS可以达到BFS一样空间的DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-word-break"><span class="nav-number">21.</span> <span class="nav-text">139 word break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55jump-game"><span class="nav-number">22.</span> <span class="nav-text">55jump game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-jump-game最少跳跃次数"><span class="nav-number">23.</span> <span class="nav-text">45 jump game最少跳跃次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322找钱最少硬币数"><span class="nav-number">24.</span> <span class="nav-text">322找钱最少硬币数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络流"><span class="nav-number">25.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ford-fulkerson算法"><span class="nav-number">25.1.</span> <span class="nav-text">Ford-fulkerson算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flow-value-lemma-最小cut上的流量-最大网络流"><span class="nav-number">25.2.</span> <span class="nav-text">flow value lemma :最小cut上的流量 == 最大网络流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#已知最大流-cur-capacity-求cut"><span class="nav-number">25.3.</span> <span class="nav-text">已知最大流(cur/capacity) 求cut</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何找augmenting-path-BFS"><span class="nav-number">25.4.</span> <span class="nav-text">如何找augmenting path BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TrieNode字典树-find-insert复杂度为字符串商都"><span class="nav-number">26.</span> <span class="nav-text">TrieNode字典树 find/insert复杂度为字符串商都</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树字典树-每层多一个字符的字典树"><span class="nav-number">27.</span> <span class="nav-text">后缀树字典树 每层多一个字符的字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><span class="nav-number">28.</span> <span class="nav-text">后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀数组-A-后缀的起始位置"><span class="nav-number">29.</span> <span class="nav-text">后缀数组 A[]后缀的起始位置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成后缀数组"><span class="nav-number">29.1.</span> <span class="nav-text">生成后缀数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aho-Corasick"><span class="nav-number">30.</span> <span class="nav-text">Aho-Corasick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-B两人选k种可乐达到期望最大"><span class="nav-number">31.</span> <span class="nav-text">A,B两人选k种可乐达到期望最大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火车换乘"><span class="nav-number">32.</span> <span class="nav-text">火车换乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><span class="nav-number">33.</span> <span class="nav-text">16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP"><span class="nav-number">34.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-有重复的subset-1-2-2-2"><span class="nav-number">35.</span> <span class="nav-text">90 有重复的subset[1,2,2,2]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-subset-1-2-3-gt-1-1-2-1-2-3-2-3-2-3"><span class="nav-number">36.</span> <span class="nav-text">78 subset[1,2,3]-&gt;[1][1,2][1,2,3][2,3][2][3]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#815-换公交"><span class="nav-number">37.</span> <span class="nav-text">815 换公交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fib"><span class="nav-number">38.</span> <span class="nav-text">fib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-数组index当底边，值当杯子两侧，最大面积"><span class="nav-number">39.</span> <span class="nav-text">11 数组index当底边，值当杯子两侧，最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#！30-字典中单词连续出现在字符串中的位置-AC自动机（？"><span class="nav-number">40.</span> <span class="nav-text">！30 字典中单词连续出现在字符串中的位置 AC自动机（？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-连续最长不重复子序列"><span class="nav-number">41.</span> <span class="nav-text">3 连续最长不重复子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-string中字符组成回文串的最大长度"><span class="nav-number">42.</span> <span class="nav-text">409 string中字符组成回文串的最大长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#！5-最长回文串"><span class="nav-number">43.</span> <span class="nav-text">！5 最长回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Manacher’s-算法-O-n"><span class="nav-number">43.1.</span> <span class="nav-text">Manacher’s 算法 O(n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回文树"><span class="nav-number">43.2.</span> <span class="nav-text">回文树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347桶排序-int数组中最常出现的n个"><span class="nav-number">44.</span> <span class="nav-text">347桶排序 int数组中最常出现的n个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#242-Anagram-相同字母的单词"><span class="nav-number">45.</span> <span class="nav-text">242 Anagram 相同字母的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-卡特兰数括号"><span class="nav-number">46.</span> <span class="nav-text">22 卡特兰数括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树遍历"><span class="nav-number">47.</span> <span class="nav-text">树遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-reverse-String"><span class="nav-number">48.</span> <span class="nav-text">344 reverse String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><span class="nav-number">49.</span> <span class="nav-text">238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#371-不用’-’用位运算完成求和"><span class="nav-number">50.</span> <span class="nav-text">371 不用’+’用位运算完成求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#412-遇到3-5和3-amp-5的倍数变成特定字符"><span class="nav-number">51.</span> <span class="nav-text">412 遇到3||5和3&amp;5的倍数变成特定字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3sum-0-荷兰国旗写法3指针"><span class="nav-number">52.</span> <span class="nav-text">15 3sum=0 荷兰国旗写法3指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-最大子列乘积-保留当前值之前的最大积和最小积"><span class="nav-number">53.</span> <span class="nav-text">152 最大子列乘积 保留当前值之前的最大积和最小积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#818-A加速，R掉头并减速，到指定位置最少需要多少条指令"><span class="nav-number">54.</span> <span class="nav-text">818 A加速，R掉头并减速，到指定位置最少需要多少条指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#551-出现两个以上A或者3个以上L为false"><span class="nav-number">55.</span> <span class="nav-text">551 出现两个以上A或者3个以上L为false</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34"><span class="nav-number">56.</span> <span class="nav-text">34</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？698-减枝？DP方法"><span class="nav-number">57.</span> <span class="nav-text">？698 减枝？DP方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239"><span class="nav-number">58.</span> <span class="nav-text">239</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#476"><span class="nav-number">59.</span> <span class="nav-text">476</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#464-博弈"><span class="nav-number"></span> <span class="nav-text">464 博弈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#486-两个人只能从list的两端取数，预测最后谁摸到的点数sum高"><span class="nav-number">1.</span> <span class="nav-text">486 两个人只能从list的两端取数，预测最后谁摸到的点数sum高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#292"><span class="nav-number">2.</span> <span class="nav-text">292</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lc538-O-1-空间-线索二叉树-Morris-Inorder-中序-Tree-Traversal"><span class="nav-number"></span> <span class="nav-text">lc538 O(1)空间 线索二叉树 Morris Inorder(中序) Tree Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Morris-Inorder-中序-Tree-Traversal"><span class="nav-number">1.</span> <span class="nav-text">Morris Inorder(中序) Tree Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convert-BST-to-Greater-Tree"><span class="nav-number">2.</span> <span class="nav-text">Convert BST to Greater Tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-判断树平衡-在计算高度时同时判断平衡只需要O-n"><span class="nav-number"></span> <span class="nav-text">110 判断树平衡 在计算高度时同时判断平衡只需要O(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树"><span class="nav-number"></span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><span class="nav-number"></span> <span class="nav-text">红黑树：将3-结点变成左二叉树，将2-3变成二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#581-需要排序的最小子串，整个串都被排序了-递增"><span class="nav-number"></span> <span class="nav-text">581 需要排序的最小子串，整个串都被排序了 递增</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-Single-Number"><span class="nav-number"></span> <span class="nav-text">136 Single Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#438-Anagrams-in-a-String-滑动窗口"><span class="nav-number"></span> <span class="nav-text">438 Anagrams in a String 滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141链表环检测"><span class="nav-number"></span> <span class="nav-text">141链表环检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#142-环起始于哪个node"><span class="nav-number">1.</span> <span class="nav-text">142 环起始于哪个node</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-链表相交于哪一点"><span class="nav-number"></span> <span class="nav-text">160 链表相交于哪一点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#168"><span class="nav-number"></span> <span class="nav-text">168</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-众数-Boyer-Moore-Voting-Algorithm"><span class="nav-number"></span> <span class="nav-text">169 众数 Boyer-Moore Voting Algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#搜索算法的优化"><span class="nav-number"></span> <span class="nav-text">搜索算法的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number"></span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-爬山：局部贪心，快速找到可行解，局部最优"><span class="nav-number"></span> <span class="nav-text">1. 爬山：局部贪心，快速找到可行解，局部最优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-First搜索：全局最优贪心"><span class="nav-number">1.</span> <span class="nav-text">Best-First搜索：全局最优贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支界限：组合优化"><span class="nav-number">2.</span> <span class="nav-text">分支界限：组合优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串搜索"><span class="nav-number"></span> <span class="nav-text">字符串搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Rabin-Karp"><span class="nav-number"></span> <span class="nav-text">Rabin-Karp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Review"><span class="nav-number"></span> <span class="nav-text">Review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-枚举："><span class="nav-number">1.</span> <span class="nav-text">1. 枚举：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">2.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链表DELETE-IF"><span class="nav-number">2.1.</span> <span class="nav-text">链表DELETE_IF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建链表"><span class="nav-number">2.2.</span> <span class="nav-text">创建链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转链表"><span class="nav-number">2.3.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combinations-从list中选n个的组合"><span class="nav-number">2.4.</span> <span class="nav-text">combinations 从list中选n个的组合</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/custom/custom.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
