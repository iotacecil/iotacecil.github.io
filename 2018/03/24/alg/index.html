<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
 
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="alg," />










<meta name="description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 网易https://www.nowcoder.com/discuss/105576?type=2 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://bl">
<meta name="keywords" content="alg">
<meta property="og:type" content="article">
<meta property="og:title" content="alg">
<meta property="og:url" content="http://blog.iotaa.xyz/2018/03/24/alg/index.html">
<meta property="og:site_name" content="Learn &amp; practice">
<meta property="og:description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 网易https://www.nowcoder.com/discuss/105576?type=2 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://bl">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/randomgen.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/histo1.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lexpermu.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/nqueenbb.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/digits.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/minbracket.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/strstrbest.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/backup.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/substring.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyerright.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyerright2.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyer3.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/rabin-karp.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/ranbinmod.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/kbright.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/DFA.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/dfaconstruction.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/KMPDFA.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/knapsack.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/pointcover.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/vetexcover.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSTTSP.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MMTSP.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/pagbb.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bbtsp.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/optaplanner.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/tspdp.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/scalenetwork.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/shuku.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/stringsort.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/threepart.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSD.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSD2.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/LSD.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/indexsort.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc611.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/mst.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/prim.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/singlelink.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/singleclu.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc753.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc7532.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/Hierholzer1.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/Hierholzer2.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bipartite.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/matching.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphmostuse.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphtra.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/tuopu.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphcy.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/kolakoski.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/shijiebei.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bus1.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bus2.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/mounting.jpg">
<meta property="og:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/fenzhi.jpg">
<meta property="og:updated_time" content="2018-12-13T14:00:48.038Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="alg">
<meta name="twitter:description" content="刷题顺序https://vjudge.net/article/6https://www.cnblogs.com/JuneWang/p/3773880.html 网易https://www.nowcoder.com/discuss/105576?type=2 微软187https://blog.csdn.net/v_july_v/article/details/6697883面试https://bl">
<meta name="twitter:image" content="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/randomgen.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.iotaa.xyz/2018/03/24/alg/"/>





  <title>alg | Learn & practice</title>
  








  <!--prettify代码高亮脚本引入-->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="top-scroll-bar"></div>
<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learn & practice</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.iotaa.xyz/2018/03/24/alg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learn & practice">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">alg</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T03:07:34+08:00">
                2018-03-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-12-13T22:00:48+08:00">
                2018-12-13
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法备忘/" itemprop="url" rel="index">
                    <span itemprop="name">算法备忘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>刷题顺序<br><a href="https://vjudge.net/article/6" target="_blank" rel="noopener">https://vjudge.net/article/6</a><br><a href="https://www.cnblogs.com/JuneWang/p/3773880.html" target="_blank" rel="noopener">https://www.cnblogs.com/JuneWang/p/3773880.html</a></p>
<p>网易<br><a href="https://www.nowcoder.com/discuss/105576?type=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/105576?type=2</a></p>
<p>微软187<br><a href="https://blog.csdn.net/v_july_v/article/details/6697883" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6697883</a><br>面试<br><a href="https://blog.csdn.net/v_july_v/article/details/6803368" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/6803368</a><br><a href="https://www.cnblogs.com/JuneWang/p/3773880.html" target="_blank" rel="noopener">https://www.cnblogs.com/JuneWang/p/3773880.html</a></p>
<p><a href="https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001" target="_blank" rel="noopener">https://www.educative.io/collection/page/5642554087309312/5679846214598656/140001</a></p>
<p><a href="https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html" target="_blank" rel="noopener">https://hrbust-acm-team.gitbooks.io/acm-book/content/search/a_star_search.html</a></p>
<p>笔试题todo<br><a href="https://www.nowcoder.com/test/4575457/summary" target="_blank" rel="noopener">https://www.nowcoder.com/test/4575457/summary</a></p>
<h3 id="lc749-病毒隔离"><a href="#lc749-病毒隔离" class="headerlink" title="lc749 病毒隔离"></a>lc749 病毒隔离</h3><p>每天只能隔离一片1的圈,而且必须是不隔离会感染最多的圈，每天1会向周围扩散</p>
<blockquote>
<p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grid = </span><br><span class="line">[[1,1,1,0,0,0,0,0,0],</span><br><span class="line"> [1,0,1,0,1,1,1,1,1],</span><br><span class="line"> [1,1,1,0,0,0,0,0,0]]</span><br><span class="line">Output: 13</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Explanation: The region on the left only builds two new walls.</p>
<p>先隔离掉右边的1 用上5+1+5，然后左边扩散了，之需要把<code>[0][3]</code>和<code>[0][4]</code>隔离了。<br>还有<code>[2]</code>排 所以就只有2个墙了</p>
<h3 id="lt912-最佳见面地点"><a href="#lt912-最佳见面地点" class="headerlink" title="lt912 最佳见面地点"></a>lt912 最佳见面地点</h3><blockquote>
<p>现在有三人分别居住在(0,0), (0,4), 和 (2,2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 - 0 - 0 - 0 - 1</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 0 - 0 - 0</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 1 - 0 - 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>点(0, 2)是最佳见面地点，最小的路程总和为2+2+2=6，返回6。</p>
<p>思路：只要见面地点在A,B中间，到A,B的花费都是 AB长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length;</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                cols.add(j);</span><br><span class="line">                rows.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cols.sort(Integer::compareTo);</span><br><span class="line">    rows.sort(Integer::compareTo);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;cols.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        sum += cols.get(cols.size()-<span class="number">1</span> - i)-cols.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;rows.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        sum += rows.get(rows.size()-<span class="number">1</span> - i)-rows.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="542-01矩阵-变成离0距离的矩阵"><a href="#542-01矩阵-变成离0距离的矩阵" class="headerlink" title="542 01矩阵 变成离0距离的矩阵"></a>542 01矩阵 变成离0距离的矩阵</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure>
<p>还可以dp todo</p>
<p>1.把0都放入队列，非零格子最大化<br>2.如果bfs到这个格子的距离比格子的值小就更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] ori = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;   </span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">              que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] top = que.poll();             </span><br><span class="line">        <span class="keyword">int</span> curx = top[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cury = top[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ori.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newx = curx + ori[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newy = cury + ori[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= n || newy &lt; <span class="number">0</span> || newy &gt;= m ||</span><br><span class="line">                    matrix[newx][newy] &lt;= matrix[curx][cury] +<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                matrix[newx][newy] = matrix[curx][cury] + <span class="number">1</span>;</span><br><span class="line">                que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newx, newy&#125;);    </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lt-663-墙和门"><a href="#lt-663-墙和门" class="headerlink" title="lt 663 墙和门"></a>lt 663 墙和门</h3><p>您将获得一个使用这三个可能值初始化的 m×n 2D 网格。<br>-1 - 墙壁或障碍物。<br>0 - 门。<br>INF - Infinity是一个空房间。我们使用值 2 ^ 31 - 1 = 2147483647 来表示INF，您可以假设到门的距离小于 2147483647</p>
<p>在代表每个空房间的网格中填入到距离最近门的距离。<br>如果不可能到达门口，则应填入 INF。</p>
<blockquote>
<p>给定 2D 网格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INF  -1  0  INF</span><br><span class="line">INF INF INF  -1</span><br><span class="line">INF  -1 INF  -1</span><br><span class="line">  0  -1 INF INF</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  -1   0   1</span><br><span class="line">2   2   1  -1</span><br><span class="line">1  -1   2  -1</span><br><span class="line">0  -1   3   4</span><br></pre></td></tr></table></figure></p>
<p>BFS方法同上<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rooms.length;</span><br><span class="line">    <span class="keyword">int</span> m = rooms[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = que.poll();</span><br><span class="line">        <span class="keyword">int</span> curx = cur[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cury = cur[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = curx + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = cury + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= n || newy &lt; <span class="number">0</span> || newy &gt;= m</span><br><span class="line">                    || rooms[newx][newy] == -<span class="number">1</span> || rooms[newx][newy] &lt; rooms[curx][cury] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rooms[newx][newy] = rooms[curx][cury] + <span class="number">1</span>;</span><br><span class="line">            que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newx,newy&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="lt-803-建筑物之间的最短距离"><a href="#lt-803-建筑物之间的最短距离" class="headerlink" title="lt 803 建筑物之间的最短距离"></a>lt 803 建筑物之间的最短距离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">盖房子，在最短的距离内到达所有的建筑物。</span><br><span class="line">给定三个建筑物(0,0),(0,4),(2,2)和障碍物(0,2):</span><br><span class="line"></span><br><span class="line">    1 - 0 - 2 - 0 - 1</span><br><span class="line">    |   |   |   |   |</span><br><span class="line">    0 - 0 - 0! - 0 - 0</span><br><span class="line">    |   |   |   |   |</span><br><span class="line">    0 - 0 - 1 - 0 - 0</span><br><span class="line">点(1,2)是建造房屋理想的空地，因为3+3+1=7的总行程距离最小。所以返回7。</span><br></pre></td></tr></table></figure>
<h3 id="899-操作字符串前k个字符放到最后-输出字典序最小的"><a href="#899-操作字符串前k个字符放到最后-输出字典序最小的" class="headerlink" title="899 操作字符串前k个字符放到最后 输出字典序最小的"></a>899 操作字符串前k个字符放到最后 输出字典序最小的</h3><blockquote>
<p>Input: S = “cba”, K = 1<br>Output: “acb”</p>
<p>Input: S = “baaca”, K = 3<br>Output: “aaabc”<br>Explanation:<br>In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.<br>In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.</p>
</blockquote>
<p>当k=1 字符串只能旋转<br>当k&gt;1的时候，固定第一位，可以把后面任意一位转到第二位，即确定第一位，可以和后面所有数字比较，然后放到最后，冒泡排序。</p>
<h3 id="132-pattern"><a href="#132-pattern" class="headerlink" title="132 pattern"></a>132 pattern</h3><blockquote>
<p>Input: [3, 1, 4, 2]<br>Output: True<br>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>
</blockquote>
<p>正确做法：栈</p>
<p>方法1：用一个for循环找到当前之前的min<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> min_i = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            min_i = Math.min(min_i,nums[j]);  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k =j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[k] &gt; min_i &amp;&amp; nums[j]&gt;nums[k])&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lt700-怎么划分最赚钱-完全背包"><a href="#lt700-怎么划分最赚钱-完全背包" class="headerlink" title="lt700 怎么划分最赚钱 完全背包"></a>lt700 怎么划分最赚钱 完全背包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长度    | 1   2   3   4   5   6   7   8  </span><br><span class="line">--------------------------------------------</span><br><span class="line">价格    | 1   5   8   9  10  17  17  20</span><br></pre></td></tr></table></figure>
<p>给出 price = [1, 5, 8, 9, 10, 17, 17, 20], n = 8 返回 22//切成长度为 2 和 6 的两段</p>
<p>dp:(0,n),(1,n-1),…,(n/2,n/2)<br>二维dp（？）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutting</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i][j - i] + prices[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>记忆递归：<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutting</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(n))<span class="keyword">return</span> map.get(n);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        sum = Math.max(sum, cutting(prices, n-i) + prices[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="862-和至少为K的最短子数组"><a href="#862-和至少为K的最短子数组" class="headerlink" title="862 和至少为K的最短子数组"></a>862 和至少为K的最短子数组</h3><blockquote>
<p>Input: A = [2,-1,2], K = 3<br>Output: 3</p>
</blockquote>
<p>思路：用前缀和找区间和，关键：递增有序栈，<br>用当前值更新队尾，如果当前的presum比队尾presum小，则下一个减这个得到的区间更短而且值更大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubarrayWindow</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">long</span>[] presum = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;=K)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        presum[i+<span class="number">1</span>] = presum[i] +A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minlen = n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (deque.size() &gt;<span class="number">0</span> &amp;&amp; presum[i] - presum[deque.getFirst()] &gt;= K)&#123;</span><br><span class="line"></span><br><span class="line">            minlen = Math.min(minlen, i-deque.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">while</span> (deque.size() &gt; <span class="number">0</span> &amp;&amp; presum[i] &lt;= presum[deque.getLast()])&#123;</span><br><span class="line">         deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minlen == n+<span class="number">1</span>?-<span class="number">1</span>:minlen;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="861-01矩阵反转能得到的最大01行和"><a href="#861-01矩阵反转能得到的最大01行和" class="headerlink" title="861 01矩阵反转能得到的最大01行和"></a>861 01矩阵反转能得到的最大01行和</h3><blockquote>
<p>Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>Output: 39<br>Explanation:<br>Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
</blockquote>
<p>思路：贪心<br>1判断行首是0，直接翻转一行，因为2^3比4+2+1还要大<br>同列是一个数量级2^?的，判断列0和1的个数翻转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            col += A[r][c] ^ A[r][<span class="number">0</span>];</span><br><span class="line">        ans += Math.max(col, R - col) * (<span class="number">1</span> &lt;&lt; (C-<span class="number">1</span>-c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sw44-判断扑克牌是否顺子"><a href="#sw44-判断扑克牌是否顺子" class="headerlink" title="sw44 判断扑克牌是否顺子"></a>sw44 判断扑克牌是否顺子</h3><p>1.排序，<br>2.数0（大王小王可以当作任意数字）的个数，<br>3.统计数组相邻数字之间的空缺数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] cards)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cards == <span class="keyword">null</span> || cards.length &lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Arrays.sort(cards);</span><br><span class="line">    <span class="keyword">int</span> zerocnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> card :cards)&#123;</span><br><span class="line">        <span class="keyword">if</span>(card == <span class="number">0</span>)zerocnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;cards.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cards[i-<span class="number">1</span>] == <span class="number">0</span> ||cards[i-<span class="number">1</span>] ==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cards[i] == cards[i-<span class="number">1</span>])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        interval += cards[i] - cards[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(interval &gt; zerocnt)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="263-Ugly-Number-判断是否是丑数"><a href="#263-Ugly-Number-判断是否是丑数" class="headerlink" title="263 Ugly Number 判断是否是丑数"></a>263 Ugly Number 判断是否是丑数</h3><p>包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">while</span>( num % <span class="number">2</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">3</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( num % <span class="number">5</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num ==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="264-输出第n个丑数"><a href="#264-输出第n个丑数" class="headerlink" title="264 输出第n个丑数"></a>264 输出第n个丑数</h4><p>正确做法：3ms //todo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m2 = nums[t2] * <span class="number">2</span>, m3 = nums[t3] * <span class="number">3</span>, m5 = nums[t5] * <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> mm = Math.min(m2, Math.min(m3, m5));</span><br><span class="line">        <span class="keyword">if</span> (mm == m2) t2++;</span><br><span class="line">        <span class="keyword">if</span> (mm == m3) t3++;</span><br><span class="line">        <span class="keyword">if</span> (mm == m5) t5++;</span><br><span class="line">        nums[i] = mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8% 105ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Long&gt; que =<span class="keyword">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class="line">    que.add(<span class="number">1l</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;n ; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> tmp = que.poll();</span><br><span class="line">        <span class="comment">// 重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty() &amp;&amp; que.peek() == tmp)tmp = que.poll();</span><br><span class="line"></span><br><span class="line">        que.add(tmp * <span class="number">2</span>);</span><br><span class="line">        que.add(tmp * <span class="number">3</span>);</span><br><span class="line">        que.add(tmp * <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> que.poll().intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="859-如果交换A字符串中两个字母可以得到B就true"><a href="#859-如果交换A字符串中两个字母可以得到B就true" class="headerlink" title="859 如果交换A字符串中两个字母可以得到B就true"></a>859 如果交换A字符串中两个字母可以得到B就true</h3><blockquote>
<p>Input: A = “”, B = “aa”<br>Output: false</p>
</blockquote>
<p>1.如果长度不一样，false</p>
<blockquote>
<p>Input: A = “ab”, B = “ab”<br>Output: false<br>Input: A = “aa”, B = “aa”<br>Output: true</p>
</blockquote>
<p>2.如果一样的字符串，一定要有重复的字符</p>
<blockquote>
<p>Input: A = “ab”, B = “ba”<br>Output: true</p>
</blockquote>
<p>3.不一样的字符只有2个，记录位置并交换比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">buddyStrings</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.length() != B.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> same = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span>[] acnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> dif = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx1 = -<span class="number">1</span>,idx2=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length();i++)&#123;</span><br><span class="line">        acnt[A.charAt(i) -<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(acnt[A.charAt(i) -<span class="string">'a'</span>] &gt;=<span class="number">2</span>)same = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dif == <span class="number">0</span> &amp;&amp; i == A.length()-<span class="number">1</span>)<span class="keyword">return</span> same;</span><br><span class="line">        <span class="keyword">if</span>(A.charAt(i) != B.charAt(i))&#123;</span><br><span class="line">            dif++;</span><br><span class="line">            <span class="keyword">if</span>(dif&gt;<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(idx1 &lt; <span class="number">0</span> )idx1 = i;</span><br><span class="line">            <span class="keyword">else</span> idx2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        System.out.println(idx1+" "+idx2);</span></span><br><span class="line">    <span class="keyword">if</span>(idx1!=idx2)<span class="keyword">return</span> A.charAt(idx1) == B.charAt(idx2) &amp;&amp; A.charAt(idx2) ==B.charAt(idx1);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lc70爬楼梯"><a href="#lc70爬楼梯" class="headerlink" title="lc70爬楼梯"></a>lc70爬楼梯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">       dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一段楼梯台阶有15级台阶，以小明的脚力一步最多只能跨3级，请问小明登上这段楼梯有多少种不同的走法?()</p>
</blockquote>
<p>$f(n)=f(n-1)+f(n-2)+f(n-3)$      (对于n&gt;=4)<br>$f(n-1)=f(n-2)+f(n-3)+f(n-4)$    (对于n&gt;=5)<br>前面两式相减可以得到：  $f(n)=2*f(n-1)-f(n-4)$  (对于n&gt;=5)<br>而对于n&lt;=5的情况有：<br>f(1)=1<br>f(2)=2<br>f(3)=4<br>f(4)=7<br>一直算到15.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>) + f(n-<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] =<span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] =<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;n+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]+dp[i-<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈混洗-火车调度"><a href="#栈混洗-火车调度" class="headerlink" title="栈混洗 火车调度"></a>栈混洗 火车调度</h3><h3 id="随机数发生器"><a href="#随机数发生器" class="headerlink" title="随机数发生器"></a>随机数发生器</h3><p>在 C 语言标准库中，Brian W. Kernighan 和 Dennis M. Ritchie 设计的随机数収生器如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* rand:  return pseudo-random integer on 0..32767 */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>; </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* srand:  set seed for rand() */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    next = seed; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>维护一个32位的无符号长整数next，随着next的“随意”变化，不断输出伪随机数。<br>通过srand(seed)，可以设置next的初始值（随机种子）。</p>
<p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/randomgen.jpg" alt="randomgen.jpg"></p>
<ol>
<li>在next当前值的基础上乘以1103515245 = 3 5   5  7  129749，并加上12345。</li>
<li>通过整除运算在该长整数的二进制展开中截取高16位，进而通过模余运算抹除最高比特位。<br>经如此的“混沌化”处理之后，即可作为“随机数”返回。 </li>
</ol>
<h3 id="231-2的整数次"><a href="#231-2的整数次" class="headerlink" title="231 2的整数次"></a>231 2的整数次</h3><h3 id="191二进制中1的个数"><a href="#191二进制中1的个数" class="headerlink" title="191二进制中1的个数"></a>191二进制中1的个数</h3><p>难点：如果把1一直右移 负数会死循环。如果拿1一直左移要32次。<br>做法：从右去掉1能去掉多少次<br>整数-1会把最右边的1变成0，如果右边有0全变成1.<br>原数和这个数 与 就把最右边1以及右边都变成0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n-<span class="number">1</span>)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lc-325-lt-919"><a href="#lc-325-lt-919" class="headerlink" title="lc 325 lt 919"></a>lc 325 lt 919</h3><h3 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a>数组嵌套</h3><blockquote>
<p><code>S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }</code><br> stop adding right before a duplicate element occurs in S.<br> Input: A = [5,4,0,3,1,6,2]<br>Output: 4<br>Explanation:<br>A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</p>
</blockquote>
<blockquote>
<p>One of the longest S[K]:<br>S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</p>
</blockquote>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>从不大于n的自然数随机选一个，它是素数的概率大约是1/ln(n)<br><a href="https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0%E5%AE%9A%E7%90%86/1972457?fromtitle=%E8%B4%A8%E6%95%B0%E5%AE%9A%E7%90%86&amp;fromid=4710126" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0%E5%AE%9A%E7%90%86/1972457?fromtitle=%E8%B4%A8%E6%95%B0%E5%AE%9A%E7%90%86&amp;fromid=4710126</a><br>1-100有25个素数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;math.log(<span class="number">100</span>)</span><br><span class="line"><span class="number">4.605170185988092</span></span><br></pre></td></tr></table></figure></p>
<h3 id="926-将01串变成前0后1或全0或全1的最少flip次数-前缀！"><a href="#926-将01串变成前0后1或全0或全1的最少flip次数-前缀！" class="headerlink" title="926!!将01串变成前0后1或全0或全1的最少flip次数 前缀！"></a>926!!将01串变成前0后1或全0或全1的最少flip次数 前缀！</h3><blockquote>
<p>Input: “010110”<br>Output: 2<br>Explanation: We flip to get 011111, or alternatively 000111.</p>
</blockquote>
<p>思路1：前缀<code>[1..i]</code> 变成全0或者变成<code>[000111]</code>的最小反转次数,推到整个数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0101100011 S</span><br><span class="line">0112333345 oCnt(把所有1转0)</span><br><span class="line">0011123444 fCnt(第一个1之后0的个数)</span><br><span class="line">0011122333 fCnt更新为min(将当前位置之前的所有1转0，或者当前位置之前1后0转1)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFlipsMonoIncr</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.charAt(i) == <span class="string">'1'</span>)&#123;</span><br><span class="line">            oCnt ++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oCnt &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            fCnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键 fCnt 随前缀更新</span></span><br><span class="line">       fCnt = oCnt &lt; fCnt ? oCnt:fCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="925-是否是因长按重复的字符串"><a href="#925-是否是因长按重复的字符串" class="headerlink" title="925 是否是因长按重复的字符串"></a>925 是否是因长按重复的字符串</h3><blockquote>
<p>Input: name = “leelee”, typed = “lleeelee”<br>Output: true</p>
</blockquote>
<p>双指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLongPressedNameCnt</span><span class="params">(String name, String typed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls1 = name.length();</span><br><span class="line">    <span class="keyword">int</span> ls2 = typed.length();</span><br><span class="line">    <span class="keyword">if</span> (ls1 &lt; <span class="number">1</span> || ls2 &lt; ls1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt; ls2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 &lt; ls1 &amp;&amp; name.charAt(p1) == typed.charAt(p2))&#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键 p1已经到下一个不相同的字符了，p2还在上一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1&gt;<span class="number">0</span> &amp;&amp; name.charAt(p1-<span class="number">1</span>) == typed.charAt(p2))&#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1 == ls1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="平面最近点对-分治"><a href="#平面最近点对-分治" class="headerlink" title="平面最近点对 分治"></a>平面最近点对 分治</h3><h3 id="780-x-y可以向下x步，或者向右y步能否到达tx-ty"><a href="#780-x-y可以向下x步，或者向右y步能否到达tx-ty" class="headerlink" title="!!780 x,y可以向下x步，或者向右y步能否到达tx,ty"></a>!!780 x,y可以向下x步，或者向右y步能否到达tx,ty</h3><blockquote>
<p>Input: sx = 1, sy = 1, tx = 3, ty = 5<br>One series of moves that transforms the starting point to the target is:<br>(1, 1) -&gt; (1, 2)<br>(1, 2) -&gt; (3, 2)<br>(3, 2) -&gt; (3, 5)<br>out: True</p>
</blockquote>
<p>正常递归思路 超时</p>
<h3 id="532-数组中有几个相差k的pair"><a href="#532-数组中有几个相差k的pair" class="headerlink" title="532 数组中有几个相差k的pair"></a>532 数组中有几个相差k的pair</h3><blockquote>
<p>输入: [3, 1, 4, 1, 5], k = 2<br>输出: 2<br>解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。<br>尽管数组中有两个1，但我们只应返回不同的数对的数量。</p>
</blockquote>
<p>set的解法33% //todo比双指针慢</p>
<h3 id="220-数组中是否有相差-lt-t-idx差-lt-k-的元素"><a href="#220-数组中是否有相差-lt-t-idx差-lt-k-的元素" class="headerlink" title="220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素"></a>220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素</h3><blockquote>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true</p>
</blockquote>
<p>2.桶</p>
<p>1.40% 用容量k的TreeSet,超过k删除最左<br>判断能否和ceiling合floor&lt;=t<br>如果不能 放入treeset等待</p>
<h3 id="373-start和end数组-拼成-start-end-求start-end最小的k个点对"><a href="#373-start和end数组-拼成-start-end-求start-end最小的k个点对" class="headerlink" title="373 start和end数组 拼成[start,end] 求start+end最小的k个点对"></a>373 start和end数组 拼成[start,end] 求start+end最小的k个点对</h3><h3 id="719-数组中两两匹配，第k小的两数之差"><a href="#719-数组中两两匹配，第k小的两数之差" class="headerlink" title="719 数组中两两匹配，第k小的两数之差"></a>719 数组中两两匹配，第k小的两数之差</h3><blockquote>
<p>nums = [1,3,1]<br>k = 1<br>输出：0<br>解释：<br>所有数对如下：<br>(1,3) -&gt; 2<br>(1,1) -&gt; 0<br>(3,1) -&gt; 2<br>因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。</p>
</blockquote>
<h3 id="lt1472-s任意交换奇数位字符和偶数位字符-能否变成t"><a href="#lt1472-s任意交换奇数位字符和偶数位字符-能否变成t" class="headerlink" title="lt1472 s任意交换奇数位字符和偶数位字符 能否变成t"></a>lt1472 s任意交换奇数位字符和偶数位字符 能否变成t</h3><blockquote>
<p>给出 s=”abcd”，t=”cdab”，返回”Yes”。<br>第一次a与c交换，第二次b与d交换。</p>
</blockquote>
<p>对奇数位和偶数位计数</p>
<h3 id="219-是否有重复元素-下标相差-lt-k"><a href="#219-是否有重复元素-下标相差-lt-k" class="headerlink" title="219 是否有重复元素 下标相差&lt;=k"></a>219 是否有重复元素 下标相差&lt;=k</h3><blockquote>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true</p>
</blockquote>
<p>放进一个FIFO大小为(k+1) 相差k 的set，当有add失败的时候就true</p>
<h3 id="442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间"><a href="#442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间" class="headerlink" title="442  1 ≤ a[i] ≤ n 找到所有出现2次的元素 O(1) 空间"></a>442  <code>1 ≤ a[i] ≤ n</code> 找到所有出现2次的元素 O(1) 空间</h3><blockquote>
<p>some elements appear twice and others appear once.<br>Input:[4,3,2,7,8,2,3,1]<br>Output:[2,3]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4-&gt;[4,3,2,-7,8,2,3,1] </span><br><span class="line">3-&gt;[4,3,-2,-7,8,2,3,1]</span><br><span class="line">2-&gt;[4,-3,-2,-7,8,2,3,1]</span><br><span class="line">7-&gt;[4,-3,-2,-7,8,2,-3,1]</span><br><span class="line">8-&gt;[4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">2-&gt;[4,[3],-2,-7,8,2,-3,-1]</span><br><span class="line">3-&gt;[4,[3],[2],-7,8,2,-3,-1]</span><br><span class="line">1-&gt;[-4,[3],[2],-7,8,2,-3,-1]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[idx] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Math.abs(idx) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[idx] = -nums[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401 二进制手表"></a>401 二进制手表</h3><p>上排1,2,4,8表示小时 下排1,2,4,8,16,32表示分钟<br>上1,2 下 16，8，1 表示3:25</p>
<blockquote>
<p>Input: n = 1 两了几个led灯 所有可能的时间<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
</blockquote>
<p>计算小时和分钟里有多少个1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span> ; h++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span> ; m++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.bitCount((h&lt;&lt;<span class="number">6</span>) + m) == num)&#123;</span><br><span class="line">                times.add(String.format(<span class="string">"%d:%02d"</span>,h,m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="汉明重量-Hamming-weight-32位int有多少个1"><a href="#汉明重量-Hamming-weight-32位int有多少个1" class="headerlink" title="汉明重量 Hamming weight 32位int有多少个1"></a>汉明重量 Hamming weight 32位int有多少个1</h3><blockquote>
<p>Input: 11<br>Output: 3<br>Integer 11 has binary representation 00000000000000000000000000001011</p>
</blockquote>
<blockquote>
<p>X与X-1相与得到的最低位永远是0</p>
</blockquote>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>0 1 0 0 0 1 0 0 0 1 0 0 0 0</td>
</tr>
<tr>
<td>X-1</td>
<td>0 1 0 0 0 1 0 0 0 0 1 1 1 1</td>
</tr>
<tr>
<td>X &amp; (X-1)</td>
<td>0 1 0 0 0 1 0 0 0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<h3 id="477-全部汉明距离Integer-bitCount-x-y"><a href="#477-全部汉明距离Integer-bitCount-x-y" class="headerlink" title="477 全部汉明距离Integer.bitCount(x ^ y)"></a>477 全部汉明距离<code>Integer.bitCount(x ^ y)</code></h3><blockquote>
<p>Input: 4, 14, 2<br>Output: 6<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>
</blockquote>
<p>4  = 0100<br>14 = 1110<br>2  = 0010<br>0x3+2<em>1+2</em>1+1*2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>,n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//有几个num这个位是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">            bitCnt += (nums[j] &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += bitCnt*(n-bitCnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="338-0-n每个数字有几个1位-O-n-复杂度"><a href="#338-0-n每个数字有几个1位-O-n-复杂度" class="headerlink" title="338 0~n每个数字有几个1位 O(n)复杂度"></a>338 0~n每个数字有几个1位 O(n)复杂度</h3><blockquote>
<p>Input: 5<br>Output: [0,1,1,2,1,2]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num ; i++) &#123;</span><br><span class="line">        f[i] = f[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="87-判断两个字符串是不是拆分成两半二叉树交换子树构成的"><a href="#87-判断两个字符串是不是拆分成两半二叉树交换子树构成的" class="headerlink" title="87 判断两个字符串是不是拆分成两半二叉树交换子树构成的"></a>87 判断两个字符串是不是拆分成两半二叉树交换子树构成的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length()!=s2.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s1.equals(s2))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 不剪枝这一步会TL</span></span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;s1.length() ; i++) &#123;</span><br><span class="line">        cnt[s1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        cnt[s2.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">26</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;s1.length() ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(<span class="number">0</span>,i))&amp;&amp;</span><br><span class="line">                isScramble(s1.substring(i), s2.substring(i)))||</span><br><span class="line">                (isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(s1.length()-i))&amp;&amp;</span><br><span class="line">                isScramble(s1.substring(i), s2.substring(<span class="number">0</span>,s1.length()-i))))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161"><a href="#lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161" class="headerlink" title="lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161"></a>lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sl = s.length();</span><br><span class="line">    <span class="keyword">int</span> tl = t.length();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(t))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(sl-tl)&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = Math.min(sl,tl);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        idx = i+<span class="number">1</span>;<span class="comment">// &gt;=1</span></span><br><span class="line">        <span class="comment">// 前面已经相等了</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) != t.charAt(i))&#123;</span><br><span class="line">            <span class="comment">// 比较两个字符串的a, b的index+1, index+1 位以后是否相等</span></span><br><span class="line">            <span class="comment">// 或者 index+1, index 是否相等，</span></span><br><span class="line">            <span class="comment">// 或者index, index+1是否相等</span></span><br><span class="line">            <span class="keyword">return</span> s.substring(idx).equals(t.substring(idx)) || </span><br><span class="line">            s.substring(idx).equals(t.substring(idx-<span class="number">1</span>)) || </span><br><span class="line">            s.substring(idx-<span class="number">1</span>).equals(t.substring(idx));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h3><h3 id="取模和取余rem"><a href="#取模和取余rem" class="headerlink" title="取模和取余rem"></a>取模和取余rem</h3><p>java的<code>%</code>取余 python 取模<br>求 整数商： c = a/b;</p>
<p>计算模或者余数： r = a - c*b.<br>例如：计算-7 Mod 4<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">-7</span>%<span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>那么：a = -7；b = 4；</p>
<p>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</p>
<p>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</p>
<h3 id="149-在同一条直线上最多的点数"><a href="#149-在同一条直线上最多的点数" class="headerlink" title="149 在同一条直线上最多的点数"></a>149 在同一条直线上最多的点数</h3><h3 id="线段上格点的个数"><a href="#线段上格点的个数" class="headerlink" title="线段上格点的个数"></a>线段上格点的个数</h3><blockquote>
<p>P1=(1,11) P2=(5,3)<br>out: 3 (2,9) (3,7) (4,5)</p>
</blockquote>
<p>答案是gcd(|x1-x2|,|y1-y2|)-1<br>最大公约数：共有约数中最大的一个<br>x相差4，y相差8 求分成（/）最多多少份，x,y都是整数</p>
<h3 id="火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼"><a href="#火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼" class="headerlink" title="火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼"></a>火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼</h3><blockquote>
<p>3节车厢，按照1，2，3依次入轨编组，可以在左边形成1 2 3，1 3 2，2 1 3，2 3 1，321。<br>问1-2-3-4能否编程4，1，3，2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设序列是1,2,3,4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] train = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = train.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; m ; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(train[i]&gt;train[j]&amp;&amp;train[i]&gt;train[k]&amp;&amp;train[k]&gt;train[j])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) System.out.println(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println(<span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><h3 id="lt476石子合并-区间dp"><a href="#lt476石子合并-区间dp" class="headerlink" title="lt476石子合并 区间dp"></a>lt476石子合并 区间dp</h3><blockquote>
<p>有n堆石子排成一列，每堆石子有一个重量w[i], 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和w[i]+w[i+1]。问安排怎样的合并顺序，能够使得总合并代价达到最小<br>in : 4 1 1 4 out: 18</p>
</blockquote>
<h3 id="lc84直方图中的最大矩形poj2559"><a href="#lc84直方图中的最大矩形poj2559" class="headerlink" title="lc84直方图中的最大矩形poj2559"></a>lc84直方图中的最大矩形poj2559</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/histo1.jpg" alt="histo1.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo next</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="15-3sum-a-b-c-0"><a href="#15-3sum-a-b-c-0" class="headerlink" title="15 3sum a + b + c = 0"></a>15 3sum a + b + c = 0</h3><blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<p>关键：去重技巧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//75%</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;num.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//关键去重</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||(i&gt;<span class="number">0</span>&amp;&amp;num[i]!=num[i-<span class="number">1</span>]))&#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i+<span class="number">1</span>,hi=num.length-<span class="number">1</span>,sum = <span class="number">0</span>-num[i];</span><br><span class="line">            <span class="comment">//关键</span></span><br><span class="line">            <span class="keyword">while</span> (lo&lt;hi)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[lo]+num[hi] == sum)&#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i],num[lo],num[hi]));</span><br><span class="line">                    <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (lo&lt;hi&amp;&amp;num[lo]==num[lo+<span class="number">1</span>])lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo&lt;hi&amp;&amp;num[hi]==num[hi-<span class="number">1</span>])hi--;</span><br><span class="line">                    lo++;hi--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num[lo]+num[hi]&lt;sum)lo++;</span><br><span class="line">                <span class="keyword">else</span> hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lt-1487-2sum-最接近target"><a href="#lt-1487-2sum-最接近target" class="headerlink" title="lt 1487 2sum 最接近target"></a>lt 1487 2sum 最接近target</h3><h3 id="16-3sum-最接近target的值"><a href="#16-3sum-最接近target的值" class="headerlink" title="16 3sum 最接近target的值"></a>16 3sum 最接近target的值</h3><p>//todo nexttime</p>
<h3 id="18-4sum-外层for-用3sum找target-nums-i"><a href="#18-4sum-外层for-用3sum找target-nums-i" class="headerlink" title="18 4sum 外层for 用3sum找target-nums[i]"></a>18 4sum 外层for 用3sum找<code>target-nums[i]</code></h3><h3 id="454-4-sum-2-poj2785-4-Values-whose-Sum-is-0"><a href="#454-4-sum-2-poj2785-4-Values-whose-Sum-is-0" class="headerlink" title="454 4 sum 2 poj2785 4 Values whose Sum is 0"></a>454 4 sum 2 poj2785 4 Values whose Sum is 0</h3><p>用poj的方法11%<br>4个分别有n个数字的数组ABCD，每个数组中取一个，合为0的组合数。<br>c+d = -a-b<br>从A,B中找出n^2种组合，从C,D中找出n^2种组合，排序二分找到lowerbound和upbound。</p>
<p>正确方法：计算c+d的时候放入hashmap计数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;C.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;D.length ; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = C[i] + D[j];</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span> )+<span class="number">1</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;A.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;B.length ; j++) &#123;</span><br><span class="line">            res += map.getOrDefault(-(A[i]+B[j]),<span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="914-相同数字的牌划分成一组，每组数量相同-能否划分"><a href="#914-相同数字的牌划分成一组，每组数量相同-能否划分" class="headerlink" title="914 相同数字的牌划分成一组，每组数量相同 能否划分"></a>914 相同数字的牌划分成一组，每组数量相同 能否划分</h3><blockquote>
<p>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p>
</blockquote>
<p>计数，求最大公约数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deck==<span class="keyword">null</span>||deck.length&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count.put(i, count.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : count.values()) res = gcd(i, res);</span><br><span class="line">    <span class="keyword">return</span> res &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; <span class="number">0</span> ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="916"><a href="#916" class="headerlink" title="916"></a>916</h3><blockquote>
<p>b 中的每个字母都出现在 a 中，包括重复出现的字母，那么称单词 b 是单词 a 的子集。 例如，“wrr” 是 “warrior” 的子集，但不是 “world” </p>
</blockquote>
<h3 id="7-整数反转-integer越界"><a href="#7-整数反转-integer越界" class="headerlink" title="7 整数反转 integer越界"></a>7 整数反转 integer越界</h3><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = x&lt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rst&gt;Integer.MAX_VALUE/<span class="number">10</span>||(rst==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;add&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rst&lt;Integer.MIN_VALUE/<span class="number">10</span>||(rst==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;add&lt;-<span class="number">8</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rst = rst*<span class="number">10</span>+add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="319-n个灯泡-n轮开关"><a href="#319-n个灯泡-n轮开关" class="headerlink" title="319 n个灯泡 n轮开关"></a>319 n个灯泡 n轮开关</h3><p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</p>
<blockquote>
<p>输入: 3<br>输出: 1<br>解释:<br>初始时, 灯泡状态 [关闭, 关闭, 关闭].<br>第一轮后, 灯泡状态 [开启, 开启, 开启].<br>第二轮后, 灯泡状态 [开启, 关闭, 开启].<br>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </p>
</blockquote>
<p>你应该返回 1，因为只有一个灯泡还亮着。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被按奇数下的灯泡还亮着。<br>当第d轮可以整除i灯泡i被按下。所以如果i有奇个除数，则最后是开的。<br>例如12，</p>
<h3 id="451-字符串按频率排序-桶排序"><a href="#451-字符串按频率排序-桶排序" class="headerlink" title="451 字符串按频率排序 桶排序"></a>451 字符串按频率排序 桶排序</h3><h3 id="最大值为k的不重叠子数组的长度和？"><a href="#最大值为k的不重叠子数组的长度和？" class="headerlink" title="最大值为k的不重叠子数组的长度和？??"></a>最大值为k的不重叠子数组的长度和？??</h3><p><a href="https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/maximum-sum-lengths-non-overlapping-subarrays-k-max-element/</a></p>
<blockquote>
<p>Input : arr[] = {2, 1, 4,   9,   2, 3,   8,   3, 4}  k = 4<br>Output : 5<br>{2, 1, 4} =&gt; Length = 3<br>{3, 4} =&gt; Length = 2<br>So, 3 + 2 = 5 is the answer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lensum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n&amp;&amp;arr[i]&lt;=k)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == k)flag = <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//？？？</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) ans+=cnt;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n&amp;&amp;arr[i]&gt;k)i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="689-高频题-找到三个长度为k互不重叠的子数组的最大和"><a href="#689-高频题-找到三个长度为k互不重叠的子数组的最大和" class="headerlink" title="689!!!高频题 找到三个长度为k互不重叠的子数组的最大和"></a>689!!!高频题 找到三个长度为k互不重叠的子数组的最大和</h3><blockquote>
<p>Input: [1,2,1,2,6,7,5,1], 2<br>不重叠窗口为2的数组的和  <code>[1, 2], [2, 6], [7, 5]</code><br>返回 起始索引为 [0, 3, 5]。<br>也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。</p>
</blockquote>
<p><a href="https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode.com/articles/maximum-sum-of-3-non-overlapping-intervals/</a><br><a href="https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/maximum-sum-of-3-non-overlapping-subarrays/</a></p>
<h3 id="121-只能买卖一次-买卖股票的利润"><a href="#121-只能买卖一次-买卖股票的利润" class="headerlink" title="121 只能买卖一次 买卖股票的利润"></a>121 只能买卖一次 买卖股票的利润</h3><blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>
</blockquote>
<p>方法1：两次for，找最大差值 10% 262ms<br>方法2：Kadane算法(maximum subarray)先找到最低值，保留并更新最低值，并更新最大差值 2ms 36%</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minP = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;minP)minP = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-minP&gt;maxP)maxP = prices[i]-minP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp 保留前i天的最低值 更新第i天的最大差值 3ms 19%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] mindp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] maxdp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    mindp[<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">    maxdp[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        mindp[i] = Math.min(mindp[i-<span class="number">1</span>],prices[i]);</span><br><span class="line">       <span class="comment">//当天的股价-前i-1天的min价格</span></span><br><span class="line">        maxdp[i] = Math.max(maxdp[i-<span class="number">1</span>],prices[i]-mindp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxdp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dp2: 4 ms 15%<br>转换成53 将price reduce成每天的收益<br><code>[7,1,5,3,6,4]-&gt;[ ,-6,4,-2,3,-2]</code><br>在[4,-2,3]持有股票，从day2 [1]买进后的累积和最大<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 53!!!最大subarray sum</span><br><span class="line">Kadane <span class="number">14</span>ms <span class="number">19</span>%</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>],rst = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        rst = Math.max(rst,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>greedy:</p>
<h3 id="198-不能偷相邻房屋-最大利润"><a href="#198-不能偷相邻房屋-最大利润" class="headerlink" title="198 不能偷相邻房屋 最大利润"></a>198 不能偷相邻房屋 最大利润</h3><blockquote>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 </p>
</blockquote>
<h3 id="122-可以买卖多次-买股票的利润"><a href="#122-可以买卖多次-买股票的利润" class="headerlink" title="122 可以买卖多次 买股票的利润"></a>122 可以买卖多次 买股票的利润</h3><blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<h3 id="123-最多买卖2次的-买股票利润-考到"><a href="#123-最多买卖2次的-买股票利润-考到" class="headerlink" title="123 最多买卖2次的 买股票利润 考到"></a>123 最多买卖2次的 买股票利润 考到</h3><blockquote>
<p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<h3 id="188-最多k次买卖的-买卖股票利润"><a href="#188-最多k次买卖的-买卖股票利润" class="headerlink" title="188 最多k次买卖的 买卖股票利润"></a>188 最多k次买卖的 买卖股票利润</h3><blockquote>
<p>输入: [3,2,6,5,0,3], k = 2<br>输出: 7<br>解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<h3 id="重复元素很多的数组排序"><a href="#重复元素很多的数组排序" class="headerlink" title="重复元素很多的数组排序"></a>重复元素很多的数组排序</h3><p><a href="https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/how-to-sort-a-big-array-with-many-repetitions/</a></p>
<blockquote>
<p>AVL or Red-Black to sort in O(n Log m) time where m is number of distinct elements.<br>//todo</p>
</blockquote>
<h3 id="621-todo"><a href="#621-todo" class="headerlink" title="621 todo"></a>621 todo</h3><p>26 种不同种类的任务  每个任务都可以在 1 个单位时间内执行完<br>两个相同种类的任务之间必须有长度为 n 的冷却时间</p>
<blockquote>
<p>输入: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>输出: 8</p>
</blockquote>
<p>执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</p>
<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516 最长回文子序列"></a>516 最长回文子序列</h3><h3 id="Rearrange-a-string"><a href="#Rearrange-a-string" class="headerlink" title="Rearrange a string"></a>Rearrange a string</h3><p><a href="https://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/rearrange-a-string-so-that-all-same-characters-become-at-least-d-distance-away/</a></p>
<h3 id="440-第k小的字典序"><a href="#440-第k小的字典序" class="headerlink" title="440 第k小的字典序"></a>440 第k小的字典序</h3><h3 id="386-字典序数字-todo"><a href="#386-字典序数字-todo" class="headerlink" title="!!386 字典序数字 todo"></a>!!386 字典序数字 todo</h3><p>dfs 112ms 71%<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   1        2        3    ...</span><br><span class="line">  /\        /\       /\</span><br><span class="line">10 ...19  20...29  30...39   ....</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        dfs(rst,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; rst,<span class="keyword">int</span> n,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        rst.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur*<span class="number">10</span>+i&gt;n)<span class="keyword">return</span>;</span><br><span class="line">            dfs(rst,n,<span class="number">10</span>*cur+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关：<br>permutation的字典序<br>思想：字典序全排列算法：保证尽可能长的前缀不变，后缀慢慢增加<br> abc 保证前面不变，后面增加一点点 -&gt; acb ，cb不能增大了，-&gt;bac<br> 从右向左扫描 例如 321 是递增的 表示不能再增加<br> 从右向左扫描到第一次增大的位置，和右边比较大的数交换。1 2 3 扫描到2，和3交换。<br> 1 3 2 扫描到1降了，1和2交换 2 3 1  31不是最小后缀 变成2 1 3 </p>
<p>算法：<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lexpermu.jpg" alt="lexpermu.jpg"><br> 1.从右想左 找到第一次下降位置<br> 2.用后缀中比当前位置大的最小数字交换<br> 3.保证后缀最小（翻转？）</p>
<h3 id="636-单核cpu函数调用栈"><a href="#636-单核cpu函数调用栈" class="headerlink" title="636 单核cpu函数调用栈"></a>636 单核cpu函数调用栈</h3><p>日志是具有以下格式的字符串：function_id：start_or_end：timestamp。例如：”0:start:0” 表示函数 0 从 0 时刻开始运行。”0:end:0” 表示函数 0 在 0 时刻结束。</p>
<p>函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。</p>
<blockquote>
<p>输入 n = 2<br>logs =<br>[“0:start:0”,<br> “1:start:2”,<br> “1:end:5”,<br> “0:end:6”]<br>输出：[3, 4]</p>
</blockquote>
<p>函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。<br>现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。<br>函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。<br>所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。</p>
<p>stack + start[] ac 15%</p>
<h3 id="649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营"><a href="#649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营" class="headerlink" title="649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营"></a>649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营</h3><p>禁止一名参议员的权利：<br>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p>
<p>宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p>
<blockquote>
<p>输入: “RD”<br>输出: “Radiant”<br>解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</p>
</blockquote>
<blockquote>
<p>输入: “RDD”<br>输出: “Dire”<br>解释:<br>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利<br>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止<br>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利<br>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</p>
</blockquote>
<h3 id="495-给定攻击时间和中毒状态持续时间，问中毒状态总时长"><a href="#495-给定攻击时间和中毒状态持续时间，问中毒状态总时长" class="headerlink" title="495 给定攻击时间和中毒状态持续时间，问中毒状态总时长"></a>495 给定攻击时间和中毒状态持续时间，问中毒状态总时长</h3><blockquote>
<p>Input: [1,2], 2<br>Output: 3 (1-2-4)</p>
</blockquote>
<p>8ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeSeries==<span class="keyword">null</span>||timeSeries.length&lt;<span class="number">1</span>||duration==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;timeSeries.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//每次取间隔或者duration</span></span><br><span class="line">      rst += Math.min(duration,timeSeries[i+<span class="number">1</span>]-timeSeries[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rst += duration;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//todo again<br>按 区间的做法：100% 4ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="keyword">int</span>[] timeSeries, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeSeries==<span class="keyword">null</span>||timeSeries.length&lt;<span class="number">1</span>||duration==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = timeSeries[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> end = timeSeries[<span class="number">0</span>]+duration;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;timeSeries.length;i++)&#123;</span><br><span class="line">        <span class="comment">//Input: [1,4], 2 </span></span><br><span class="line">        <span class="keyword">if</span>(timeSeries[i]&gt;end)&#123;</span><br><span class="line">            result += (end-start);</span><br><span class="line">            start = timeSeries[i];</span><br><span class="line">        &#125;</span><br><span class="line">        end = timeSeries[i]+duration;</span><br><span class="line">    &#125;</span><br><span class="line">        result+=(end-start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="77combinations-C-n-k-C-n-1-k-1-C-n-1-k"><a href="#77combinations-C-n-k-C-n-1-k-1-C-n-1-k" class="headerlink" title="77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)"></a>77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)</h3><p><code>C(n-1,k-1)</code>表示选这个数，<code>C(n-1,k)</code>表示不选这个数<br>88%的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combineFast(<span class="keyword">int</span> n,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n||k&lt;<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = combine(n-<span class="number">1</span>,k-<span class="number">1</span> );</span><br><span class="line">    <span class="keyword">for</span>(List&lt;Integer&gt; list:result)&#123;</span><br><span class="line">        list.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    result.addAll(combine(n-<span class="number">1</span>,k ));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    math 8% C(n,k)=C(n-1,k-1)+C(n-1,k)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combineMath(<span class="keyword">int</span> n,<span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==n||k==<span class="number">0</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=k ; i++) &#123;</span><br><span class="line">            row.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(row));</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">this</span>.combineMath(n-<span class="number">1</span>,k-<span class="number">1</span> );</span><br><span class="line">    result.forEach(e-&gt;e.add(n));</span><br><span class="line">    result.addAll(<span class="keyword">this</span>.combineMath(n-<span class="number">1</span>,k ));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NqueenBB"><a href="#NqueenBB" class="headerlink" title="NqueenBB"></a>NqueenBB</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/nqueenbb.jpg" alt="nqueenbb.jpg"><br>N – 1’ in the backslash code is there to ensure that the codes are never negative because we will be using the codes as indices in an array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slash /</span><br><span class="line"> 0  1  2  3  4  5  6  7 </span><br><span class="line"> 1  2  3  4  5  6  7  8 </span><br><span class="line"> 2  3  4  5  6  7  8  9 </span><br><span class="line"> 3  4  5  6  7  8  9 10 </span><br><span class="line"> 4  5  6  7  8  9 10 11 </span><br><span class="line"> 5  6  7  8  9 10 11 12 </span><br><span class="line"> 6  7  8  9 10 11 12 13 </span><br><span class="line"> 7  8  9 10 11 12 13 14</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">backslash \</span><br><span class="line"> 7  6  5  4  3  2  1  0 </span><br><span class="line"> 8  7  6  5  4  3  2  1 </span><br><span class="line"> 9  8  7  6  5  4  3  2 </span><br><span class="line">10  9  8  7  6  5  4  3 </span><br><span class="line">11 10  9  8  7  6  5  4 </span><br><span class="line">12 11 10  9  8  7  6  5 </span><br><span class="line">13 12 11 10  9  8  7  6 </span><br><span class="line">14 13 12 11 10  9  8  7</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;N ; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;N ; c++) &#123;</span><br><span class="line">       slashCode[r][c]=r+c;</span><br><span class="line">       backslashCode[r][c]=r-c+(N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bb 5ms 78%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] slashCode, backslashCode;</span><br><span class="line"><span class="comment">//记录这个code是不是已经占用了</span></span><br><span class="line"><span class="keyword">boolean</span>[] rowocc;</span><br><span class="line"><span class="keyword">boolean</span>[] slashocc,backslashocc;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">     slashCode = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    backslashCode = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    rowocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">     slashocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    backslashocc = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;n ; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;n ; c++) &#123;</span><br><span class="line">           slashCode[r][c]=r+c;</span><br><span class="line">           backslashCode[r][c]=r-c+(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nqueen(rst,<span class="number">0</span>,n,board);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">addBoard</span><span class="params">(<span class="keyword">int</span>[][] board)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; rst  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] row:board)&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:row)&#123;</span><br><span class="line">            sb.append((i==<span class="number">0</span>?<span class="string">"."</span>:<span class="string">"Q"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        rst.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSafe</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (slashocc[slashCode[row][col]] ||</span><br><span class="line">            backslashocc[backslashCode[row][col]] ||</span><br><span class="line">            rowocc[row])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nqueen</span><span class="params">(List&lt;List&lt;String&gt;&gt; rst,<span class="keyword">int</span> col,<span class="keyword">int</span> n,<span class="keyword">int</span>[][] board)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col&gt;=n)&#123;</span><br><span class="line">        rst.add(addBoard(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSafe(board,i,col))&#123;</span><br><span class="line">             board[i][col] = <span class="number">1</span>;</span><br><span class="line">             rowocc[i] = <span class="keyword">true</span>;</span><br><span class="line">            slashocc[slashCode[i][col]] = <span class="keyword">true</span>;</span><br><span class="line">            backslashocc[backslashCode[i][col]] = <span class="keyword">true</span>;</span><br><span class="line">            nqueen(rst,col+<span class="number">1</span>,n,board);</span><br><span class="line">            rowocc[i] = <span class="keyword">false</span>;</span><br><span class="line">            slashocc[slashCode[i][col]] = <span class="keyword">false</span>;</span><br><span class="line">            backslashocc[backslashCode[i][col]] = <span class="keyword">false</span>;</span><br><span class="line">            board[i][col] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>check whether slash code ( j + i ) or backslash code ( j – i + 7 ) are used (keep two arrays that will tell us which diagonals are occupied). </p>
<h3 id="179-一组非负数，拼接成最大的正整数"><a href="#179-一组非负数，拼接成最大的正整数" class="headerlink" title="179 一组非负数，拼接成最大的正整数"></a>179 一组非负数，拼接成最大的正整数</h3><blockquote>
<p>Input: [10,2]<br>Output: “210”</p>
</blockquote>
<p>String s1 = “9”;<br>String s2 = “31”;</p>
<p>String case1 =  s1 + s2; // 931<br>String case2 = s2 + s1; // 319</p>
<blockquote>
<p>String concatenation may be O(n^2) in Java (depends on if the compiler optimizes). Using StringBuilder is O(n).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="comment">//变成String数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">        strs[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    Arrays.sort(strs,(a,b)-&gt;(b+a).compareTo(a+b));</span><br><span class="line">    <span class="keyword">if</span>(strs[<span class="number">0</span>].equals(<span class="string">"0"</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="402-去掉数字串中k个数字留下最小的数字"><a href="#402-去掉数字串中k个数字留下最小的数字" class="headerlink" title="402 去掉数字串中k个数字留下最小的数字"></a>402 去掉数字串中k个数字留下最小的数字</h3><p>Input: num = “1432219”, k = 3<br>Output: “1219”<br>找最小数字：从高位，越高位越小的数。<br>算法：从高位开始，如果去掉这个数用后面一位换上来，143-&gt;13变小了，则换掉<br>用栈，下一个位置比栈顶小，则把栈顶换掉。<br>注意点：如果下一个数字比栈顶小，k&gt;0表示可以替换多少个，向前(栈里)找最多k个应该应该去掉的数，把top放在下一个覆盖的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="string">"1234567890"</span>;</span><br><span class="line">k=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="comment">// len=10,k=9  但是0比所有前9个都小，则</span></span><br><span class="line"><span class="keyword">while</span>(top!=<span class="number">0</span>&amp;&amp;num.charAt(i)&lt;stack[top-<span class="number">1</span>]&amp;&amp;k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    top--;</span><br><span class="line">    k--;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0覆盖掉1 之后截取stack中len-k=1长度并且去掉0</span></span><br><span class="line">    stack[top++]=num.charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="500-判断字符串是不是在键盘的同一行"><a href="#500-判断字符串是不是在键盘的同一行" class="headerlink" title="500 判断字符串是不是在键盘的同一行"></a>500 判断字符串是不是在键盘的同一行</h3><p>流： 正则很慢 流也很慢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findWords(String[] words)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(words).parallel().filter(s-&gt;s.toLowerCase().matches(<span class="string">"[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*"</span>)).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="42"><a href="#42" class="headerlink" title="42"></a>42</h3><h3 id="683-K-Empty-Slots"><a href="#683-K-Empty-Slots" class="headerlink" title="683 - K Empty Slots"></a>683 - K Empty Slots</h3><h3 id="最长01串"><a href="#最长01串" class="headerlink" title="最长01串"></a>最长01串</h3><h3 id="799倒香槟第-i-j-个杯子的容积"><a href="#799倒香槟第-i-j-个杯子的容积" class="headerlink" title="799倒香槟第[i,j]个杯子的容积"></a>799倒香槟第<code>[i,j]</code>个杯子的容积</h3><blockquote>
<p>输入: poured(倾倒香槟总杯数) = 2,<br>query_glass(杯子的位置数) = 1, query_row(行数) = 1<br>输出: 0.5<br>解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</p>
</blockquote>
<p>第一行流过10杯，则第二行流过9杯，左边分到4.5 右边分到4.5<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">champagneTower</span><span class="params">(<span class="keyword">int</span> poured, <span class="keyword">int</span> query_row, <span class="keyword">int</span> query_glass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] A= <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line">    A[<span class="number">0</span>][<span class="number">0</span>] = (<span class="keyword">double</span>) poured;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>;r&lt;= query_row;++r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>;c&lt;=r;c++)&#123;</span><br><span class="line">            <span class="keyword">double</span> q = (A[r][c] - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(q &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                A[r+<span class="number">1</span>][c] += q;</span><br><span class="line">                A[r+<span class="number">1</span>][c+<span class="number">1</span>] += q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(<span class="number">1</span>,A[query_row][query_glass]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-N-大整数"><a href="#2-N-大整数" class="headerlink" title="2^N 大整数"></a>2^N 大整数</h3><h3 id="287-O-1-空间，找到数组中重复的数字"><a href="#287-O-1-空间，找到数组中重复的数字" class="headerlink" title="287 O(1)空间，找到数组中重复的数字"></a>287 O(1)空间，找到数组中重复的数字</h3><h3 id="查找第二小-大的元素"><a href="#查找第二小-大的元素" class="headerlink" title="查找第二小/大的元素"></a>查找第二小/大的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secondMin2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = Integer.MAX_VALUE,second = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;=first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = arr[j];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[j]&lt;=second&amp;&amp;arr[j]!=first)</span><br><span class="line">            second = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">secondMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = Integer.MIN_VALUE,second = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;=first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = arr[j];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[j]&gt;=second&amp;&amp;arr[j]!=first)</span><br><span class="line">            second = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序数组中小于target的"><a href="#排序数组中小于target的" class="headerlink" title="排序数组中小于target的"></a>排序数组中小于target的</h3><p>2 4 6 8 9 target=14</p>
<ol>
<li>2+9&lt;14 cnt+=4</li>
<li>4+9&lt;14 cnt+=3</li>
<li>6+9&gt;14,6+8==14,start==end 结束</li>
</ol>
<h3 id="给定一个数字范围，找到其中有几个首尾相同的数字"><a href="#给定一个数字范围，找到其中有几个首尾相同的数字" class="headerlink" title="给定一个数字范围，找到其中有几个首尾相同的数字"></a>给定一个数字范围，找到其中有几个首尾相同的数字</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/digits.jpg" alt="digits.jpg"></p>
<h3 id="百万数字中找最大20个"><a href="#百万数字中找最大20个" class="headerlink" title="百万数字中找最大20个"></a>百万数字中找最大20个</h3><p>用开始20个数字构造20个node的最小堆，接下来的数字比root大则replace，insert</p>
<h3 id="每秒最大桶数量减半，求t时刻一共消耗了多少"><a href="#每秒最大桶数量减半，求t时刻一共消耗了多少" class="headerlink" title="每秒最大桶数量减半，求t时刻一共消耗了多少"></a>每秒最大桶数量减半，求t时刻一共消耗了多少</h3><p>方法1：按递减排序，减半，再排序，一共排序t次<br>方法2：维持最大堆，每次取root减半再插入</p>
<h3 id="？445-链表数字相加"><a href="#？445-链表数字相加" class="headerlink" title="？445 链表数字相加"></a>？445 链表数字相加</h3><blockquote>
<p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>
<p>？递归写法</p>
<h3 id="896有正负的数列判断单调"><a href="#896有正负的数列判断单调" class="headerlink" title="896有正负的数列判断单调"></a>896有正负的数列判断单调</h3><p>用首尾判断up/down，中间相邻遍历判断up/down和之前不符return false<br>20ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n=A.length;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">boolean</span> up= (A[n-<span class="number">1</span>]-A[<span class="number">0</span>])&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (A[i+<span class="number">1</span>]!=A[i] &amp;&amp; (A[i+<span class="number">1</span>]-A[i]&gt;<span class="number">0</span>)!=up) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14 最长公共前缀"></a>14 最长公共前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(strs==<span class="keyword">null</span>||strs.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   String rst = strs[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">    <span class="comment">//削减rst以匹配每个后面的单词</span></span><br><span class="line">       <span class="keyword">while</span>(strs[i].indexOf(rst)!=<span class="number">0</span>)&#123;</span><br><span class="line">           rst =rst.substring(<span class="number">0</span>,Math.min(rst.length()-<span class="number">1</span>,strs[i].length()));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="718-最长公共子串40ms-90"><a href="#718-最长公共子串40ms-90" class="headerlink" title="718 最长公共子串40ms 90%"></a>718 最长公共子串40ms 90%</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.length,n = b.length;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> max= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            max = Math.max(max,dp[i][j]=a[i]==b[j]?<span class="number">1</span>+dp[i+<span class="number">1</span>][j+<span class="number">1</span>]:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rolling hash<br><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-repeated-subarray/solution/</a></p>
<h3 id="括号串达到匹配需要最小的逆转次数"><a href="#括号串达到匹配需要最小的逆转次数" class="headerlink" title="括号串达到匹配需要最小的逆转次数"></a>括号串达到匹配需要最小的逆转次数</h3><blockquote>
<p>Input:  exp = “}}}{“<br>Output: 2 </p>
</blockquote>
<p>将匹配的括号都去掉，<code>{</code>的个数是m=3，<code>}</code>的个数是n=3<br>m/3+n/2 = 2+1=3<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/minbracket.jpg" alt="minbracket.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minReversal</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">if</span>((len&amp;<span class="number">1</span>)!=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    Deque&lt;Character&gt; que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'&#125;'</span>&amp;&amp;!s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.peek()==<span class="string">'&#123;'</span>)que.pop();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                que.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mn = que.size();</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()&amp;&amp;que.peek()==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">        que.pop();</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当m+n是偶数的时候ceil(n/2)+ceil(m/2)=</span></span><br><span class="line">    <span class="keyword">return</span> (mn/<span class="number">2</span>+n%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="22-卡特兰数括号"><a href="#22-卡特兰数括号" class="headerlink" title="22 ??卡特兰数括号"></a>22 ??卡特兰数括号</h3><p>left括号数量小于n，right括号数量必须小于left不然(()))肯定不合理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;rst.add(s);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(left&gt;<span class="number">0</span>)help(rst,s+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line"><span class="keyword">if</span>(right&lt;<span class="number">0</span>)help(rst,s+<span class="string">")"</span>,left,right+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="32-括号字符串中合法的括号对"><a href="#32-括号字符串中合法的括号对" class="headerlink" title="32 ?括号字符串中合法的括号对"></a>32 ?括号字符串中合法的括号对</h3><p>方法1. stack:栈底放-1，当栈空&amp;&amp;读到是<code>)</code>将<code>)</code>的index当栈底。每次读到<code>)</code>弹栈，并更新<code>i-peek()</code>，因为peek为没消掉的<code>(</code>的前一个位置<br>方法22. 从左向右扫描，当左括号数==右括号数更新max，当右括号&gt;左括号置0.<br>  从右向左扫描，同理更新max，当左括号&gt;右括号重置0.</p>
<hr>
<h3 id="28字符串indexOf匹配暴力-Substring-Search"><a href="#28字符串indexOf匹配暴力-Substring-Search" class="headerlink" title="28字符串indexOf匹配暴力 Substring Search"></a>28字符串indexOf匹配暴力 Substring Search</h3><p>各种字符串匹配算法<br><a href="http://www-igm.univ-mlv.fr/~lecroq/string/" target="_blank" rel="noopener">http://www-igm.univ-mlv.fr/~lecroq/string/</a><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/strstrbest.jpg" alt="strstrbest.jpg"><br><a href="https://algs4.cs.princeton.edu/53substring/" target="_blank" rel="noopener">https://algs4.cs.princeton.edu/53substring/</a><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/backup.jpg" alt="backup.jpg"><br>方法1是维持一个pattern长度的buffer<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/substring.jpg" alt="substring.jpg"><br>流的情况下 没有backup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADA B RAC</span><br><span class="line">ADA[C]R i-=j</span><br><span class="line"> ADACR</span><br></pre></td></tr></table></figure></p>
<h4 id="Boyer-Moore-74-5ms-亚线性"><a href="#Boyer-Moore-74-5ms-亚线性" class="headerlink" title="!!!Boyer-Moore 74% 5ms 亚线性"></a>!!!Boyer-Moore 74% 5ms 亚线性</h4><p>alg4<br>1.构建right表示target中字符的最右位置是NEEDLE<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyerright.jpg" alt="boyerright.jpg"><br>2.source从左到右扫描，target从右向左<br>如果出现不匹配T是target里没有的，i到j+1<br>如果出现不匹配N是target里的，则用right，将target里N的位置和它对齐<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyerright2.jpg" alt="boyerright2.jpg"><br>当前j=3,right[‘N’] = 0,skip=3<br>第三种情况，至少保证i不能回退<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/boyer3.jpg" alt="boyer3.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        right[c] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target.length(); j++)</span><br><span class="line">            right[target.charAt(j)] = j;</span><br><span class="line">        <span class="keyword">int</span> m = target.length();</span><br><span class="line">        <span class="keyword">int</span> n = source.length();</span><br><span class="line">        <span class="keyword">int</span> skip;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i += skip) &#123;</span><br><span class="line">            skip = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target.charAt(j) != source.charAt(i+j)) &#123;</span><br><span class="line">                    skip = Math.max(<span class="number">1</span>, j - right[source.charAt(i+j)]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RabinKarp-31-8ms-线性"><a href="#RabinKarp-31-8ms-线性" class="headerlink" title="RabinKarp 31% 8ms 线性"></a>RabinKarp 31% 8ms 线性</h4><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/rabin-karp.jpg" alt="rabin-karp.jpg"><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/ranbinmod.jpg" alt="ranbinmod.jpg"></p>
<p>正确性：<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/kbright.jpg" alt="kbright.jpg"><br>线性求mod<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    private long longRandomPrime()&#123;</span></span><br><span class="line"><span class="comment">//        BigInteger prime = BigInteger.probablePrime(31,new Random());</span></span><br><span class="line"><span class="comment">//        return prime.longValue();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">long</span> q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        h = (R * h + key.charAt(j)) % q;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//变成拉斯维加斯算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String source,String target, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;target.length() ; j++)</span><br><span class="line">        <span class="keyword">if</span> (target.charAt(j) != source.charAt(i + j))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">searchRabinKarp</span><span class="params">(String source,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> m = target.length();</span><br><span class="line">    <span class="keyword">int</span> n = source.length();</span><br><span class="line">    <span class="keyword">long</span> RM = <span class="number">1</span>;</span><br><span class="line">    q = <span class="number">1877124611</span>;<span class="comment">//保证不冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=m-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        RM = (R * RM) % q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> patHash = hash(target,m);</span><br><span class="line">    <span class="keyword">long</span> txtHash = hash(source, m);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//一开始就匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(source,target, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for hash match; if hash match, check for exact match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// Remove leading digit, add trailing digit, check for match.</span></span><br><span class="line">        txtHash = (txtHash + q - RM*source.charAt(i-m) % q) % q;</span><br><span class="line">        txtHash = (txtHash*R + source.charAt(i)) % q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match</span></span><br><span class="line">        <span class="keyword">int</span> offset = i - m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(source, target,offset))</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no match</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="187-rolling-hash-DNA序列中出现2次以上长为10的子串"><a href="#187-rolling-hash-DNA序列中出现2次以上长为10的子串" class="headerlink" title="187 rolling-hash DNA序列中出现2次以上长为10的子串"></a>187 rolling-hash DNA序列中出现2次以上长为10的子串</h4><p>//todo</p>
<h4 id="暴力-O（MN）"><a href="#暴力-O（MN）" class="headerlink" title="暴力 O（MN）"></a>暴力 O（MN）</h4><p>双指针<br>i的位置是txt已匹配过的最后位置<br>15% 13ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(source==<span class="keyword">null</span>||source.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,N = source.length();</span><br><span class="line">    <span class="keyword">int</span> j,M = target.length();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,j=<span class="number">0</span>; i &lt;N&amp;&amp;j&lt;M ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(source.charAt(i)==target.charAt(j))j++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i-=j;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M)<span class="keyword">return</span> i-M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按indexOf简化 43% 7ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lens = source.length();</span><br><span class="line">    <span class="keyword">int</span> tar = target.length();</span><br><span class="line">    <span class="keyword">char</span>[] targetArr = target.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] sourceArr = source.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> first = targetArr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = lens-tar;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i]!=first)&#123;</span><br><span class="line">            <span class="keyword">while</span> (++i&lt;=max&amp;&amp;sourceArr[i]!=first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=max)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j+tar-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt;end&amp;&amp;sourceArr[j]==targetArr[k] ; k++,j++) ;</span><br><span class="line">            <span class="keyword">if</span>(j == end)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>java <code>indexOf</code>实现</p>
<ul>
<li>最长公共前缀：indexOf<br>73% 5ms<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> indexOf( source.toCharArray(),<span class="number">0</span>,source.length(),target.toCharArray(),<span class="number">0</span>,target.length(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param source:左值（被查找）</span></span><br><span class="line"><span class="comment">@param count长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找位置&gt;=左值长度</span></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">            <span class="comment">//traget空？返回左值长度</span></span><br><span class="line">            <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fromIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右值为0，返回查找位置</span></span><br><span class="line">        <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">        <span class="comment">//最后一个匹配的下标，至少减去右值的长度</span></span><br><span class="line">        <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="comment">/* Look for first character. */</span></span><br><span class="line">            <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">                <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                        == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                    <span class="comment">/* Found whole string. */</span></span><br><span class="line">                    <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍"><a href="#KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍" class="headerlink" title="KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍"></a>KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍</h3><p>基于DFA<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/DFA.jpg" alt="DFA.jpg"><br>用一个dfa[][]记录j回退多远<br>1对target构建dfa<br>构造DFA的时间是O（MR）的，可以对每个状态设置一个匹配/非匹配去掉R<br>9ms 24%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serachByKMP</span><span class="params">(String source,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> M = target.length();</span><br><span class="line">    <span class="keyword">int</span> N = source.length();</span><br><span class="line">    <span class="keyword">int</span>[] dfa = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    dfa[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//For the pattern “AAACAAAAAC”,</span></span><br><span class="line">    <span class="comment">//lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">0</span>&amp;&amp;target.charAt(k)!=target.charAt(i))</span><br><span class="line">            k = dfa[k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target.charAt(k)==target.charAt(i))&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfa[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//[0, 0, 0, 1, 0]</span></span><br><span class="line">    <span class="comment">//"mississippi", </span></span><br><span class="line">    <span class="comment">// "issip"     q=4 i=5 dfa[3]=1</span></span><br><span class="line">    <span class="comment">// "issip"     q=1 i=5</span></span><br><span class="line">    <span class="comment">//    "issip" </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">0</span>&amp;&amp;target.charAt(q)!=source.charAt(i))</span><br><span class="line">            q = dfa[q-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target.charAt(q)==source.charAt(i))</span><br><span class="line">            q++;</span><br><span class="line">        <span class="keyword">if</span>(q==M)</span><br><span class="line">            <span class="keyword">return</span> i-M+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/dfaconstruction.jpg" alt="dfaconstruction.jpg"><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/KMPDFA.jpg" alt="KMPDFA.jpg"><br>2.对source遍历一遍dfa<br>12.44% 39ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(source.length()&lt;target.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="keyword">null</span>||target.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> M = target.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">    <span class="comment">//构建DFA</span></span><br><span class="line">    dfa[target.charAt(<span class="number">0</span>)][<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> X = <span class="number">0</span>,j=<span class="number">1</span>;j&lt;M;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">            dfa[c][j] = dfa[c][X];<span class="comment">//复制上一列匹配失败</span></span><br><span class="line">        dfa[target.charAt(j)][j] = j+<span class="number">1</span>;<span class="comment">//更新匹配成功</span></span><br><span class="line">        X = dfa[target.charAt(j)][X];<span class="comment">//重启状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟一遍DFA</span></span><br><span class="line">    <span class="keyword">int</span> i,j,N = source.length();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>,j=<span class="number">0</span>; i  &lt; N&amp;&amp;j&lt; M; i++) &#123;</span><br><span class="line">        j = dfa[source.charAt(i)][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M) <span class="keyword">return</span> i-M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文本串T某个前缀的后缀是模式串P的前缀。取最长的后缀。<br>1 子序列 不连续 2 字串 连续<br>KMP:getIndexOf<br>d之前【最长前缀】和【最长后缀】的匹配长度<br>(abcabc)d 前缀：(a-&gt;ab-&gt;abc-&gt;…-&gt;abcab) 后缀:(c-&gt;bc-&gt;abc-&gt;…-&gt;bcabc)<br>所以最长匹配是3：abc,记录在d位置上<br>int[]next =  f(“abcabcd”)={-1,0,0,1，2，3}<br>关键加速求解匹配</p>
<h3 id="3-最长不重复字串"><a href="#3-最长不重复字串" class="headerlink" title="3 最长不重复字串"></a>3 最长不重复字串</h3><p>18%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LS</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">            start = Math.max(start,map.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max,i-start+<span class="number">1</span>);</span><br><span class="line">        map.put(c,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="879"><a href="#879" class="headerlink" title="879"></a>879</h3><p>G 名成员 第i种犯罪会产生<code>profit[i]</code> 利润，需要<code>group[i]</code>名成员参与。计划产生P利润有多少种方案。</p>
<blockquote>
<p>Input: G = 5, P = 3, group = [2,2], profit = [2,3]<br>output: 2</p>
</blockquote>
<p><code>dp[k][i][j]</code> 产生i利润 用j个人 完成前k个任务 的方案数</p>
<h3 id="576-无向图访问所有点的最短边数"><a href="#576-无向图访问所有点的最短边数" class="headerlink" title="576 无向图访问所有点的最短边数"></a>576 无向图访问所有点的最短边数</h3><h3 id="fraction-背包问题"><a href="#fraction-背包问题" class="headerlink" title="fraction 背包问题"></a>fraction 背包问题</h3><p>Items can be broen down 贪心按value/weight排序<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/knapsack.jpg" alt="knapsack.jpg"></p>
<h3 id="顶点覆盖"><a href="#顶点覆盖" class="headerlink" title="顶点覆盖"></a>顶点覆盖</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/pointcover.jpg" alt="pointcover.jpg"><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/vetexcover.jpg" alt="vetexcover.jpg"></p>
<h3 id="最大团：在一个无向图中找出一个点数最多的完全图"><a href="#最大团：在一个无向图中找出一个点数最多的完全图" class="headerlink" title="最大团：在一个无向图中找出一个点数最多的完全图"></a>最大团：在一个无向图中找出一个点数最多的完全图</h3><h3 id="任务分配问题一般可以在多项式时间内转化成最大流量问题"><a href="#任务分配问题一般可以在多项式时间内转化成最大流量问题" class="headerlink" title="任务分配问题一般可以在多项式时间内转化成最大流量问题"></a>任务分配问题一般可以在多项式时间内转化成最大流量问题</h3><h3 id="hdu-1813-IDA搜索Iterative-Deepening-A"><a href="#hdu-1813-IDA搜索Iterative-Deepening-A" class="headerlink" title="hdu 1813 IDA搜索Iterative Deepening A,"></a>hdu 1813 IDA<em>搜索Iterative Deepening A</em>,</h3><h3 id="tsp"><a href="#tsp" class="headerlink" title="tsp"></a>tsp</h3><p>最小生成树解TSP<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSTTSP.jpg" alt="MSTTSP.jpg"><br>这样求得的最优解不超过真正最优解的2倍<br>证明：2-近似算法<br>任何一个哈密顿回路OPT删去一条边就是一个生成树。<br>我们找的是最小生成树T肯定小于哈密顿回路减1条边的生成树长度<br>所以T&lt;OPT<br>所以欧拉回路&lt;2OPT<br>因为抄近路不会增加长度所以MST生成的结果不会超过2OPT</p>
<p>最小权匹配算法MM<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MMTSP.jpg" alt="MMTSP.jpg"><br>1.奇数度的顶点一定是偶数个，将偶数个奇数度定点两两配对<br>2.将每个匹配加入最小生成树，每个顶点都变成偶数度，得到欧拉图<br>3.沿着欧拉回路跳过走过的点抄近路 得到哈密顿回路<br>证明：不超过最优解的1.5倍</p>
<p>代价函数：<br>在搜索树结点计算的最大化问题以该节点为根的值（可行解/目标函数）的上界。<br>父节点不小于子节点（最大化问题）</p>
<p>界：到达叶节点得到的最优值<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/pagbb.jpg" alt="pagbb.jpg"><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bbtsp.jpg" alt="bbtsp.jpg"></p>
<p>optaPlanner<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/optaplanner.jpg" alt="optaplanner.jpg"></p>
<ol>
<li>数学公式定义</li>
<li>随机算法模板<br>2.1 迭代局部搜索</li>
</ol>
<p>tsp数据集<br><a href="https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/" target="_blank" rel="noopener">https://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/</a></p>
<p><a href="https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournament" target="_blank" rel="noopener">https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#travelingTournament</a><br>TSPP:tsp with profit（在顶点上）分3种</p>
<ol>
<li>PTP(profitable tour problem)找到最小 cost-profit 的circuit</li>
<li>OP(orienteering problem),也叫selective TSP(STSP)。cost是约束，求不超过cost的最大profit</li>
<li>PCTSP（prize-collecting)profit是约束，目的是找到不低于profit的最小cost。</li>
</ol>
<p>数据：<br>遗传算法：<br>最大效益中國郵差問題</p>
<p>time window on vertex OP </p>
<p> VRP</p>
<p>0~3的tspdp解法<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/tspdp.jpg" alt="tspdp.jpg"></p>
<h3 id="ip2cidr"><a href="#ip2cidr" class="headerlink" title="ip2cidr"></a>ip2cidr</h3><p>找末尾1的位置<code>x &amp; -x</code></p>
<h3 id="131"><a href="#131" class="headerlink" title="131"></a>131</h3><h3 id="819-找出句子中出现频率最高没被ban掉的词"><a href="#819-找出句子中出现频率最高没被ban掉的词" class="headerlink" title="819 找出句子中出现频率最高没被ban掉的词"></a>819 找出句子中出现频率最高没被ban掉的词</h3><p>正则去掉所有标点</p>
<blockquote>
<p>“Bob hit a ball, the hit BALL flew far after it was hit.”</p>
</blockquote>
<p>pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。<br>其他六个是<br>L：字母；<br>M：标记符号（一般不会单独出现）；<br>Z：分隔符（比如空格、换行等）；<br>S：符号（比如数学符号、货币符号等）；<br>N：数字（比如阿拉伯数字、罗马数字等）；<br>C：其他字符<br>P：各种标点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//busymannote</span></span><br><span class="line"><span class="comment">// [Bob, hit, a, ball, the, hit, BALL, flew, far, after, it, was, hit]</span></span><br><span class="line">paragraph.split(<span class="string">"\\PL+"</span>);</span><br><span class="line"><span class="comment">// Bob hit a ball the hit BALL flew far after it was hit</span></span><br><span class="line">paragraph.replaceAll(<span class="string">"\\pP"</span>,<span class="string">""</span>);</span><br><span class="line">paragraph.replaceAll(<span class="string">"[^a-zA-Z ]"</span>, <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> </span>&#123;</span><br><span class="line"> Set&lt;String&gt; ban = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(banned));</span><br><span class="line">    Map&lt;String,Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    String[] split = paragraph.toLowerCase().split(<span class="string">"\\PL+"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s:split)<span class="keyword">if</span>(!ban.contains(s))cnt.put(s,cnt.getOrDefault(s,<span class="number">0</span> )+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.max(cnt.entrySet(),Map.Entry.comparingByValue()).getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="亚线性算法o-n-小于输入规模"><a href="#亚线性算法o-n-小于输入规模" class="headerlink" title="亚线性算法o(n)小于输入规模"></a>亚线性算法o(n)小于输入规模</h3><p>亚线性时间：<br><a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E5%B0%BA%E5%BA%A6%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">scale-free network</a>S：<br>大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接。<br>网络中随机抽取一个节点，它的度是多少呢？这个概率分布就称为节点的度分布<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/scalenetwork.jpg" alt="scalenetwork.jpg"><br>顶点的度满足幂律分布（也称为帕累托分布）,所以不能均匀采样计算每个人的平均度数。</p>
<p>亚线性空间<br>中位数问题，知道所有的输入，有O(n)的分治算法</p>
<h3 id="水库抽样Reservpor-Sampling-亚线性空间"><a href="#水库抽样Reservpor-Sampling-亚线性空间" class="headerlink" title="水库抽样Reservpor Sampling 亚线性空间"></a>水库抽样Reservpor Sampling 亚线性空间</h3><blockquote>
<p>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</p>
</blockquote>
<p>当扫描到前n个数字时，保留数组中k个均匀的抽样<br>1.k大小的数组<br>2.填充k个元素<br>3.收到第i个元素t。以k/i的概率替换A中的元素。这样保证收到第i个数字的时候，i在k中的概率是k/i。<br>实现：生成<code>[1..k..i]</code>中随机数j，如果j&lt;=k（k/i的概率),A[j]=t<br>证明：第i个数接收时有k/i的概率在k数组中，当第i+1个数接收时,i+1有k/(i+1)概率在数组k中，并且刚好替换掉的是第i个数的概率是k中选i：1/k，所以第i+1个数来之后i还在k中的概率是（1-k/(i+1)*1/k)=（1-1/(1+i)）<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/shuku.jpg" alt="shuku.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] stream,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] reserve = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        reserve[i]=stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;k)reserve[j]=stream[i];</span><br><span class="line">    &#125;<span class="comment">//sout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="398-数组中重复元素随机返回index"><a href="#398-数组中重复元素随机返回index" class="headerlink" title="398 数组中重复元素随机返回index"></a>398 数组中重复元素随机返回index</h3><blockquote>
<p>int[] nums = new int[] {1,2,3,3,3};<br>Solution solution = new Solution(nums);</p>
</blockquote>
<blockquote>
<p>// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.<br>solution.pick(3);</p>
</blockquote>
<blockquote>
<p>// pick(1) should return 0. Since in the array only nums[0] is equal to 1.<br>solution.pick(1);</p>
</blockquote>
<p>水库抽样：流式处理，空间复杂度O(1),pick O(N)<br>如果用hashmap，初始化O(N)时间，O（N）空间，数组太大就不行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">this</span>.r = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rst =-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=target)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//以1/++cnt的概率抽这个数</span></span><br><span class="line">            <span class="comment">// int j = r.nextInt(++cnt);</span></span><br><span class="line">            <span class="comment">// if(j==0)rst=i;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//不赋值变量从180ms-&gt;127ms</span></span><br><span class="line">            <span class="keyword">if</span>(r.nextInt(++cnt)==<span class="number">0</span>)rst=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="？？382-随机链表-extremely-large-and-its-length-is-unknown"><a href="#？？382-随机链表-extremely-large-and-its-length-is-unknown" class="headerlink" title="？？382 随机链表 extremely large and its length is unknown"></a>？？382 随机链表 extremely large and its length is unknown</h3><p>长度不知，读到第三个node，让它的概率变成1/3，用1/3的概率替换掉之前选择的item</p>
<blockquote>
<p>由于计算机产生的随机数都是伪随机数，对于相同的随机数引擎会产生一个相同的随机数序列，因此，如果不使用静态变量（static），会出现每次调用包含随机数引擎的函数时，随机数会重新开始产生随机数，因此会产生相同的一串随机数。比如你第一次调用产生100个随机数，第二次调用仍然会产生这一百个随机数。如果将随机数引擎设置为静态变量，那么第一次调用会产生随机数序列中的前100个随机数，第二次调用则会产生第100到200的随机数。</p>
</blockquote>
<h3 id="频繁元素计算-Misra-Gries-MG-算法"><a href="#频繁元素计算-Misra-Gries-MG-算法" class="headerlink" title="频繁元素计算 Misra Gries(MG)算法"></a>频繁元素计算 Misra Gries(MG)算法</h3><h3 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h3><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><h3 id="堆排序不稳定"><a href="#堆排序不稳定" class="headerlink" title="堆排序不稳定"></a>堆排序不稳定</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/stringsort.jpg" alt="stringsort.jpg"><br>测试：6 5 12 至少都比内置的快<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String str=<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line">       String[] words2 = <span class="keyword">new</span> String[<span class="number">10000</span>];</span><br><span class="line">       Random random=<span class="keyword">new</span> Random();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span>  j= <span class="number">0</span>; j &lt;words2.length ; j++) &#123;</span><br><span class="line">           StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">           <span class="keyword">int</span> length = random.nextInt(<span class="number">30</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">               <span class="keyword">int</span> number=random.nextInt(<span class="number">62</span>);</span><br><span class="line">               sb.append(str.charAt(number));</span><br><span class="line">           &#125;</span><br><span class="line">           words2[j] = sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line">       String[] word3 = words2.clone();</span><br><span class="line">       String[] word4 = words2.clone();</span><br><span class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">       sort(words2, <span class="number">0</span>,words2.length-<span class="number">1</span> ,<span class="number">0</span> );</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end-start);</span><br><span class="line">       <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">       MSD.sort(word3);</span><br><span class="line">       <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end2-start2);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">       Arrays.sort(word4);</span><br><span class="line">       <span class="keyword">long</span> end3 = System.currentTimeMillis();</span><br><span class="line">       System.out.println(end3-start3);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="三向快速排序-不稳定"><a href="#三向快速排序-不稳定" class="headerlink" title="三向快速排序 不稳定"></a>三向快速排序 不稳定</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/threepart.jpg" alt="threepart.jpg"><br>取第一位，将所有字符串分成3份<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threewaypart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&gt;d)<span class="keyword">return</span> s.charAt(d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] a ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        String tmp = a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo,gt = hi;</span><br><span class="line">        <span class="keyword">int</span> v = charAt(a[lo],d);</span><br><span class="line">        <span class="keyword">int</span> i = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = charAt(a[i],d);</span><br><span class="line">            <span class="keyword">if</span>(t&lt;v)swap(a,lt++,i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t&gt;v)swap(a,i,gt--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,lo,lt-<span class="number">1</span>,d);</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=<span class="number">0</span>)sort(a, lt, gt, d+<span class="number">1</span>);</span><br><span class="line">        sort(a,gt+<span class="number">1</span>,hi , d );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">"4PGC938"</span>,<span class="string">"2iye230"</span>,<span class="string">"2iye231"</span>,<span class="string">"3cio720"</span>,<span class="string">"fds"</span>,<span class="string">"1"</span>,<span class="string">"4PGC933"</span>,<span class="string">"4PGC9382"</span>,<span class="string">"4PGC9384"</span>,<span class="string">"4PGC9385"</span>,<span class="string">"4PGC9387"</span>,<span class="string">"4PGC9388"</span>,<span class="string">"4PGC9389"</span>&#125;;</span><br><span class="line">       sort(words,<span class="number">0</span> , words.length-<span class="number">1</span>,<span class="number">0</span> );</span><br><span class="line">        System.out.println(Arrays.toString(words));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="MSD-most-significant-digit-first-不用长度相同从左开始"><a href="#MSD-most-significant-digit-first-不用长度相同从左开始" class="headerlink" title="MSD most-significant-digit-first 不用长度相同从左开始"></a>MSD most-significant-digit-first 不用长度相同从左开始</h3><p>一般也是NW复杂度，对于N很大的情况可以达到$Nlog_RN$<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSD.jpg" alt="MSD.jpg"><br>ASCII的R是256，需要count[258]<br>Unicode需要65536，可能要几小时<br>按第0位分组，对每组递归按第1位分组…n<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/MSD2.jpg" alt="MSD2.jpg"><br>当前前d位都相同的组，组内字符串个数小于15，用插入排序<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] aux;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&gt;d)<span class="keyword">return</span> s.charAt(d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> String[a.length];</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(String v,String w,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt;Math.min(v.length(),w.length()) ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.charAt(i)&lt;w.charAt(i))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(v.charAt(i)&gt;w.charAt(i))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  v.length()&lt;w.length();</span><br><span class="line"><span class="comment">//        return v.substring(d).compareTo(w.substring(d))&lt;0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//添加一步阈值，如果a长度太小，直接用插入排序</span></span><br><span class="line">    <span class="keyword">if</span>(hi&lt;=lo+M)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;lo&amp;&amp;less(a[j],a[j-<span class="number">1</span>],d);j--) &#123;</span><br><span class="line">                String tmp = a[j];</span><br><span class="line">                a[j]=a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0位留作字符串结尾？</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">2</span> ];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        count[charAt(a[i],d)+<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        aux[count[charAt(a[i],d)+<span class="number">1</span>]++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;=hi ; i++) &#123;</span><br><span class="line">        a[i] =aux[i-lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R ; i++) &#123;</span><br><span class="line">        sort(a,lo+count[i],lo+count[i+<span class="number">1</span>]-<span class="number">1</span>,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] words = &#123;<span class="string">"4PGC938"</span>,<span class="string">"2iye230"</span>,<span class="string">"2iye231"</span>,<span class="string">"3cio720"</span>,<span class="string">"fds"</span>,<span class="string">"1"</span>,<span class="string">"4PGC933"</span>,<span class="string">"4PGC9382"</span>,<span class="string">"4PGC9384"</span>,<span class="string">"4PGC9385"</span>,<span class="string">"4PGC9387"</span>,<span class="string">"4PGC9388"</span>,<span class="string">"4PGC9389"</span>&#125;;</span><br><span class="line">    sort(words);</span><br><span class="line">    System.out.println(Arrays.toString(words));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先"><a href="#LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先" class="headerlink" title="LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先"></a>LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/LSD.jpg" alt="LSD.jpg"><br>长度相同的字符串，从最后一位开始排序<br>（如何应用到变长字符串？）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="comment">//只初始化一次</span></span><br><span class="line">    String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = w-<span class="number">1</span>; d &gt;=<span class="number">0</span> ; d--) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">            count[a[i].charAt(d)+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;R ; i++) &#123;</span><br><span class="line">            count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">            aux[count[a[i].charAt(d)]++]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a[i]=aux[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="key-index-count-sort键索引计数法-稳定的"><a href="#key-index-count-sort键索引计数法-稳定的" class="headerlink" title="key-index count sort键索引计数法 稳定的"></a>key-index count sort键索引计数法 稳定的</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/indexsort.jpg" alt="indexsort.jpg"><br>count:[0, 2, 3, 1, 2, 1, 3]<br>累加cnt[0, 2, 5, 6, 8, 9, 12] 起始索引<br>结果[a, a, b, b, b, c, d, d, e, f, f, f]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span>[] countt(String s)&#123;</span><br><span class="line">    <span class="keyword">int</span> N = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;N ; i++) &#123;</span><br><span class="line">        <span class="comment">//关键 +1</span></span><br><span class="line">        count[s.charAt(i)-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span>[] acu()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">char</span>[] axuu(String s)&#123;</span><br><span class="line">  <span class="keyword">char</span>[] axu = <span class="keyword">new</span>  <span class="keyword">char</span>[s.length()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//关键 ++</span></span><br><span class="line">        axu[count[s.charAt(i)-<span class="string">'a'</span>]++] = s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> axu;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(countt(<span class="string">"dacffbdbfbea"</span>)));</span><br><span class="line">System.out.println(Arrays.toString(acu()));</span><br><span class="line">String dacffbdbfbea = Arrays.toString(axuu(<span class="string">"dacffbdbfbea"</span>));</span><br></pre></td></tr></table></figure></p>
<h3 id="611数组中符合三角形边长的对数"><a href="#611数组中符合三角形边长的对数" class="headerlink" title="611数组中符合三角形边长的对数"></a>611数组中符合三角形边长的对数</h3><p>线性扫描 复杂度n^2<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc611.jpg" alt="lc611.jpg"></p>
<h3 id="数组组成三角形的最大周长nlogn"><a href="#数组组成三角形的最大周长nlogn" class="headerlink" title="数组组成三角形的最大周长nlogn"></a>数组组成三角形的最大周长nlogn</h3><p>贪心，排序，如果 $a[i]&lt;a[i-1]+a[i-2]$ 则没有其他两条边可以两边之和<code>&gt;</code>第三边了，换下一条当最长边。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxC</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">2</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i-<span class="number">1</span>]+A[i-<span class="number">2</span>])<span class="keyword">return</span> A[i]+A[i-<span class="number">1</span>]+A[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MST："><a href="#MST：" class="headerlink" title="MST："></a>MST：</h3><p>将图的点分成2个集合，用边连接两个集合中的点，最小的边集是MST</p>
<h3 id="MST和聚类："><a href="#MST和聚类：" class="headerlink" title="MST和聚类："></a>MST和聚类：</h3><p>连通图<br>将图的点分成2个集合，边两端连的是不同集合，最小的边集是MST<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/mst.jpg" alt="mst.jpg"><br>假设分为6和其它点2个集合，在6-2 3-6 6-0 6-4四条连接两个集合的边中取最小边，标记成黑色。<br>再随机分两个集合，不要让黑色边跨集合</p>
<h4 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h4><p>kruskal遍历所有边(优先队列)，判断边的两点是否在一个集合里(find)，如果在则说明这条边加上会有环，如果不在，则union(v,w)并且将这条边加入mst。直到找到n-1条边。<br>复杂度$ElogE$ 空间E</p>
<ul>
<li>因为不仅维护优先队列还要union-find所以效率一般比prim慢</li>
</ul>
<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><p>prim复杂度$ElogV$ 空间V<br>prim优化：将marked[]和emst[] 替换为两个顶点索引数组edgeTo[] 和distTo[]<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/prim.jpg" alt="prim.jpg"><br>每个没在MST中的顶点只保留(更新)离mst中点最短的边。</p>
<h3 id="聚类：single-link"><a href="#聚类：single-link" class="headerlink" title="聚类：single link"></a>聚类：single link</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/singlelink.jpg" alt="singlelink.jpg"><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/singleclu.jpg" alt="singleclu.jpg"></p>
<h3 id="753-输出能包含所有密码可能性的最短串"><a href="#753-输出能包含所有密码可能性的最短串" class="headerlink" title="753 输出能包含所有密码可能性的最短串"></a>753 输出能包含所有密码可能性的最短串</h3><blockquote>
<p>Input: n = 2, k = 2<br>Output: “00110” 包含了00,01,10,11</p>
</blockquote>
<p><a href="https://leetcode.com/problems/cracking-the-safe/solution/" target="_blank" rel="noopener">官方解</a><br><a href="https://www.youtube.com/watch?v=EWG6e-yBL94" target="_blank" rel="noopener">de Bruijn Card Trick</a></p>
<ol>
<li>方法1<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc753.jpg" alt="lc753.jpg"><br>每个点1次<br>写出n个数的组合(11,12,22,21) 并找出哈密尔顿路径</li>
<li>方法2<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/lc7532.jpg" alt="lc7532.jpg"><br>每条边1次<br>写出(n-1)个数的组合(1,2) 的完全图，找出欧拉环路(circuit)。de Bruijn 序列的数量为欧拉环的数量。<br>用k个数字，长度有n的组合有$k^n$种，但是因为可以首尾相连，总共de Bruijn的数量是<br>$\frac{k! k^{n-1}}{k^n}$</li>
<li>方法3 用不重复的最小字典序Lyndon Word<br>例子：<br>1.列出所有长度为4的组合1111,1112…以及能被4整除的长度(1,2)的组合1,2,11,22.<br>2.所有按字典序排序<br>3.去除所有旋转之后相同的组合，只保留字典序最小的：01和10只保留01<blockquote>
<p>n = 6, k = 2<br>0 000001 000011 000101 000111 001 001011 001101 001111 01 010111 011 011111 1</p>
</blockquote>
</li>
<li>连起来就是最小的de Bruijin sequence</li>
</ol>
<h4 id="Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words"><a href="#Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words" class="headerlink" title="Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words."></a>Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.</h4><h3 id="332-欧拉路径-每条边一次"><a href="#332-欧拉路径-每条边一次" class="headerlink" title="332 欧拉路径 每条边一次"></a>332 欧拉路径 每条边一次</h3><p>(这道题不用判断)<br>只有1个点入度比出度少1（起点）&amp;&amp; 只有一个点入度比出度多1（终点）其余点入度==出度</p>
<h4 id="Hierholzer：O-e"><a href="#Hierholzer：O-e" class="headerlink" title="Hierholzer：O(e)"></a>Hierholzer：O(e)</h4><p>删除边<code>e(u,v)</code>，并<code>dfs(v)</code>，不断寻找封闭回路，</p>
<blockquote>
<p>从v点出发一定会回到v。因为入度出度相等。虽然可能不包含所有点和边。<br>总是可以回到以前的点，从另一条路走，把其它所有的边全部遍历掉。</p>
</blockquote>
<p><strong>不是拓扑排序，拓扑排序每个点仅1次</strong><br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/Hierholzer1.jpg" alt="Hierholzer1.jpg"><br>path里加入{0},{2}头插法{2,0}//保证远的在后面<br>dfs回到1，继续找封闭回路<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/Hierholzer2.jpg" alt="Hierholzer2.jpg"></p>
<blockquote>
<p>Input: tickets = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code></p>
</blockquote>
<ol>
<li>用hashmap记录每个点的出度的点，建图</li>
<li>输出字典序靠前的序列，用优先队列，先访问的会后回溯到dfs插到链表头。（后序遍历：全部遍历完了再加入（退栈)）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; rst = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    Map&lt;String,PriorityQueue&lt;String&gt; &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String[] edge:tickets)&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; nei = map.getOrDefault(edge[<span class="number">0</span>],<span class="keyword">new</span> PriorityQueue&lt;String&gt;());</span><br><span class="line">        nei.add(edge[<span class="number">1</span>]);</span><br><span class="line">        map.put(edge[<span class="number">0</span>],nei);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rst,map,<span class="string">"JFK"</span>);</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedList&lt;String&gt; rst,Map&lt;String,PriorityQueue&lt;String&gt; &gt; map,String start)</span></span>&#123;</span><br><span class="line">  PriorityQueue&lt;String&gt; pri = map.get(start);</span><br><span class="line">    <span class="keyword">while</span>(pri!=<span class="keyword">null</span>&amp;&amp;!pri.isEmpty())</span><br><span class="line">        dfs(rst,map,pri.poll());</span><br><span class="line">    rst.addFirst(start);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历stack：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="两个帅不能处在同一条直线上的所有可行位置"><a href="#两个帅不能处在同一条直线上的所有可行位置" class="headerlink" title="两个帅不能处在同一条直线上的所有可行位置"></a>两个帅不能处在同一条直线上的所有可行位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">81</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i/<span class="number">9</span>%<span class="number">3</span>==i%<span class="number">9</span>%<span class="number">3</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i/<span class="number">9</span>+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;i%<span class="number">9</span>+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻煎饼排序的最少次数"><a href="#翻煎饼排序的最少次数" class="headerlink" title="翻煎饼排序的最少次数"></a>翻煎饼排序的最少次数</h3><h3 id="164-桶排序找区间最大值"><a href="#164-桶排序找区间最大值" class="headerlink" title="164 桶排序找区间最大值"></a>164 桶排序找区间最大值</h3><h3 id="求数组的最大gap"><a href="#求数组的最大gap" class="headerlink" title="求数组的最大gap"></a>求数组的最大gap</h3><h3 id="二分图-让每条边的两个顶点属于不同的集合"><a href="#二分图-让每条边的两个顶点属于不同的集合" class="headerlink" title="二分图 让每条边的两个顶点属于不同的集合"></a>二分图 让每条边的两个顶点属于不同的集合</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bipartite.jpg" alt="bipartite.jpg"><br>max match：没有两点共享1点，最多的边数<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/matching.jpg" alt="matching.jpg"><br>maximal:再加一条边就有两条边有共同顶点了<br>maximum：有两种matching的画法，3条边的为max</p>
<ol>
<li>室友分配问题不是二分图，因为有3人团，是最大团问题</li>
<li>出租车和乘客匹配问题 问题是求最小边和</li>
<li>分配老师给班级是二分图max match问题</li>
</ol>
<h4 id="785-是否是二分图"><a href="#785-是否是二分图" class="headerlink" title="785 是否是二分图"></a>785 是否是二分图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入[0]=&#123;1,3&#125;0的邻点是1,3</span><br><span class="line">[[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br></pre></td></tr></table></figure>
<p>不用建图，已经是邻接表了。<br>按算法4上75%<br>还可以优化mark和color为一个数组，用位运算变更状态，变成boolean的dfs<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">boolean</span>[] color;</span><br><span class="line"><span class="keyword">boolean</span> isTwo = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBiartie</span><span class="params">(<span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    color = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s =<span class="number">0</span>;s&lt;graph.length;s++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[s])dfs(graph,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isTwo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :G[v])&#123;</span><br><span class="line">        color[w]=!color[v];</span><br><span class="line">        dfs(G,w);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])isTwo=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成boolean的dfs-&gt;100%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">boolean</span>[] color;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    color = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;graph.length ; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[s]&amp;&amp;!dfs(graph,s))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w:graph[v])&#123;</span><br><span class="line">        <span class="comment">//*关键</span></span><br><span class="line">        <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">        color[w]=!color[v];</span><br><span class="line">        <span class="keyword">if</span>(!dfs(graph,w))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人"><a href="#886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人" class="headerlink" title="886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人"></a>886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人</h4><p>边集-&gt;邻接表-&gt;二分图</p>
<p>边集-&gt;邻接矩阵-&gt;二分图dfs染色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBiparitition</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span>[][] dislikes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="comment">//边集-&gt;无向图 邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dislikes)&#123;</span><br><span class="line">        graph[d[<span class="number">0</span>]-<span class="number">1</span>][d[<span class="number">1</span>]-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        graph[d[<span class="number">1</span>]-<span class="number">1</span>][d[<span class="number">0</span>]-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(group[i] == <span class="number">0</span>&amp;&amp; !dfs2d(graph,group,i,<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可不可以分到g组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs2d</span><span class="params">(<span class="keyword">int</span>[][] graph,<span class="keyword">int</span>[] group,<span class="keyword">int</span> idx,<span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    group[idx] = g;</span><br><span class="line">    <span class="comment">//行是邻边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[idx][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == g)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">0</span>&amp;&amp;!dfs2d(graph,group,i,-g))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="图的度"><a href="#图的度" class="headerlink" title="图的度"></a>图的度</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphmostuse.jpg" alt="graphmostuse.jpg"><br>1.顶点v的度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(Map&lt;Integer,List&lt;Integer&gt;&gt; graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :graph.get(v))&#123;</span><br><span class="line">        degree++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> degree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.所有顶点的最大度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDegree</span><span class="params">(Map&lt;Integer,List&lt;Integer&gt;&gt; graph)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:graph.keySet())&#123;</span><br><span class="line">        max = Math.max(degree(graph,v ),max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.</p>
<h3 id="图的遍历顺序"><a href="#图的遍历顺序" class="headerlink" title="图的遍历顺序"></a>图的遍历顺序</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphtra.jpg" alt="graphtra.jpg"><br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pre;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; post;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge:edges)&#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        post = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        reversePost = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">( List&lt;Integer&gt;[] graph ,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        pre.add(v);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w :graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])</span><br><span class="line">                dfs(graph,w);</span><br><span class="line">        &#125;</span><br><span class="line">        post.add(v);</span><br><span class="line">        reversePost.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 5, 4, 6, 9, 10, 11, 12, 2, 3, 7, 8]</span></span><br><span class="line"><span class="comment">[1, 4, 5, 10, 12, 11, 9, 6, 0, 3, 2, 7, 8]</span></span><br><span class="line"><span class="comment">[8, 7, 2, 3, 0, 6, 9, 11, 12, 10, 5, 4, 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DepthFirstOrder sl = <span class="keyword">new</span> DepthFirstOrder(<span class="number">13</span>,<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">5</span>&#125;,&#123;<span class="number">0</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,<span class="number">6</span>&#125;,&#123;<span class="number">8</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>&#125;,&#123;<span class="number">9</span>,<span class="number">12</span>&#125;,&#123;<span class="number">11</span>,<span class="number">12</span>&#125;&#125;);</span><br><span class="line">        System.out.println(sl.pre);</span><br><span class="line">        System.out.println(sl.post);</span><br><span class="line">        System.out.println(sl.reversePost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="调度问题：给定一组任务，安排执行时间-gt-拓扑排序"><a href="#调度问题：给定一组任务，安排执行时间-gt-拓扑排序" class="headerlink" title="调度问题：给定一组任务，安排执行时间-&gt;拓扑排序"></a>调度问题：给定一组任务，安排执行时间-&gt;拓扑排序</h3><p><strong>DAG的拓扑排序是dfs逆后排序</strong><br>将一张图拉成边全部向下的图<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/tuopu.jpg" alt="tuopu.jpg"></p>
<h4 id="拓扑排序：有向环"><a href="#拓扑排序：有向环" class="headerlink" title="拓扑排序：有向环"></a>拓扑排序：有向环</h4><blockquote>
<p>{0, 3}, {1, 3}, {3, 2}, {2, 1} 0-&gt; 3-&gt;2-&gt;1-&gt;3<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/graphcy.jpg" alt="graphcy.jpg"></p>
</blockquote>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法4 p386</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"><span class="keyword">private</span> Deque&lt;Integer&gt; cycle;<span class="comment">//环</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Deque <span class="title">cycle</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    marked =<span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    List&lt;Integer&gt;[] graph=<span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;numCourses ; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge :prerequisites) &#123;</span><br><span class="line">        graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(graph));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    onStack[v] =<span class="keyword">true</span>;</span><br><span class="line">    marked[v] =<span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span>(graph[v].size()&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w:graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(cycle!=<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">            edgeTo[w] = v;</span><br><span class="line">            dfs(graph,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">            cycle = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x !=w ; x=edgeTo[x]) &#123;</span><br><span class="line">                cycle.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            cycle.push(w);</span><br><span class="line">            cycle.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[v] =<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="207-先修课程有环则返回false-拓扑排序"><a href="#207-先修课程有环则返回false-拓扑排序" class="headerlink" title="?207 先修课程有环则返回false 拓扑排序"></a>?207 先修课程有环则返回false 拓扑排序</h4><p>??和并查集的区别（？<br>按算法4上88.45%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> cycle = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    marked =<span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    List&lt;Integer&gt;[] graph=<span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;numCourses ; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;2,0&#125;,&#123;1,0&#125;,&#123;3,1&#125;,&#123;3,2&#125;,&#123;1,3&#125;&#125;-&gt;[[], [0, 3], [0], [1, 2]]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge :prerequisites) &#123;</span><br><span class="line">        graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])dfs(graph,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(graph[v].size()&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//dfs是从起点到v的有向路径，onstack保存了递归中经历的点</span></span><br><span class="line">    onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w :graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!marked[w])</span><br><span class="line">        dfs(graph,w);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">            cycle = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个点出发没有环</span></span><br><span class="line">    onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>56% 有可以优化到100%4ms的方法<br>1.邻接表存储课程依赖图L<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List[] graph_;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span></span><br><span class="line"><span class="function">    graph_ </span>= <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">    &#123;graph_[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] back:prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = back[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lesson = back[<span class="number">1</span>];</span><br><span class="line">        graph_[lesson].add(pre);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.定义状态<code>int[] visit = new int[numCourses];</code><br>3.dfs每个顶点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hasCircle(i,visit))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>4.dfs 检查有没有环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span>[] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[idx]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(visited[idx]==<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    List&lt;Integer&gt; neib = graph_[idx];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:neib)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCircle(i,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[idx]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="210-输出修课顺序"><a href="#210-输出修课顺序" class="headerlink" title="210 输出修课顺序"></a>210 输出修课顺序</h4><blockquote>
<p>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>  Output: [0,1,2,3] or [0,2,1,3]</p>
</blockquote>
<p>用onStack和post 11%</p>
<h3 id="kolakoski序列找规律"><a href="#kolakoski序列找规律" class="headerlink" title="kolakoski序列找规律"></a>kolakoski序列找规律</h3><p><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/kolakoski.jpg" alt="kolakoski.jpg"></p>
<h4 id="lc481-返回kolakoski前N中有几个1"><a href="#lc481-返回kolakoski前N中有几个1" class="headerlink" title="lc481 返回kolakoski前N中有几个1"></a>lc481 返回kolakoski前N中有几个1</h4><h3 id="174-骑士从左上到右下找公主，求初始血量"><a href="#174-骑士从左上到右下找公主，求初始血量" class="headerlink" title="174 骑士从左上到右下找公主，求初始血量"></a>174 骑士从左上到右下找公主，求初始血量</h3><p>dp[i][j]表示到i,j的最少血量，因为右下角一格也要减<br>dp[n-1][m],dp[n][m-1]=1表示走完了右下角还剩下1点血<br>dp[0~n-2][m]和dp[n][0~m-2]都是非法值，为了取min设置MAX_VALUE<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])-dungeon[i][j]);</span><br></pre></td></tr></table></figure></p>
<h3 id="伪多项式时间"><a href="#伪多项式时间" class="headerlink" title="伪多项式时间"></a>伪多项式时间</h3><p>一个整数是否是素数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n mod i</span><br></pre></td></tr></table></figure></p>
<p>运行时间与数值n的二进制位数呈指数增长<br>整数需要的bit位数x=logn 复杂度$O(2^{x})$<br>每加1位，时间翻倍<br>857 ：‭‭001101011001‬<br>421 ：‭‭000110100101‬</p>
<hr>
<h3 id="97-s1和s2是否交错组成s3"><a href="#97-s1和s2是否交错组成s3" class="headerlink" title="!!97 s1和s2是否交错组成s3"></a>!!97 s1和s2是否交错组成s3</h3><p><a href="https://leetcode.com/problems/interleaving-string/solution/" target="_blank" rel="noopener">Solution</a><br>状态dp[len1][len2]表示s1长度len1，s2长度len2出现在s3[len1+len2]中<br>任意位置s3[i]一定是由s1[m],s2[n]组成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1=&quot;aa  bc   c&quot;</span><br><span class="line">s2=&quot;  db  bca&quot;</span><br><span class="line">s3=&quot;aadbbcbcac&quot;</span><br></pre></td></tr></table></figure></p>
<p>dp行表示当前len1的匹配情况下，不断扩展len2与s3的匹配情况<br>dp列表示当前len2的匹配情况下，不断扩展len1与s3的匹配情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遍历s3的位置：</span><br><span class="line">  遍历s1的长度，s3+1-s1为s2的长度</span><br><span class="line">    如果s3当前位置与s2当前匹配&amp;&amp;dp[][s2-1]匹配了</span><br><span class="line">       ||s3当前与s1当前匹配并且dp[s1-1][s2]:</span><br><span class="line">         dp[s1][s2] = true</span><br></pre></td></tr></table></figure></p>
<p>可以用滚动数组降成1维</p>
<p>？？？按背包问题递减更新 99%<br>ct的意义<br>动态规划中的ct<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s3.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ct = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = Math.min(s1.length(), i + <span class="number">1</span>); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; (i-j)&lt;s2.length() &amp;&amp;s2.charAt(i - j) == s3.charAt(i)) ct = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[j - <span class="number">1</span>] &amp;&amp; s1.charAt(j- <span class="number">1</span>) == s3.charAt(i))&#123;</span><br><span class="line">                dp[j] = <span class="keyword">true</span>;</span><br><span class="line">                ct = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> dp[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>]&amp;&amp;i&lt;s2.length()&amp;&amp;s2.charAt(i)==s3.charAt(i))ct = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ct)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="62-从左上角走到右下角总共有多少种不同方式"><a href="#62-从左上角走到右下角总共有多少种不同方式" class="headerlink" title="62 从左上角走到右下角总共有多少种不同方式"></a>62 从左上角走到右下角总共有多少种不同方式</h3><p>f[m][n] = f[m-1][n]+f[m][n-1]<br>简化成一维dp<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniPath</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="comment">//一行一行扫下去，下一行的底数是上一行，表示从上一行走下来的走法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//加上左边走过来的走法</span></span><br><span class="line">            res[j]+=res[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="!数学公式"></a>!数学公式</h4><p>m行n列，左上到右下总共步数m+n-2步，可以选择m-1个时间点向下走。<br>问题可以转换为有(m+n-2)位，可以赋值m-1次1和n-1次0有多少数字。<br>$C_{m+n-2}^{m-1}$<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rst=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;Math.min(m-<span class="number">1</span>,n-<span class="number">1</span>);i++)&#123;</span><br><span class="line">    rst=rst*(m+n-<span class="number">2</span>-i)/(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)rst;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="63-有障碍物的左上到右下"><a href="#63-有障碍物的左上到右下" class="headerlink" title="63 有障碍物的左上到右下"></a>63 有障碍物的左上到右下</h3><p>dp[i][j]定义为走到i,j的方法数，障碍物则为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obs[i][j]==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//dp[i][j]=0//res[j]=0;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="64-从左上角走到右下角的最少sum"><a href="#64-从左上角走到右下角的最少sum" class="headerlink" title="64 从左上角走到右下角的最少sum"></a>64 从左上角走到右下角的最少sum</h3><p>grid[n][m]+=Math.min(grid[n-1][m],grid[n][m-1]);</p>
<hr>
<h3 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h3><p>以1为首位的数字的概率为30%</p>
<h3 id="169-众数-Boyer-Moore-Voting-Algorithm"><a href="#169-众数-Boyer-Moore-Voting-Algorithm" class="headerlink" title="!!!169 众数 Boyer-Moore Voting Algorithm"></a>!!!169 众数 Boyer-Moore Voting Algorithm</h3><p>1.hashmap,直到有计数&gt;n/2 break-&gt;return 11%<br>2.随机数44% 因为一半以上都是这个数，可能只要循环两边就找到了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = random.nextInt(nums.length);</span><br><span class="line">        <span class="keyword">int</span> choose = nums[idx];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==cur&amp;&amp;++cnt&gt;nums.length/<span class="number">2</span>)<span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.39% 计算用每个数字的每一位投票，1的个数&gt;n/2则为1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> rst =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        mask = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num&amp;mask)!=<span class="number">0</span>)cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;n/<span class="number">2</span>)rst|=mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-moore-voting-在线算法92"><a href="#4-moore-voting-在线算法92" class="headerlink" title="4.moore voting 在线算法92%"></a>4.moore voting 在线算法92%</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设就是第一个数</span></span><br><span class="line">    <span class="keyword">int</span> maj = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="comment">//第一个数就cnt=1</span></span><br><span class="line">        <span class="keyword">if</span>(num==maj)cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(--cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等于0 从头开始做</span></span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">            maj = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化100%</strong><br>每次取两个不同的数删除，最后剩下的返回<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                res=e;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(res!=e)&#123;</span><br><span class="line">                    count--;<span class="comment">//删除这个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>5.排序取中间的数<br>6.C++专有 部分排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">    nth_element(nums.begin(),nums.begin()+nums.size()/<span class="number">2</span>,nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.分治???</p>
<hr>
<h3 id="节点是随机变量的有向无环图-贝叶斯网络BN"><a href="#节点是随机变量的有向无环图-贝叶斯网络BN" class="headerlink" title="节点是随机变量的有向无环图=贝叶斯网络BN"></a>节点是随机变量的有向无环图=贝叶斯网络BN</h3><p>求联合概率会用到最小生成树</p>
<ol>
<li>如果$84*148=B6A8$成立，则公式采用的是__进制表示的<br>$(8*x+4)*(x^2+4*x+8)=11*x^3+6*x^2+10*x+8$<br>$=&gt;(3x^2+6x+2)(x-12)=0$<br>$=&gt;x=12$</li>
</ol>
<ul>
<li>快速算法：84和148末尾4*8=32实际上是8，则32-8=24是12的倍数<br>24表示在这种进制下个位应该为0</li>
</ul>
<p>逆邻接表：A-&gt;B-&gt;C-&gt;D：B,C,D指向A</p>
<p>树的前/中/后序遍历本质都是DFS</p>
<h3 id="DLS可以达到BFS一样空间的DFS"><a href="#DLS可以达到BFS一样空间的DFS" class="headerlink" title="DLS可以达到BFS一样空间的DFS"></a>DLS可以达到BFS一样空间的DFS</h3><hr>
<h3 id="后缀树字典树-每层多一个字符的字典树"><a href="#后缀树字典树-每层多一个字符的字典树" class="headerlink" title="后缀树字典树 每层多一个字符的字典树"></a>后缀树字典树 每层多一个字符的字典树</h3><h3 id="后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><a href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2" class="headerlink" title="后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)"></a>后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</h3><h3 id="后缀数组-A-后缀的起始位置"><a href="#后缀数组-A-后缀的起始位置" class="headerlink" title="后缀数组 A[]后缀的起始位置"></a>后缀数组 A[]后缀的起始位置</h3><p>//Memory Limit Exceeded<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] suffixes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SuffixArray</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    N = s.length();</span><br><span class="line">    suffixes = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        suffixes[i] = s.substring(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(suffixes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“alohomora”<br>1.按字典序排序所有可能的后缀S[0]=”a”,[1]=”alohomora”,[2]=”homora”..[len-1]=”ra”<br>2.A[i]是S[A[i]]的索引,是后缀的真实起始位置.A[i]是i包括i位以后的后缀<br>  [0] =”alohomora”，[len-1]=”a”，[len-2]=”ra<br>  A[i]的i是字典序的i，值是真实位置<br>  例：S[A[0]]=S[8]=表示第一个字典序，实际位置是字符串substring(8);</p>
<h4 id="生成后缀数组"><a href="#生成后缀数组" class="headerlink" title="生成后缀数组"></a>生成后缀数组</h4><p>Manber-Myers O(n)但是太复杂</p>
<p>排序后缀目录：桶排序</p>
<h3 id="Aho-Corasick"><a href="#Aho-Corasick" class="headerlink" title="Aho-Corasick"></a>Aho-Corasick</h3><p>1添加失败链接<br>2缝衣针字符串序号数组</p>
<hr>
<h3 id="A-B两人选k种可乐达到期望最大"><a href="#A-B两人选k种可乐达到期望最大" class="headerlink" title="A,B两人选k种可乐达到期望最大"></a>A,B两人选k种可乐达到期望最大</h3><p>A选m个，B选(n-m)个<br>每种可乐对A,B的满意度为a,b 如何使两人满意度期望和最大<br>输出 买k种可乐的数量<br>期望和：$m/n*a+(m-n)/n*b$的最大值 全部买期望最大那种<br>输入：n=2 m=1 k=2；a=1 b=2；a=3 b=1<br>m/n=.5<br>0.5x1+0.5x2=0.5+1=1.5<br>0.5x3+0.5x1 = 2  全部买第二种可乐<br>输出:0 2</p>
<hr>
<h3 id="火车换乘"><a href="#火车换乘" class="headerlink" title="??火车换乘"></a>??火车换乘</h3><p>保证每个车错过能在30分钟以后换车<br>输入：城市n 火车数m<br>from1 to3 cost800 18:00 21:00<br>…<br>输出从1到n的最小花费</p>
<hr>
<h3 id="16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><a href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16" class="headerlink" title="16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16"></a>16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</h3><p>A进入1/8只需要打败B，A进入1/4需要P(A进入1/8)*(P(C进入1/8)*P(A赢了C)+P(D进入1/8)*P(A赢了D))<br>A进入1/2需要赢没比过的另外4个队<br>A变成冠军需要赢没比过的另外8个队<br>分组问题：如果1/4赛 1234 5678是一组4个是一组<br>如果1/2赛  8个是一组<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/shijiebei.jpg" alt="shijiebei.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">int</span> inergroup = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line"> <span class="keyword">int</span> group= <span class="number">1</span>&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">16</span> ; j++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">16</span>;k++) &#123;</span><br><span class="line">    <span class="comment">//在同一个大组</span></span><br><span class="line">    <span class="keyword">if</span>(j/group==k/group) &#123;</span><br><span class="line">    <span class="comment">//不在同一个小组</span></span><br><span class="line">    <span class="keyword">if</span> (j / inergroup != k / inergroup) &#123;</span><br><span class="line">        dp[i][j] += dp[i - <span class="number">1</span>][j] * dp[i - <span class="number">1</span>][k] * p[j][k];</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<p>第一轮：1进入1/8赢的概率是[1][2] 1打败2的概率=0.133<br>第二轮：1赢了1/8进入1/4赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1在第2轮的获胜概率是0加上1在上一轮胜利的概率0.133 ×3在上一轮获胜的概率0.335×1赢3的概率0.21</span><br><span class="line">1 2 0.00935655</span><br><span class="line">1在第2轮的获胜概率是0.00935655加上1在上一轮胜利的概率0.133 ×4在上一轮获胜的概率0.665×1赢4的概率0.292</span><br><span class="line">1 2 0.0351825</span><br></pre></td></tr></table></figure></p>
<p>第三轮：1赢了1/4在1/2半决赛赢的概率是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1在第3轮的获胜概率是0加上1在上一轮胜利的概率0.0351825 ×5在上一轮获胜的概率0.336947×1赢5的概率0.67</span><br><span class="line">1 3 0.00794261</span><br><span class="line">1在第3轮的获胜概率是0.00794261加上1在上一轮胜利的概率0.0351825 ×6在上一轮获胜的概率0.198831×1赢6的概率0.27</span><br><span class="line">1 3 0.00983136</span><br><span class="line">1在第3轮的获胜概率是0.00983136加上1在上一轮胜利的概率0.0351825 ×7在上一轮获胜的概率0.0229419×1赢7的概率0.953</span><br><span class="line">1 3 0.0106006</span><br><span class="line">1在第3轮的获胜概率是0.0106006加上1在上一轮胜利的概率0.0351825 ×8在上一轮获胜的概率0.44128×1赢8的概率0.353</span><br><span class="line">1 3 0.016081</span><br></pre></td></tr></table></figure></p>
<p>第四轮：1赢了1/2变成冠军的概率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1在第4轮的获胜概率是0加上1在上一轮胜利的概率0.016081 ×9在上一轮获胜的概率0.0606261×1赢9的概率0.328</span><br><span class="line">1 4 0.000319777</span><br><span class="line">1在第4轮的获胜概率是0.000319777加上1在上一轮胜利的概率0.016081 ×10在上一轮获胜的概率0.0113548×1赢10的概率0.128</span><br><span class="line">1 4 0.000343149</span><br><span class="line">1在第4轮的获胜概率是0.000343149加上1在上一轮胜利的概率0.016081 ×11在上一轮获胜的概率0.203126×1赢11的概率0.873</span><br><span class="line">1 4 0.00319478</span><br><span class="line">1在第4轮的获胜概率是0.00319478加上1在上一轮胜利的概率0.016081 ×12在上一轮获胜的概率0.147508×1赢12的概率0.082</span><br><span class="line">1 4 0.00338929</span><br><span class="line">1在第4轮的获胜概率是0.00338929加上1在上一轮胜利的概率0.016081 ×13在上一轮获胜的概率0.160952×1赢13的概率0.771</span><br><span class="line">1 4 0.00538485</span><br><span class="line">1在第4轮的获胜概率是0.00538485加上1在上一轮胜利的概率0.016081 ×14在上一轮获胜的概率0.0877648×1赢14的概率0.3</span><br><span class="line">1 4 0.00580826</span><br><span class="line">1在第4轮的获胜概率是0.00580826加上1在上一轮胜利的概率0.016081 ×15在上一轮获胜的概率0.240971×1赢15的概率0.405</span><br><span class="line">1 4 0.00737766</span><br><span class="line">1在第4轮的获胜概率是0.00737766加上1在上一轮胜利的概率0.016081 ×16在上一轮获胜的概率0.0876971×1赢16的概率0.455</span><br><span class="line">1 4 0.00801932</span><br></pre></td></tr></table></figure></p>

</div></div>
<hr>
<hr>
<hr>
<h3 id="815-换公交-BFS"><a href="#815-换公交-BFS" class="headerlink" title="!815 换公交 BFS"></a>!815 换公交 BFS</h3><p><code>routes = [[1, 2, 7], [3, 6, 7]]</code><br>表示环线<code>1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;</code><br>求从S-&gt;T的最少公交车数量（不是少的站点）</p>
<blockquote>
<p>Input: routes = [[1, 2, 7], [3, 6, 7]]<br>S = 1<br>T = 6<br>Output: 2乘坐 routes[0]到7，换routes[1]到6</p>
</blockquote>
<p>易错点1： bfs的size保留当前层的定点数<br>易错点2： deque的add和poll</p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;0,1,6,16,22,23&#125;,</span><br><span class="line"> &#123;14,15,24,32&#125;,</span><br><span class="line"> &#123;4,10,12,20,24,28,33&#125;,</span><br><span class="line"> &#123;1,10,11,19,27,33&#125;,</span><br><span class="line"> &#123;11,23,25,28&#125;,</span><br><span class="line"> &#123;15,20,21,23,29&#125;,</span><br><span class="line"> &#123;29&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p> S=4 T=21<br>bfs，起点入队，遍历起点可以到达的所有公交(4可以达公交2)，遍历所有公交2上的可达<code>stop{4,10,12,20,24,28,33},</code><br>如果没到T，则4乘的公交换一辆，再遍历有4公交上的其他可达stop。<br><strong>用size保留当前层的定点数</strong> 4的bus全部遍历完后size==0。下一轮重新获取<code>que.size()</code><br>如果4的所有公交都不能达到T，则必须换乘cnt+1。当前起点变成<code>stop{10}</code>，遍历它的公交和stop，不行就{12}这些都是cnt+1可达的。直到<code>stop{20}-&gt;bus{2,5}</code>遍历公交5的stop找到T，bfs换乘1层找到的。</p>
<p>注意deque的add是addLast，push是addFirst,poll是pollFirst，pop是poolFirst 队列应该是add+poll,<br>bfs如果用栈，则会在这一层还没找完先找下一层cnt=1{4}-&gt;<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bus1.jpg" alt="bus1.jpg"><br><code>cnt=2{33:[2, 3]}-&gt;</code><br>将{1,10,11,19,27,33}入队<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/bus2.jpg" alt="bus2.jpg"><br>所以回到下一次size–的时候取到了下一层的点33,两个bus都标记过了<br>然后就全乱了<br><code>{27:[3]}-&gt;{19:[3]}-&gt;{11:[3,4]}-&gt;bus4</code>的最后<code>{28:[2,4]}-&gt;25:[4]-&gt;cnt=3{23:[0,4,5]}-&gt;bus5</code>找到21<br>本来应该<code>bus[2]-&gt;20-&gt;bus[5]</code>结果<code>bus[2]-&gt;bus[4]-&gt;bus[5]</code></p>

</div></div>
<p>数据结构：</p>
<ol>
<li>{站点：list&lt;经过的公交车id&gt;}</li>
<li>list&lt;公交车id&gt; 标记已经乘过的公交</li>
<li>BFS连通分量<code>while(!que.empty)</code>，<br> 遍历一辆车的连通分量<code>while(que.size()&gt;0)</code><br> 遍历当前节点相邻的busid是否乘过<code>for(int car:list)，</code><br> 并标记这个车的连通分量已乘过，遍历这个连通分量<code>for(int t:routes[car])</code>中有没有T，有则结束，没有则将整个连通分量入队。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todonexttime</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="fib"><a href="#fib" class="headerlink" title="fib"></a>fib</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    num++;<span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == -<span class="number">1</span>)memo[n] = fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="11-数组index当底边，值当杯子两侧，最大面积"><a href="#11-数组index当底边，值当杯子两侧，最大面积" class="headerlink" title="11 数组index当底边，值当杯子两侧，最大面积"></a>11 数组index当底边，值当杯子两侧，最大面积</h3><hr>
<h3 id="347桶排序-int数组中最常出现的n个"><a href="#347桶排序-int数组中最常出现的n个" class="headerlink" title="?347桶排序 int数组中最常出现的n个"></a>?347桶排序 int数组中最常出现的n个</h3><p>桶长度为数组长度，数字出现的最高次数为len，把频率相同的放在同一个桶。最后从桶序列高到低遍历。<br>99%<br>不用map，遍历一次找到max和min 建len = max-min+1的数组计数<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rst = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> rst;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE,max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; min)min = nums[i];</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;max) max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[max-min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">        data[nums[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> ArrayList[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[data[i]]== <span class="keyword">null</span>)&#123;</span><br><span class="line">                bucket[data[i]] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                bucket[data[i]].add(i+min);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bucket[data[i]].add(i+min);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =nums.length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)<span class="keyword">return</span> rst;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            rst.addAll(bucket[i]);</span><br><span class="line">            k-=bucket[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><br>用map AC34%</p>
<p>优先队列O(nlogk)如果k和n的数量差不多 还能维护一个(n-k)的堆 复杂度变成nlog(n-k)</p>
<h3 id="242-Anagram-相同字母的单词"><a href="#242-Anagram-相同字母的单词" class="headerlink" title="242 Anagram 相同字母的单词"></a>242 Anagram 相同字母的单词</h3><h3 id="344-reverse-String"><a href="#344-reverse-String" class="headerlink" title="344 reverse String"></a>344 reverse String</h3><p>转成char数组/位运算做法77%比stringbuilder好</p>
<h3 id="238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><a href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法" class="headerlink" title="238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法"></a>238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</h3><p>left数组：自己左边数的乘积[1,1,2,6]<br>right数组:自己右边的乘积（包括自己）[24,12,4,1]<br>left和right对应位置相乘<br>不用extra space<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span> to n-<span class="number">1</span>)&#123;</span><br><span class="line">    res[i]=res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(n-<span class="number">1</span> to <span class="number">0</span>)&#123;</span><br><span class="line">    res[i]*right;</span><br><span class="line">    right*=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<h3 id="371-不用’-’用位运算完成求和"><a href="#371-不用’-’用位运算完成求和" class="headerlink" title="371 不用’+’用位运算完成求和"></a>371 不用’+’用位运算完成求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = a^b;<span class="comment">//0^0=0,0^1=1,1^1=0 </span></span><br><span class="line">    <span class="keyword">int</span> carry = (a&amp;b)&lt;&lt;<span class="number">1</span>;<span class="comment">//当ab相等的时候需要进位</span></span><br><span class="line">    <span class="comment">//a+b=（a xor b）+ （(a and b) &lt;&lt; 1）</span></span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)<span class="keyword">return</span> getSum(rst,carry);</span><br><span class="line">    <span class="keyword">return</span> rst;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="412-遇到3-5和3-amp-5的倍数变成特定字符"><a href="#412-遇到3-5和3-amp-5的倍数变成特定字符" class="headerlink" title="412 遇到3||5和3&amp;5的倍数变成特定字符"></a>412 遇到3||5和3&amp;5的倍数变成特定字符</h3><p>不用%最快方法!<br>对于CPU取余数的运算相对来说效率很低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,fizz=<span class="number">0</span>,buzz=<span class="number">0</span>;i&lt;=n ;i++)&#123;</span><br><span class="line">          fizz++;</span><br><span class="line">          buzz++;</span><br><span class="line">          <span class="keyword">if</span>(fizz==<span class="number">3</span> &amp;&amp; buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fizz==<span class="number">3</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Fizz"</span>);</span><br><span class="line">              fizz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(buzz==<span class="number">5</span>)&#123;</span><br><span class="line">              ret.add(<span class="string">"Buzz"</span>);</span><br><span class="line">              buzz=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ret.add(String.valueOf(i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="551-出现两个以上A或者3个以上L为false"><a href="#551-出现两个以上A或者3个以上L为false" class="headerlink" title="551 出现两个以上A或者3个以上L为false"></a>551 出现两个以上A或者3个以上L为false</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> s.indexOf(<span class="string">"A"</span>)==s.lastIndexOf(<span class="string">"A"</span>) &amp;&amp; s.indexOf(<span class="string">"LLL"</span>) == -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="476"><a href="#476" class="headerlink" title="476"></a>476</h3><p>前导0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到左边第一个1，然后后面全置0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);<span class="comment">//高位为1的右1步，再|则第二高位肯定是1-&gt;00011xxxxx</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);<span class="comment">//连续4个1 但是如果位数不够就只有3个1或者更少</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">//让全1的无符号右移1格1111-0111得到1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"><a href="#292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢" class="headerlink" title="292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"></a>292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢</h3><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>10亿结点的2-3树高度在19-30之间。：math.log(1000000000,3)~math.log(1000000000,2)<br>与BST不同，2-3树是由下往上构建，防止升序插入10个键高为9的情况<br>2-3树的高度在$\lfloor log_3N \rfloor=\lfloor logN/log3 \rfloor$ 到$\lfloor lgN \rfloor$ 之间</p>
<h3 id="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><a href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树" class="headerlink" title="红黑树：将3-结点变成左二叉树，将2-3变成二叉树"></a>红黑树：将3-结点变成左二叉树，将2-3变成二叉树</h3><p>有二叉树高效查找和2-3树高效平衡插入<br>红黑树高度不超过$\lfloor 2logN \rfloor$ 实际上查找长度约为$1.001logN-0.5$</p>
<p>插入：总是用红链接将新结点和父节点链接（如果变成了右红链接需要旋转）</p>
<h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136 Single Number"></a>136 Single Number</h3><p>异或 0^12=12,12^12=0<br><a href="https://leetcode.com/articles/single-number/" target="_blank" rel="noopener">single number</a><br>$$2(a+b+c)-(a+a+b+b+c)$$ <code>2*sum(set(list))-sum(list)</code></p>
<h3 id="141链表环检测"><a href="#141链表环检测" class="headerlink" title="141链表环检测"></a>141链表环检测</h3><p>空间O(1) 快慢指针：快指针走2步，慢指针走一步，当快指针遇到慢指针<br>最坏情况，快指针和慢指针相差环长q -1步<br><div><div class="fold_hider"><div class="close hider_title">cpp练习</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        auto slow = head;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="160-链表相交于哪一点"><a href="#160-链表相交于哪一点" class="headerlink" title="160 链表相交于哪一点"></a>160 链表相交于哪一点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>思路1：计算len(a),len(b)，a长则a一直跳到len(a)==len(b)再开始比较.val<br>思路2：将a,b连成m+n长的链表遍历两遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1 → a2  c1 → c2 → c3 -null- b1 → b2 → b3  c1 → c2 → c3</span><br><span class="line">       // ↘</span><br><span class="line">       //   c1 → c2 → c3</span><br><span class="line">        // ↗            </span><br><span class="line">b1 → b2 → b3  c1 → c2 → c3 -null- a1 → a2  c1 → c2 → c3</span><br></pre></td></tr></table></figure></p>
<div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(headA==<span class="keyword">null</span>||headB==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            ListNode a = headA;</span><br><span class="line">            ListNode b = headB;</span><br><span class="line">            <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="keyword">null</span>)&#123;a=headB;&#125;<span class="keyword">else</span>&#123;a=a.next;&#125;</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="keyword">null</span>)&#123;b=headA;&#125;<span class="keyword">else</span>&#123;b=b.next;&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="168-lt1350"><a href="#168-lt1350" class="headerlink" title="168 lt1350"></a>168 lt1350</h3><p>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>…<br>26 -&gt; Z<br>27 -&gt; AA<br>28 -&gt; AB<br>递归26进制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="string">""</span> : convertToTitle(--n / <span class="number">26</span>) + (<span class="keyword">char</span>)(<span class="string">'A'</span> + (n % <span class="number">26</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>88%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">   --n;</span><br><span class="line">   sb.insert(<span class="number">0</span>,(<span class="keyword">char</span>)(n%<span class="number">26</span>+<span class="string">'A'</span> ));</span><br><span class="line">   n/=<span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure></p>
<h3 id="1-爬山：局部贪心，快速找到可行解，局部最优"><a href="#1-爬山：局部贪心，快速找到可行解，局部最优" class="headerlink" title="1. 爬山：局部贪心，快速找到可行解，局部最优"></a>1. 爬山：局部贪心，快速找到可行解，局部最优</h3><ul>
<li>8数码:启发函数：当前状态和目标状态的距离：错位方块个数。<ol>
<li>深度优先<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/mounting.jpg" alt="mounting.jpg"></li>
<li>每次将当前节点S的子节点按启发式函数由大到小压入栈</li>
</ol>
</li>
</ul>
<p>8数码BFS优先队列<br><div><div class="fold_hider"><div class="close hider_title">展开代码</div></div><div class="fold">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> newX,<span class="keyword">int</span> newY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = matrix[x][y];</span><br><span class="line">    matrix[x][y] = matrix[newX][newY];</span><br><span class="line">    matrix[newX][newY] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    printPath(root.parent);</span><br><span class="line">    print2D(root.mat);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">createNode</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> newX,<span class="keyword">int</span> newY,<span class="keyword">int</span> level,Node parent)</span></span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node();</span><br><span class="line">    node.parent = parent;</span><br><span class="line"></span><br><span class="line">    node.mat = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        node.mat[i] = matrix[i].clone();</span><br><span class="line">    &#125;</span><br><span class="line">    swap(node.mat,x ,y , newX,newY);</span><br><span class="line">    node.cost = Integer.MAX_VALUE;</span><br><span class="line">    node.x = newX;</span><br><span class="line">    node.y = newY;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span>[][] from,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span>[][] end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//扩展距离小的</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(node -&gt; (node.cost + node.level))</span><br><span class="line">    );</span><br><span class="line">    Node root = createNode(from,x ,y ,x ,y ,<span class="number">0</span> , <span class="keyword">null</span>);</span><br><span class="line">    root.cost = calCost(from,end );</span><br><span class="line">    que.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        Node min = que.poll();</span><br><span class="line">        <span class="comment">//结果，从子节点向上递归打印</span></span><br><span class="line">        <span class="keyword">if</span>(min.cost==<span class="number">0</span>) &#123;</span><br><span class="line">            printPath(min);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4个方向挪动白块四个方向为什么不会重复状态死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isInBoard(min.x+row[i],min.y+col[i]))&#123;</span><br><span class="line">                Node child = createNode(min.mat,min.x ,min.y , min.x+row[i], min.y+col[i], min.level+<span class="number">1</span>, min);</span><br><span class="line">                child.cost = calCost(child.mat,end );</span><br><span class="line">                que.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></p>
<h3 id="Best-First搜索：全局最优贪心"><a href="#Best-First搜索：全局最优贪心" class="headerlink" title="Best-First搜索：全局最优贪心"></a>Best-First搜索：全局最优贪心</h3><ul>
<li>当前所有可扩展节点中启发函数最优点</li>
<li>用堆</li>
</ul>
<h3 id="分支界限：组合优化"><a href="#分支界限：组合优化" class="headerlink" title="分支界限：组合优化"></a>分支界限：组合优化</h3><ul>
<li>多阶段图搜索：最短路径<ul>
<li>爬山与BF算法得到最优解都需要遍历整个空间</li>
</ul>
<ol>
<li>用爬山生成界限(可行解or最优解的上限)<br><img src="https://iota-1254040271.cos.ap-shanghai.myqcloud.com/image/fenzhi.jpg" alt="fenzhi.jpg"></li>
</ol>
</li>
</ul>
<h3 id="Rabin-Karp"><a href="#Rabin-Karp" class="headerlink" title="Rabin-Karp"></a>Rabin-Karp</h3><p>O(MN)</p>
<h3 id="1-枚举："><a href="#1-枚举：" class="headerlink" title="1. 枚举："></a>1. 枚举：</h3><ol>
<li><p>小于N的完美立方 $a^3=b^3+c^3+d^3$</p>
<blockquote>
<p>按a的值从小到大输出a&gt;b&gt;c&gt;d</p>
</blockquote>
<ul>
<li>a-&gt;[2,N];b-&gt;[2,a-1];c[c,a-1];d[c,a-1]</li>
</ul>
</li>
<li><p>称硬币:已经分组称了3次12枚硬币，找出假币</p>
<blockquote>
<p>ABCD EFGH even<br>ABI EFJK up<br>ABIJ EFGH even<br>输出假的硬币</p>
</blockquote>
<ul>
<li>数据结构 <code>char Left[3][7]`</code>char Right[3][7]<code></code>char result[3][7]` 一共称3次，每边最多放6个硬币，result（天平右边的情况）</li>
<li><code>isFake(char c,bool light )</code>假设函数：c是轻的</li>
<li><code>for(char c= &#39;A&#39; to &#39;L&#39;)</code>枚举假硬币</li>
<li><code>for(3)</code>三次称重情况都匹配<ul>
<li>如果假设c是轻的，数组保存输入的left,right;如果c是种的，right保存到left 互换</li>
<li><code>switch result[i][0]</code> 选择三种u,e,d的情况<ul>
<li>如果 第一次实验为up,右边高，则c应该出现在right,当<code>right.indexOf(c)==null</code>//没出现 return false</li>
<li>如果even 判断出现在left||right</li>
<li>d 判断出现在left</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p>熄灯问题(deng.java)</p>
<blockquote>
<p>按一个位置，改变上下左右自己5个灯的状态，边角自动变少3，4<br>给定每盏灯的初始状态，求按钮方案，使灯全熄灭<br>输入 01矩阵 输出 01矩阵<br>一个按钮按两次及以上是无意义的，按钮次序无关<br>{0,1,1,0,1,0},<br>{1,0,0,1,1,1},<br>{0,0,1,0,0,1},<br>{1,0,0,1,0,1},<br>{0,1,1,1,0,0}</p>
</blockquote>
<ul>
<li>枚举所有可能的开关状态30个开关有$2^{30}$个状态（方案数）</li>
<li>只需枚举第一行作为（局部） 后面几行都是确定的。第一行没灭的灯必须要第二行按灭，且其它灯不能按</li>
<li>一行01可以采用位运算 一维char数组5位(5行) 用int [0,2^6-1]</li>
<li>一个bit异或1 反转<code>1^1-&gt;0反转0^1-&gt;1反转；</code></li>
<li>j位 置1 <code>|=(1&lt;&lt;j)</code></li>
<li>j位 置0 <code>&amp;=~(1&lt;&lt;j)</code></li>
<li>取第j 位的值 <code>&gt;&gt;j&amp;1</code><blockquote>
<p> 主循环：1.遍历第一行开关状态<br> 2.每次换第一行重置原来灯状态lighting[]=输入<br> 3.对每一行，每一个灯，按switch更新lighting</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(getBit(result,i,j)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">0</span>)FlipBit(lights,i,j-<span class="number">1</span>);</span><br><span class="line">FlipBit(lights,i,j);</span><br><span class="line"><span class="keyword">if</span>(j&lt;<span class="number">5</span>)FlipBit(lights,i,j+<span class="number">1</span>);&#125;&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">4</span>)&#123;lights[i+<span class="number">1</span>]^= switchs;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>&gt;  4.更新开关，下一行开关为上一行还亮着灯的位置回3
&gt;  5.当lighting最后一行为0，结束
</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol>
<li>汉诺塔：将A上的n个移动到C用B中转可以分解为3个字问题(1,2)<ol>
<li>A上n-1个移动到B，用C中转+移动一个盘子sout(A-&gt;c)</li>
<li>再将B上n-1个移动到C，用A中转</li>
<li>回到0 A上n-2个移动到C，用B中转</li>
</ol>
</li>
<li>n皇后 递归代替多重循环</li>
</ol>
<h3 id="654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"><a href="#654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树" class="headerlink" title="654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"></a>654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树</h3><p>stack：<br>[3,2,1,6,0,5]<br>1.栈底是数组最大值，即树根<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3left-&gt;</span><br><span class="line"> right-&gt;2-&gt;1 stack:3,2,1</span><br><span class="line">将栈里比cur小的右链变成当前最大值的左链，pop所有比6小的元素</span><br><span class="line">6left-&gt;3</span><br><span class="line">        -&gt;right-&gt;2-&gt;1 stack：6</span><br><span class="line">6left-&gt;3</span><br><span class="line"> right-&gt;0 stack:6,0</span><br><span class="line">5left-&gt;0,6right-&gt;5</span><br><span class="line">6-&gt;left-&gt;3</span><br><span class="line">         -&gt;right-&gt;2-&gt;1</span><br><span class="line"> -&gt;right-&gt;5</span><br><span class="line">          -&gt;left-&gt;0</span><br></pre></td></tr></table></figure></p>
<p>68%<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    TreeNode cur = nums[i];</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek().val&lt;cur.val)&#123;</span><br><span class="line">        cur.left = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">        stack.peek().right=cur;</span><br><span class="line">    stack.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> stack.isEmpty()?<span class="keyword">null</span>:stack.removeLast();</span><br></pre></td></tr></table></figure></p>
<p>递归95% 递归熟练 11ms<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> max = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =start+<span class="number">1</span>;i&lt;=end;i++)&#123;</span><br><span class="line">        max = nums[]</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[max]);</span><br><span class="line">    root.left = build(nums,start,max-<span class="number">1</span>);</span><br><span class="line">    root.right = build(nums,max+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/alg/" rel="tag"># alg</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/21/busyman/" rel="next" title="busyman Notes">
                <i class="fa fa-chevron-left"></i> busyman Notes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/24/Apriori-FP/" rel="prev" title="Apriori_FP">
                Apriori_FP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">学习一个技术不要轻易过去，要有技术深度做一个demo</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#lc749-病毒隔离"><span class="nav-number">1.</span> <span class="nav-text">lc749 病毒隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt912-最佳见面地点"><span class="nav-number">2.</span> <span class="nav-text">lt912 最佳见面地点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#542-01矩阵-变成离0距离的矩阵"><span class="nav-number">3.</span> <span class="nav-text">542 01矩阵 变成离0距离的矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-663-墙和门"><span class="nav-number">4.</span> <span class="nav-text">lt 663 墙和门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-803-建筑物之间的最短距离"><span class="nav-number">5.</span> <span class="nav-text">lt 803 建筑物之间的最短距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#899-操作字符串前k个字符放到最后-输出字典序最小的"><span class="nav-number">6.</span> <span class="nav-text">899 操作字符串前k个字符放到最后 输出字典序最小的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-pattern"><span class="nav-number">7.</span> <span class="nav-text">132 pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt700-怎么划分最赚钱-完全背包"><span class="nav-number">8.</span> <span class="nav-text">lt700 怎么划分最赚钱 完全背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#862-和至少为K的最短子数组"><span class="nav-number">9.</span> <span class="nav-text">862 和至少为K的最短子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#861-01矩阵反转能得到的最大01行和"><span class="nav-number">10.</span> <span class="nav-text">861 01矩阵反转能得到的最大01行和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sw44-判断扑克牌是否顺子"><span class="nav-number">11.</span> <span class="nav-text">sw44 判断扑克牌是否顺子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#263-Ugly-Number-判断是否是丑数"><span class="nav-number">12.</span> <span class="nav-text">263 Ugly Number 判断是否是丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#264-输出第n个丑数"><span class="nav-number">12.1.</span> <span class="nav-text">264 输出第n个丑数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#859-如果交换A字符串中两个字母可以得到B就true"><span class="nav-number">13.</span> <span class="nav-text">859 如果交换A字符串中两个字母可以得到B就true</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc70爬楼梯"><span class="nav-number">14.</span> <span class="nav-text">lc70爬楼梯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈混洗-火车调度"><span class="nav-number">15.</span> <span class="nav-text">栈混洗 火车调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机数发生器"><span class="nav-number">16.</span> <span class="nav-text">随机数发生器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#231-2的整数次"><span class="nav-number">17.</span> <span class="nav-text">231 2的整数次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#191二进制中1的个数"><span class="nav-number">18.</span> <span class="nav-text">191二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-325-lt-919"><span class="nav-number">19.</span> <span class="nav-text">lc 325 lt 919</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组嵌套"><span class="nav-number">20.</span> <span class="nav-text">数组嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#素数定理"><span class="nav-number">21.</span> <span class="nav-text">素数定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#926-将01串变成前0后1或全0或全1的最少flip次数-前缀！"><span class="nav-number">22.</span> <span class="nav-text">926!!将01串变成前0后1或全0或全1的最少flip次数 前缀！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#925-是否是因长按重复的字符串"><span class="nav-number">23.</span> <span class="nav-text">925 是否是因长按重复的字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平面最近点对-分治"><span class="nav-number">24.</span> <span class="nav-text">平面最近点对 分治</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#780-x-y可以向下x步，或者向右y步能否到达tx-ty"><span class="nav-number">25.</span> <span class="nav-text">!!780 x,y可以向下x步，或者向右y步能否到达tx,ty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#532-数组中有几个相差k的pair"><span class="nav-number">26.</span> <span class="nav-text">532 数组中有几个相差k的pair</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#220-数组中是否有相差-lt-t-idx差-lt-k-的元素"><span class="nav-number">27.</span> <span class="nav-text">220 数组中是否有相差&lt;=t,idx差&lt;=k 的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#373-start和end数组-拼成-start-end-求start-end最小的k个点对"><span class="nav-number">28.</span> <span class="nav-text">373 start和end数组 拼成[start,end] 求start+end最小的k个点对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#719-数组中两两匹配，第k小的两数之差"><span class="nav-number">29.</span> <span class="nav-text">719 数组中两两匹配，第k小的两数之差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt1472-s任意交换奇数位字符和偶数位字符-能否变成t"><span class="nav-number">30.</span> <span class="nav-text">lt1472 s任意交换奇数位字符和偶数位字符 能否变成t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#219-是否有重复元素-下标相差-lt-k"><span class="nav-number">31.</span> <span class="nav-text">219 是否有重复元素 下标相差&lt;=k</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#442-1-≤-a-i-≤-n-找到所有出现2次的元素-O-1-空间"><span class="nav-number">32.</span> <span class="nav-text">442  1 ≤ a[i] ≤ n 找到所有出现2次的元素 O(1) 空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#401-二进制手表"><span class="nav-number">33.</span> <span class="nav-text">401 二进制手表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉明重量-Hamming-weight-32位int有多少个1"><span class="nav-number">34.</span> <span class="nav-text">汉明重量 Hamming weight 32位int有多少个1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#477-全部汉明距离Integer-bitCount-x-y"><span class="nav-number">35.</span> <span class="nav-text">477 全部汉明距离Integer.bitCount(x ^ y)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#338-0-n每个数字有几个1位-O-n-复杂度"><span class="nav-number">36.</span> <span class="nav-text">338 0~n每个数字有几个1位 O(n)复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87-判断两个字符串是不是拆分成两半二叉树交换子树构成的"><span class="nav-number">37.</span> <span class="nav-text">87 判断两个字符串是不是拆分成两半二叉树交换子树构成的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt640-字符串-S-和-T-判断他们是否只差一步编辑-lc161"><span class="nav-number">38.</span> <span class="nav-text">lt640 字符串 S 和 T, 判断他们是否只差一步编辑 lc161</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-编辑距离"><span class="nav-number">39.</span> <span class="nav-text">72 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取模和取余rem"><span class="nav-number">40.</span> <span class="nav-text">取模和取余rem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#149-在同一条直线上最多的点数"><span class="nav-number">41.</span> <span class="nav-text">149 在同一条直线上最多的点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段上格点的个数"><span class="nav-number">42.</span> <span class="nav-text">线段上格点的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火车编组-1-2-3-4不可能的出栈顺序-ACM列车长的烦恼"><span class="nav-number">43.</span> <span class="nav-text">火车编组 1,2,3,4不可能的出栈顺序 ACM列车长的烦恼</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间dp"><span class="nav-number">44.</span> <span class="nav-text">区间dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt476石子合并-区间dp"><span class="nav-number">45.</span> <span class="nav-text">lt476石子合并 区间dp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc84直方图中的最大矩形poj2559"><span class="nav-number">46.</span> <span class="nav-text">lc84直方图中的最大矩形poj2559</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3sum-a-b-c-0"><span class="nav-number">47.</span> <span class="nav-text">15 3sum a + b + c = 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-1487-2sum-最接近target"><span class="nav-number">48.</span> <span class="nav-text">lt 1487 2sum 最接近target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3sum-最接近target的值"><span class="nav-number">49.</span> <span class="nav-text">16 3sum 最接近target的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4sum-外层for-用3sum找target-nums-i"><span class="nav-number">50.</span> <span class="nav-text">18 4sum 外层for 用3sum找target-nums[i]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#454-4-sum-2-poj2785-4-Values-whose-Sum-is-0"><span class="nav-number">51.</span> <span class="nav-text">454 4 sum 2 poj2785 4 Values whose Sum is 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#914-相同数字的牌划分成一组，每组数量相同-能否划分"><span class="nav-number">52.</span> <span class="nav-text">914 相同数字的牌划分成一组，每组数量相同 能否划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#916"><span class="nav-number">53.</span> <span class="nav-text">916</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-整数反转-integer越界"><span class="nav-number">54.</span> <span class="nav-text">7 整数反转 integer越界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#319-n个灯泡-n轮开关"><span class="nav-number">55.</span> <span class="nav-text">319 n个灯泡 n轮开关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#451-字符串按频率排序-桶排序"><span class="nav-number">56.</span> <span class="nav-text">451 字符串按频率排序 桶排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大值为k的不重叠子数组的长度和？"><span class="nav-number">57.</span> <span class="nav-text">最大值为k的不重叠子数组的长度和？??</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#689-高频题-找到三个长度为k互不重叠的子数组的最大和"><span class="nav-number">58.</span> <span class="nav-text">689!!!高频题 找到三个长度为k互不重叠的子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-只能买卖一次-买卖股票的利润"><span class="nav-number">59.</span> <span class="nav-text">121 只能买卖一次 买卖股票的利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-不能偷相邻房屋-最大利润"><span class="nav-number">60.</span> <span class="nav-text">198 不能偷相邻房屋 最大利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-可以买卖多次-买股票的利润"><span class="nav-number">61.</span> <span class="nav-text">122 可以买卖多次 买股票的利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-最多买卖2次的-买股票利润-考到"><span class="nav-number">62.</span> <span class="nav-text">123 最多买卖2次的 买股票利润 考到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#188-最多k次买卖的-买卖股票利润"><span class="nav-number">63.</span> <span class="nav-text">188 最多k次买卖的 买卖股票利润</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复元素很多的数组排序"><span class="nav-number">64.</span> <span class="nav-text">重复元素很多的数组排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#621-todo"><span class="nav-number">65.</span> <span class="nav-text">621 todo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-最长回文子序列"><span class="nav-number">66.</span> <span class="nav-text">516 最长回文子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rearrange-a-string"><span class="nav-number">67.</span> <span class="nav-text">Rearrange a string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#440-第k小的字典序"><span class="nav-number">68.</span> <span class="nav-text">440 第k小的字典序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#386-字典序数字-todo"><span class="nav-number">69.</span> <span class="nav-text">!!386 字典序数字 todo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#636-单核cpu函数调用栈"><span class="nav-number">70.</span> <span class="nav-text">636 单核cpu函数调用栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#649-2种n个参议员，2种操作-无限多轮，直到所有票在同一个阵营"><span class="nav-number">71.</span> <span class="nav-text">649 2种n个参议员，2种操作 无限多轮，直到所有票在同一个阵营</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#495-给定攻击时间和中毒状态持续时间，问中毒状态总时长"><span class="nav-number">72.</span> <span class="nav-text">495 给定攻击时间和中毒状态持续时间，问中毒状态总时长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77combinations-C-n-k-C-n-1-k-1-C-n-1-k"><span class="nav-number">73.</span> <span class="nav-text">77combinations  C(n,k)=C(n-1,k-1)+C(n-1,k)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NqueenBB"><span class="nav-number">74.</span> <span class="nav-text">NqueenBB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#179-一组非负数，拼接成最大的正整数"><span class="nav-number">75.</span> <span class="nav-text">179 一组非负数，拼接成最大的正整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#402-去掉数字串中k个数字留下最小的数字"><span class="nav-number">76.</span> <span class="nav-text">402 去掉数字串中k个数字留下最小的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#500-判断字符串是不是在键盘的同一行"><span class="nav-number">77.</span> <span class="nav-text">500 判断字符串是不是在键盘的同一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42"><span class="nav-number">78.</span> <span class="nav-text">42</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#683-K-Empty-Slots"><span class="nav-number">79.</span> <span class="nav-text">683 - K Empty Slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长01串"><span class="nav-number">80.</span> <span class="nav-text">最长01串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#799倒香槟第-i-j-个杯子的容积"><span class="nav-number">81.</span> <span class="nav-text">799倒香槟第[i,j]个杯子的容积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-N-大整数"><span class="nav-number">82.</span> <span class="nav-text">2^N 大整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#287-O-1-空间，找到数组中重复的数字"><span class="nav-number">83.</span> <span class="nav-text">287 O(1)空间，找到数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找第二小-大的元素"><span class="nav-number">84.</span> <span class="nav-text">查找第二小/大的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序数组中小于target的"><span class="nav-number">85.</span> <span class="nav-text">排序数组中小于target的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定一个数字范围，找到其中有几个首尾相同的数字"><span class="nav-number">86.</span> <span class="nav-text">给定一个数字范围，找到其中有几个首尾相同的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百万数字中找最大20个"><span class="nav-number">87.</span> <span class="nav-text">百万数字中找最大20个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#每秒最大桶数量减半，求t时刻一共消耗了多少"><span class="nav-number">88.</span> <span class="nav-text">每秒最大桶数量减半，求t时刻一共消耗了多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？445-链表数字相加"><span class="nav-number">89.</span> <span class="nav-text">？445 链表数字相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#896有正负的数列判断单调"><span class="nav-number">90.</span> <span class="nav-text">896有正负的数列判断单调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-number">91.</span> <span class="nav-text">14 最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#718-最长公共子串40ms-90"><span class="nav-number">92.</span> <span class="nav-text">718 最长公共子串40ms 90%</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#括号串达到匹配需要最小的逆转次数"><span class="nav-number">93.</span> <span class="nav-text">括号串达到匹配需要最小的逆转次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-卡特兰数括号"><span class="nav-number">94.</span> <span class="nav-text">22 ??卡特兰数括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-括号字符串中合法的括号对"><span class="nav-number">95.</span> <span class="nav-text">32 ?括号字符串中合法的括号对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28字符串indexOf匹配暴力-Substring-Search"><span class="nav-number">96.</span> <span class="nav-text">28字符串indexOf匹配暴力 Substring Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Boyer-Moore-74-5ms-亚线性"><span class="nav-number">96.1.</span> <span class="nav-text">!!!Boyer-Moore 74% 5ms 亚线性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RabinKarp-31-8ms-线性"><span class="nav-number">96.2.</span> <span class="nav-text">RabinKarp 31% 8ms 线性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#187-rolling-hash-DNA序列中出现2次以上长为10的子串"><span class="nav-number">96.3.</span> <span class="nav-text">187 rolling-hash DNA序列中出现2次以上长为10的子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暴力-O（MN）"><span class="nav-number">96.4.</span> <span class="nav-text">暴力 O（MN）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP-Knuth-Morris-Pratt-适合查找自我重复的字符串-线性的M倍"><span class="nav-number">97.</span> <span class="nav-text">KMP-Knuth-Morris-Pratt 适合查找自我重复的字符串 线性的M倍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-最长不重复字串"><span class="nav-number">98.</span> <span class="nav-text">3 最长不重复字串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#879"><span class="nav-number">99.</span> <span class="nav-text">879</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#576-无向图访问所有点的最短边数"><span class="nav-number">100.</span> <span class="nav-text">576 无向图访问所有点的最短边数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fraction-背包问题"><span class="nav-number">101.</span> <span class="nav-text">fraction 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顶点覆盖"><span class="nav-number">102.</span> <span class="nav-text">顶点覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大团：在一个无向图中找出一个点数最多的完全图"><span class="nav-number">103.</span> <span class="nav-text">最大团：在一个无向图中找出一个点数最多的完全图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务分配问题一般可以在多项式时间内转化成最大流量问题"><span class="nav-number">104.</span> <span class="nav-text">任务分配问题一般可以在多项式时间内转化成最大流量问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hdu-1813-IDA搜索Iterative-Deepening-A"><span class="nav-number">105.</span> <span class="nav-text">hdu 1813 IDA搜索Iterative Deepening A,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tsp"><span class="nav-number">106.</span> <span class="nav-text">tsp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ip2cidr"><span class="nav-number">107.</span> <span class="nav-text">ip2cidr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131"><span class="nav-number">108.</span> <span class="nav-text">131</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#819-找出句子中出现频率最高没被ban掉的词"><span class="nav-number">109.</span> <span class="nav-text">819 找出句子中出现频率最高没被ban掉的词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#亚线性算法o-n-小于输入规模"><span class="nav-number">110.</span> <span class="nav-text">亚线性算法o(n)小于输入规模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水库抽样Reservpor-Sampling-亚线性空间"><span class="nav-number">111.</span> <span class="nav-text">水库抽样Reservpor Sampling 亚线性空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#398-数组中重复元素随机返回index"><span class="nav-number">112.</span> <span class="nav-text">398 数组中重复元素随机返回index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#？？382-随机链表-extremely-large-and-its-length-is-unknown"><span class="nav-number">113.</span> <span class="nav-text">？？382 随机链表 extremely large and its length is unknown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#频繁元素计算-Misra-Gries-MG-算法"><span class="nav-number">114.</span> <span class="nav-text">频繁元素计算 Misra Gries(MG)算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#笛卡尔树"><span class="nav-number">115.</span> <span class="nav-text">笛卡尔树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式前向星"><span class="nav-number">116.</span> <span class="nav-text">链式前向星</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序不稳定"><span class="nav-number">117.</span> <span class="nav-text">堆排序不稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三向快速排序-不稳定"><span class="nav-number">118.</span> <span class="nav-text">三向快速排序 不稳定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSD-most-significant-digit-first-不用长度相同从左开始"><span class="nav-number">119.</span> <span class="nav-text">MSD most-significant-digit-first 不用长度相同从左开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSD-基数排序radix-sort-定长字符串-复杂度WN-低位优先"><span class="nav-number">120.</span> <span class="nav-text">LSD 基数排序radix sort 定长字符串 复杂度WN  低位优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-index-count-sort键索引计数法-稳定的"><span class="nav-number">121.</span> <span class="nav-text">key-index count sort键索引计数法 稳定的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#611数组中符合三角形边长的对数"><span class="nav-number">122.</span> <span class="nav-text">611数组中符合三角形边长的对数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组组成三角形的最大周长nlogn"><span class="nav-number">123.</span> <span class="nav-text">数组组成三角形的最大周长nlogn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MST："><span class="nav-number">124.</span> <span class="nav-text">MST：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MST和聚类："><span class="nav-number">125.</span> <span class="nav-text">MST和聚类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kruskal"><span class="nav-number">125.1.</span> <span class="nav-text">kruskal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim"><span class="nav-number">125.2.</span> <span class="nav-text">prim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类：single-link"><span class="nav-number">126.</span> <span class="nav-text">聚类：single link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#753-输出能包含所有密码可能性的最短串"><span class="nav-number">127.</span> <span class="nav-text">753 输出能包含所有密码可能性的最短串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inverse-Burrows-Wheeler-Transform-IBWT-生成-Lyndon-words"><span class="nav-number">127.1.</span> <span class="nav-text">Inverse Burrows-Wheeler Transform (IBWT) 生成 Lyndon words.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-欧拉路径-每条边一次"><span class="nav-number">128.</span> <span class="nav-text">332 欧拉路径 每条边一次</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hierholzer：O-e"><span class="nav-number">128.1.</span> <span class="nav-text">Hierholzer：O(e)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个帅不能处在同一条直线上的所有可行位置"><span class="nav-number">129.</span> <span class="nav-text">两个帅不能处在同一条直线上的所有可行位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#翻煎饼排序的最少次数"><span class="nav-number">130.</span> <span class="nav-text">翻煎饼排序的最少次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#164-桶排序找区间最大值"><span class="nav-number">131.</span> <span class="nav-text">164 桶排序找区间最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求数组的最大gap"><span class="nav-number">132.</span> <span class="nav-text">求数组的最大gap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分图-让每条边的两个顶点属于不同的集合"><span class="nav-number">133.</span> <span class="nav-text">二分图 让每条边的两个顶点属于不同的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#785-是否是二分图"><span class="nav-number">133.1.</span> <span class="nav-text">785 是否是二分图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#886-给出dislike边集，能不能分成2组，组里没有互相讨厌的人"><span class="nav-number">133.2.</span> <span class="nav-text">886 给出dislike边集，能不能分成2组，组里没有互相讨厌的人</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的度"><span class="nav-number">134.</span> <span class="nav-text">图的度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历顺序"><span class="nav-number">135.</span> <span class="nav-text">图的遍历顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度问题：给定一组任务，安排执行时间-gt-拓扑排序"><span class="nav-number">136.</span> <span class="nav-text">调度问题：给定一组任务，安排执行时间-&gt;拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拓扑排序：有向环"><span class="nav-number">136.1.</span> <span class="nav-text">拓扑排序：有向环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#207-先修课程有环则返回false-拓扑排序"><span class="nav-number">136.2.</span> <span class="nav-text">?207 先修课程有环则返回false 拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#210-输出修课顺序"><span class="nav-number">136.3.</span> <span class="nav-text">210 输出修课顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kolakoski序列找规律"><span class="nav-number">137.</span> <span class="nav-text">kolakoski序列找规律</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lc481-返回kolakoski前N中有几个1"><span class="nav-number">137.1.</span> <span class="nav-text">lc481 返回kolakoski前N中有几个1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-骑士从左上到右下找公主，求初始血量"><span class="nav-number">138.</span> <span class="nav-text">174 骑士从左上到右下找公主，求初始血量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪多项式时间"><span class="nav-number">139.</span> <span class="nav-text">伪多项式时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-s1和s2是否交错组成s3"><span class="nav-number">140.</span> <span class="nav-text">!!97 s1和s2是否交错组成s3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-从左上角走到右下角总共有多少种不同方式"><span class="nav-number">141.</span> <span class="nav-text">62 从左上角走到右下角总共有多少种不同方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数学公式"><span class="nav-number">141.1.</span> <span class="nav-text">!数学公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-有障碍物的左上到右下"><span class="nav-number">142.</span> <span class="nav-text">63 有障碍物的左上到右下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-从左上角走到右下角的最少sum"><span class="nav-number">143.</span> <span class="nav-text">64 从左上角走到右下角的最少sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本福特定律"><span class="nav-number">144.</span> <span class="nav-text">本福特定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-众数-Boyer-Moore-Voting-Algorithm"><span class="nav-number">145.</span> <span class="nav-text">!!!169 众数 Boyer-Moore Voting Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-moore-voting-在线算法92"><span class="nav-number">145.1.</span> <span class="nav-text">4.moore voting 在线算法92%</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点是随机变量的有向无环图-贝叶斯网络BN"><span class="nav-number">146.</span> <span class="nav-text">节点是随机变量的有向无环图=贝叶斯网络BN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLS可以达到BFS一样空间的DFS"><span class="nav-number">147.</span> <span class="nav-text">DLS可以达到BFS一样空间的DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树字典树-每层多一个字符的字典树"><span class="nav-number">148.</span> <span class="nav-text">后缀树字典树 每层多一个字符的字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀树-对字典树路径压缩，一层多个字符-生成需要O-N-2"><span class="nav-number">149.</span> <span class="nav-text">后缀树 对字典树路径压缩，一层多个字符 生成需要O(N^2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀数组-A-后缀的起始位置"><span class="nav-number">150.</span> <span class="nav-text">后缀数组 A[]后缀的起始位置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成后缀数组"><span class="nav-number">150.1.</span> <span class="nav-text">生成后缀数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aho-Corasick"><span class="nav-number">151.</span> <span class="nav-text">Aho-Corasick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-B两人选k种可乐达到期望最大"><span class="nav-number">152.</span> <span class="nav-text">A,B两人选k种可乐达到期望最大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#火车换乘"><span class="nav-number">153.</span> <span class="nav-text">??火车换乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16支队伍两两获胜概率已知求冠军概率1-8-gt-1-4-gt-1-16"><span class="nav-number">154.</span> <span class="nav-text">16支队伍两两获胜概率已知求冠军概率1/8-&gt;1/4-&gt;1/16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#815-换公交-BFS"><span class="nav-number">155.</span> <span class="nav-text">!815 换公交 BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fib"><span class="nav-number">156.</span> <span class="nav-text">fib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-数组index当底边，值当杯子两侧，最大面积"><span class="nav-number">157.</span> <span class="nav-text">11 数组index当底边，值当杯子两侧，最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347桶排序-int数组中最常出现的n个"><span class="nav-number">158.</span> <span class="nav-text">?347桶排序 int数组中最常出现的n个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#242-Anagram-相同字母的单词"><span class="nav-number">159.</span> <span class="nav-text">242 Anagram 相同字母的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-reverse-String"><span class="nav-number">160.</span> <span class="nav-text">344 reverse String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-1-2-3-4-gt-返回1位置是除了1其它数的乘积-不用除法"><span class="nav-number">161.</span> <span class="nav-text">238 [1,2,3,4]-&gt;返回1位置是除了1其它数的乘积 不用除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#371-不用’-’用位运算完成求和"><span class="nav-number">162.</span> <span class="nav-text">371 不用’+’用位运算完成求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#412-遇到3-5和3-amp-5的倍数变成特定字符"><span class="nav-number">163.</span> <span class="nav-text">412 遇到3||5和3&amp;5的倍数变成特定字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#551-出现两个以上A或者3个以上L为false"><span class="nav-number">164.</span> <span class="nav-text">551 出现两个以上A或者3个以上L为false</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#476"><span class="nav-number">165.</span> <span class="nav-text">476</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢"><span class="nav-number">166.</span> <span class="nav-text">292每个人可以拿1-3块石头，拿到最后一块的赢，所有4的倍数的情况先手不能赢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">167.</span> <span class="nav-text">2-3树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树：将3-结点变成左二叉树，将2-3变成二叉树"><span class="nav-number">168.</span> <span class="nav-text">红黑树：将3-结点变成左二叉树，将2-3变成二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">169.</span> <span class="nav-text">136 Single Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141链表环检测"><span class="nav-number">170.</span> <span class="nav-text">141链表环检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-链表相交于哪一点"><span class="nav-number">171.</span> <span class="nav-text">160 链表相交于哪一点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#168-lt1350"><span class="nav-number">172.</span> <span class="nav-text">168 lt1350</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-爬山：局部贪心，快速找到可行解，局部最优"><span class="nav-number">173.</span> <span class="nav-text">1. 爬山：局部贪心，快速找到可行解，局部最优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-First搜索：全局最优贪心"><span class="nav-number">174.</span> <span class="nav-text">Best-First搜索：全局最优贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支界限：组合优化"><span class="nav-number">175.</span> <span class="nav-text">分支界限：组合优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rabin-Karp"><span class="nav-number">176.</span> <span class="nav-text">Rabin-Karp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-枚举："><span class="nav-number">177.</span> <span class="nav-text">1. 枚举：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">178.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#654-二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树"><span class="nav-number">179.</span> <span class="nav-text">654 二叉树根是数组中最大元素，左子树是左边元素建子树，右子树是右边元素建子树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/custom/custom.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
